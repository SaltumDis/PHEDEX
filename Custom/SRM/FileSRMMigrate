#!/usr/bin/env perl

##H Manage downloads into a SRM MSS node, marking transfer completed
##H when the files have been migrated to tape.
##H
##H This agent is technically a transfer agent, so follows the file
##H routing rules.  However it can only be a terminal node and is
##H somewhat simplified in its logic.  We also short-cut the data
##H wanted/available protocol as this is not a real transfer.
##H
##H Usage:
##H   FileSRMMigrate
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-log OUT]
##H      -storagemap PATH
##H
##H -state         agent state directory
##H -node          the node where this agent runs
##H -db            database connection configuration parameter file
##H -log           where to redirect logging information
##H -storagemap    storage mapping catalogue

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
	     "storagemap=s"=> \$args{STORAGEMAP},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG}
    || !$args{MYNODE} || !$args{STORAGEMAP})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileCastorMigrate (%args))->process();

######################################################################
# Routines for this agent.
package FileCastorMigrate; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  STORAGEMAP => undef,		# Program to query PFNs
		  WAITTIME => 150 + rand(50),	# Agent activity cycle
	  	  AGENTID => "FileDownload");	# Identity for activity logs
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	$dbh = &connectToDatabase ($self);

	# Follow minimally the transfer handshake so all accounting
	# infrastructure continues to report the right values.  The
	# assumption is of course the Buffer/MSS node is shared and
	# there are no transfers out from the MSS node.
	#
	# Automatically issue all files "in transfer", but do not
	# mark them wanted at the source: we don't want the stager
	# to activate on these files.
	my $start = &mytimeofday();
	&dbexec($dbh, qq{
	    update t_xfer_state
	    set from_state = 1, to_state = 2,
	        time_available = :now, time_xfer_start = :now
	    where to_node = :node and to_state = 0},
	    ":node" => $$self{ID_MYNODE}, ":now" => &mytimeofday());
	$dbh->commit();

	# Process files pending migration.
        my $xrstmt = &dbprep ($dbh, qq{
	    insert into t_xfer_replica
	    (id, fileid, node, state, time_create, time_state)
	    values (seq_xfer_replica.nextval, :fileid, :node, 0, :now, :now)});
        my $xsstmt = &dbprep ($dbh, qq{
	    update t_xfer_state
	    set to_state = 3, time_xfer_end = :now
	    where to_node = :node and fileid = :fileid});
        my $xdstmt = &dbprep ($dbh, qq{
	    delete from t_xfer_state
	    where to_node = :node and fileid = :fileid});
	my $q = &dbexec($dbh, qq{
	    select xs.fileid, f.logical_name, f.filesize, xs.time_available
	    from t_xfer_state xs join t_xfer_file f on f.id = xs.fileid
	    where xs.to_node = :node and xs.to_state = 2
	    order by xs.time_available asc},
  	    ":node" => $$self{ID_MYNODE});
	while (my ($fileid, $lfn, $size, $available) = $q->fetchrow())
	{
	    # Check if the file has been migrated.  If not, skip it.
	    my $pfn = &pfnLookup ($lfn, "direct", "local", $$self{STORAGEMAP});
	    do { &alert ("failed to find pfn for file $lfn"); next } if !$pfn;

            # Check the status of the file
            my $migrated = 0;
            open(INFO, "srm-get-metadata $pfn |");
            while(<INFO>) {
                if (/isPermanent :true/) {
                    $migrated = 1;
                }
            }
            close (INFO)
                or &alert( "No dCache migration info for $pfn: $!" );

	    next if (! $migrated);

	    # Migrated, mark transfer completed
	    my $now = &mytimeofday();
	    my %args = (":node" => $$self{ID_MYNODE}, ":fileid" => $fileid);
	    &dbbindexec($xsstmt, %args, ":now" => $now);
	    &dbbindexec($xrstmt, %args, ":now" => $now);
	    &dbbindexec($xdstmt, %args);
	    $dbh->commit ();

	    # Log delay data.
    	    &logmsg ("xstats: $$self{MYNODE} "
		     . sprintf('%.1fs', $now - $available)
		     . " $size $lfn $pfn");

	    # Give up if we've taken too long
	    last if $now - $start > 10*60;
	}
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}
