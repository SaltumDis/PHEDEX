#!/usr/bin/env perl

##H Manage downloads into a dCache MSS node, marking transfer completed
##H when the files have been migrated to tape.
##H
##H This agent is technically a transfer agent, so follows the file
##H routing rules.  However it can only be a terminal node and is
##H somewhat simplified in its logic.  We also short-cut the data
##H wanted/available protocol as this is not a real transfer.
##H
##H Usage:
##H   FileDCacheMigrate
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-log OUT]
##H      -pfnquery COMMAND[,ARGS...]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -pfnquery  command to query pfns from catalogue
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
	     "pfnquery=s"  => sub { push(@{$args{PFN_QUERY}}, split(/,/, $_[1])) },
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG}
    || !$args{MYNODE} || !$args{PFN_QUERY})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileDCacheMigrate (%args))->process();

######################################################################
# Routines for this agent.
package FileDCacheMigrate; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  PFN_QUERY => undef,		# Program to query PFNs
		  WAITTIME => 150 + rand(50),	# Agent activity cycle
	  	  AGENTID => "FileDownload");	# Identity for activity logs
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

        # Follow minimally the transfer handshake so all accounting
        # infrastructure continues to report the right values.  The
        # assumption is of course the Buffer/MSS node is shared and
        # there are no transfers out from the MSS node.
        #
        # Automatically issue all files "in transfer", but do not
        # mark them wanted at the source: we don't want the stager
        # to activate on these files.
	my $start = &mytimeofday();
        &dbexec($dbh, qq{
            update t_xfer_state
            set from_state = 1, to_state = 2
                time_available = :now, time_xfer_start = :now
            where to_node = :node and to_state = 0},
            ":node" => $$self{ID_MYNODE}, ":now" => &mygettimeofday());
        $dbh->commit();

        # Process files pending migration.
        my $xrstmt = &dbprep ($dbh, qq{
            insert into t_xfer_replica
            (id, fileid, node, state, time_create, time_state)
            values (seq_xfer_replica.nextval, :fileid, :node, 0, :now, :now)});
        my $xsstmt = &dbprep ($dbh, qq{
            update t_xfer_state
            set to_state = 3, time_xfer_end = :now
            where to_node = :node and fileid = :fileid});
        my $xdstmt = &dbprep ($dbh, qq{
	    delete from t_xfer_state
	    where to_node = :node and fileid = :fileid});
        my $q = &dbexec($dbh, qq{
            select xs.fileid, f.logical_name, f.filesize, xs.time_available
            from t_xfer_state xs join t_xfer_file f on f.fileid = xs.fileid
            where xs.to_node = :node and xs.to_state = 2
            order by xs.time_available asc},
            ":node" => $$self{ID_MYNODE});
        while (my ($fileid, $lfn, $size, $available) = $q->fetchrow())
        {
            # Check if the file has been migrated.  If not, skip it.
            my $pfn = &pfnLookup ($lfn, "direct", "local", @{$$self{PFN_QUERY}});
            do { &alert ("failed to find pfn for file $lfn"); next } if !$pfn;

	    # Get the path and the filename
	    my ($path, $filename) = ($pfn =~ m!(.*)/(.*)!);

	    # Read dCache stage info
	    open (DCACHE, "$path/.(use)(1)($filename)")
		or die "no migration info for $pfn: $!";
	    my $status = <DCACHE>;
	    close (DCACHE):
	    next if !$status;

            # Migrated, mark transfer completed
            my $now = &mytimeofday();
	    my %args = (":node" => $$self{ID_MYNODE}, ":fileid" => $fileid);
	    &dbbindexec($xsstmt, %args, ":now" => $now);
	    &dbbindexec($xrstmt, %args, ":now" => $now);
	    &dbbindexec($xdstmt, %args);
            $dbh->commit ();

            # Log delay data.
            &logmsg ("xstats: $$self{MYNODE} "
                     . sprintf('%.1fs', $now - $available)
                     . " $size $lfn");

            # Give up if we've taken too long
            last if $now - $start > 10*60;
        }
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}
