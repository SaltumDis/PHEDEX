#!/usr/bin/env perl

##H Manage downloads into a dCache MSS node, marking transfer completed
##H when the files have been migrated to tape.
##H
##H This agent is technically a transfer agent, so follows the file
##H routing rules.  However it can only be a terminal node and is
##H somewhat simplified in its logic.  We also short-cut the data
##H wanted/available protocol as this is not a real transfer.
##H
##H Usage:
##H   FileDCacheMigrate
##H      -state DIRECTORY -db FILE[:SECTION] [-log OUT]
##H      -nodes PATTERN[,PATTERN...] [-protocols PROTOCOL[,PROTOCOL...]]
##H
##H -state         agent state directory
##H -db            database connection configuration parameter file
##H -log           where to redirect logging information
##H -nodes         the nodes for which this agent runs
##H -protocols     the protocols accepted by this agent (default: 'direct')

######################################################################
my %args;
use Getopt::Long;
use PHEDEX::Core::Help;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "nodes=s"     => sub { push(@{$args{NODES}},
                                         split(/,/, $_[1])) },
             "protocols=s" => sub { push(@{$args{PROTOCOLS}},
                                         split(/,/, $_[1])) },
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG} || !$args{NODES})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileDCacheMigrate (%args))->process();

######################################################################
# Routines for this agent.
package FileDCacheMigrate; use strict; use warnings; use base 'PHEDEX::Core::Agent';
use PHEDEX::Core::Command;
use PHEDEX::Core::Logging;
use PHEDEX::Core::Timing;
use PHEDEX::Core::Catalogue;
use PHEDEX::Core::DB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  NODES => undef,		# Nodes to operate for
		  PROTOCOLS => [ 'direct' ],	# Protocols to accept
		  WAITTIME => 150 + rand(50),	# Agent activity cycle
	  	  AGENTID => "FileDownload");	# Identity for activity logs
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	# Automate portions of the hand shake so accounting reports
	# the right values.  The Buffer/MSS nodes are expected to be
	# shared in reality and this agent to be the only one making
	# transfers to the MSS.

	my @nodes;
	($dbh, @nodes) = &expandNodesAndConnect ($self);
	my ($mynode, %myargs) = &myNodeFilter($self, "xt.to_node");
	my $start = &mytimeofday();

	# Advertise myself available so file routing kicks in.
        &dbexec($dbh, qq{delete from t_xfer_sink xt where $mynode}, %myargs);
        &dbexec($dbh, qq{
            insert into t_xfer_sink (from_node, to_node, protocols, time_update)
            select xt.from_node, xt.to_node, :protos, :now from t_adm_link xt
            where $mynode},
            ":protos" => "@{$$self{PROTOCOLS}}", ":now" => $start, %myargs);

	# Auto-export from buffer to me and put them into transfer.
	&dbexec($dbh, qq{
	    insert all
	       into t_xfer_task_export values (id, :now)
	       into t_xfer_task_inxfer values (id, :now)
	    select xt.id from t_xfer_task xt
	    where $mynode
	      and not exists
	        (select 1 from t_xfer_task_export xte where xte.task = xt.id)},
	    ":now" => $start, %myargs);

	$dbh->commit();

	# Pick up work and process it.
        my $done = &dbprep ($dbh, qq{
	    insert into t_xfer_task_done
	    (task, report_code, xfer_code, time_xfer, time_update)
	    values (:task, 0, 0, :now, :now)});
	my $q = &dbexec($dbh, qq{
	    select
	      xt.id, n.name, f.filesize, f.logical_name,
	      xt.to_pfn, xt.time_assign
	    from t_xfer_task xt
	      join t_xfer_file f on f.id = xt.fileid
	      join t_adm_node n on n.id = xt.to_node
	    where $mynode
	      and not exists
	        (select 1 from t_xfer_task_done xtd where xtd.task = xt.id)
	    order by xt.time_assign asc, xt.rank asc}, %myargs);
	while (my ($task, $dest, $size, $lfn, $pfn, $available) = $q->fetchrow())
	{
            # Get the path and the filename
            my ($path, $filename) = ($pfn =~ m!(.*)/(.*)!);

	    # Check if the file has been migrated.  If not, skip it.
	    open (DCACHE, "$path/.(use)(1)($filename)")
		or do { &warn ("no migration info for $pfn: $!"); next };
	    my $status = <DCACHE>;
	    close (DCACHE)
		or do { &warn ("no migration info for $pfn: $?"); next };

	    next if !$status;

	    # Migrated, mark transfer completed
	    my $now = &mytimeofday();
	    &dbbindexec($done, ":task" => $task, ":now" => $now);
	    $dbh->commit ();

	    # Log delay data.
    	    &logmsg ("xstats: to_node=$dest time="
		     . sprintf('%.1fs', $now - $available)
		     . " size=$size lfn=$lfn pfn=$pfn");

	    # Give up if we've taken too long
	    last if $now - $start > 10*60;
	}
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}
