#!/usr/bin/perl

## Prestage castor files before passing them to the rest of the chain.
##
## This agent scans the XML catalogues of all drops in its work queue
## and stages in all the files that are not currently staged in.  The
## drops stay pending in the work queue until all the files have been
## staged in.
##
## The stage-in is done according to the instructions of the Castor
## team to avoid overloading the stager and tape systems.  The stage
## requests are ordered by tape name and position of the files.  We
## issue several stage requests in one command to reduce the number
## of stager processes at the server (there is one process for each
## request).  Moreover, we throttle ourselves back if the number of
## pending tape mounts is high (~4000) or pending stage requests is
## high (~200).
##
## The file names in the catalogues must be correct full PFNs, the
## agent does check that the file exists in Castor before attempting
## to stage the files in.
##
## Because the agent wants to process simultaneously as many drops as
## possible, all the work is done in &idle().

BEGIN { use strict; $^W = 1; }
my ($dropdir, @nextdir, $inbox, $workdir, $outdir, $stopflag, $pidfile);
my @startTime;
my $waittime = 59;		# Seconds to sleep between file checks
my %bad = ();			# Drops we've warned are bad
my %junk = ();			# Drops we've warned are junk in inbox

my $maxhours = 60;		# Number of hours to retry stagein
my $maxtapereqs = 4000;		# Max pending tape mounts
my $maxmytapereqs = 1000;	# Max pending tape mounts by myself
my $maxstagereqs = 200;		# Max pending stager requests
my $maxfiles = 50;		# Max number of files in one request

$ENV{STAGE_HOST} ||= "stagecmsprod";	# Castor stage host
$ENV{STAGE_POOL} ||= "cms_prod2";	# Castor stage pool

my $me = $0; $me =~ s|.*/||;
my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";

my $STAGE_RETRY = -2;		# Retry another time
my $STAGE_NONEXISTENT = -1;	# No such file
my $STAGE_ON_DISK = 0;		# File has been staged on disk
my $STAGE_PENDING = 1;		# Stage-in still in progress
my $STAGE_UNKNOWN = 2;		# Stager hasn't heard of this file

use File::Path;
use Data::Dumper;
eval qx(cat "$home/UtilsReaders.pm"); die $@ if $@;
eval qx(cat "$home/UtilsAgent.pm"); die $@ if $@;

######################################################################
# Routines specific to this agent.

# Find out if the PFN exists in Castor, and if so, the tape it is on,
# the position on the tape and the file size.  Return a four-tuple of
# success, tape, position and size.  The success is zero if we failed
# to execute nsls; this probably indicates a transient error.  If the
# success code is non-zero, then the rest are the file attributes; if
# the values are undef, the file doesn't exist.
sub fileProperties
{
    my ($pfn, $cache) = @_;
    if (! exists $cache->{$pfn})
    {
	# Fill cache for the whole directory
	my $dir = $pfn; $dir =~ s|/[^/]+$||;
	open (NSLS, "nsls -lT $dir |") || return (0, undef, undef, undef);
	while (<NSLS>)
	{
	    chomp;
	    my ($tape, $pos, $size, $file) = (split (/\s+/, $_))[3,4,6,8];
	    $cache->{"$dir/$file"} = [ $tape, $pos, $size ];
	}
	close (NSLS);
    }

    return (1, @{$cache->{$pfn}});
}

# Find out files stager knows about.  Returns a reference to a hash of
# PFNs currently in the stager disk pool, each with stager status such
# as "STAGED" or "STAGEIN".   Returns undef if stageqry cannot be run.
# The latter should be treated as a transient error.
sub stagerFileList
{
    open(STAGEQ, "stageqry -h $ENV{STAGE_HOST} -p $ENV{STAGE_POOL} -a --format status,xfile |")
	|| return undef;
    my $files = {};
    while (<STAGEQ>) {
	my ($status, $file) = split(/\s+/, $_);
	$files->{$file} = $status;
    }
    close(STAGEQ);
    return $files;
}

# Figure out tape mount load level.  Returns a tuple of total number
# of requests and requests by ourselves.  The values are undef if we
# cannot run the necessary programs for some reason.  This should be
# considered a transient error.
sub tapeMountLoad
{
    my ($total, $ours) = (0, 0);
    open(QSTAT, "showqueues -x |")
	or do { &alert ("cannot run showqueues: $!"); return (undef, undef); };
    while (<QSTAT>)
    {
	$total++ if /^Q/;
	$ours++ if /^Q.*cmsprod/; # FIXME: don't hardcode cmsprod
    }
    close (QSTAT);
    return ($total, $ours);
}

# Figure out stager load level.  Returns the number of outstanding
# requests or undef if we cannot run the necessary programs for
# some reason.  The latter should be considered a transient error.
sub stagerLoad
{
    open(STAGEQ, "stageqry -h $ENV{STAGE_HOST} -a --format status |")
	or do { &alert ("cannot run stageqry: $!"); return undef; };
    my $reqs = scalar (grep(/STAGEIN/, <STAGEQ>));
    close(STAGEQ);
    return $reqs;
}

# Update the stage-in status of a file.  If we haven't initialised
# state data for the file, do so.  Then check if the file is staged
# in; if so, return $STAGE_ON_DISK to indicate it's availabale.
# Otherwise if more than 15 minutes have passed since we requested
# the file to be staged in, check that the system still knows it's
# being requested; if not, including if we never asked for the file
# before, return $STAGE_UNKNOWN to indicate new stage-in is needed.
# Returns $STAGE_NONEXISTENT if the file doesn't exist at all, and
# $STAGE_RETRY if there was a transient error.
sub checkFileStatus
{
    my ($file, $cache, $stagedin) = @_;
    my $pfn = $file->{PFN};

    # Get file properties if we don't have them.  If this fails
    # return undef to indicate transient failure.  Otherwise if
    # the file doesn't exist, return zero to indicate failure.
    if (! exists $file->{TAPE})
    {
	my ($success, $tape, $pos, $size) = &fileProperties ($pfn, $cache);
	return $STAGE_RETRY if ! $success;
	return $STAGE_NONEXISTENT
	    if (! defined $tape || ! defined $pos || ! defined $size);
	$file->{STATUS} = $STAGE_UNKNOWN;
	$file->{TAPE} = $tape;
	$file->{POS} = $pos;
	$file->{SIZE} = $size;
	$file->{LAST} = 0;
	$file->{STARTED} = time();
	$file->{DIRTY} = 1;
    }

    # Check if it's in the list of staged in files.
    return $STAGE_ON_DISK if (($stagedin->{$pfn} || '') eq 'STAGED');

    # If it's more than 15 minutes since we last requested for
    # stage-in, check that the system still knows we want it.
    # If not, including if we never requested for the file,
    # mark it as requiring stage-in.
    my $now = time ();
    if (! $file->{LAST})
    {
	$file->{LAST} = $now;
	$file->{DIRTY} = 1;
    }
    elsif ($file->{STATUS} == $STAGE_PENDING && $now - $file->{LAST} > 900)
    {
	if ($now - $file->{STARTED} > $maxhours * 3600)
	{
	    &alert("file could not be staged in $maxhours hours, giving up");
	    &markBad ($file->{DROP});
	    $file->{BAD} = 1;
	    $file->{DIRTY} = 1;
	    return $STAGE_RETRY;
	}

	$file->{LAST} = $now;
	$file->{DIRTY} = 1;
	return $STAGE_RETRY if ! defined $stagedin->{$pfn};
	return $STAGE_PENDING if $stagedin->{$pfn} eq 'STAGEIN'; # Still known
	&alert ("File lost STAGEIN status, requesting again: $pfn");
    }

    # This file needs to be staged in
    return $STAGE_UNKNOWN;
}

# Check and update the status of all files.
sub updateFileStatus
{
    my ($file, $cache, $stagedin) = @_;

    # Ignore files we've already complained about
    return if $file->{BAD};

    my $status = &checkFileStatus ($file, $cache, $stagedin);
    if ($status == $STAGE_RETRY)
    {
	# Try again another time
	return;
    }
    elsif ($status == $STAGE_NONEXISTENT)
    {
	# Bad file, mark it bad
	&alert ("$file->{DROP}: no such file $file->{PFN}");
	&markBad ($file->{DROP});
	$file->{BAD} = 1;
	$file->{DIRTY} = 1;
    }
    elsif ($status != $file->{STATUS})
    {
	# Update the file status
	$file->{STATUS} = $status;
	$file->{DIRTY} = 1;
    }
}

# Restore saved file status
sub readStageInProgress
{
    my (@pending) = @_;
    my @files = ();

    # Read in current file status
    for my $drop (@pending)
    {
	&maybeStop();

    	# Sanity checking
    	next if (! &inspectDrop ($drop));
    	delete $bad{$drop};

	# Get XML catalogue
	my $xmlcat = (<$workdir/$drop/XMLCatFragment.*.{txt,xml}>)[0];
	if (! defined $xmlcat)
	{
	    &alert ("no xml catalogue in $drop");
	    &markBad ($drop);
	    next;
	}
    	my $catalog = &readXMLCatalog ($drop, $xmlcat);
    	next if ! keys %$catalog;

	# Create status object for each file, read in saved one if it exists.
    	foreach my $file (values %$catalog)
    	{
	    my $pfn = $file->{PFN}[0];
	    my $lfn = $file->{LFN}[0];
	    my $info = { DROP => $drop, PFN => $pfn, LFN => $lfn };
	    if (-f "$workdir/$drop/stagein.$lfn")
	    {
		my $saved = eval &input ("$workdir/$drop/stagein.$lfn");
		if ($@) {
		    &warn ("ignoring corrupt stagein status for $drop/$lfn: $@");
		} else {
		    $info = $saved;
		    $info->{DIRTY} = 0;
		}
	    }
	    push(@files, $info);
        }
    }

    return @files;
}

# Flush drops whose files have been staged in.
sub flushStagedInDrops
{
    my ($files, $pending) = @_;

    # Mark done drops whose all files have been staged in
    my %drops = ();
    my @remaining = ();
    foreach my $file (@$files)
    {
	my $drop = $file->{DROP};
	$drops{$drop} ||= [ 0, 0, time() ];
	$drops{$drop}[0]++;
	$drops{$drop}[1]++ if $file->{STATUS} == $STAGE_ON_DISK;
	$drops{$drop}[2] = $file->{STARTED} if $drops{$drop}[2] > $file->{STARTED};
    }
    foreach my $drop (sort keys %drops)
    {
	if ($drops{$drop}[0] == $drops{$drop}[1] && ! -f "$workdir/$drop/bad")
	{
	    my $timing = [];
	    &timeStart($timing);
	    $timing->[0] = $drops{$drop}[2];
	    unlink (<$workdir/$drop/stagein.*>);
	    &touch ("$workdir/$drop/done");
	    &relayDrop ($drop);
	    &logmsg ("stats: $drop @{[&formatElapsedTime($timing)]} success");
	}
	else
	{
	    push(@remaining, $drop);
	}
    }

    @$pending = @remaining;
}

# Save the file status for the given files
sub saveFileStatus
{
    foreach my $file (@_)
    {
	next if ! $file->{DIRTY};
        &alert ("failed to update stagein status for $file->{LFN}")
	    if ! &output ("$workdir/$file->{DROP}/stagein.$file->{LFN}", Dumper ($file));
    }
}

# Update the status for all files, then determine which drops are ready
# to proceed and which ones need staging in.
sub processAllFiles
{
    my (@pending) = @_;
    while (@pending)
    {
	&maybeStop();

        # Recover where we were
        my @files = &readStageInProgress (@pending);

        # Get the list of files already staged in
        my $stagedin = &stagerFileList();
        return if ! defined $stagedin;

        # Update status
	my %cache = ();
        foreach my $file (@files) {
            &updateFileStatus ($file, \%cache, $stagedin);
        }

        # Write out the new file state
	&saveFileStatus (@files);

	# Send out completely staged in drops
	&flushStagedInDrops(\@files, \@pending);

        # Determine the files that need to be staged in, in a good order
        # i.e. sorted by tape and position, then issue requests in batches.
        my @requests = sort { $a->{TAPE} cmp $b->{TAPE} || $a->{POS} cmp $b->{POS} }
		       grep ($_->{STATUS} == $STAGE_UNKNOWN, @files);
	while (@requests)
	{
	    # Suspend until the system load drops low enough, and then go back
	    # to start of the loop so we reconsider staged in files and send
	    # them out.  Also makes it safer if we get stopped.
	    my ($tapereqs, $mytapereqs, $stagereqs) = (&tapeMountLoad(), &stagerLoad());
	    if (! defined $tapereqs
	        || ! defined $mytapereqs
	        || ! defined $stagereqs
	        || $tapereqs > $maxtapereqs
	        || $mytapereqs > $maxmytapereqs
	        || $stagereqs > $maxstagereqs)
	    {
	        $tapereqs = 'U' if ! defined $tapereqs;
	        $mytapereqs = 'U' if ! defined $mytapereqs;
	        $stagereqs = 'U' if ! defined $stagereqs;
	        &note ("backing out, overloaded ($tapereqs/$mytapereqs/$stagereqs)");
	        return;
	    }

	    # Select the next up to $maxfiles to stage in
	    my $nfiles = ($#requests > $maxfiles ? $maxfiles : $#requests);
	    my @slice = @requests[$#requests - $nfiles .. $#requests];
	    delete @requests[$#requests - $nfiles .. $#requests];

	    # Mark these files as pending now
	    map { $_->{STATUS} = $STAGE_PENDING; $_->{DIRTY} = 1; } @slice;
	    &saveFileStatus (@slice);

	    # Issue background stage-in
	    my $rc = &runcmd ("stagein", "--nowait", "--rdonly",
			      "-h", $ENV{STAGE_HOST}, "-p", $ENV{STAGE_POOL},
			      "-A", "deferred",
			      map { ("-M", $_->{PFN}) } @slice);
	    &alert ("stagein failed: @{[&runerror($rc)]}") if ($rc);

	    # Sleep a bit, castor doesn't like rapid-fire request chains
	    select (undef, undef, undef, 0.33);
	}
    }
}

# Actually process the drop.  Do nothing here.
sub processDrop {}

sub idle
{
    my ($sleep, @pending) = @_;
    &timeStart();
    &processAllFiles (@pending);
    &maybeStop();
    sleep ($sleep);
}

while (scalar @ARGV)
{
    if ($ARGV[0] eq '-stagehost' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_HOST} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-stagepool' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_POOL} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-hours' && scalar @ARGV > 1)
    { shift (@ARGV); $maxhours = shift(@ARGV); }
    elsif ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $dropdir = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@nextdir, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $waittime = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$dropdir)
{
    print STDERR
	"usage: $me\n",
	"    -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-stagehost STAGE-HOST] [-stagepool POOL]\n",
	"    [-hours MAX-HOURS] [-wait SECS-TO-WAIT]\n";
    exit (1);
}

&process();
