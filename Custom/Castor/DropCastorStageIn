#!/usr/bin/perl

## Prestage castor files before passing them to the rest of the chain.
##
## This agent scans the XML catalogues of all drops in its work queue
## and stages in all the files that are not currently staged in.  The
## drops stay pending in the work queue until all the files have been
## staged in.
##
## The stage-in is done according to the instructions of the Castor
## team to avoid overloading the stager and tape systems.  The stage
## requests are ordered by tape name and position of the files.  We
## issue several stage requests in one command to reduce the number
## of stager processes at the server (there is one process for each
## request).  Moreover, we throttle ourselves back if the number of
## pending tape mounts is high (~4000) or pending stage requests is
## high (~200).
##
## The file names in the catalogues must be correct full PFNs, the
## agent does check that the file exists in Castor before attempting
## to stage the files in.
##
## Because the agent wants to process simultaneously as many drops as
## possible, all the work is done in &idle().

BEGIN { use strict; $^W = 1; }
my ($dropdir, @nextdir, $inbox, $workdir, $outdir, $stopflag, $pidfile);
my @startTime;
my $waittime = 59;		# Seconds to sleep between file checks
my %bad = ();			# Drops we've warned are bad
my %junk = ();			# Drops we've warned are junk in inbox

my $maxhours = 60;		# Number of hours to retry stagein
my $maxtapereqs = 4000;		# Max pending tape mounts
my $maxmytapereqs = 1000;	# Max pending tape mounts by myself
my $maxstagereqs = 200;		# Max pending stager requests
my $maxfiles = 200;		# Max number of files in one request

$ENV{STAGE_HOST} ||= "stagecmsprod";	# Castor stage host
$ENV{STAGE_POOL} ||= "cms_prod2";	# Castor stage pool

my $me = $0; $me =~ s|.*/||;
my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";

my $STAGE_RETRY = -2;		# Retry another time
my $STAGE_NONEXISTENT = -1;	# No such file
my $STAGE_ON_DISK = 0;		# File has been staged on disk
my $STAGE_PENDING = 1;		# Stage-in still in progress
my $STAGE_UNKNOWN = 2;		# Stager hasn't heard of this file

use File::Path;
use Data::Dumper;
eval qx(cat "$home/UtilsReaders.pm"); die $@ if $@;
eval qx(cat "$home/UtilsAgent.pm"); die $@ if $@;

######################################################################
# Routines specific to this agent.

# Find out stager status for a file
sub stageQueryFile
{
    my $pfn = shift;
    my $status = "UNSTAGED";
    open (PFN, "stageqry -h $ENV{STAGE_HOST} --noheader --format status -M $pfn |");
    while (<PFN>) 
    {
	chomp;
	$status = $_;
    }
    close (PFN);
    return $status;
}

# Find out if the PFN exists in Castor, and if so, the tape it is on,
# the position on the tape and the file size.  Return a four-tuple of
# success, tape, position and size.  The success is zero if we failed
# to execute nsls; this probably indicates a transient error.  If the
# success code is non-zero, then the rest are the file attributes; if
# the values are undef, the file doesn't exist.
sub fileProperties
{
    my ($pfn) = @_;
    open (NSLS, "nsls -lT $pfn |") || return (0, undef, undef, undef);
    my ($tape, $pos, $size) = (split(/\s+/, <NSLS>))[3,4,6];
    close (NSLS);
    return (1, $tape, $pos, $size);
}

# Find out which files are currently staged in.  Returns the list of
# PFNs currently staged in on the disk pool, or undef if stageqry
# cannot be run.  The latter should be treated as a transient error.
sub stagedInFiles
{
    open(STAGEQ, "stageqry -h $ENV{STAGE_HOST} -p $ENV{STAGE_POOL} -a --format xfile |")
	|| return undef;
    my @files = map { chomp; $_ } <STAGEQ>;
    close(STAGEQ);
    return @files;
}

# Figure out tape mount load level.  Returns a tuple of total number
# of requests and requests by ourselves.  The values are undef if we
# cannot run the necessary programs for some reason.  This should be
# considered a transient error.
sub tapeMountLoad
{
    my ($total, $ours) = (0, 0);
    open(QSTAT, "showqueues -x |")
	or do { &alert ("cannot run showqueues: $!"); return (undef, undef); };
    while (<QSTAT>)
    {
	$total++ if /^Q/;
	$ours++ if /^Q.*cmsprod/; # FIXME: don't hardcode cmsprod
    }
    close (QSTAT);
    return ($total, $ours);
}

# Update the stage-in status of a file.  If we haven't initialised
# state data for the file, do so.  Then check if the file is staged
# in; if so, return $STAGE_ON_DISK to indicate it's availabale.
# Otherwise if more than 15 minutes have passed since we requested
# the file to be staged in, check that the system still knows it's
# being requested; if not, including if we never asked for the file
# before, return $STAGE_UNKNOWN to indicate new stage-in is needed.
# Returns $STAGE_NONEXISTENT if the file doesn't exist at all, and
# $STAGE_RETRY if there was a transient error.
sub checkFileStatus
{
    my ($file, $stagedin) = @_;
    my $pfn = $file->{PFN};

    # Get file properties if we don't have them.  If this fails
    # return undef to indicate transient failure.  Otherwise if
    # the file doesn't exist, return zero to indicate failure.
    if (! exists $file->{TAPE})
    {
	my ($success, $tape, $pos, $size) = &fileProperties ($pfn);
	return $STAGE_RETRY if ! $success;
	return $STAGE_NONEXISTENT
	    if (! defined $tape || ! defined $pos || ! defined $size);
	$file->{STATUS} = $STAGE_UNKNOWN;
	$file->{TAPE} = $tape;
	$file->{POS} = $pos;
	$file->{SIZE} = $size;
	$file->{LAST} = 0;
	$file->{STARTED} = time();
    }

    # Check if it's in the list of staged in files.
    return $STAGE_ON_DISK if grep ($_ eq $pfn, @$stagedin);

    # If it's more than 15 minutes since we last requested for
    # stage-in, check that the system still knows we want it.
    # If not, including if we never requested for the file,
    # mark it as requiring stage-in.
    my $now = time ();
    if (! $file->{LAST})
    {
	$file->{LAST} = $now;
    }
    elsif ($now - $file->{LAST} > 900)
    {
	if ($now - $file->{STARTED} > $maxhours * 3600)
	{
	    &alert("file could not be staged in $maxhours hours, giving up");
	    &markBad ($file->{DROP});
	    $file->{BAD} = 1;
	    return $STAGE_RETRY;
	}

	$file->{LAST} = $now;
	my $status = &stageQueryFile ($pfn);
	return $STAGE_RETRY if ! defined $status;
	return $STAGE_PENDING if $status eq 'STAGEIN'; # Still known
	
	&alert ("File lost STAGEIN status, requesting again: $pfn");
    }

    # This file needs to be staged in
    return $STAGE_UNKNOWN;
}

# Check and update the status of all files.
sub updateFileStatus
{
    my ($file, $stagedin) = @_;

    # Ignore files we've already complained about
    return if $file->{BAD};

    my $status = &checkFileStatus ($file, $stagedin);
    if ($status == $STAGE_RETRY)
    {
	# Try again another time
	return;
    }
    elsif ($status == $STAGE_NONEXISTENT)
    {
	# Bad file, mark it bad
	&alert ("$file->{DROP}: no such file $file->{PFN}");
	&markBad ($file->{DROP});
	$file->{BAD} = 1;
    }
    else
    {
	# Update the file status, and add to files we need
	$file->{STATUS} = $status;
    }

    # Write out the new file state
    &alert ("failed to update stagein status for $file->{LFN}")
	if ! &output ("$workdir/$file->{DROP}/stagein.$file->{LFN}", Dumper ($file));
}

# Update the status for all files, then determine which drops are ready
# to proceed and which ones need staging in.
sub processAllFiles
{
    my (@pending) = @_;
    my @files = ();

    # Read in current file status
    for my $drop (@pending)
    {
    	# Sanity checking
    	next if (! &inspectDrop ($drop));
    	delete $bad{$drop};

	# Get XML catalogue
	my $xmlcat = (<$workdir/$drop/XMLCatFragment.*.{txt,xml}>)[0];
	if (! defined $xmlcat)
	{
	    &alert ("no xml catalogue in $drop");
	    &markBad ($drop);
	    next;
	}
    	my $catalog = &readXMLCatalog ($drop, $xmlcat);
    	next if ! keys %$catalog;

	# Create status object for each file, read in saved one if it exists.
    	foreach my $file (values %$catalog)
    	{
	    my $pfn = $file->{PFN}[0];
	    my $lfn = $file->{LFN}[0];
	    my $info = { DROP => $drop, PFN => $pfn, LFN => $lfn };
	    if (-f "$workdir/$drop/stagein.$lfn")
	    {
		my $saved = eval &input  ("$workdir/$drop/stagein.$lfn");
		if ($@) {
		    &warn ("ignoring corrupt stagein status for $drop/$lfn: $@");
		} else {
		    $info = $saved;
		}
	    }
	    push(@files, $info);
        }
    }

    # Get the list of files already staged in
    my @staged = &stagedInFiles();
    return if grep (! defined $_, @staged);

    # Update status
    foreach my $file (@files) {
        &updateFileStatus ($file, \@staged);
    }

    # Mark done drops whose all files have been staged in
    my %drops = ();
    foreach my $file (@files)
    {
	my $drop = $file->{DROP};
	$drops{$drop} ||= [ 0, 0, time() ];
	$drops{$drop}[0]++;
	$drops{$drop}[1]++ if $file->{STATUS} == $STAGE_ON_DISK;
	$drops{$drop}[2] = $file->{STARTED} if $drops{$drop}[2] > $file->{STARTED};
    }
    foreach my $drop (keys %drops)
    {
	if ($drops{$drop}[0] == $drops{$drop}[1] && ! -f "$workdir/$drop/bad")
	{
	    my $timing = [];
	    &timeStart($timing);
	    $timing->[0] = $drops{$drop}[2];
	    &touch ("$workdir/$drop/done");
	    &relayDrop ($drop);
	    &logmsg ("stats: $drop @{[&formatElapsedTime($timing)]} success");
	}
    }

    # Determine the files that need to be staged in, in a good order
    # i.e. sorted by tape and position, then issue requests in batches.
    my @requests = map { $_->{PFN} }
		   sort { $a->{TAPE} cmp $b->{TAPE} || $a->{POS} cmp $b->{POS} }
		   grep ($_->{STATUS} == $STAGE_UNKNOWN, @files);
    while (scalar @requests)
    {
	my $nfiles = ($#requests > $maxfiles ? $maxfiles : $#requests);
	my @slice = @requests[0 .. $nfiles];
	delete @requests[0 .. $nfiles];

	my $rc = &runcmd ("stagein", "--nowait", "--rdonly",
			  "-h", $ENV{STAGE_HOST}, "-p", $ENV{STAGE_POOL},
			  "-A", "deferred",
			  map { ("-M", $_) } @slice);
	&alert ("stagein failed: @{[&runerror($rc)]}") if ($rc);
    }
}

# Actually process the drop.  Do nothing here.
sub processDrop {}

sub idle
{
    my ($sleep, @pending) = @_;
    my ($tapereqs, $mytapereqs) = &tapeMountLoad();

    &processAllFiles (@pending)
        if (defined $tapereqs
	    && $tapereqs < $maxtapereqs
	    && defined $mytapereqs
	    && $mytapereqs < $maxmytapereqs);

    &maybeStop();
    sleep ($sleep);
}

while (scalar @ARGV)
{
    if ($ARGV[0] eq '-stagehost' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_HOST} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-stagepool' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_POOL} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-hours' && scalar @ARGV > 1)
    { shift (@ARGV); $maxhours = shift(@ARGV); }
    elsif ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $dropdir = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@nextdir, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $waittime = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$dropdir)
{
    print STDERR
	"usage: $me\n",
	"    -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-stagehost STAGE-HOST] [-stagepool POOL]\n",
	"    [-hours MAX-HOURS] [-wait SECS-TO-WAIT]\n";
    exit (1);
}

&process();
