#!/usr/bin/env perl

## Prestage castor files before passing them to the rest of the chain.
##
## This agent scans the XML catalogues of all drops in its work queue
## and stages in all the files that are not currently staged in.  The
## drops stay pending in the work queue until all the files have been
## staged in.
##
## The stage-in is done according to the instructions of the Castor
## team to avoid overloading the stager and tape systems.  The stage
## requests are ordered by tape name and position of the files.  We
## issue several stage requests in one command to reduce the number
## of stager processes at the server (there is one process for each
## request).  Moreover, we throttle ourselves back if the number of
## pending tape mounts is high (~4000) or pending stage requests is
## high (~200).
##
## The file names in the catalogues must be correct full PFNs, the
## agent does check that the file exists in Castor before attempting
## to stage the files in.
##
## Because the agent wants to process simultaneously as many drops as
## possible, all the work is done in &idle().

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
$ENV{STAGE_HOST} ||= "stagecmsprod";	# Castor stage host
$ENV{STAGE_POOL} ||= "cms_prod2";	# Castor stage pool
my %args = (WAITTIME => 59);		# Sleep time between checks
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-stagehost' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_HOST} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-stagepool' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_POOL} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-hours' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MAXHOURS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@{$args{NEXTDIR}}, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$args{DROPDIR})
{
    print STDERR
	"usage: $me\n",
	"    -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-stagehost STAGE-HOST] [-stagepool POOL]\n",
	"    [-hours MAX-HOURS] [-wait SECS-TO-WAIT]\n";
    exit (1);
}

(new DropCastorStageIn (%args))->process();

######################################################################
# Routines specific to this agent.
package DropCastorStageIn; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsReaders;

our ($STAGE_RETRY, $STAGE_NONEXISTENT, $STAGE_ON_DISK, $STAGE_PENDING, $STAGE_UNKNOWN);

sub new
{
    # Somehow initialising these at package level doesn't set them
    $STAGE_RETRY = -2;		# Retry another time
    $STAGE_NONEXISTENT = -1;	# No such file
    $STAGE_ON_DISK = 0;		# File has been staged on disk
    $STAGE_PENDING = 1;		# Stage-in still in progress
    $STAGE_UNKNOWN = 2;		# Stager hasn't heard of this file

    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MAXHOURS => 60,	# Number of hours to retry stagein
    	    	  MAXTAPEREQS => 4000,	# Max pending tape mounts
    	    	  MAXMYTAPEREQS => 1000,# Max pending tape mounts by myself
    	    	  MAXSTAGEREQS => 200,	# Max pending stager requests
    	    	  MAXFILES => 50);	# Max number of files in one request
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Find out if the PFN exists in Castor, and if so, the tape it is on,
# the position on the tape and the file size.  Return a four-tuple of
# success, tape, position and size.  The success is zero if we failed
# to execute nsls; this probably indicates a transient error.  If the
# success code is non-zero, then the rest are the file attributes; if
# the values are undef, the file doesn't exist.
sub fileProperties
{
    my ($pfn, $cache) = @_;
    if (! exists $cache->{$pfn})
    {
	# Fill cache for the whole directory
	my $dir = $pfn; $dir =~ s|/[^/]+$||;
	open (NSLS, "nsls -lT $dir |") || return (0, undef, undef, undef);
	while (<NSLS>)
	{
	    chomp;
	    my ($tape, $pos, $size, $file) = (split (/\s+/, $_))[3,4,6,8];
	    $cache->{"$dir/$file"} = [ $tape, $pos, $size ];
	}
	close (NSLS);
    }

    return (1, @{$cache->{$pfn} || []});
}

# Find out files stager knows about.  Returns a reference to a hash of
# PFNs currently in the stager disk pool, each with stager status such
# as "STAGED" or "STAGEIN".   Returns undef if stageqry cannot be run.
# The latter should be treated as a transient error.
sub stagerFileList
{
    open(STAGEQ, "stageqry -h $ENV{STAGE_HOST} -p $ENV{STAGE_POOL} -a --format status,xfile |")
	|| return undef;
    my $files = {};
    while (<STAGEQ>) {
	my ($status, $file) = split(/\s+/, $_);
	$files->{$file} = $status;
    }
    close(STAGEQ);
    return $files;
}

# Figure out tape mount load level.  Returns a tuple of total number
# of requests and requests by ourselves.  The values are undef if we
# cannot run the necessary programs for some reason.  This should be
# considered a transient error.
sub tapeMountLoad
{
    my ($total, $ours) = (0, 0);
    open(QSTAT, "showqueues -x |")
	or do { &alert ("cannot run showqueues: $!"); return (undef, undef); };
    while (<QSTAT>)
    {
	$total++ if /^Q/;
	$ours++ if /^Q.*cmsprod/; # FIXME: don't hardcode cmsprod
    }
    close (QSTAT);
    return ($total, $ours);
}

# Update the stage-in status of a file.  If we haven't initialised
# state data for the file, do so.  Then check if the file is staged
# in; if so, return $STAGE_ON_DISK to indicate it's availabale.
# Otherwise if more than 15 minutes have passed since we requested
# the file to be staged in, check that the system still knows it's
# being requested; if not, including if we never asked for the file
# before, return $STAGE_UNKNOWN to indicate new stage-in is needed.
# Returns $STAGE_NONEXISTENT if the file doesn't exist at all, and
# $STAGE_RETRY if there was a transient error.
sub checkFileStatus
{
    my ($self, $file, $cache, $stagedin) = @_;
    my $pfn = $file->{PFN};

    # Get file properties if we don't have them.
    if (! exists $file->{TAPE})
    {
	my ($success, $tape, $pos, $size) = &fileProperties ($pfn, $cache);
	return $STAGE_RETRY if ! $success;
	return $STAGE_NONEXISTENT
	    if (! defined $tape || ! defined $pos || ! defined $size);
	$file->{STATUS} = $STAGE_UNKNOWN;
	$file->{TAPE} = $tape;
	$file->{POS} = $pos;
	$file->{SIZE} = $size;
	$file->{LAST} = 0;
	$file->{STARTED} = time();
	$file->{DIRTY} = 1;
    }

    # Check if it's in the list of staged in files.
    return $STAGE_ON_DISK if (($stagedin->{$pfn} || '') eq 'STAGED');

    # If it's more than 15 minutes since we last requested for
    # stage-in, check that the system still knows we want it.
    # If not, including if we never requested for the file,
    # mark it as requiring stage-in.
    my $now = time ();
    if (! $file->{LAST})
    {
	$file->{LAST} = $now;
	$file->{DIRTY} = 1;
    }
    elsif ($file->{STATUS} == $STAGE_PENDING && $now - $file->{LAST} > 900)
    {
	if ($now - $file->{STARTED} > $self->{MAXHOURS} * 3600)
	{
	    &alert("file could not be staged in $self->{MAXHOURS} hours, giving up");
	    $self->markBad ($file->{DROP});
	    $file->{BAD} = 1;
	    $file->{DIRTY} = 1;
	    return $STAGE_RETRY;
	}

	$file->{LAST} = $now;
	$file->{DIRTY} = 1;
	return $STAGE_RETRY if ! defined $stagedin->{$pfn};
	return $STAGE_PENDING if $stagedin->{$pfn} eq 'STAGEIN'; # Still known
	&alert ("File lost STAGEIN status, requesting again: $pfn");
    }

    # This file needs to be staged in
    return $STAGE_UNKNOWN;
}

# Check and update the status of all files.
sub updateFileStatus
{
    my ($self, $file, $cache, $stagedin) = @_;

    # Ignore files we've already complained about
    return if $file->{BAD};

    my $status = $self->checkFileStatus ($file, $cache, $stagedin);
    if ($status == $STAGE_RETRY)
    {
	# Try again another time
	return;
    }
    elsif ($status == $STAGE_NONEXISTENT)
    {
	# Bad file, mark it bad
	&alert ("$file->{DROP}: no such file $file->{PFN}");
	$self->markBad ($file->{DROP});
	$file->{BAD} = 1;
	$file->{DIRTY} = 1;
    }
    elsif ($status != $file->{STATUS})
    {
	# Update the file status
	$file->{STATUS} = $status;
	$file->{DIRTY} = 1;
    }
}

# Restore saved file status
sub readStageInProgress
{
    my ($self, @pending) = @_;
    my @files = ();

    # Read in current file status
    for my $drop (@pending)
    {
	$self->maybeStop();

    	# Sanity checking
    	next if (! $self->inspectDrop ($drop));
    	delete $self->{BAD}{$drop};

	# Get XML catalogue
	my $dropdir = "$self->{WORKDIR}/$drop";
	my $xmlcat = (<$dropdir/XMLCatFragment.*.{txt,xml}>)[0];
	if (! defined $xmlcat)
	{
	    &alert ("no xml catalogue in $drop");
	    $self->markBad ($drop);
	    next;
	}
    	my $catalog = eval { &readXMLCatalog ($xmlcat) };
    	do { &alert($@); $self->markBad ($drop); next } if $@;

	# Create status object for each file, read in saved one if it exists.
    	foreach my $file (values %$catalog)
    	{
	    my $pfn = $file->{PFN}[0];
	    my $lfn = $file->{LFN}[0];
	    my $info = { DROP => $drop, PFN => $pfn, LFN => $lfn, STATUS => $STAGE_RETRY };
	    if (-f "$self->{WORKDIR}/$drop/stagein.$lfn")
	    {
		my $saved = do { no strict "vars"; eval &input ("$self->{WORKDIR}/$drop/stagein.$lfn") };
		if ($@) {
		    &warn ("ignoring corrupt stagein status for $drop/$lfn: $@");
		} else {
		    $info = $saved;
		    $info->{DIRTY} = 0;
		}
	    }
	    push(@files, $info);
        }
    }

    return @files;
}

# Flush drops whose files have been staged in.
sub flushStagedInDrops
{
    my ($self, $files, $pending) = @_;

    # Mark done drops whose all files have been staged in
    my %drops = ();
    my @remaining = ();
    foreach my $file (@$files)
    {
	my $drop = $file->{DROP};
	$drops{$drop} ||= [ 0, 0, time() ];
	$drops{$drop}[0]++;
	$drops{$drop}[1]++ if $file->{STATUS} == $STAGE_ON_DISK;
	$drops{$drop}[2] = $file->{STARTED} if $drops{$drop}[2] > $file->{STARTED};
    }
    foreach my $drop (sort keys %drops)
    {
	if ($drops{$drop}[0] == $drops{$drop}[1] && ! -f "$self->{WORKDIR}/$drop/bad")
	{
	    my $timing = [];
	    my $dropdir = "$self->{WORKDIR}/$drop";
	    &timeStart($timing);
	    $timing->[0] = $drops{$drop}[2];
	    unlink (<$dropdir/stagein.*>);
	    &touch ("$dropdir/done");
	    $self->relayDrop ($drop);
	    &logmsg ("stats: $drop @{[&formatElapsedTime($timing)]} success");
	}
	else
	{
	    push(@remaining, $drop);
	}
    }

    @$pending = @remaining;
}

# Save the file status for the given files
sub saveFileStatus
{
    my $self = shift;
    foreach my $file (@_)
    {
	next if ! $file->{DIRTY};
        &alert ("failed to update stagein status for $file->{LFN}")
	    if ! &output ("$self->{WORKDIR}/$file->{DROP}/stagein.$file->{LFN}", Dumper ($file));
    }
}

# Update the status for all files, then determine which drops are ready
# to proceed and which ones need staging in.
sub processAllFiles
{
    my ($self, @pending) = @_;
    while (@pending)
    {
	$self->maybeStop();

        # Recover where we were
        my @files = $self->readStageInProgress (@pending);

        # Get the list of files already staged in
        my $stagedin = &stagerFileList();
        return if ! defined $stagedin;

        # Update status
	my %cache = ();
        foreach my $file (@files) {
            $self->updateFileStatus ($file, \%cache, $stagedin);
        }

        # Write out the new file state
	$self->saveFileStatus (@files);

	# Send out completely staged in drops
	$self->flushStagedInDrops(\@files, \@pending);

        # Determine the files that need to be staged in, in a good order
        # i.e. sorted by tape and position, then issue requests in batches.
	# Note that we reverse the list because we take items off the end.
        my @requests = reverse
		       sort { $a->{TAPE} cmp $b->{TAPE} || $a->{POS} cmp $b->{POS} }
		       grep ($_->{STATUS} == $STAGE_UNKNOWN, @files);
	while (@requests)
	{
	    # Suspend until the system load drops low enough, and then go back
	    # to start of the loop so we reconsider staged in files and send
	    # them out.  Also makes it safer if we get stopped.
	    my ($tapereqs, $mytapereqs) = &tapeMountLoad();
	    my $stagereqs = scalar (grep(/STAGEIN/, values %$stagedin));
	    if (! defined $tapereqs
	        || ! defined $mytapereqs
	        || $tapereqs > $self->{MAXTAPEREQS}
	        || $mytapereqs > $self->{MAXMYTAPEREQS}
	        || $stagereqs > $self->{MAXSTAGEREQS})
	    {
	        $tapereqs = 'U' if ! defined $tapereqs;
	        $mytapereqs = 'U' if ! defined $mytapereqs;
	        $stagereqs = 'U' if ! defined $stagereqs;
	        &note ("backing out, overloaded ($tapereqs/$mytapereqs/$stagereqs)");
	        return;
	    }

	    # Select the next up to maxfiles to stage in
	    my $nfiles = ($#requests > $self->{MAXFILES} ? $self->{MAXFILES} : $#requests);
	    my @slice = @requests[$#requests - $nfiles .. $#requests];
	    delete @requests[$#requests - $nfiles .. $#requests];

	    # Mark these files as pending now
	    map { $_->{STATUS} = $STAGE_PENDING; $_->{DIRTY} = 1; } @slice;
	    $self->saveFileStatus (@slice);

	    # Issue background stage-in
	    my $rc = &runcmd ("stagein", "--nowait", "--rdonly",
			      "-h", $ENV{STAGE_HOST}, "-p", $ENV{STAGE_POOL},
			      "-A", "deferred",
			      map { ("-M", $_->{PFN}) } @slice);
	    &alert ("stagein failed: @{[&runerror($rc)]}") if ($rc);

	    # Sleep a bit, castor doesn't like rapid-fire request chains
	    select (undef, undef, undef, 0.33);
	}
    }
}

# Do all the processing in the idle routine
sub idle
{
    my ($self, @pending) = @_;
    &timeStart($self->{STARTTIME});
    $self->processAllFiles (@pending);
    $self->maybeStop();
    sleep ($self->{WAITTIME});
}
