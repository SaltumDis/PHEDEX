#!/usr/bin/perl

## Prestage castor files before passing them to the rest of the chain.
##
## The agent scans the XML catalog, and checks whether each file
## listed has been staged. If one or more files are either not staged,
## or in STAGEIN, the drop is left in the work dropbox, and a stage request
## is issued for files that are not in STAGEIN. If all files are 
## staged, then the drop is relayed to the next agent in the chain,
## the xml catalogue update agent.
##
## Drops will therefore accumulate in the work dropbox of this agent
## until all the files listed are staged. This latency is accepted, as
## files that appear in distribution unstaged trigger errors in agents
## further down the chain.
##
## The files don't have to have correct PFNs at this point.  Only the
## non-directory part of the PFN is used to stage in, as it is unique
## in CMS.
##
## This agent periodically inspects the drop box, looking for new
## incoming directories from completed batch jobs.  For each such
## new assignment, it goes through the staging process.  At
## each step we update the state so that if the script terminates,
## crashes or is otherwise stopped, it will pick up in the right
## place.  At the end, we pass the assignment to the next agent.

BEGIN { use strict; $^W = 1; }
my ($dropdir, @nextdir, $inbox, $workdir, $outdir, $stopflag, $pidfile);
my @startTime;
my $waittime = 7;		# Seconds to sleep between meta set queries
my %bad = ();			# Drops we've warned are bad
my %junk = ();			# Drops we've warned are junk in inbox

my $retries = 60;		# Number of times (hours) to retry stagein

$ENV{STAGE_HOST} ||= "stagecmsprod";	# Castor stage host
$ENV{STAGE_POOL} ||= "cms_prod2";	# Castor stage pool

my $me = $0; $me =~ s|.*/||;
my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";

my $STAGE_ON_DISK = 0;		# File has been staged on disk
my $STAGE_PENDING = 1;		# Stage-in still in progress
my $STAGE_FAILED = 2;		# Something went bad

use File::Path;
eval qx(cat "$home/UtilsReaders.pm"); die $@ if $@;
eval qx(cat "$home/UtilsAgent.pm"); die $@ if $@;

######################################################################
# Routines specific to this agent.

# Determine actual location of a file in castor.  Used if there is
# no summary file to tell the full path for the files.
sub stageQueryFile
{
    my $pfn = shift;
    my $lfn = $pfn; $lfn =~ s|.*/||;
    my $lfnrx = quotemeta ($lfn);
    my $status = "UNSTAGED";
    my $path = undef;

    open (PFN, "stageqry -f -h $ENV{STAGE_HOST} -M $lfn |");
    while (<PFN>) 
    {
	chomp;
	if (/^$lfnrx\s+([A-Z]+)/)
	{
	    $status = $1;
	}
        elsif (/^ \//)
	{
            s/\s//g;
	    $path = $_;
	    last;
        }
    }
    close (PFN);
    return ($status, $path);
}

# Actually stage in a file.
sub stageOneFile
{
    my ($drop, $lfn, $pfn) = @_;
    my ($attempt, $started) = (0, time());
    my ($status, $path) = &stageQueryFile ($pfn);

    # Return right now if it's on disk
    return $STAGE_ON_DISK if $status eq 'STAGED';

    # Not yet staged or still staging in, check what we've done in the past
    my $record = "$workdir/$drop/stagein.$lfn";
    if (-f $record)
    {
	my $state = &input ($record);
	if ($state !~ /^(\d+) (\d+)$/) {
	    &alert ("corrupted $record");
	    &markBad ($drop);
	    return $STAGE_FAILED;
	}

	$attempt = $1;
	$started = $2;
    }

    # Check what we should do now
    if ($status eq 'UNSTAGED' && -f $record) {
	&warn ("retrying forgotten stagein request for $pfn");
    } elsif ($status eq 'STAGEIN' && time() - $started > 3600) {
	&warn ("no stagein progress for an hour for $pfn");
    } elsif ($status eq 'STAGEIN') {
	return $STAGE_PENDING;
    } elsif ($status ne 'UNSTAGED' && $status ne 'STAGEIN') {
	&alert ("unrecognised stager status '$status' for $pfn");
	&markBad ($drop);
	return $STAGE_FAILED;
    }

    # We are going again.  If tried too many times, give up.
    if (++$attempt >= $retries)
    {
	&alert ("$attempt attempts to stage in $pfn is too much!");
	&markBad ($drop);
	return $STAGE_FAILED;
    }

    # Record what we've been up to so far
    if (! &output ($record, "$attempt $started\n"))
    {
	&alert ("failed to record stagein $record: $!");
	return $STAGE_PENDING;
    }

    # Start stagein process.  Assume failures are transient and
    # someone will fix them in due course (we have ~60 hours).
    if ($status ne 'STAGEIN')
    {
	my $status = &runcmd ("stagein", "--nowait", "--rdonly",
			      "-h", $ENV{STAGE_HOST}, "-p", $ENV{STAGE_POOL},
			      "-A", "deferred", "-M", $pfn);
	&alert ("stagein failed: $status") if ($status);
    }

    return $STAGE_PENDING;
}


# Stage in files mentioned in the XML catalog.  Assumes PFN is full
# valid castor path.  Starts file stage-in for files not yet on disk.
# If there are pending stage-ins, drop is held pending until the file
# is successfully staged, fails, or number of attempts is exceeded.
sub stageFilesIn
{
    my ($drop, $xmlcat) = @_;
    my $catalog = &readXMLCatalog ($drop, $xmlcat);
    return 0 if ! keys %$catalog;

    foreach my $file (values %$catalog)
    {
	my $pfn = $file->{PFN}[0];
	my $lfn = $file->{LFN}[0];
	my $status = &stageOneFile ($drop, $lfn, $pfn);
	return 0 if $status == $STAGE_FAILED;
	return 0 if $status == $STAGE_PENDING;
	# Otherwise it's $STAGE_ON_DISK, and ok
    }

    &touch("$workdir/$drop/done");
    return 1;
}

# Actually process the drop.
sub processDrop
{
    my ($drop) = @_;

    # Sanity checking
    return if (! &inspectDrop ($drop));
    delete $bad{$drop};
    &timeStart();

    # Find the catalog file.
    my $xmlcat = (<$workdir/$drop/XMLCatFragment.*.{txt,xml}>)[0];
    if (! $xmlcat)
    {
	&alert("no xml catalog file found in $drop");
	&markBad ($drop);
	return;
    }

    # Stage files in, but leave drop in queue if files are still pending
    return if ! &stageFilesIn ($drop, $xmlcat);
    &relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime()]} success");
}

while (scalar @ARGV)
{
    if ($ARGV[0] eq '-stagehost' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_HOST} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-stagepool' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_POOL} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-retries' && scalar @ARGV > 1)
    { shift (@ARGV); $retries = shift(@ARGV); }
    elsif ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $dropdir = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@nextdir, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $waittime = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$dropdir)
{
    print STDERR
	"usage: $me\n",
	"    -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-stagehost STAGE-HOST] [-stagepool POOL]\n",
	"    [-retries N-RETRIES] [-wait SECS-TO-WAIT]\n";
    exit (1);
}

&process();
