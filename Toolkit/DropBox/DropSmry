#!/usr/bin/env perl

##H This drop box agent parses production jobs summary files 
##H and drops a XML catalog fragment and a checksum file.
##H Those two files are used by DropTMDBPublisher) to inject the data into TMDB.
##H
##H File sizes are obtained passing the LFNs and the EVD output path 
##H to a glue site script (-sizequery option). 
##H
##H if option -publish is given, a site glue script is called
##H with arguments the location of the XML fragment and the EVDS_OutputPath
##H so that the XML POOL fragment can be published into the phedex catalogue
##H
##H Like all drop box agents, this agent periodically inspects the
##H inbox, looking for new completed drops.  Each new drop is processed
##H and passed to the next
##H drop box agent, or destroyed if there is no next agent.  If the
##H agent terminates, crashes or is otherwise stopped, it will pick
##H up in the right place when started the next time.
##H
##H Usage: DropSmry -state DIRECTORY [-next NEXT-AGENT] [-log OUT]
##H                 -sizequery COMMAND[,ARGS...] -publish COMMAND[,ARGS...]

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "next=s@"     => $args{NEXTDIR},
	     "sizequery=s" => sub { push(@{$args{SIZE_QUERY}}, split(/,/, $_[1])) },
	     "publish=s"   => sub { push(@{$args{PUBLISH}}, split(/,/, $_[1])) },
	     "help|h"      => sub { &usage() });

if (scalar @ARGV || !$args{DROPDIR} || !$args{SIZE_QUERY})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new DropSmry (%args))->process();

######################################################################
# Routines specific to this agent.
package DropSmry; use strict; use warnings; use base 'UtilsAgent';
use File::Path; use UtilsCache; use UtilsReaders; use UtilsCommand; use UtilsLogging;
use UtilsTiming; use UtilsWriters; use MIME::Base64; use Compress::Zlib;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (SIZE_QUERY => undef, # Program to query file sizes
		  PUBLISH => undef);   # Program to publish files into local phedex pool catalog      
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub ProcessSmry
{
    my ($self, $drop, $smryfile) = @_;
    my $writePOOL = 0; 
    my $POOLfragment = undef; 
    my $cksums = undef;
    my $assID = undef;
    my $EVDS_OutputPath = undef;
    my $dropdir = "$$self{WORKDIR}/$drop";

    # Parse the smry file.
    if (!open (IN, "< $smryfile")) {&alert ("cannot open summary file $smryfile: $!"); return 1;}
    while(<IN>) {
        chomp;
	do {$writePOOL=1; next} if /^POOL=1/;      # POOL fragment between lines POOL=1 and POOL_END      
	$writePOOL = 0          if /^POOL_END/;
	if ($writePOOL) {
	    $POOLfragment .= $_ 
	} else {
	    $assID=$1           if /_ASS_ID=(\d+)/;        # assignment ID     
	    $EVDS_OutputPath=$1 if /EVDS_OutputPath=(.+)/; # Output path for EVD files
	    $cksums=$1          if /_OUT_CKSUMS=(.+)/;     # string with LFN:cksum pairs separated with commas 
	}
    }
    close (IN);
    if (!$assID || !$EVDS_OutputPath || !$cksums || !$POOLfragment ) {
	&alert ("$drop: failed to parse $smryfile"); return 1;
    }

    # create XML POOL fragment (with Preamble and Trailer so that it can be directly used by publishing tools)
    my $XMLCatFragment="$dropdir/XMLCatFragment.$assID.xml";
    my $xml = Compress::Zlib::memGunzip (decode_base64 ($POOLfragment));
    my $XMLcontent = join("\n", grep(!/^\d+a$/ && !/^\.$/, split(/\n/, $xml)));  # remove spurious lines
    do { &alert("$drop: failed to write $XMLCatFragment"); return 1}
      if ! &output ($XMLCatFragment, &genXMLPreamble() . $XMLcontent . &genXMLTrailer());

    # create chksum file with format (chksum filesize LFN)
    my $ChecksumFile="$dropdir/Checksum.$assID.txt";
    my $cksumContent;
    $cksums =~ s/ //g; 
    my %LFNcksums = split(/[,:]/, $cksums);
    for (keys %LFNcksums){
	# query filesizes calling local site glue script
	my $lfn = $_;
 	my $filesize = qx(@{$$self{SIZE_QUERY}} $lfn $EVDS_OutputPath); chomp ($filesize);
	if (!$filesize) {&alert ("$drop: could not get filesize for $lfn"); return 1;}	
	# write chksum drop file
	my $cksum = $LFNcksums{$lfn};
	if (!$cksum) {&alert ("$drop: could not get checksum for $lfn"); return 1;}
	$cksumContent .= "$cksum $filesize $lfn\n";
    }
    do { &alert("$drop: failed to write $ChecksumFile"); return 1}
      if  ! &output ($ChecksumFile, $cksumContent);

    # execute script to publish into local phedex pool catalog
    if ($$self{PUBLISH}) {
	do { &alert ("failed to publish $XMLCatFragment into local catalogue"); return 1} 
	    if &runcmd (@{$$self{PUBLISH}}, "$XMLCatFragment", "$EVDS_OutputPath"); 
    }

    # OK, we are done
    &touch ("$dropdir/done");
    return 0;
}


# Actually process the drop.
sub processDrop
{
    my ($self, $drop) = @_;
    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $$self{BAD}{$drop};
    &timeStart($$self{STARTTIME});

    # Find the Smry file.
    my $dropdir = "$$self{WORKDIR}/$drop";
    my $smryfile = (<$dropdir/*.smry>)[0];
    do { &alert("$drop: no summary file"); $self->markBad ($drop); return }
      if ! $smryfile;

    # Process summary file
    do { $self->markBad ($drop); return }
      if $self->ProcessSmry ($drop, $smryfile);

    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($$self{STARTTIME})]} success");
}
