#!/usr/bin/env perl

## This drop box agent parses production jobs summary files 
## and drops a XML catalog fragment and a checksum file.
## Those two files are used by DropTMDBPublisher) to inject the data into TMDB.
##
## File sizes are obtained passing the LFNs and the EVD output path 
## to a glue site script (-sizequery option). 
##
## if option -publish is given, a site glue script is called
## with arguments the location of the XML fragment and the EVDS_OutputPath
## so that the XML POOL fragment can be published into the phedex catalogue
##
## Like all drop box agents, this agent periodically inspects the
## inbox, looking for new completed drops.  Each new drop is processed
## and passed to the next
## drop box agent, or destroyed if there is no next agent.  If the
## agent terminates, crashes or is otherwise stopped, it will pick
## up in the right place when started the next time.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################

my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@{$args{NEXTDIR}}, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-sizequery' && scalar @ARGV > 1)
    { shift (@ARGV); @{$args{SIZE_QUERY}} = split(/,/, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-publish' && scalar @ARGV > 1)
    { shift (@ARGV); @{$args{PUBLISH}} = split(/,/, shift(@ARGV)); }
    else
    { last; }
}

if (scalar @ARGV || !$args{DROPDIR} || !$args{SIZE_QUERY})
{
    print STDERR
	"usage: $me -in IN-DROP-BOX -out NEXT-DROP-BOX\n",
	"           -sizequery SIZE-QUERY-SCRIPT[,ARGS]\n", 
	"           -publish PUBLISH-SCRIPT[,ARGS]\n",
	"           [-wait SECS-TO-WAIT]\n";
    exit (1);
}

(new DropSmry (%args))->process();

######################################################################
# Routines specific to this agent.
package DropSmry; use strict; use warnings; use base 'UtilsAgent';
use File::Path; use UtilsCache; use UtilsReaders; use UtilsCommand; use UtilsLogging;
use UtilsTiming; use UtilsWriters; use MIME::Base64; use Compress::Zlib;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (SIZE_QUERY => undef, # Program to query file sizes
		  PUBLISH => undef);   # Program to publish files into local phedex pool catalog      
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub ProcessSmry
{
    my ($self, $drop, $smryfile) = @_;
    my $writePOOL = 0; 
    my $POOLfragment = undef; 
    my $cksums = undef;
    my $assID = undef;
    my $EVDS_OutputPath = undef;
    my $dropdir = "$self->{WORKDIR}/$drop";

    # Parse the smry file.
    if (!open (IN, "< $smryfile")) {&alert ("cannot open summary file $smryfile: $!"); return 1;}
    while(<IN>) {
        chomp;
	do {$writePOOL=1; next} if /^POOL=1/;      # POOL fragment between lines POOL=1 and POOL_END      
	$writePOOL = 0          if /^POOL_END/;
	if ($writePOOL) {
	    $POOLfragment .= $_ 
	} else {
	    $assID=$1           if /_ASS_ID=(\d+)/;        # assignment ID     
	    $EVDS_OutputPath=$1 if /EVDS_OutputPath=(.+)/; # Output path for EVD files
	    $cksums=$1          if /_OUT_CKSUMS=(.+)/;     # string with LFN:cksum pairs separated with commas 
	}
    }
    close (IN);
    if (!$assID || !$EVDS_OutputPath || !$cksums || !$POOLfragment ) {
	&alert ("$drop: failed to parse $smryfile"); return 1;
    }

    # create XML POOL fragment (with Preamble and Trailer so that it can be directly used by publishing tools)
    my $XMLCatFragment="$dropdir/XMLCatFragment.$assID.xml";
    my $xml = Compress::Zlib::memGunzip (decode_base64 ($POOLfragment));
    my $XMLcontent = join("\n", grep(!/^\d+a$/ && !/^\.$/, split(/\n/, $xml)));  # remove spurious lines
    do { &alert("$drop: failed to write $XMLCatFragment"); return 1}
      if ! &output ($XMLCatFragment, &genXMLPreamble() . $XMLcontent . &genXMLTrailer());

    # create chksum file with format (chksum filesize LFN)
    my $ChecksumFile="$dropdir/Checksum.$assID.txt";
    my $cksumContent;
    $cksums =~ s/ //g; 
    my %LFNcksums = split(/[,:]/, $cksums);
    for (keys %LFNcksums){
	# query filesizes calling local site glue script
	my $lfn = $_;
 	my $filesize = qx(@{$self->{SIZE_QUERY}} $lfn $EVDS_OutputPath); chomp ($filesize);
	if (!$filesize) {&alert ("$drop: could not get filesize for $lfn"); return 1;}	
	# write chksum drop file
	my $cksum = $LFNcksums{$lfn};
	if (!$cksum) {&alert ("$drop: could not get checksum for $lfn"); return 1;}
	$cksumContent .= "$cksum $filesize $lfn\n";
    }
    do { &alert("$drop: failed to write $ChecksumFile"); return 1}
      if  ! &output ($ChecksumFile, $cksumContent);

    # execute script to publish into local phedex pool catalog
    if ($self->{PUBLISH}) {
	&warn ("failed to publish $XMLCatFragment into local catalogue") 
	    if &runcmd (@{$self->{PUBLISH}}, "$XMLCatFragment", "$EVDS_OutputPath"); 
    }

    # OK, we are done
    &touch ("$dropdir/done");
    return 0;
}


# Actually process the drop.
sub processDrop
{
    my ($self, $drop) = @_;
    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $self->{BAD}{$drop};
    &timeStart($self->{STARTTIME});

    # Find the Smry file.
    my $dropdir = "$self->{WORKDIR}/$drop";
    my $smryfile = (<$dropdir/*.smry>)[0];
    do { &alert("$drop: no summary file"); $self->markBad ($drop); return }
      if ! $smryfile;

    # Process summary file
    do { $self->markBad ($drop); return }
      if $self->ProcessSmry ($drop, $smryfile);

    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($self->{STARTTIME})]} success");
}
