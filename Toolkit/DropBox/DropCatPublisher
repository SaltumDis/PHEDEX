#!/usr/bin/env perl

## This agent registers files into the catalogue (RLS or local) as a
## preliminary step before transfer.
##
## The agent merges the XML catalogue into the local catalogue and moves
## the drop to the next agent, normally the transfer database agent.
##
## Note that normally the files have to be published in the catalogue
## before publishing them for transfer so that transfer agents that
## expect to find the info in the catalogue can do their job simply.
##
## Like all drop box agents, this agent periodically inspects the
## inbox, looking for new completed drops.  For each new drop, the
## files are published, and the drop is passed to the next
## drop box agent, or destroyed if there is no next agent.  If the
## agent terminates, crashes or is otherwise stopped, it will pick
## up in the right place when started the next time.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-catalogue' && scalar @ARGV > 1)
    { shift (@ARGV); $args{CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@{$args{NEXTDIR}}, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$args{DROPDIR} || !$args{CATALOGUE})
{
    print STDERR
	"usage: $me -catalogue CONTACT-STRING\n",
	"    -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-wait SECS-TO-WAIT]\n";
    exit (1);
}

(new DropCatPublisher (%args))->process();

######################################################################
# Routines specific to this agent.
package DropCatPublisher; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (CATALOGUE => undef);	# Catalogue contact string
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    die if not defined $self->{CATALOGUE};
    bless $self, $class;
    return $self;
}

# Import the XML catalogue fragment to the file catalogue.
sub updateFileCatalogue
{
    my ($self, $drop, $xmlcat) = @_;
    my $ret = &runcmd ("FCpublish", "-d", $self->{CATALOGUE}, "-u", "file:$xmlcat");

    if ($ret)
    {
	&alert("FCpublish failed for $drop: " . &runerror ($ret));
	$self->markBad ($drop);
	return 1;
    }

    unlink("$xmlcat.BAK");
    &touch("$self->{WORKDIR}/$drop/done");
    return 0;
}

# Actually process the drop.
sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $self->{BAD}{$drop};
    &timeStart($self->{STARTTIME});

    # Find the catalogue file.
    my $dropdir = "$self->{WORKDIR}/$drop";
    my $xmlcat = (<$dropdir/XMLCatFragment.*.{txt,xml}>)[0];
    if (! defined $xmlcat)
    {
	&alert("no xml catalogue file found in $drop");
	$self->markBad ($drop);
	return;
    }

    # Merge XML contents into RLS.
    return if $self->updateFileCatalogue ($drop, $xmlcat);
    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($self->{STARTTIME})]} success");
}
