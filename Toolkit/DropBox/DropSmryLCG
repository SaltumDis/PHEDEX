#!/usr/bin/env perl

##H This drop box agent parses LCG production jobs summary files 
##H and drops a XML catalog fragment and a checksum file.
##H Those two files are used by DropTMDBPublisher to inject the data into TMDB.
##H
##H In LCG, the output EVD files are packaged in a zip archive. The zip file
##H is the one injected in TMDB. 
##H
##H Like all drop box agents, this agent periodically inspects the
##H inbox, looking for new completed drops.  Each new drop is processed
##H and passed to the next
##H drop box agent, or destroyed if there is no next agent.  If the
##H agent terminates, crashes or is otherwise stopped, it will pick
##H up in the right place when started the next time.
##H
##H Usage: DropSmryLCG -state DIRECTORY [-next NEXT-AGENT] [-log OUT]
##H                    -publish COMMAND[,ARGS...]

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "next=s@"     => $args{NEXTDIR},
	     "publish=s"   => sub { push(@{$args{PUBLISH}}, split(/,/, $_[1])) },
	     "help|h"      => sub { &usage() });

if (scalar @ARGV || !$args{DROPDIR})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new DropSmryLCG (%args))->process();

######################################################################
# Routines specific to this agent.
package DropSmryLCG; use strict; use warnings; use base 'UtilsAgent';
use File::Path; use UtilsCache; use UtilsReaders; use UtilsCommand; use UtilsLogging;
use UtilsTiming; use UtilsWriters; use MIME::Base64; use Compress::Zlib;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MYNODE => undef,     # My TMDB node name
		  PUBLISH => undef);   # glue script to publish files into local phedex pool catalog 
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub ProcessSmry
{
    my ($self, $drop, $smryfile) = @_;
    my $guid  = undef;
    my $size  = undef;
    my $cksum = undef;
    my $lfn   = undef;
    my $turl  = undef;
    my $surl  = undef;
    my $dropdir = "$$self{WORKDIR}/$drop";

    # Parse the smry file.
    do {&alert ("cannot open summary file $smryfile: $!"); return 1;} if !open (IN, "< $smryfile");
    while(<IN>) {
        chomp;
	$guid  = $1   if /OUT_GUID=([-0-9A-Fa-f]+)/;  # zip's guid
	$size  = $1   if /OUT_SIZE=(\d+)/;            # zip's size
	$cksum = $1   if /OUT_CKSUM=(\d+)/;           # zip's cksum
	$lfn   = $1   if /OUT_LFN=(.+)/;              # zip's LFN
	$turl  = $1   if /OUT_TURL=(.+)/;             # zip's TURL 
        $surl  = $1   if /OUT_SURL=(.+)/;             # zip's SURL
    }
    close (IN);
    if (!$guid || !$size || !$lfn || !$turl) {
	&alert ("$drop: failed to parse $smryfile"); return 1;
    }

    # create XML POOL fragment
    my $XMLCatFragment="$dropdir/XMLCatFragment.$guid.xml";
    do { $surl=$turl; $surl =~ s/gsiftp/sfn/} if !$surl; 
    my $XMLcontent = &createZipXMLfragment($guid, $lfn, $surl);
    do { &alert("$drop: failed to create XML fragment for zip archive"); return 1} if !$XMLcontent;
    do { &alert("$drop: failed to write $XMLCatFragment"); return 1}
      if ! &output ($XMLCatFragment, &genXMLPreamble() . $XMLcontent . &genXMLTrailer());

    # create chksum file with format "cksum filesize LFN"
    my $ChecksumFile="$dropdir/Checksum.$guid.txt";
    $cksum = -1 if !$cksum;
    my $cksumContent = "$cksum $size $lfn\n";
    do { &alert("$drop: failed to write $ChecksumFile"); return 1}
      if  ! &output ($ChecksumFile, $cksumContent);

    # execute script to publish into local phedex pool catalog
    if ($$self{PUBLISH}) {
        do { &alert ("failed to publish $XMLCatFragment into local catalogue"); return 1} 
            if &runcmd (@{$$self{PUBLISH}}, "$XMLCatFragment"); 
    }

    # OK, we are done
    &touch ("$dropdir/done");
    return 0;
}


sub createZipXMLfragment
{
    my ($guid, $lfn, $surl) = @_;
    
    if ($lfn =~ /.+\.(\w+)\.(\d+)\.(.+)\.(.+)\./) {
	my $xmldata = <<EOF;
  <File ID="$guid">
    <physical>
      <pfn filetype="EVDZip" name="$surl"/>
    </physical>
    <logical>
      <lfn name="$lfn"/>
    </logical>
    <metadata att_name="Content" att_value="ZippedProd"/>
    <metadata att_name="DBoid" att_value=""/>
    <metadata att_name="DataType" att_value="ZippedProd"/>
    <metadata att_name="FileCategory" att_value="ZippedProd"/>
    <metadata att_name="Flags" att_value=""/>
    <metadata att_name="dataset" att_value="$3"/>
    <metadata att_name="jobid" att_value="$1"/>
    <metadata att_name="owner" att_value="$4"/>
    <metadata att_name="runid" att_value="$2"/>
  </File>
EOF
      return $xmldata;
    } else {
	&alert("wrong format for LFN = $lfn"); return 0;	
    }
}

# Actually process the drop.
sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $$self{BAD}{$drop};
    &timeStart($$self{STARTTIME});

    # Find the Smry file.
    my $dropdir = "$$self{WORKDIR}/$drop";
    my $smryfile = (<$dropdir/*.smry>)[0];
    do { &alert("$drop: no summary file"); $self->markBad ($drop); return }
      if ! $smryfile;

    # Process summary file
    do { $self->markBad ($drop); return }
      if $self->ProcessSmry ($drop, $smryfile);

    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($$self{STARTTIME})]} success");
}
