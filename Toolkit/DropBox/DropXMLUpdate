#!/usr/bin/env perl

## This drop box agent converts incomplete paths to full mass storage
## paths (PFNs) in the XML catalogues of the drops that pass through.
##
## The batch processing environment produces catalogues where the PFNs
## are relative (./EVD*).  Before entering the information into the
## transfer chain, it is necessary to convert the paths to the full
## local names.  This is done using either of two ways.  If the drop
## has a summary file (Smry.*.txt), the EVDS_OutputPath is assumed to
## be the directory into which the files were put; this information is
## trusted blindly.  Failing that, castor is queried for the full path.
##
## The script can therefore be used in one of two ways: by providing
## correct Smry.*.txt files, in which case it will be happy to pass on
## any information and is not dependent on castor in any way, or by
## making sure the files are staged in on castor, and letting the
## agent find them there then.  The former is more general, the latter
## only really works correctly when receiving files live from a farm.
##
## If the XML file is not in the proper POOL format, that too is
## corrected.  Normally the files received from a farm or stored in
## RefDB are not yet normalised in such a way.
##
## Like all drop box agents, this agent periodically inspects the
## inbox, looking for new completed drops.  For each new drop, the
## XMLCatFragment is updated, and the drop is passed to the next
## drop box agent, or destroyed if there is no next agent.  If the
## agent terminates, crashes or is otherwise stopped, it will pick
## up in the right place when started the next time.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
$ENV{STAGE_HOST} ||= "stagecmsprod";
$ENV{STAGE_POOL} ||= "cms_prod2";
my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@{$args{NEXTDIR}}, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-stagehost' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_HOST} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-stagepool' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_POOL} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$args{DROPDIR})
{
    print STDERR
	"usage: $me -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-stagehost STAGE-HOST] [-stagepool STAGE-POOL]\n",
	"    [-wait SECS-TO-WAIT]\n";
    exit (1);
}

(new DropXMLUpdate (%args))->process();

######################################################################
# Routines specific to this agent.
package DropXMLUpdate; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use UtilsCache;
use UtilsReaders;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsWriters;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = ();
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Determine the full path for the files from the summary file.
sub getPFNRoot
{
    my $summary = shift;
    my $root = undef;
    if ($summary && open (SMRY, "< $summary"))
    {
	while (<SMRY>)
	{
	    next if ! /^EVDS_OutputPath=(.*)$/;
	    $root = $1;
	    last;
	}
        close (SMRY);
    }
    return $root;
}

# Update the XML catalog fragment to real POOL format.  We should
# receive the fragment as a pure fragment to which we add a wrapper
# that makes it valid stand-alone catalog.  For historical reasons
# it may also include a diff wrapper, which we remove.  Replaces the
# original catalog file with a new one.
#
# While we are at it, also update PFNs in the catalog.  The incoming
# catalog has fake PFNs of the format "./LFN".  Remap them to the real
# physical paths either using the path given in a Smry file, or failing
# that, by using "stageqry".  Finally, run the whole catalogue through
# FCpublish again to make sure old XML catalogues are updated to the
# current format (pre-POOL-1.4 to current).
sub updateCatalog
{
    my ($self, $drop, $xmlcat, $pfnroot) = @_;

    # Read the catalogue.  Our read routine ignores random junk
    my $dropdir = "$self->{WORKDIR}/$drop";
    my $catalogue = eval { &readXMLCatalog ($xmlcat) };
    do { &alert ("$drop: $@"); $self->markBad ($drop); return 1; } if $@;

    # Read attribute data
    my $attrsfile = "$dropdir/attrs";
    my $attrs = eval { -f $attrsfile ? &readAttributeCache ($attrsfile) : [] };
    do { &alert("$drop: $@"); $self->markBad ($drop); return 1; } if $@;

    # Rewrite relative PFNs to use $pfnroot
    foreach my $entry (values %$catalogue)
    {
	$entry->{TEXT} =~ s|(<pfn\s.*name=")\./([^"]*)|$1$pfnroot/$2|gm;
	map { s|^\./|$pfnroot/| } @{$entry->{PFN}};
    }

    my $content = join ("\n", map { $_->{TEXT} } values %$catalogue);
    do { &alert("$drop: failed to write catalogue: $!"); return 1; }
        if ! &outputCatalog ($xmlcat, $content);

    # Reformat old POOL catalogues.  Assume POOL errors are fatal,
    # other errors are transient.
    if (my $status = &runcmd ("FCpublish", "-u", "file:$xmlcat", "-d",
		    	      "file:$dropdir/newcat.$$.xml"))
    {
	&alert ("$drop: failed to upgrade catalogue: @{[&runerror($status)]}");
	$self->markBad ($drop);
	return 1;
    }

    do { &alert ("$drop: failed to replace catalogue: $!"); return 1; }
        if ! &mv ("$dropdir/newcat.$$.xml", $xmlcat);

    # Merge new catalogue to the attribute cache, and write it out
    &mergeCatalogueToCache ($attrs, $catalogue);
    do { &alert ("$drop: failed to write attribute cache: $!"); return 1; }
        if ! &outputAttributeCache ($attrsfile, $attrs);

    # OK, we are done
    unlink <$dropdir/*.xml.BAK>;
    &touch ("$dropdir/done");
    return 0;
}

# Actually process the drop.
sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $self->{BAD}{$drop};
    &timeStart($self->{STARTTIME});

    # Find the catalog file.
    my $dropdir = "$self->{WORKDIR}/$drop";
    my $xmlcat = (<$dropdir/XMLCatFragment.*.{txt,xml}>)[0];
    my $summary = (<$dropdir/Smry.*.txt>)[0];
    my $pfnroot = &getPFNRoot ($summary);
    do { &alert("$drop: no catalogue"); $self->markBad ($drop); return }
        if ! $xmlcat;
    do { &alert("$drop: no summary"); $self->markBad ($drop); return }
        if ! $summary;
    do { &alert ("$drop: no file root"); $self->markBad ($drop); return }
        if ! $pfnroot;

    # Reformat catalog
    return if $self->updateCatalog ($drop, $xmlcat, $pfnroot);
    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($self->{STARTTIME})]} success");
}
