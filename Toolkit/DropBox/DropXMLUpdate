#!/usr/bin/perl

## This drop box agent converts incomplete paths to full mass storage
## paths (PFNs) in the XML catalogues of the drops that pass through.
##
## The batch processing environment produces catalogues where the PFNs
## are relative (./EVD*).  Before entering the information into the
## transfer chain, it is necessary to convert the paths to the full
## local names.  This is done using either of two ways.  If the drop
## has a summary file (Smry.*.txt), the EVDS_OutputPath is assumed to
## be the directory into which the files were put; this information is
## trusted blindly.  Failing that, castor is queried for the full path.
##
## The script can therefore be used in one of two ways: by providing
## correct Smry.*.txt files, in which case it will be happy to pass on
## any information and is not dependent on castor in any way, or by
## making sure the files are staged in on castor, and letting the
## agent find them there then.  The former is more general, the latter
## only really works correctly when receiving files live from a farm.
##
## If the XML file is not in the proper POOL format, that too is
## corrected.  Normally the files received from a farm or stored in
## RefDB are not yet normalised in such a way.
##
## Like all drop box agents, this agent periodically inspects the
## inbox, looking for new completed drops.  For each new drop, the
## XMLCatFragment is updated, and the drop is passed to the next
## drop box agent, or destroyed if there is no next agent.  If the
## agent terminates, crashes or is otherwise stopped, it will pick
## up in the right place when started the next time.

BEGIN { use strict; $^W = 1; }
$me = $0; $me =~ s|.*/||;
$home = $0; $home =~ s|/[^/]+$||; $home ||= ".";
unshift(@INC, $home);

######################################################################
$ENV{STAGE_HOST} ||= "stagecmsprod";
$ENV{STAGE_POOL} ||= "cms_prod2";
my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@{$args{NEXTDIR}}, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-stagehost' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_HOST} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-stagepool' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_POOL} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$args{DROPDIR})
{
    print STDERR
	"usage: $me -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-stagehost STAGE-HOST] [-stagepool STAGE-POOL]\n",
	"    [-wait SECS-TO-WAIT]\n";
    exit (1);
}

(new DropXMLUpdate (%args))->process();

######################################################################
# Routines specific to this agent.
package DropXMLUpdate;
use strict;
use Exporter;
use File::Path;
use UtilsCommand;
use UtilsLogging;
use UtilsWriters;
use UtilsTiming;
use UtilsAgent;
use base 'UtilsAgent';

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = ();
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Determine actual location of a file in castor.  Used if there is
# no summary file to tell the full path for the files.
sub getPFNFromCastor
{
    my $lfn = shift;
    open (PFN, "stageqry -f -h $ENV{STAGE_HOST} -p $ENV{STAGE_POOL} -M $lfn |");
    while (<PFN>) 
    {
        if (/^ \//)
	{
            s/\s//g;
	    close (PFN);
            return $_;
        }
    }
    close (PFN);
    return undef;
}

# Determine the full path for the files from the summary file.
# Returns "undef" if this doesn't work (e.g. there is no summary),
# in which case the caller falls back on getPFNFromCastor above.
sub getPFNRoot
{
    my $summary = shift;
    my $root = undef;
    if ($summary && open (SMRY, "< $summary"))
    {
	while (<SMRY>)
	{
	    next if ! /^EVDS_OutputPath=(.*)$/;
	    $root = $1;
	    last;
	}
        close (SMRY);
    }
    return $root;
}

# Update the XML catalog fragment to real POOL format.  We should
# receive the fragment as a pure fragment to which we add a wrapper
# that makes it valid stand-alone catalog.  For historical reasons
# it may also include a diff wrapper, which we remove.  Replaces the
# original catalog file with a new one.
#
# While we are at it, also update PFNs in the catalog.  The incoming
# catalog has fake PFNs of the format "./LFN".  Remap them to the real
# physical paths either using the path given in a Smry file, or failing
# that, by using "stageqry".  Finally, run the whole catalogue through
# FCpublish again to make sure old XML catalogues are updated to the
# current format (pre-POOL-1.4 to current).
sub updateCatalog
{
    my ($self, $drop, $xmlcat, $summary) = @_;
    my $pfnroot = &getPFNRoot ($summary);

    if (! open (CAT, "< $xmlcat"))
    {
	# Assume it's a transient error and return failure
	&alert ("Cannot read catalog in $drop: $!");
	return 1;
    }

    my $content = "";
    my $inbody = 0;
    while (<CAT>)
    {
	if (! $inbody && m|<File\s|) {
	    $inbody = 1;
	    $content .= $_;
	} elsif ($inbody && m|</File>|) {
	    $inbody = 0;
	    $content .= $_;
        } elsif ($inbody && m|^(.*<pfn\s.*name=")\./(.*)("/>.*)|) {
	    my ($pre, $lfn, $post) = ($1, $2, $3);
	    my $pfn = ($pfnroot ? "$pfnroot/$lfn" : getPFNFromCastor($lfn));
	    if (! $pfn || $pfn !~ m|^/|)
	    {
		close (CAT);
		# Assume it's transient error and return failure.  stageqry
		# seems to return nothing for some files every once in a while,
		# but gets its act together later on.  So just keep trying.
		&alert("cannot map logical file name $lfn to full castor path");
		return 1;
	    }
	    $content .= $pre . $pfn . $post . "\n";
	} elsif ($inbody) {
	    $content .= $_;
	}
    }
    close (CAT);

    if (! &outputCatalog ($xmlcat, $content))
    {
	# Assume it's a transient error and return failure
	&alert ("failed rewrite catalog for $drop: $!");
	return 1;
    }

    # Rewrite to reformat old catalogues
    my $status = &runcmd ("FCpublish",
			  "-u", "file:$xmlcat",
			  "-d", "file:$self->{WORKDIR}/$drop/newcat.$$.xml");
    if ($status)
    {
	&alert ("failed to clean up the catalogue with FCpublish for $drop: $status");
	$self->markBad ($drop);
	return 1;
    }

    if (! &mv ("$self->{WORKDIR}/$drop/newcat.$$.xml", $xmlcat))
    {
	# Assume transient errors
	&alert ("failed to rename catalogue in $drop: $!");
	return 1;
    }

    return 0;
}

# Actually process the drop.
sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $self->{BAD}{$drop};
    &timeStart($self->{STARTTIME});

    # Find the catalog file.
    my $dropdir = "$self->{WORKDIR}/$drop";
    my $xmlcat = (<$dropdir/XMLCatFragment.*.{txt,xml}>)[0];
    my $summary = (<$dropdir/Smry.*.txt>)[0];
    if (! $xmlcat)
    {
	&alert("no xml catalog file found in $drop");
	$self->markBad ($drop);
	return;
    }

    # Reformat catalog
    return if $self->updateCatalog ($drop, $xmlcat, $summary);
    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($self->{STARTTIME})]} success");
}
