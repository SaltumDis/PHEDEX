#!/usr/bin/perl

## This drop box agent converts incomplete paths to full mass storage
## paths (PFNs) in the XML catalogues of the drops that pass through.
##
## The batch processing environment produces catalogues where the PFNs
## are relative (./EVD*).  Before entering the information into the
## transfer chain, it is necessary to convert the paths to the full
## local names.  This is done using either of two ways.  If the drop
## has a summary file (Smry.*.txt), the EVDS_OutputPath is assumed to
## be the directory into which the files were put; this information is
## trusted blindly.  Failing that, castor is queried for the full path.
##
## The script can therefore be used in one of two ways: by providing
## correct Smry.*.txt files, in which case it will be happy to pass on
## any information and is not dependent on castor in any way, or by
## making sure the files are staged in on castor, and letting the
## agent find them there then.  The former is more general, the latter
## only really works correctly when receiving files live from a farm.
##
## If the XML file is not in the proper POOL format, that too is
## corrected.  Normally the files received from a farm or stored in
## RefDB are not yet normalised in such a way.
##
## Like all drop box agents, this agent periodically inspects the
## inbox, looking for new completed drops.  For each new drop, the
## XMLCatFragment is updated, and the drop is passed to the next
## drop box agent, or destroyed if there is no next agent.  If the
## agent terminates, crashes or is otherwise stopped, it will pick
## up in the right place when started the next time.

BEGIN { use strict; $^W = 1; }
my ($dropdir, @nextdir, $inbox, $workdir, $outdir, $stopflag, $pidfile);
my @startTime;
my $waittime = 7;		# Seconds to sleep between meta set queries
my %bad = ();			# Drops we've warned are bad
my %junk = ();			# Drops we've warned are junk in inbox

my $me = $0; $me =~ s|.*/||;
my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";

$ENV{STAGE_HOST} ||= "stagecmsprod";
$ENV{STAGE_POOL} ||= "cms_prod2";

use File::Path;
eval qx(cat "$home/UtilsCommand.pm"); die $@ if $@;
eval qx(cat "$home/UtilsTiming.pm"); die $@ if $@;
eval qx(cat "$home/UtilsLogging.pm"); die $@ if $@;
eval qx(cat "$home/UtilsAgent.pm"); die $@ if $@;

######################################################################
# Routines specific to this agent.

# Determine actual location of a file in castor.  Used if there is
# no summary file to tell the full path for the files.
sub getPFNFromCastor
{
    my $lfn = shift;
    open (PFN, "stageqry -f -h $ENV{STAGE_HOST} -p $ENV{STAGE_POOL} -M $lfn |");
    while (<PFN>) 
    {
        if (/^ \//)
	{
            s/\s//g;
	    close (PFN);
            return $_;
        }
    }
    close (PFN);
    return undef;
}

# Determine the full path for the files from the summary file.
# Returns "undef" if this doesn't work (e.g. there is no summary),
# in which case the caller falls back on getPFNFromCastor above.
sub getPFNRoot
{
    my $summary = shift;
    my $root = undef;
    if ($summary && open (SMRY, "< $summary"))
    {
	while (<SMRY>)
	{
	    next if ! /^EVDS_OutputPath=(.*)$/;
	    $root = $1;
	    last;
	}
        close (SMRY);
    }
    return $root;
}

# Update the XML catalog fragment to real POOL format.  We should
# receive the fragment as a pure fragment to which we add a wrapper
# that makes it valid stand-alone catalog.  For historical reasons
# it may also include a diff wrapper, which we remove.  Replaces the
# original catalog file with a new one.
#
# While we are at it, also update PFNs in the catalog.  The incoming
# catalog has fake PFNs of the format "./LFN".  Remap them to the real
# physical paths either using the path given in a Smry file, or failing
# that, by using "stageqry".
sub updateCatalog
{
    my ($drop, $xmlcat, $summary) = @_;
    my $pfnroot = &getPFNRoot ($summary);

    if (! open (CAT, "< $xmlcat"))
    {
	# Assume it's a transient error and return failure
	&alert ("Cannot read catalog in $drop: $!");
	return 1;
    }

    my $content = "";
    my $inbody = 0;
    while (<CAT>)
    {
	if (! $inbody && m|<File\s|) {
	    $inbody = 1;
	    $content .= $_;
	} elsif ($inbody && m|</File>|) {
	    $inbody = 0;
	    $content .= $_;
        } elsif ($inbody && m|^(.*<pfn\s.*name=")\./(.*)("/>.*)|) {
	    my ($pre, $lfn, $post) = ($1, $2, $3);
	    my $pfn = ($pfnroot ? "$pfnroot/$lfn" : getPFNFromCastor($lfn));
	    if (! $pfn || $pfn !~ m|^/|)
	    {
		close (CAT);
		# Assume it's transient error and return failure.  stageqry
		# seems to return nothing for some files every once in a while,
		# but gets its act together later on.  So just keep trying.
		&alert("cannot map logical file name $lfn to full castor path");
		return 1;
	    }
	    $content .= $pre . $pfn . $post . "\n";
	} elsif ($inbody) {
	    $content .= $_;
	}
    }
    close (CAT);

    $content = ("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n"
		. "<!DOCTYPE POOLFILECATALOG SYSTEM \"InMemory\"><POOLFILECATALOG>\n"
		. '  <META name="Content" type="string"/>' . "\n"
		. '  <META name="DBoid" type="string"/>' . "\n"
		. '  <META name="DataType" type="string"/>' . "\n"
		. '  <META name="FileCategory" type="string"/>' . "\n"
       		 . '  <META name="Flags" type="string"/>' . "\n"
		. '  <META name="dataset" type="string"/>' . "\n"
       		 . '  <META name="jobid" type="string"/>' . "\n"
		. '  <META name="owner" type="string"/>' . "\n"
		. '  <META name="runid" type="string"/>' . "\n"
		. $content. "\n"
		. "</POOLFILECATALOG>\n");

    if (! &output ($xmlcat, $content))
    {
	# Assume it's a transient error and return failure
	&alert ("Cannot rewrite catalog for $drop: $!");
	return 1;
    }

    return 0;
}

# Actually process the drop.
sub processDrop
{
    my ($drop) = @_;

    # Sanity checking
    return if (! &inspectDrop ($drop));
    delete $bad{$drop};
    &timeStart();

    # Find the catalog file.
    my $xmlcat = (<$workdir/$drop/XMLCatFragment.*.{txt,xml}>)[0];
    my $summary = (<$workdir/$drop/Smry.*.txt>)[0];
    if (! $xmlcat)
    {
	&alert("no xml catalog file found in $drop");
	&markBad ($drop);
	return;
    }

    # Reformat catalog
    return if &updateCatalog ($drop, $xmlcat, $summary);
    &relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime()]} success");
}

while (scalar @ARGV)
{
    if ($ARGV[0] eq '-in' && scalar @ARGV > 1)
    { shift (@ARGV); $dropdir = shift(@ARGV); }
    elsif ($ARGV[0] eq '-out' && scalar @ARGV > 1)
    { shift (@ARGV); push (@nextdir, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-stagehost' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_HOST} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-stagepool' && scalar @ARGV > 1)
    { shift (@ARGV); $ENV{STAGE_POOL} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $waittime = shift(@ARGV); }
    else
    { last; }
}
	
if (scalar @ARGV || !$dropdir)
{
    print STDERR
	"usage: $me -in IN-DROP-BOX [-out NEXT-DROP-BOX]\n",
	"    [-wait SECS-TO-WAIT]\n";
    exit (1);
}

&process();
