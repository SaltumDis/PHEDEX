#!/usr/bin/env perl

##H Deletes closed and deactivated LoadTest blocks
##H
##H Usage:
##H   LoadTestCleanup -state DIRECTORY -node NAME -db FILE[:SECTION]
##H               [-once] [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -once      run the alogrithm once, then quit -- don't go into daemon mode
##H -log       where to redirect logging information

######################################################################
my %args;
use Getopt::Long;
use PHEDEX::Core::Help;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
             "once"        => \$args{ONCE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new LoadTestCleanup (%args))->process();

######################################################################
# Routines for this agent.
package LoadTestCleanup;
use strict;
use warnings;
use base 'PHEDEX::Core::Agent', 'PHEDEX::Core::Logging';
use PHEDEX::Core::Timing;
use PHEDEX::Core::DB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node
		  ONCE => 0,			# Quit after one run
		  WAITTIME => 3600 );	        # Agent cycle time
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Do some work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = $self->connectAgent();

	# Select deactivated blocks we can clean up.  Lock the block
	# row for transactional consistency
	my $qdel = &dbexec($dbh,
	  qq{ select b.id, b.name from t_dps_block b
                join t_dps_dataset ds on ds.id = b.dataset
                join t_loadtest_param lp on lp.dest_dataset = ds.id
                where ds.is_transient = 'y'
                  and b.is_open = 'n'
		  and exists (select 1 from t_dps_block_replica br
			       where br.block = b.id)
                  and not exists (select 1 from t_dps_block_replica br
                                   where br.block = b.id
                                    and br.is_active = 'y')
               for update
	     });

	# Iterate through the blocks deleting the files and blocks
	while (my ($id, $name) = $qdel->fetchrow()) {
	    my ($fdel, $nfiles) = &dbexec($dbh, qq{
              delete from t_dps_file where inblock = :block
	      }, ':block' => $id);

            my ($bdel, $nblocks) = &dbexec($dbh, qq{
              delete from t_dps_block where id = :block
              }, ':block' => $id);
    
	    &logmsg("removing $name : $nfiles files");
	}
	
    	$dbh->commit();

    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    $self->disconnectAgent();

    $self->doStop() if $$self{ONCE};
}
