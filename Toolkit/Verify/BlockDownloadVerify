#! /usr/bin/env perl

##H
##H This agent perfoms the verification of downloaded blocks.
##H Ask Tony how it works...
##H
##H
##H Usage:
##H   BlockDownloadVerify
##H      -state DIRECTORY -nodes NAME
##H      -db FILE[:SECTION] [-log OUT]
##H
##H -state         agent state directory.
##H -nodes         nodes to run and clean files for.
##H -db            database connection configuration parameter file.
##H -log           where to redirect logging information.
##H

BEGIN
{
  use warnings; use strict; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0;
  if ( $home !~ m%/% ) { $home = '.'; }
  $home =~ s|/[^/]+$||;
  $home ||= ".";
  $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

my $debug_me = 1;

######################################################################
use Getopt::Long;
use UtilsHelp;

$args{LOGFILE} = '/home/wildish/PhEDEx/log.txt';
&GetOptions ("state=s"      => \$args{DROPDIR},
	     "log=s"        => \$args{LOGFILE},
	     "db=s"         => \$args{DBCONFIG},
	     "storagemap=s" => \$args{STORAGEMAP},
             "nodes=s"      => sub { push(@{$args{NODES}}, split(/,/, $_[1])) },
             "ignore=s"     => sub { push(@{$args{IGNORE_NODES}}, split(/,/, $_[1])) },
             "accept=s"     => sub { push(@{$args{ACCEPT_NODES}}, split(/,/, $_[1])) },
	     "help|h"	    => sub { &usage() });

#if (@ARGV || !$args{NODES} || !$args{DROPDIR} || !$args{DBCONFIG})
if (!$args{NODES} || !$args{DBCONFIG} || !$args{STORAGEMAP})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockDownloadVerify (%args))->process();

################################################
package BlockDownloadVerify; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;
use DBI;
use UtilsRFIO;
use UtilsBlockConsistencyCheck;

sub daemon() { print "Stub the daemon() call\n"; }

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  NODES    => undef,		# Node names to run this agent for
	  	  IGNORE_NODES => ['%MSS','T0%'],# TMDB nodes to ignore
	  	  ACCEPT_NODES => [],		# TMDB nodes to accept
		  WAITTIME => 60 + rand(15),	# Agent activity cycle
		  DELETING => undef,		# Are we deleting files now?
		  PROTOCOL => 'direct',         # File access protocol
	  	  STORAGEMAP => undef		# Storage path mapping rules
		  );
    
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Delete a file.  We do one step at a time; if the step fails, we just
# tell the caller to come back here again at a more opportune time.
# The steps are ordered such that they are safe to execute several
# times if we have to give for one reason or another.
sub doSizeCheck
{
  my ($self, $drop, $request) = @_;
  my $dbh = undef;
  my @nodes = ();

  my $bcc = UtilsBlockConsistencyCheck->new
		(
			DBCONFIG	=> $self->{DBCONFIG},
		);
  $bcc->STORAGEMAP( $self->{STORAGEMAP} );
  $bcc->Checks($request->{TEST_NAME}) or
    die "Test $request->{TEST_NAME} not known to UtilsBlockConsistencyCheck!\n";

  my $ns = $bcc->NS;
  $bcc->DBH($self->{DBH});
  my $technology = $bcc->Buffers(@{$self->{NODES}});
  $ns->technology( $technology );
  $bcc->LFNRef($request->{LFNs});
  foreach my $r ( @{$request->{LFNs}} )
  {
    my $pfn = $bcc->lfn2pfn($r->{LOGICAL_NAME});
    my $size = $ns->statsize($pfn);
    if ( $size == $r->{FILESIZE} )
    {
      $r->{STATUS} = 'OK';
    }
    else
    {
      $r->{STATUS} = 'Error';
    }
    $r->{TIME_REPORTED} = time();
    print scalar localtime $r->{TIME_REPORTED}, " $r->{FILEID}: $r->{STATUS}\n";
  }

  ($dbh,@nodes) = &expandNodesAndConnect($self);
  my ($n_files,$n_ok);
  $n_files = $n_ok = 0;
  foreach my $r ( @{$request->{LFNs}} )
  {
    $self->setFileState($request->{ID},$r);
    $n_files++;
    $n_ok++ if $r->{STATUS} eq 'OK';
  }
  $self->setRequestFilecount($request->{ID},$n_files,$n_ok);
  if ( $n_ok == $n_files )
  {
    $self->setRequestState($request,'OK');
  }
  $dbh->commit();
  &disconnectFromDatabase ($self, $dbh);

# my $result = $bcc->getOnWithItThen();

  print "So far, so good...\n";

return 1 unless $n_files - $n_ok;
return 0;

  my $status = eval
  {
    ($dbh, @nodes) = &expandNodesAndConnect ($self);
	
#   Issue file removal from disk now.
#   my $log = "$$self{DROPDIR}/@{[time()]}.$$request{ID}.$$request{TEST_NAME}.log";
#   $self->addJob( sub { $self->sizeCheckJob ($request, @_) },
#     { TIMEOUT => 30, LOGFILE => $log, DB => $dbh },
#     (@{$$self{CMD_RM}}, 'post', $$file{PFN}) );


#   Report completition time to DB. If the physicval deletion fails,
#   we will roll back.
    my $now = &mytimeofday();
#   &dbexec($dbh, qq{
#     update t_xfer_delete set time_complete = :now
#       where fileid = :fileid and node = :node},
#       ":fileid" => $$file{FILEID}, ":node" => $$file{NODEID}, ":now" => $now);
    return 1;
  };

  do
  {
    chomp ($@);
    &alert ("database error: $@");
    eval { $dbh->rollback() } if $dbh;
    $status = 0
  } if $@;
    
# Return status code to caller
  return $status;
}

sub sizeCheckJob
{
$DB::single=$debug_me;
    my ($self, $file, $job) = @_;
    if ($$job{STATUS})
    {
	&warn("failed to delete file $$file{PFN} at node "
	      ."$$file{NODE}, log in $$job{LOGFILE}");
    }
    else
    {
	&logmsg("deleted file $$file{PFN} at node $$file{NODE}");
	unlink ($$job{LOGFILE});
    }
}

sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $$self{BAD}{$drop};
    &timeStart($$self{STARTTIME});

    # Read back file information
    my $dropdir = "$$self{WORKDIR}/$drop";
    my $request = do { no strict "vars"; eval &input ("$dropdir/packet") };
    my $bad = 0;
    $bad = 1 if ($@ || !$request );
    foreach ( qw/ BLOCK ID LFNs N_FILES PRIORITY TEST TEST_NAME TIME_EXPIRE / )
    {
      $bad = 1 unless defined $request->{$_};
    }
    if ( $bad )
    {
	&alert ("corrupt packet in $drop");
        $self->setRequestState($request,'Rejected');
	$self->markBad ($drop);
	return;
    }

#   I can only process size-checks for now. Reject anything else
    if ( $request->{TEST_NAME} eq 'size' )
    {
      my $result = $self->doSizeCheck ($drop, $request);
$DB::single=1;
      return if ! $result;
    }
#   elsif ( $request->{TEST_NAME} eq 'migration' ) { }
#   elsif ( $request->{TEST_NAME} eq 'cksum' ) { }
#   elsif ( $request->{TEST_NAME} eq 'dbs' ) { }
    else
    {
      $self->setRequestState($request,'Rejected');
      $self->markBad($drop);
      return;
    }
#    # Try deleting this file.  If something fails, keep this drop as
#    # is, we'll come back to it later.
##   return if ! $self->deleteOneFile ($drop, $file);
#
#   Mark drop done so it will be nuked
    &touch ("$dropdir/done");
#
#    # Log transfer delay stats
#    my $dtransfer = &mytimeofday() - $$file{TIME_START};
#    &logmsg ("xstats: $$file{NODE} " . sprintf('%.2fs', $dtransfer)
#	     . " $$file{LFN} => $$file{PFN}");
#
    # OK, got far enough to nuke and log it
$DB::single=$debug_me;
    $self->relayDrop ($drop);
}

# Get a list of pending requests
sub requestQueue
{
    my ($self, $dbh, $limit, $node, $filter, $filter_args) = @_;
    my (@requests,$sql,%p,$q,$q1,$n,$i);
    my $now = &mytimeofday();

    # Find all the files that we are expected to work on
    $n = 0;

    $sql = qq{
		select b.id, block, n_files, time_expire, priority,
		test, t.name test_name
		from t_dvs_block b join t_dvs_test t on b.test = t.id
		join t_status_block_verify v on b.id = v.id
		where b.node = :node
		and status = 0
		${$filter}
		order by priority desc, time_expire asc
       };
    %p = ( ":node" => $$self{NODES_ID}{$node}, %{$filter_args} );
    $q = &dbexec($dbh,$sql,%p);

    $sql = qq{ select logical_name, checksum, filesize, vf.fileid,
		nvl(time_reported,0) time_reported, nvl(status,0) status
		from t_dps_file pf join t_dvs_file vf on vf.fileid = pf.id
		left join t_dvs_file_result vfr on vfr.fileid = vf.fileid
		where vf.request = :request };
    while ( my $h = $q->fetchrow_hashref() )
    {
      %p = ( ':request' => $h->{ID} );
      $q1 = &dbexec($dbh,$sql,%p);
      while ( my $g = $q1->fetchrow_hashref() )
      {
        push @{$h->{LFNs}}, $g;
      }
      $n += scalar @{$h->{LFNs}};
      push @requests, $h;
      last if ++$i >= $limit;
    }

    print "Got ",scalar @requests," requests, for $n files in total\n";
    return @requests;
}

sub dropBoxName
{
# Derive a dropbox name for a request. Required to be alphabetically
# sorted to the same order that the requests should be processed in.
  my ($self,$request) = @_;
  my $b = sprintf("%08x_%08x_%08x",
                   $request->{PRIORITY},
                   $request->{TIME_EXPIRE},
                   $request->{ID}
                 );
  return $b;
}

# Create a drop for deleting a file.  We create a drop for ourselves,
# i.e. in our own inbox, and then process the file in "processDrop".
# This way we have a permanent record of where we are with deleting
# the file, in case we have to give up some operation for temporary
# failures.
sub startOne
{
    my ($self, $request) = @_;

    # Create a pending drop in my inbox
    my $drop = "$$self{DROPDIR}/inbox/" . $self->dropBoxName($request);
    do { &alert ("$drop already exists"); return 0; } if -d $drop;
    do { &alert ("failed to submit $$request{ID}"); &rmtree ($drop); return 0; }
	if (! &mkpath ($drop)
	    || ! &output ("$drop/packet", Dumper ($request))
	    || ! &touch ("$drop/go.pending"));

    # OK, kick it go
    return 1 if &mv ("$drop/go.pending", "$drop/go");
    &warn ("failed to mark $$request{ID} ready to go");
    return 0;
}

# Pick up work from the database.
sub idle
{
  my ($self, @pending) = @_;
  my $dbh = undef;
  my @nodes = ();

  eval
  {
    ($dbh, @nodes) = &expandNodesAndConnect ($self);
    my ($filter, %filter_args) = &otherNodeFilter ($self, "b.node");

    foreach my $node (@nodes)
    {

#     Close out finished requests. Do I need this?
#     $self->checkResults($dbh, \@nodes, \$filter, \%filter_args);

#     Get a list of requests to process
      foreach my $request ($self->requestQueue ($dbh, 5, $node, \$filter, \%filter_args))
      {
 	if ( $self->startOne ($request) )
        {
          $self->setRequestState($request,'Queued');
        }
        else
        {
          $self->setRequestState($request,'Error');
        }
      }
#       Intermediate commit after having dealt with all files at a node
      $dbh->commit();
    }
  };
  do { chomp ($@); &alert ("database error: $@");
  eval { $dbh->rollback() } if $dbh } if $@;

  # Wait for all jobs to finish
  while (@{$$self{JOBS}})
  {
    $self->pumpJobs();
    select (undef, undef, undef, 0.1);
  }

  # Disconnect from the database
  &disconnectFromDatabase ($self, $dbh);

  # Have a little nap
  $self->nap (5 + 0 * $$self{WAITTIME});
}

sub setFileState
{
# Change the state of a file-test in the database
  my ($self, $request, $result) = @_;
  my ($sql,%p,$q);
  return unless defined $result;

  $sql = qq{
	insert into t_dvs_file_result fr 
	(id,request,fileid,time_reported,status)
	values
	(seq_dvs_file_result.nextval,:request,:fileid,:time,
	 (select id from t_dvs_status where name like :status_name )
	)
       };
  %p = ( ':fileid'      => $result->{FILEID},
  	 ':request'     => $request,
         ':status_name' => $result->{STATUS},
         ':time'        => $result->{TIME_REPORTED},
       );
  $q = &dbexec($self->{DBH},$sql,%p);
}

sub setRequestFilecount
{
  my ($self,$id,$n_tested,$n_ok) = @_;
  my ($sql,%p,$q);

  $sql = qq{ update t_status_block_verify set n_tested = :n_tested,
		files_ok = :n_ok where id = :id };
  %p = ( ':n_tested' => $n_tested,
	 ':n_ok'     => $n_ok,
	 ':id'       => $id
       );
  $q = &dbexec($self->{DBH},$sql,%p);
}

sub setRequestState
{
# Change the state of a request in the database
  my ($self, $request, $state) = @_;
  my ($sql,%p,$q);
  my ($disconnect, $dbh, @nodes);
  return unless defined $request->{ID};
  if ( ! defined ($dbh = $self->{DBH} ) )
  {
    ($dbh,@nodes) = &expandNodesAndConnect($self);
    $disconnect=1;
  }

  print "Request=$request->{ID}, state=$state\n";

  $sql = qq{
	update t_status_block_verify sbv 
	set time_reported = :time,
	status = 
	 (select id from t_dvs_status where name like :state )
	where id = :id
       };
  %p = ( ':id'    => $request->{ID},
         ':state' => $state,
         ':time'  => time()
       );
  $q = &dbexec($dbh,$sql,%p);
  if ( $disconnect )
  {
#   wind up this transaction by hand
    $dbh->commit();
    &disconnectFromDatabase($self,$dbh);
  }
}

sub checkResults
{
  print "Stub for checkResults for now...\n";
# select nvl(status,0) status, count(nvl(status,0)) status_count from t_dvs_file vf left join t_dvs_file_result vfr on vfr.fileid = vf.fileid where vf.request = 260 group by status;
}
1;
