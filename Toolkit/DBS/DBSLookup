#!/usr/bin/env python
#
# List datasets or blocks from DBS1 or DBS2

import sys
from fnmatch import filter
import re

def dbs1Lookup(url, instance, item):
  from DBSAPIOLD.dbsCgiApi import DbsCgiApi
  from DBSAPIOLD.dbsException import DbsException

  api = DbsCgiApi(url, {'instance' : instance})
  
  p = re.compile('^/([^/]+)/([^/]+)(/[^/]+|\#[^\#]+)$')
  parts = p.findall(item)
  if not parts: raise Exception("Bad dataset or block format")
  haswilds = item.count('*')
  parts = parts[0]
  if parts[2].startswith('#'):
    lookingfor = 'BLOCK'
  else:
    lookingfor = 'DATASET'

  if lookingfor == 'DATASET':
    datasets = api.listProcessedDatasets(item)
    for dataset in datasets:
      print dataset['datasetPathName']
  else:
    pattern = '/'+parts[0]+'/*/*'
    blocks = []
    datasets = api.listProcessedDatasets(pattern)
    for dataset in datasets:
      ds_blocks = api.listBlocks(dataset['datasetPathName'])
      blocks.extend( filter(ds_blocks, item) )

    blocks = set(blocks)
    for block in blocks:
      print block


def dbs2Lookup(url, item):
  from DBSAPI.dbsApi import DbsApi

  myargs = { 'level': 'WARNING',
             'url': url,
             'version': 'v00_00_06' }

  api = DbsApi(myargs)

  p = re.compile('^/([^/]+)/([^/]+)(/[^/]+|\#[^\#]+)$')
  parts = p.findall(item)
  if not parts: raise Exception("Bad dataset or block format")
  haswilds = item.count('*')
  parts = parts[0]
  if parts[2].startswith('#'):
    lookingfor = 'BLOCK'
  else:
    lookingfor = 'DATASET'

  if lookingfor == 'DATASET':
    for dataset in api.listProcessedDatasets(item):
      print dataset['Name']
  else:
    for block in api.listBlocks("", item):
      print block['Name']
    

from optparse import OptionParser

try:
  usage =  "usage: %prog [options]\n"
  usage += "\nTakes a DBS URL and a data item string and tries to look up the data in that DBS, printing the results"
  usage += "\nThe data_item should be of the form /PRIMARY/TIER/DATASET or /PRIMARY/TIER#BLOCK"
  usage += "\nThe data_item can have glob-style wildcards"
  usage += "\n%prog look in either a DBS-1 or DBS-2 depending on the URL"
  usage += "\nYou will probably want to put the arguments in quotes to prevent the shell from interpreting them"
  parser = OptionParser(usage=usage)
  parser.add_option('-u', '--url', dest='url', help='DBS URL')
  parser.add_option('-i', '--instance', dest='instance', help='DBS-1 Instance')
  parser.add_option('-d', '--data_item', dest='item', help='Data item (dataset or block)')
  (opts, args) = parser.parse_args()
  if not opts.url or not opts.item:
    raise Exception("Options --url and --data_item are required")
  
  if re.compile('Servlet').search(opts.url):
    dbs2Lookup(opts.url, opts.item)
  else:
    if not opts.instance:
      raise Exception("Option --instance is required in the case of DBS-1 URLs")
    dbs1Lookup(opts.url, opts.instance, opts.item)
    
  sys.exit(0)
except Exception, ex:
  if ex.__doc__ != 'Request to exit from the interpreter.' :
    print "Caught Exception object: %s "  % ex
except:
  print "Caught Unknown exception"
