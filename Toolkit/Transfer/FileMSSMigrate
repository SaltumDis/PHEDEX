#!/usr/bin/env perl

##H Manage downloads into an MSS node, marking transfer completed
##H when the files have been migrated to tape.
##H
##H This agent is technically a transfer agent, so follows the file
##H routing rules.  However it can only be a terminal node and is
##H somewhat simplified in its logic.  We also short-cut the data
##H wanted/available protocol as this is not a real transfer.
##H
##H Usage:
##H   FileMSSMigrate
##H      -state DIRECTORY -db FILE[:SECTION] [-log OUT]
##H      -nodes PATTERN[,PATTERN...] [-protocols PROTOCOL[,PROTOCOL...]]
##H
##H -state         agent state directory
##H -db            database connection configuration parameter file
##H -log           where to redirect logging information
##H -nodes         the nodes for which this agent runs
##H -protocols     the protocols accepted by this agent (default: 'direct')
##H -mssbackend    the type of MSS, for which standard code exists. 
##H                Available are: srm, castor, dcache, fake. Default is 'fake'.
##H                Don't forget to also specify a proper protocol from your TFC!
##H -checkroutine  a file with perl code that actually performs the check, in case you need
##H                a custom backend. This option has precendence over -mssbackend
##H                No default. See example at the end this file
##H -retransferlost Mark lost files for retransfer. 
##H                 Curently only dcache plugin supports it. Even there it's fake. :)


BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "nodes=s"     => sub { push(@{$args{NODES}},
                                         split(/,/, $_[1])) },
             "protocols=s" => sub { push(@{$args{PROTOCOLS}},
                                         split(/,/, $_[1])) },
	     "mssbackend=s" => \$args{MSSBACKEND},
	     "checkroutine=s" => \$args{CHECKROUTINE},
	     "retransferlost!" => \$args{RETRANSFERLOST},
	     "help|h"      => sub { &usage() },
);

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG} || !$args{NODES})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileMSSMigrate (%args))->process();

######################################################################
# Routines for this agent.
package FileMSSMigrate; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  NODES => undef,		# Nodes to operate for
		  PROTOCOLS => [ 'direct' ],	# Protocols to accept
		  MSSBACKEND => 'fake',         # MSS backend
		  CHECKROUTINE => '',           # check file in MSS routine
		  RETRANSFERLOST => '',         # whether to mark lost files for re-xfer 
		  WAITTIME => 150 + rand(50),	# Agent activity cycle
	  	  AGENTID => "FileDownload");	# Identity for activity logs
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;

    bless $self, $class;

    $self->loadcheckroutine(); 

    return $self;
}

# Called by agent main routine before sleeping.  Pick up work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	# Automate portions of the hand shake so accounting reports
	# the right values.  The Buffer/MSS nodes are expected to be
	# shared in reality and this agent to be the only one making
	# transfers to the MSS.

	my @nodes;
	($dbh, @nodes) = &expandNodesAndConnect ($self);
	my ($mynode, %myargs) = &myNodeFilter($self, "xt.to_node");
	my $start = &mytimeofday();

	# Advertise myself available so file routing kicks in.
        &dbexec($dbh, qq{delete from t_xfer_sink xt where $mynode}, %myargs);
        &dbexec($dbh, qq{
            insert into t_xfer_sink (from_node, to_node, protocols, time_update)
            select xt.from_node, xt.to_node, :protos, :now from t_adm_link xt
            where $mynode},
            ":protos" => "@{$$self{PROTOCOLS}}", ":now" => $start, %myargs);

	# Auto-export from buffer to me and put them into transfer.
	&dbexec($dbh, qq{
	    insert into t_xfer_task_export values (id, :now)
	    select xt.id from t_xfer_task xt
	    where $mynode
	      and not exists
	        (select 1 from t_xfer_task_export xte where xte.task = xt.id)},
	    ":now" => $start, %myargs);

	&dbexec($dbh, qq{
	    insert into t_xfer_task_inxfer values (id, :now)
	    select xt.id from t_xfer_task xt
	    where $mynode
	      and not exists
	        (select 1 from t_xfer_task_inxfer xti where xti.task = xt.id)},
	    ":now" => $start, %myargs);

	$dbh->commit();

	# Pick up work and process it.
        my $done = &dbprep ($dbh, qq{
	    insert into t_xfer_task_done
	    (task, report_code, xfer_code, time_xfer, time_update)
	    values (:task, 0, 0, :now, :now)});
	my $q = &dbexec($dbh, qq{
	    select
	      xt.id, n.name, f.filesize, f.logical_name,
	      xt.to_pfn, xt.time_assign
	    from t_xfer_task xt
	      join t_xfer_file f on f.id = xt.fileid
	      join t_adm_node n on n.id = xt.to_node
	    where $mynode
	      and not exists
	        (select 1 from t_xfer_task_done xtd where xtd.task = xt.id)
	    order by xt.time_assign asc, xt.rank asc}, %myargs);
	while (my ($task, $dest, $size, $lfn, $pfn, $available) = $q->fetchrow())
	{
	    &logmsg("Checking pfn $pfn");
	    
	    my $status = &checkFileInMSS($pfn);
	    
	    if ($status == 0) {
		&logmsg ("Not yet migrated: $pfn"); next;
	    }
	    elsif ($status == -1) {
		&logmsg ("File reported lost: $pfn"); 
		&markForRetransfer($lfn) if ($args{RETRANSFERLOST}); 
		next;
	    }
	    
	    # Migrated, mark transfer completed
	    my $now = &mytimeofday();
	    &dbbindexec($done, ":task" => $task, ":now" => $now);
	    $dbh->commit ();

	    # Log delay data.
    	    &logmsg ("xstats: to_node=$dest time="
		     . sprintf('%.1fs', $now - $available)
		     . " size=$size lfn=$lfn pfn=$pfn");

	    # Give up if we've taken too long
	    last if $now - $start > 10*60;
	}
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}

sub markForRetransfer {
    my $lfn = shift @_;
    &logmsg ("Marking for retransfer: $lfn");
}

sub loadcheckroutine {
    my $self = shift;


    undef &checkFileInMSS;

    if ($$self{CHECKROUTINE}) {
        require $$self{CHECKROUTINE};
    }
    elsif ($$self{MSSBACKEND} eq 'srm'){
	&logmsg("Loading SRM backend routine");
	*checkFileInMSS = \&checkFileInMSS_SRM;
    }
    elsif ($$self{MSSBACKEND} eq 'castor'){
	&logmsg("Loading Castor backend routine");
	*checkFileInMSS = \&checkFileInMSS_castor;
    }
    elsif ($$self{MSSBACKEND} eq 'dcache') {
	#as in original FiledCacheMigrate agent
	my $subr = join "",(<DATA>);
        eval $subr;
    }
    elsif ($$self{MSSBACKEND} eq 'fake')  {
        &logmsg("Loading fake backend routine");
        *checkFileInMSS = \&checkFileInMSS_fake;
    }
    elsif ($$self{MSSBACKEND}) {
	die "Unknown -mssbackend specified\n"; 
    }
    else {
	#This is not required at this point, but..
	&logmsg("Loading fake backend routine afterall");
        *checkFileInMSS = \&checkFileInMSS_fake;
    }

    die "Finished loadcheckroutine(), but somehow no checkFileInMSS routine defined\n" 
	unless defined &checkFileInMSS;
}


# This is a fake backend - always returns  successful migration status
sub checkFileInMSS_fake {
    return 1
}

# Castor Migration routine
sub checkFileInMSS_castor {
    my $pfn = shift @_;
    my $migrated = 0;
    open (NSLS, "nsls -l $pfn |")
	or do { &warn ("cannot nsls $pfn: $!"); return 0 };
    my $status = <NSLS>;
    close (NSLS)
	or do { &warn ("cannot nsls $pfn: $?"); return 0 };

    $migrated = 1 if ($status =~ /^m/);
    return $migrated;
}


# SRM migration routine, as in original FileSRMMigrate
# This is not a proper way to check for migration
sub checkFileInMSS_SRM {
    my $pfn = shift @_;

    my $migrated = 0;
            open (SRM, "srm-get-metadata -retry_num=1 $pfn |")
                or do { &warn ("no metadata for $pfn: $!"); return 0 };

    while(<SRM>) {
	if (/isPermanent :true/) {
	    $migrated = 1;
	}
    }

    close (SRM)
	or do { &warn ("no migration info for $pfn: $?"); return 0 };

    return $migrated
}

#Below is an embedded example of a file with checking subroutine,
#from original FiledCacheMigrate agent 
#For your custom subroutine, create a file in your config dir, 
#fill it with your code for &checkFileInMSS and call this agent with
# -checkroutine ${PHEDEX_CONFIG}/$your_file.pl

__DATA__
    print "Loading default checkFileInMSS...\n";
sub checkFileInMSS {
    my $pfn = shift @_;
    
# Get the path and the filename
    my ($path, $filename) = ($pfn =~ m!(.*)/(.*)!);

    # Check if the file has been migrated.  If not, skip it.
    open (DCACHE, "$path/.(use)(1)($filename)")
	or do { &warn ("no migration info for $pfn: $!"); return 0 };
    
    my $status = <DCACHE>;
    
    close (DCACHE)
	or do { &warn ("no migration info for $pfn: $?"); return 0 };
    
    return $status?1:0 ;
	
}

