#!/usr/bin/env perl

##H Helper tool to oversee running of a transfer job.
##H
##H This tool monitors an actual transfer as long as the job runs,
##H handles the log output and generates the final transfer report
##H for each file in the copy job.  One instance of the tool is
##H started for every sub-process invocation (srmcp, etc.).
##H
##H Usage:
##H   TransferWrapper COPY-JOB-DIR TIMEOUT COMMAND [ARGS...]
##H
##H COPY-JOB-DIR is the download agent copy job directory.  It
##H contains all the state information about this particular job.
##H
##H COMMAND and ARGS are the command to execute.

use PHEDEX::Core::JobManager;
use PHEDEX::Core::Command;
use PHEDEX::Core::Timing;
use Data::Dumper;
use POE;

# Handle arguments.
my $copyjob = shift(@ARGV);
die "$0: no copy job specified\n" if ! $copyjob;
die "$copyjob: no such directory\n" if ! -d $copyjob;

my $timeout = shift(@ARGV);
die "$timeout: not a valid timeout\n" if $timeout !~ /^\d+$/;
$timeout = undef if $timeout == 0;

# Read the copy job information so we can prepare a report.
my $copyinfo = do { no strict "vars"; eval(&input("$copyjob/info") || '') };
die "$copyjob: corrupt info\n" if $@ || ! $copyinfo || ! $$copyinfo{TASKS};

# Prepare job exit status holder and prepare saved info.
my $jobstatus = undef;
my $signalled = undef;
my $start = &mytimeofday();

unlink(<$copyjob/{command,log,time*,exit*,completed,signalled,live}>);
&output("$copyjob/command", "@ARGV")
    or die "$copyjob/command: $!\n";
&output("$copyjob/time-start", $start)
    or die "$copyjob/time-start: $!\n";

# Redirect standard input, output and error.
open(STDIN, "</dev/null");
open(STDOUT, ">> $copyjob/wrapper-log");
open(STDERR, ">&STDOUT");

# Start the job.
my $jobs = new PHEDEX::Core::JobManager (NJOBS => 1);
$jobs->addJob (sub { $jobstatus = $_[0] }, 
    { TIMEOUT => $timeout, LOGFILE => "$copyjob/log" },
    @ARGV);

# Wait for the job to exit.  Indicate liveness.
$SIG{INT} = $SIG{TERM} = sub { $signalled = shift; $jobs->killAllJobs() };
my $n = 0;

# Replace the following code with a call to POE to enable the JobManager to do
# its thing. Provide the 1-minute 'touch' in a POE session
POE::Session->create(
           inline_states => {
             _start => sub { $_[KERNEL]->yield("next") },
             next   => sub {
               return if defined $jobstatus;
	       &touch("$copyjob/live") if ! ($n++ % 60);
               $_[KERNEL]->delay(next => 1);
             },
           },
         );

POE::Kernel->run();

# Job status should now be set.
die "$0: job status lost!\n" if ! $jobstatus;
my $end = &mytimeofday();

# If we have a SRM transfer report, read that in now.
my %taskstatus = ();
if (-s "$copyjob/srm-report")
{
    # Read in the report.
    my %reported;
    foreach (split (/\n/, &input("$copyjob/srm-report") || ''))
    {
        my ($from, $to, $status, @rest) = split(/\s+/);
        $reported{$from}{$to} = [ $status, "@rest" ];
    }

    # Read in tasks and correlate with report.
    foreach my $task (%{$$copyinfo{TASKS}})
    {
	my $file = "$copyjob/../../tasks/$task";
	my $info = do { no strict "vars"; eval (&input($file) || '') };
	next if ! $info;

	my ($from, $to) = @$info{"FROM_PFN", "TO_PFN"};
	$taskstatus{$task} = $reported{$from}{$to};
    }
}

# Build per-task status update and write them out.
my $log = &input("$copyjob/log");
foreach my $task (keys %{$$copyinfo{TASKS}})
{
    my $status = { START => $start, END => $end,
	           STATUS => $$jobstatus{STATUS},
		   DETAIL => "", LOG => $log };

    if ($taskstatus{$task})
    {
	# We have a report entry, use that.
	($$status{STATUS}, $$status{DETAIL}) = @{$taskstatus{$task}};
    }
    elsif (defined $signalled)
    {
	# The wrapper itself got a signal.
	$$status{STATUS} = -4;
	$$status{DETAIL} = "transfer was terminated with signal $signalled";
    }
    elsif (exists $$jobstatus{SIGNAL})
    {
	# The transfer timed out.
	$$status{STATUS} = -5;
	$$status{DETAIL} = "transfer timed out after $$jobstatus{TIMEOUT}"
			   . " seconds with signal $$jobstatus{SIGNAL}";
    }

    &output("$copyjob/T${task}X", Dumper($status))
        or die "$copyjob/T${task}X: $!\n";
}

# Generate some useful flags.
if (defined $signalled)
{
    &output("$copyjob/signalled", $signalled)
        or die "$copyjob/signalled: $!\n";
}
elsif (exists $$jobstatus{SIGNAL})
{
    &output("$copyjob/timed-out", $$jobstatus{SIGNAL})
        or die "$copyjob/timed-out: $!\n";
}
&output("$copyjob/time-end", $end)
    or die "$copyjob/time-end: $!\n";
&output("$copyjob/exit-code", $$jobstatus{STATUS})
    or die "$copyjob/exit-code: $!\n";
&touch("$copyjob/completed");
exit(0);
