#!/usr/bin/env perl

##H Upload files from a MSS node to a transfer node, where the two
##H are assumed to be actually the same, such as Castor or dCache.
##H Makes the replica available at the destination transfer node;
##H the outbound transfer availability from the destination is
##H controlled by whether the file is staged or not.
##H
##H This is technically a download agent, so it follows the file
##H routing rules.  However no real transfer ever occurs, the
##H files jump directly to the destination node.  Note that if there
##H is a download agent running at the destination node, you will
##H want to run that with -ignore set to same as -mssnode here so
##H that the two won't compete over the same files.
##H
##H Usage:
##H   FileMSSPublish
##H      -state DIRECTORY -db FILE[:SECTION] [-log OUT]
##H      -node NAME -mssnode NAME
##H
##H -state     agent state directory
##H -db        database connection configuration parameter file
##H -node      the name of the destination node
##H -mssnode   the name of the source mass storage node
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
             "mssnode=s"   => \$args{MSSNODE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{MSSNODE}
    || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileMSSPublish (%args))->process();

######################################################################
# Routines for this agent.
package FileMSSPublish; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  MSSNODE => undef,		# MSS TMDB node name
		  WAITTIME => 50 + rand(20));	# Default wait time
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Pseudo-transfers for shared MSS/Buffer nodes, moving files
	# very quickly from the MSS node to the Buffer node.  This
	# pretends to follow minimaly the normal transfer handshake
	# so all the acocunting infrastructure continues to report
	# the right values.  The assumption is of course there are
	# no real transfers from the MSS node to the buffer node.

	# Fetch node ids for the nodes involved.
        my $myid = $$self{ID_MYNODE};
	my ($mssid) = &dbexec($dbh, qq{
	    select id from t_node where name = :node},
	    ":node" => $$self{MSSNODE})->fetchrow();

    	# Make everything available and immediately in transfer.
	my $start = &mytimeofday ();
	my ($stmt, $nprep, $nxfer, $nins, $ncopy, $ndel);
	($stmt, $nprep) = &dbexec ($dbh, qq{
	    update t_xfer_state
	    set from_state = 1, to_state = 2,
	        time_available = :now, time_xfer_start = :now
	    where from_node = :mssid and to_node = :myid and to_state = 0},
	    ":mssid" => $mssid, ":myid" => $myid, ":now" => &mytimeofday());

        # Now make them all transferred.
        ($stmt, $nxfer) = &dbexec ($dbh, qq{
	    update t_xfer_state set to_state = 3, time_xfer_end = :now
	    where from_node = :mssid and to_node = :myid and to_state = 2},
	    ":mssid" => $mssid, ":myid" => $myid, ":now" => &mytimeofday());

        die "prepare/transfer mismatch: $nprep/$nxfer\n" if $nprep != $nxfer;

        # Create destination replicas.
	($stmt, $nins) = &dbexec ($dbh, qq{
	    insert into t_xfer_replica
	    (id, fileid, node, state, time_create, time_state)
	    (select seq_xfer_replica.nextval, fileid, to_node, 0, :now, :now
	     from t_xfer_state
	     where from_node = :mssid and to_node = :myid and to_state = 3)},
	    ":mssid" => $mssid, ":myid" => $myid, ":now" => &mytimeofday());

        die "transfer/insert mismatch: $nxfer/$nins\n" if $nxfer != $nins;

        # And delete the transfers.
	($stmt, $ndel) = &dbexec ($dbh, qq{
	    delete from t_xfer_state
	    where from_node = :mssid and to_node = :myid and to_state = 3},
            ":mssid" => $mssid, ":myid" => $myid);

        die "insert/delete mismatch: $nins/$ndel\n" if $nins != $ndel;
	&logmsg ("$ndel files transferred from $$self{MSSNODE}"
		 . " to $$self{MYNODE} in "
	         . sprintf('%.1fs', &mytimeofday()-$start))
	    if $ndel > 0;

	$dbh->commit ();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Check children are still running and then wait
    $self->nap ($$self{WAITTIME});
}
