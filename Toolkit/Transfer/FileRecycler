#! /usr/bin/env perl

##H Recycle transferred files.  Never run on a production system!
##H
##H This agent removes previously transferred files to make space
##H for new ones.  It deletes anything older than a specified age,
##H plus more files if running out of disk space.  Use this in
##H challenge environment when we don't want to store the files,
##H but just want to exercise the chain.
##H
##H Files removed from TMDB, from catalogue, and from disk.
##H
##H Usage:
##H   FileRecycler
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-wait SECS]
##H      -catalogue-rm PROGRAM[,ARG...] -catalogue-proto PROTOCOL
##H      -disk-rm PROGRAM[,ARG...] [-disk-proto PROTOCOL]
##H      -pfnquery PROGRAM[,ARG...] [-disk-monitor PROGRAM[,ARG...]]
##H      [-delay-purge HOURS] [-delay-routing HOURS]
##H
##H -state            agent state directory
##H -node             the node where this agent runs
##H -db               database connection configuration parameter file
##H -wait             time to wait in seconds between work scans
##H -pfnquery         command to query pfns from catalogue
##H -catalogue-rm     command to remove file from file catalogue
##H -catalogue-proto  protocol for looking up file name for catalogue removal
##H -disk-rm          command to delete file from the disk
##H -disk-proto       protocol for looping up file name for disk removal (default: direct)
##H -disk-monitor     command to check if disk is full (default: ignore disk)
##H -delay-purge      clear files after this period (default: 48 hours)
##H -delay-inactive   time to prevent routing after purge (default: 8 hours)

BEGIN
{
  $^W = 1; use warnings; use strict;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


#---------------------------------------------
#     Argument parsing
#---------------------------------------------
use UtilsHelp;
use Getopt::Long;
my %args = (DELAY_PURGE => 48 * 3600,
	    DELAY_INACTIVE => 8 * 3600,
	    PROTO_PFN_RM => "direct",
	    WAITTIME => 60);
&GetOptions ("help|h"		=> sub { &usage() },
	     "state=s"		=> \$args{DROPDIR},
	     "node=s"		=> \$args{MYNODE},
	     "db=s"		=> \$args{DBCONFIG},
	     "wait=f"		=> \$args{WAITTIME},

	     "catalogue-proto=s"=> \$args{PROTO_CAT_RM},
	     "disk-proto=s"     => \$args{PROTO_PFN_RM},
	     "pfnquery=s"       => sub { push(@{$args{PFN_QUERY}}, split(/,/, $_[1])) },
	     "catalogue-rm=s"   => sub { push(@{$args{CMD_CAT_RM}}, split(/,/, $_[1])) },
	     "disk-rm=s"        => sub { push(@{$args{CMD_PFN_RM}}, split(/,/, $_[1])) },
	     "disk-monitor=s"   => sub { push(@{$args{CMD_DISKMON}}, split(/,/, $_[1])) },
	     "delay-purge=f"    => sub { $args{DELAY_PURGE} = $_[1] * 3600 },
	     "delay-inactive=f" => sub { $args{DELAY_INACTIVE} = $_[1] * 3600 });

if (!$args{MYNODE} || !$args{DROPDIR} || !$args{DBCONFIG}
    || !$args{PFN_QUERY} || !$args{CMD_CAT_RM} || !$args{CMD_PFN_RM}
    || !$args{PROTO_CAT_RM} || !$args{PROTO_PFN_RM})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileRecycler (%args))->process();

################################################
package FileRecycler; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  AGENTID => "Cleaner",         # Identity for activity logs
		  PFN_QUERY => undef,		# Program to query PFNs
		  PROTO_CAT_RM => undef,	# Protocol for PFN lookup for catalogue remove
		  PROTO_PFN_RM => undef,	# Protocol for PFN lookup for disk remove
		  CMD_CAT_RM => undef,		# Program to remove PFN from catalogue
		  CMD_PFN_RM => undef,		# Program to remove PFN from disk
		  CMD_DISKMON => undef,		# Program to monitor disk free space
		  DELAY_PURGE => undef,		# Time delay after download to purging
		  DELAY_INACTIVE => undef);	# Time delay after purging to re-routing

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Delete a file.  We are not too sensitive about the exit codes here, this
# should really just work, and the files may get deleted for other reasons
# by site admins so it's unwise to error out here.
sub deleteFile
{
    my ($self, $dbh, $guid, $catpfn, $diskpfn) = @_;
    my $status;

    # Remove file from catalogue
    ($status = &runcmd (@{$self->{CMD_CAT_RM}}, $catpfn))
	and &warn ("exit code @{[&runerror($status)]} from @{$self->{CMD_CAT_RM}} $catpfn");

    # Remove from the disk
    ($status = &runcmd (@{$self->{CMD_PFN_RM}}, $diskpfn))
	and &warn ("exit code @{[&runerror($status)]} from @{$self->{CMD_PFN_RM}} $diskpfn");

    # Remove replica
    &dbexec ($dbh, qq{
	delete from t_replica_state
	where guid = :guid and node = :node},
	":guid" => $guid, ":node" => $self->{MYNODE});

    # Remove outbound transfers
    &dbexec ($dbh, qq{
	delete from t_transfer_state
	where guid = :guid and from_node = :node},
	":guid" => $guid, ":node" => $self->{MYNODE});

    # Create fake inbound transfer to prevent further routing
    &dbexec ($dbh, qq{
	insert into t_transfer_state
	(timestamp, guid, to_node, to_state, to_timestamp,
	 from_node, from_state, from_timestamp, from_pfn)
	values (:now, :guid, :node, 90, :now, :node, 90, :now, null)},
	":now" => &mytimeofday(), ":guid" => $guid, ":node" => $self->{MYNODE});
}

# Pick up work from the database.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Release files in inactive t_transfer_state to routing.
	&dbexec ($dbh, qq{
	    delete from t_transfer_state
	    where from_node = :mynode
	      and to_node = :mynode
     	      and to_state = 90
     	      and to_timestamp < :old},
     	    ":mynode" => $self->{MYNODE},
	    ":old" => &mytimeofday() - $self->{DELAY_INACTIVE});

	# Check if the site wants to release some disk space.  Non-zero
	# exit code means we should release some space.
	my $diskfull = 0;
	return if ($self->{DISKMON}
		   && @{$self->{CMD_DISKMON}}
		   && ! ($diskfull = &runcmd (@{$self->{CMD_DISKMON}})));

	# Start a sweep cycle.  Find files good to be deleted. This is
	# everything existing at this node longer than DELAY_PURGE, or
	# if $diskfull, a bunch of files from oldest first.  We delete
	# files at this node even for those with pending outbound
	# transfers because this is test disk space recycling -- the
	# main difference between this and the normal disk cleaner.
	my $old = &mytimeofday() - $self->{DELAY_PURGE};
        my @guids = ();
        my $qguids = &dbexec($dbh,qq{
	    select rs.guid, rs.timestamp
	    from t_replica_state rs
	    left join t_transfer_state ts
	      on ts.guid = rs.guid
	      and ts.from_node = rs.node
      	      and (ts.to_state = 2 or ts.to_state = 3)
            where rs.node = :mynode and ts.guid is null
            order by rs.timestamp asc},
    	    ":mynode" => $self->{MYNODE});
        while (my ($guid, $time) = $qguids->fetchrow())
        {
	    next if exists $self->{PENDING}{$guid};
	    last if scalar @guids > 50;
	    last if $time > $old && ! $diskfull;
	    push(@guids, $guid);
        }

	# Get PFNs and delete the files
	my $catpfns = &guidToPFN (\@guids, $self->{PROTO_CAT_RM}, "local", @{$self->{PFN_QUERY}});
	my $diskpfns = &guidToPFN (\@guids, $self->{PROTO_DISK_RM}, "local", @{$self->{PFN_QUERY}});
	foreach my $guid (@guids)
	{
	    my $catpfn = $catpfns->{$guid};
	    my $diskpfn = $diskpfns->{$guid};
	    do { &logmsg ("no catalogue pfn for $guid"); next } if ! $catpfn;
	    do { &logmsg ("no disk pfn for $guid"); next } if ! $diskpfn;
	    $self->deleteFile ($dbh, $guid, $catpfn, $diskpfn);
	}

	# Done, commit
	$dbh->commit ();
    };

    do { &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($self->{WAITTIME});
}

1;
