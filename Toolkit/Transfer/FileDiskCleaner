#! /usr/bin/env perl

##H *** Ask Jens Rehn to write a description of what this program does
##H and what the command line options are in detail.  ***
##H
##H Usage:
##H   FileDiskCleaner
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-wait SECS]
##H
##H -state         agent state directory
##H -node          the node where this agent runs
##H -db            database connection configuration parameter file
##H -wait          time to wait in seconds between work scans
##H -importloc     path to disk to watch
##H -maxfillratio  maximum allowed disk usage in percentage (default: 75)
##H -minfreespace  minimum available disk free space in megabytes (default: 100)
##H -pfnquery      command to query pfns from catalogue
##H -pfnrm         command to remove pfns from catalogue
##H -purgesize     maximum number of files to purge per round

BEGIN
{
  use warnings; use strict; use Getopt::Long;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


#---------------------------------------------
#     Argument parsing
#---------------------------------------------
use UtilsHelp;
my %args = (MAXFILLRATIO => 75,
	    MINFREESPACE => 100,
	    PURGE => 1000,
	    WAITTIME => 60);

&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "node=s"		=> \$args{MYNODE},
	     "db=s"		=> \$args{DBCONFIG},
	     "wait=f"		=> \$args{WAITTIME},
	     "purgesize=f"      => \$args{PURGE},
	     "help|h"		=> sub { &usage() },

	     "pfnquery=s"	=> \$args{PFN_QUERY},
	     "pfnrm=s"		=> \$args{PFN_RM},
 	     "maxfillratio=f"	=> \$args{MAXFILLRATIO},
	     "minfreespace=f"	=> \$args{MINFREESPACE},
	     "importloc=s"	=> \$args{IMPORTLOC});

$args{PFN_QUERY} = [ split(/,/, $args{PFN_QUERY}) ] if $args{PFN_QUERY};
$args{PFN_RM} = [ split(/,/, $args{PFN_RM}) ] if $args{PFN_RM};

if ($args{HELPME} || !$args{IMPORTLOC}
    || !$args{MYNODE} || !$args{DROPDIR} || !$args{DBCONFIG}
    || !$args{MAXFILLRATIO} || !$args{MINFREESPACE} || !$args{PFN_QUERY}
    || !$args{PFN_RM})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileDiskCleaner (%args))->process();

################################################
package FileDiskCleaner; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;
use DBI;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  AGENTID => "Cleaner",         # Identity for activity logs
		  MAXFILLRATIO => undef,	# Maximum disk fill percentage
		  MINFREESPACE => undef,	# Minimum free space in MB
		  PURGE => undef,               # amount of files to purge per run
		  IMPORTLOC => undef,		# Disk path to watch
		  PFN_QUERY => undef,		# Program to query PFNs
		  PFN_RM => undef);		# Program to remove PFNs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Delete a file.  We do one step at a time; if the step fails, we just
# tell the caller to come back here again at a more opportune time.
# The steps are ordered such that they are safe to execute several
# times if we have to give for one reason or another.
sub deleteOneFile
{
    my ($self, $drop, $file) = @_;
    my $dbh = undef;
    my $status = eval {
	$dbh = &connectToDatabase ($self, 0) or die "failed to connect";

	# Make sure the file is still safe to delete.  More transfers
	# out might have been created for this file while we were not
	# minding this particular file (sleeping or deleting things).
	my ($npending) = &dbexec($dbh, qq{
	    select count(guid) from t_transfer_state
	    where from_node = :node and guid = :guid and to_state < 3},
	    ":node" => $self->{MYNODE}, ":guid" => $file->{GUID})->fetchrow();
	if ($npending)
	{
	    &warn ("not removing $file->{GUID}, $npending pending transfers");
	    return 0;
	}

	# Now delete the replica entry to avoid new transfer edges.
	&dbexec($dbh, qq{
	    delete from t_replica_state where guid = :guid and node = :node},
	    ":guid" => $file->{GUID}, ":node" => $self->{MYNODE});
	$dbh->commit();

	# Remove file from disk now.
	if (-e $file->{PFN}) {
	    &rmtree ($file->{PFN});
	} else {
	    &warn ("$file->{GUID}: no such file $file->{PFN}");
	}

	# Delete file from catalogue
	if (my $rc = &runcmd (@{$self->{PFN_RM}}, $file->{PFN}))
	{
	    &warn ("failed to remove $file->{GUID} from catalogue:"
		   . " exit code @{[&runerror($rc)]}");
	    return 0;
	}

	# Job done!
	return 1;
    };

    do { &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh;
	 $status = 0 } if $@;
    
    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Return status code to caller
    return $status;
}

sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $self->{BAD}{$drop};
    &timeStart($self->{STARTTIME});

    # Read back file information
    my $dropdir = "$self->{WORKDIR}/$drop";
    my $file = do { no strict "vars"; eval &input ("$dropdir/packet") };
    if ($@ || !$file || !$file->{GUID} || !$file->{PFN} || !$file->{TIME_START})
    {
	&alert ("corrupt packet in $drop");
	$self->markBad ($drop);
	return;
    }

    # Try deleting this file.  If something fails, keep this drop as
    # is, we'll come back to it later.
    return if ! $self->deleteOneFile ($drop, $file);

    # Mark drop done so it will be nuked
    &touch ("$dropdir/done");

    # Log transfer delay stats
    my $dtransfer = &mytimeofday() - $file->{TIME_START};
    &logmsg ("xstats: $file->{GUID} 0 " . sprintf('%.2f', $dtransfer));

    # OK, got far enough to nuke and log it
    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($self->{STARTTIME})]} success");
}


# Return megabytes free and percent of disk space used.
sub diskStats
{
    my ($self) = @_;
    my @dfout = split (/\s+/, qx(df -Pm $self->{IMPORTLOC} | tail -1));
    my ($free, $used) = @dfout[3,4];
    $used =~ s/%$//;
    return ($free, $used);
}

# Get a list of files to delete.
sub filesToDelete
{
    my ($self, $dbh, $limit) = @_;

    # Find all the files that we are allowed to delete: everything
    # transferred out of this node where the transfer is completed
    # (to_state = 3).  We take the files oldest first.
    my @guids = ();
    my $qguids = &dbexec($dbh,qq{
	select rs.guid
	from t_replica_state rs
	left join t_transfer_state ts
	  on ts.guid = rs.guid and ts.from_node = rs.node
	where rs.state = 1
	  and rs.node = :node
	  and ts.to_state = 3
	order by ts.to_timestamp asc},
        ":node" => $self->{MYNODE});
    while (my ($guid) = $qguids->fetchrow())
    {
	push (@guids, $guid);
	last if scalar @guids >= $limit;
    }

    # Now get PFNs for all those files.
    my @files = ();
    my $pfns = &guidToPFN (\@guids, "direct", "local", @{$self->{PFN_QUERY}});
    foreach my $guid (@guids)
    {
	my $pfn = $pfns->{$guid};
	do { &logmsg ("no pfn for $guid"); next } if ! $pfn;
	push (@files,
	      { GUID		=> $guid,
		PFN		=> $pfn,
		TIME_START	=> &mytimeofday() });
    }

    return @files;
}

# Create a drop for deleting a file.  We create a drop for ourselves,
# i.e. in our own inbox, and then process the file in "processDrop".
# This way we have a permanent record of where we are with deleting
# the file, in case we have to give up some operation for temporary
# failures.
sub startOne
{
    my ($self, $file) = @_;

    # Create a pending drop in my inbox
    my $drop = "$self->{DROPDIR}/inbox/$file->{GUID}";
    do { &alert ("$drop already exists"); return 0; } if -d $drop;
    do { &alert ("failed to submit $file->{GUID}"); &rmtree ($drop); return 0; }
	if (! &mkpath ($drop)
	    || ! &output ("$drop/packet", Dumper ($file))
	    || ! &touch ("$drop/go.pending"));

    # OK, kick it go
    &warn ("failed to mark $file->{GUID} ready to go")
	if ! &mv ("$drop/go.pending", "$drop/go");

    return 1;
}

# Pick up work from the database.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Check whether there's enough disk space.  If yes, bail out.
	my ($freespace, $usedpct) = $self->diskStats ();
	return if ! defined $freespace || ! defined $usedpct;
	return if ($usedpct < $self->{MAXFILLRATIO}
		   && $freespace > $self->{MINFREESPACE});

	# Not enough space.  Get a list of victims to evict.
	&logmsg ("disk $freespace/$usedpct% full, starting to clear out files");
	foreach my $file ($self->filesToDelete ($dbh, $self->{PURGE}))
	{
	    # If we are already processing this file, ignore it
	    next if grep ($_ eq $file->{GUID}, @pending);

	    # Otherwise initiate destruction and doom
	    $self->startOne ($file);
	}

	$dbh->commit();
    };
    do { &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($self->{WAITTIME});
}

1;
