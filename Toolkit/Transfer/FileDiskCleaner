#! /usr/bin/env perl

##H Delete replica entries, files and POOL catalogue entries for
##H disk buffers
##H
##H This agent is meant as garbage collection system for sites with
##H an MSS node for for lomg term storage plus an intermediate disk
##H buffer. The agent continuously checks the free disk space on the
##H disk buffer and initiates a clean-up if a certain watermark
##H (e.g. fill level) is reached. The maximum fill level allowed can
##H be adjusted via "-maxfillratio" and "-minfreespace". If any of
##H the two requirements are met, a clean-up is initiated.
##H
##H In that case a list of expendable fils is created by checking the
##H buffer for files which already are already safe on MSS. Those
##H files are subject to the following clean-up procedure:
##H 1. remove the corresponding replica in TMDB (t_replica_state)
##H 2. remove the file physically from disk
##H 3. remove the corresponding replica entry in the local POOL
##H    catalogue
##H
##H In addition to the watermark setting, the user also needs to
##H provide:
##H 1. the path to the diskbuffer, which should be watched
##H    "-importloc"
##H 2. the POOL commands or scripts which should be used to query
##H    PFNs from the catalogue "-pfnquery":
##H    e.g. "PFNLookup.sh,-u,$PHEDEX_CATALOGUE"
##H 3. the POOL command or script to remove PFNs from the catalogue
##H    "-pfnrm": e.g. "FCdeletePFN,-u,$PHEDEX_CATALOGUE,-p"
##H 4. the amount of files to purge before the next check of
##H    available diskspace
##H    "-purgesize": here some 1000 files is usually a good value
##H
##H
##H Usage:
##H   FileDiskCleaner
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-log OUT]
##H
##H -state         agent state directory
##H -node          the node where this agent runs
##H -db            database connection configuration parameter file
##H -importloc     path to disk to watch (in direct mode)
##H                path to wdsl file on SRM server in dcap mode
##H -maxfillratio  maximum allowed disk usage in percentage
##H                (default: 75)
##H -minfreespace  minimum available disk free space in megabytes
##H                (default: 100)
##H -pfnquery      command to query pfns from catalogue
##H -pfnrm         command to remove pfns from catalogue
##H -purgesize     maximum number of files to purge per check-iteration
##H -protocol      file access protocol used.
##H                rfio: acces to Castor MSS systems
##H                dcap: access to dCache MSS systems via PNFS
##H                srm: access to SRM interfaced MSS systems
##H                direct: direct file or NFS based access (default)
##H -log           where to redirect logging information

BEGIN
{
  use warnings; use strict; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
my %args = (MAXFILLRATIO => 75,
	    MINFREESPACE => 100,
	    PURGE => 1000,
	    WAITTIME => 60);
use Getopt::Long;
use UtilsHelp;

&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "log=s"		=> \$args{LOGFILE},
	     "db=s"		=> \$args{DBCONFIG},
	     "node=s"		=> \$args{MYNODE},
	     "purgesize=f"      => \$args{PURGE},
	     "help|h"		=> sub { &usage() },

	     "pfnquery=s"	=> \$args{PFN_QUERY},
	     "pfnrm=s"		=> \$args{PFN_RM},
 	     "maxfillratio=f"	=> \$args{MAXFILLRATIO},
	     "minfreespace=f"	=> \$args{MINFREESPACE},
	     "importloc=s"	=> \$args{IMPORTLOC},
	     "protocol=s"       => \$args{PROTOCOL});

$args{PFN_QUERY} = [ split(/,/, $args{PFN_QUERY}) ] if $args{PFN_QUERY};
$args{PFN_RM} = [ split(/,/, $args{PFN_RM}) ] if $args{PFN_RM};

if ($args{HELPME}
    || !$args{MYNODE} || !$args{DROPDIR} || !$args{DBCONFIG}
    || !$args{MAXFILLRATIO} || !$args{MINFREESPACE} || !$args{PFN_QUERY}
    || !$args{PFN_RM})
{
    die "Insufficient parameters, use -h for help.\n";
}
if (!$args{PROTOCOL} && !$args{IMPORTLOC}) {
    die "Insufficient parameters, use -h for help.\n";
}

(new FileDiskCleaner (%args))->process();

################################################
package FileDiskCleaner; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;
use DBI;
use UtilsRFIO;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  AGENTID => "FileCleaner",     # Identity for activity logs
		  MAXFILLRATIO => undef,	# Maximum disk fill percentage
		  MINFREESPACE => undef,	# Minimum free space in MB
		  PURGE => undef,               # amount of files to purge per run
		  IMPORTLOC => undef,		# Disk path to watch
		  PFN_QUERY => undef,		# Program to query PFNs
		  PROTOCOL => undef,            # File access protocol
		  PFN_RM => undef);		# Program to remove PFNs

    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Delete a file.  We do one step at a time; if the step fails, we just
# tell the caller to come back here again at a more opportune time.
# The steps are ordered such that they are safe to execute several
# times if we have to give for one reason or another.
sub deleteOneFile
{
    my ($self, $drop, $file) = @_;
    my $dbh = undef;
    my $status = eval {
	$dbh = &connectToDatabase ($self, 0) or die "failed to connect";
	
	# Make sure the file is still safe to delete.  More transfers
	# out might have been created for this file while we were not
	# minding this particular file (sleeping or deleting things).
	my ($npending) = &dbexec($dbh, qq{
	    select count(guid) from t_transfer_state
	    where from_node = :node and guid = :guid and to_state < 3},
	    ":node" => $$self{MYNODE}, ":guid" => $$file{GUID})->fetchrow();
	if ($npending)
	{
	    &warn ("not removing $$file{GUID}, $npending pending transfers");
	    return 0;
	}

	# Now delete the replica entry to avoid new transfer edges.
	&dbexec($dbh, qq{
	    delete from t_replica_state where guid = :guid and node = :node},
	    ":guid" => $$file{GUID}, ":node" => $$self{MYNODE});
	$dbh->commit();

	# Remove file from disk now.
	if ($$self{PROTOCOL} eq 'rfio') {
	    my $directPFN = $$file{PFN}; $directPFN =~ s/^[a-z]*://;
	    if (&rfstatmode($directPFN)) {
		&warn ("failed to remove $directPFN from castor") if 
		    &runcmd ("stageclr", "-h", $ENV{STAGE_HOST}, "-p", 
			     $ENV{STAGE_POOL}, "-remove_from_hsm", "-M", $directPFN);
	    } else {
		&warn ("$$file{GUID}: no such file $directPFN"); 
	    }
	} elsif ($$self{PROTOCOL} eq 'srm') {
	    &warn ("wasn't able to delete $$file{PFN} via SRM") if
		&runcmd ("srm-advisory-delete", $$file{PFN});
	} else {
	    my $directPFN = $$file{PFN}; $directPFN =~ s/^[a-z]*://;
	    if (-e $directPFN) {
		unlink ($directPFN);
	    } else {
		&warn ("$directPFN: no such file $directPFN");
	    }
	}
	
	# Delete file from catalogue
	if (my $rc = &runcmd (@{$$self{PFN_RM}}, $$file{PFN}))
	{
	    &warn ("failed to remove $$file{GUID} from catalogue:"
		   . " exit code @{[&runerror($rc)]}");
	    return 0;
	}

	# Job done!
	&logmsg ("$$file{GUID} $$file{PFN} deleted");
	return 1;
    };

    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh;
	 $status = 0 } if $@;
    
    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Return status code to caller
    return $status;
}

sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $$self{BAD}{$drop};
    &timeStart($$self{STARTTIME});

    # Read back file information
    my $dropdir = "$$self{WORKDIR}/$drop";
    my $file = do { no strict "vars"; eval &input ("$dropdir/packet") };
    if ($@ || !$file || !$$file{GUID} || !$$file{PFN} || !$$file{TIME_START})
    {
	&alert ("corrupt packet in $drop");
	$self->markBad ($drop);
	return;
    }

    # Try deleting this file.  If something fails, keep this drop as
    # is, we'll come back to it later.
    return if ! $self->deleteOneFile ($drop, $file);

    # Mark drop done so it will be nuked
    &touch ("$dropdir/done");

    # Log transfer delay stats
    my $dtransfer = &mytimeofday() - $$file{TIME_START};
    &logmsg ("xstats: $$file{GUID} 0 " . sprintf('%.2f', $dtransfer));

    # OK, got far enough to nuke and log it
    $self->relayDrop ($drop);
    &logmsg("stats: $drop @{[&formatElapsedTime($$self{STARTTIME})]} success");
}


# Return megabytes free and percent of disk space used.
# direct file access using regular mount points
sub diskStats
{
    my ($self) = @_;
    my @dfout = split (/\s+/, qx(df -Pm $$self{IMPORTLOC} | tail -1));
    my ($free, $used) = @dfout[3,4];
    $used =~ s/%$//;
    return ($free, $used);
}

# Return megabytes free and percent of disk space used.
# RFIO based file access
sub diskStatsRfio
{
    my ($self) = @_;
    my @out = split (/\s+/, qx(stageqry -h $ENV{STAGE_HOST} -p $ENV{STAGE_POOL} -s | grep FREE | head -1));
    my ($free, $freepcg) = @out[4,5];
    do {$free  =~ s/T//; $free = $free * 1024 * 1024} if $free =~ /T/;
    do {$free  =~ s/G//; $free = $free * 1024} if $free =~ /G/;
    $freepcg =~ s/\(//; $freepcg =~ s/%\)//;
    return ($free, 100 - $freepcg);
}

# Return megabytes free and percent of disk space used.
# DCAP based file access (dCache)
sub diskStatsDCAP
{
    my ($self) = @_;
    my @srmout = qx(srm-storage-element-info $$self{IMPORTLOC} 2>&1 |grep "Space");
    map { s|.*=||; s|\s\(\d+.*|| } @srmout;
    chomp @srmout;
    my $total = $srmout[0];
    my $free = $srmout[2];
    my $used = $srmout[1];
    my $usedpcg = undef;
    $usedpcg = $used/$total*100.0 if ($total > 0);
    return ($free, $usedpcg);
}

# Get a list of files to delete.
sub filesToDelete
{
    my ($self, $dbh, $limit) = @_;

    # Find all the files that we are allowed to delete: everything
    # transferred out of this node where the transfer is completed
    # (TableCleaner removed t_transfer_state entries).
    # We take the files oldest first.
    my @guids = ();
    my $qguids = &dbexec($dbh,qq{
	select guid
	from t_replica_state
	where node = :node
	  and guid not in
	     (select guid from t_transfer_state
	         where to_node = :node
	         or from_node = :node)
	order by state_timestamp asc},
        ":node" => $$self{MYNODE});
    while (my ($guid) = $qguids->fetchrow())
    {
	push (@guids, $guid);
	last if scalar @guids >= $limit;
    }

    # Now get PFNs for all those files.
    my @files = ();
    my $pfns = &guidToPFN (\@guids, $$self{PROTOCOL} ? $$self{PROTOCOL} : "direct", "local", @{$$self{PFN_QUERY}});
    foreach my $guid (@guids)
    {
	my $pfn = $$pfns{$guid};
	do { &logmsg ("no pfn for $guid"); next } if ! $pfn;
	push (@files,
	      { GUID		=> $guid,
		PFN		=> $pfn,
		TIME_START	=> &mytimeofday() });
    }

    return @files;
}

# Create a drop for deleting a file.  We create a drop for ourselves,
# i.e. in our own inbox, and then process the file in "processDrop".
# This way we have a permanent record of where we are with deleting
# the file, in case we have to give up some operation for temporary
# failures.
sub startOne
{
    my ($self, $file) = @_;

    # Create a pending drop in my inbox
    my $drop = "$$self{DROPDIR}/inbox/$$file{GUID}";
    do { &alert ("$drop already exists"); return 0; } if -d $drop;
    do { &alert ("failed to submit $$file{GUID}"); &rmtree ($drop); return 0; }
	if (! &mkpath ($drop)
	    || ! &output ("$drop/packet", Dumper ($file))
	    || ! &touch ("$drop/go.pending"));

    # OK, kick it go
    &warn ("failed to mark $$file{GUID} ready to go")
	if ! &mv ("$drop/go.pending", "$drop/go");

    return 1;
}

# Pick up work from the database.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Check whether there's enough disk space.  If yes, bail out.
	my ($freespace, $usedpct) = undef, undef;
	if ($$self{PROTOCOL} eq 'rfio') {
	    ($freespace, $usedpct) = $self->diskStatsRfio ();
	} elsif ($$self{PROTOCOL} eq 'dcap' or $$self{PROTOCOL} eq 'srm') {
	    ($freespace, $usedpct) = $self->diskStatsDCAP ();
	} else {
	    ($freespace, $usedpct) = $self->diskStats ();
        }
	return if ! defined $freespace || ! defined $usedpct;
	return if ($usedpct < $$self{MAXFILLRATIO}
		   && $freespace > $$self{MINFREESPACE});

	# Not enough space.  Get a list of victims to evict.
	&logmsg ("disk $freespace/$usedpct% full, starting to clear out files");
	foreach my $file ($self->filesToDelete ($dbh, $$self{PURGE}))
	{
	    # If we are already processing this file, ignore it
	    next if grep ($_ eq $$file{GUID}, @pending);

	    # Otherwise initiate destruction and doom
	    $self->startOne ($file);
	}

	$dbh->commit();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}

1;
