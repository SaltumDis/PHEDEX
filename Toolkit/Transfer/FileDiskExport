#!/usr/bin/perl

## This agent is for disk-only sites that should always mark files
## ready for transfer when they are requested by other sites.

BEGIN { use strict; use warnings; }
my $me = $0; $me =~ s|.*/||;
my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";
unshift(@INC, $home);

######################################################################
my %args = (DBITYPE => "Oracle");
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $master = 1; $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBNAME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbi' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBITYPE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbuser' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBUSER} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbpass' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBPASS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MYNODE} = shift(@ARGV); }
    else
    { last; }
}

if (scalar @ARGV || !$args{DROPDIR} || !$args{DBNAME} || !$args{DBUSER}
    || !$args{DBPASS} || !$args{DBITYPE} || !$args{MYNODE})
{
    print STDERR
	"usage: $me -node TMDB-NODE\n",
	"    -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
	"    -state IN-DROP-BOX [-wait SECS-TO-WAIT]\n";
    exit (1);
}

my $agent = new FileDiskExport (%args);
# Recapture interrupt signal, oracle swallows it.
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop (); };
$agent->process ();

######################################################################
# Routines for the master castor export agent.  This one simply manages
# the file transfer requests and passes the work to appropriate other
# local export agents (stage-in, checksum).
package FileDiskExport; use strict; use warnings; use base 'UtilsAgent';
use DBI;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBITYPE => undef,		# Database driver binding
    		  DBNAME => undef,		# Database name
	  	  DBUSER => undef,		# Database user name
	  	  DBPASS => undef,		# Database user password
	  	  MYNODE => undef);		# My TMDB node name
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;

    # FIXME: Update agent status
    # FIXME: Pick up and process messages to me

    # Always mark all files ready to go immediately.
    eval
    {
	my $now = time();
	my $mynode = $self->{MYNODE};
	my $dbh = DBI->connect ("DBI:$self->{DBITYPE}:$self->{DBNAME}",
	    		 	$self->{DBUSER}, $self->{DBPASS},
			 	{ RaiseError => 1, AutoCommit => 1 });

	# Mark everything available locally.
	$dbh->do(qq{
		update t_replica_state
		set state = 3, time_stamp = $now
		where state = 2 and node = '$mynode'});

	# Mark all pending transfers ready to go.
	$dbh->do(qq{
		update t_transfer_state
		set src_state = 1, src_time_stamp = $now
		where src_state = 0 and src_node = '$mynode'});

	# Purge completed transfers we no longer need to track.
	my $old = $now - 86400;
	$dbh->do(qq{
		delete from t_transfer_state
		where src_state = 1
		  and src_node = '$mynode'
	  	  and dest_state = 2
	  	  and dest_time_stamp < $old});
    };
    do { &alert ("database error: $@"); } if $@;

    # Check children are still running and then wait
    $self->maybeStop ();
    sleep ($self->{WAITTIME});
}
