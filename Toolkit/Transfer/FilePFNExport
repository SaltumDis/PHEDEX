#!/usr/bin/env perl

##H Produce transfer file names (TURLs) for exported files.
##H
##H This agent generates the export file name for outbound file
##H transfers.  It monitors the database for wanted or staged
##H files that do not yet have a transfer name, and generates
##H one.  The site storage map catalogue is used to generate
##H the export names for the files.
##H
##H Usage:
##H   FilePFNExport
##H      -state DIRECTORY -nodes PATTERN[,PATTERN...]
##H      -db FILE[:SECTION] [-log OUT]
##H      [-ignore NODE[,NODE...]] [-accept NODE[,NODE...]]
##H      -protocols PROTO[,PROTO...] -storagemap PATH
##H
##H -state       agent state directory
##H -nodes       patterns for the node names for which this agent runs
##H -db          database connection configuration parameter file
##H -log         where to redirect logging information
##H -ignore      comma-separated list of nodes to ignore transfers from
##H -accept      comma-separated list of nodes to accept transfers from
##H -protocols   comma-separated list of protocols to accept
##H -storagemap  storage mapping catalogue

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "nodes=s"     => sub { push(@{$args{NODES}}, split(/,/, $_[1])) },
             "ignore=s"    => sub { push(@{$args{IGNORE_NODES}}, split(/,/, $_[1])) },
             "accept=s"    => sub { push(@{$args{ACCEPT_NODES}}, split(/,/, $_[1])) },
             "protocols=s" => sub { push(@{$args{PROTOCOLS}}, split(/,/, $_[1])) },
	     "storagemap=s"=> \$args{STORAGEMAP},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{NODES} || !$args{DBCONFIG}
    || !$args{STORAGEMAP} || !$args{PROTOCOLS})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FilePFNExport (%args))->process();

######################################################################
# Routines specific to this agent.
package FilePFNExport; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsCatalogue;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  NODES => [],			# Patterns for nodes to run for
	  	  IGNORE_NODES => [],		# TMDB nodes to ignore
	  	  ACCEPT_NODES => [],		# TMDB nodes to accept
		  WAITTIME => 50 + rand(20),	# Agent activity cycle
	  	  STORAGEMAP => undef,		# Storage path mapping rules
		  PROTOCOLS => undef);		# Protocols to accept
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

######################################################################
# Pick up files that need PFN from database
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my @nodes;
    eval
    {
    	($dbh, @nodes) = &expandNodesAndConnect ($self);
	my ($nodes, %node_args) = &myNodeFilter ($self, "ns.");
	my ($filter, %filter_args) = &otherNodeFilter ($self, "nd.");

	# Create jobs for computing TURLs for files.
	my $now = &mytimeofday();
	my $query = &dbexec($dbh,qq{
	    select
	      xr.fileid, f.logical_name,
	      xr.node from_node_id, ns.name from_node,
	      xs.to_node to_node_id, nd.name to_node,
	      xs.to_protocols, xs.time_request
	    from t_xfer_replica xr
	      join t_xfer_file f
	        on f.id = xr.fileid
	      join t_xfer_state xs
	        on xs.from_replica = xr.id
	      join t_node nd
	        on nd.id = xs.to_node
	      join t_node ns
		on ns.id = xr.node
	    where $nodes
      	      and xs.errors < 5
	      and xs.time_request >= :old
	      and xs.time_expire > :now
      	      and xs.to_protocols is not null
      	      and xs.from_pfn is null
	      $filter},
            ":now" => $now, ":old" => $now - 15*60,
            %node_args, %filter_args);

    	my ($n, %todo) = 0;
	my %myprotos = map { $_ => 1 } @{$$self{PROTOCOLS}};
        while (my $file = $query->fetchrow_hashref())
	{
	    my $lfn = $$file{LOGICAL_NAME};
	    my $to = $$file{TO_NODE};
	    my $protos = $$file{TO_PROTOCOLS};

	    # If we failed to generate TURL or determine protocol for
	    # this file recently, ignore it until back-off time passes.
	    next if ($$self{BACKOFF}{$lfn}{$to} || $now-1) > $now;
	    delete $$self{BACKOFF}{$lfn}{$to};

	    # Determine which protocl we can use
	    my $proto = (grep(exists $myprotos{$_}, split(/,/, $protos)))[0];
	    if (! defined $proto)
	    {
		&alert ("$lfn: no available protocol for destination $to"
		        . " (available protocols:"
			. " $$file{FROM_NODE}=" . join(',', @{$$self{PROTOCOLS}})
			. " vs. $to=$protos)");
	    	$$self{BACKOFF}{$lfn}{$to} = $now + 1200*(1 + rand(2));
		next;
	    }

	    # Record as something we need to do
	    $$file{PROTOCOL} = $proto;
	    push (@{$todo{$to}{$proto}}, $file);

	    # Give up if we are picking too much work
	    last if ++$n >= 5000;
	}

	# Now process all the files.  For each destination and protocol,
	# make mass translation of the paths.
	foreach my $to (sort keys %todo)
	{
	    foreach my $proto (sort keys %{$todo{$to}})
	    {
		my $files = $todo{$to}{$proto};
		my @lfns = map { $$_{LOGICAL_NAME} } @$files;
		my $pfns = &pfnLookup(\@lfns, $proto, $to, $$self{STORAGEMAP});
	        foreach my $file (@$files)
		{
		    my $to = $$file{TO_NODE};
		    my $lfn = $$file{LOGICAL_NAME};
		    my $pfn = $$pfns{$lfn};
		    if (! $pfn)
		    {
	    	        # Whine for lack of output, and put to cool as penalty.
	    	        &warn ("no pfn for $lfn to $to with protocol $proto");
	    	        $$self{BACKOFF}{$lfn}{$to}
			    = &mytimeofday() + 1200*(1 + rand(2));
	    	        next;
		    }

		    &dbexec($dbh, qq{
	    	        update t_xfer_state set from_pfn = :pfn
	    	        where fileid = :fileid and to_node = :toid},
      	    	        ":pfn" => $pfn,
	    	        ":fileid" => $$file{FILEID},
	    	        ":toid" => $$file{TO_NODE_ID});
        	    $dbh->commit();

		    my $dtime = &mytimeofday() - $$file{TIME_REQUEST};
		    &logmsg ("xstats:"
			     . " from=$$file{FROM_NODE}"
			     . " to=$to"
			     . " fileid=$$file{FILEID}"
			     . " proto=$proto "
		 	     . sprintf('time_request=%.2fs', $dtime)
		 	     . " lfn=$lfn"
			     . " pfn=$pfn");
		}
	    }
        }
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}
