#!/usr/bin/env perl
BEGIN
{
    use warnings; use strict; use Getopt::Long;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


#---------------------------------------------
#
#
#---------------------------------------------


#---------------------------------------------
#     Argument parsing
#---------------------------------------------

my %args = (WAITTIME => 3600);

&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "node=s"		=> \$args{MYNODE},
	     "published=s"      => \$args{PUBLISHED},
	     "catalogue=s"      => \$args{CAT},
	     "catprefix=s"      => \$args{CATPREFIX},
	     "script=s"         => \$args{SCRIPT},
	     "wait=f"		=> \$args{WAITTIME});

if (!$args{MYNODE} || !$args{DROPDIR}
    || !$args{PUBLISHED} || !$args{CAT} || !$args{CATPREFIX}
    || !$args{SCRIPT})
{
    print STDERR "usage: $me -state IN-DROP-BOX -node NODENAME\n",
                 "       -script PUBLICATION-SCRIPT\n",
                 "       -catprefix CATALOG-PREFIX -catalogue POOL-CONTACT\n",
                 "       -published DIR-WITH-TREATED-PACKETS [-wait SECONDS]\n";
    exit 1;
}


my $agent = new BlockPublication (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{QUIT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{TERM} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package BlockPublication; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsTR;
use Cwd;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MYNODE     => undef,          # My TMDB node name
		  PUBMETHOD  => undef,          # method used for publishing
                                                # (script or mcrunjob)
		  SCRIPT     => undef,          # path to script for publishing
		  MCRUNJOB   => undef,          # MCRUNJOB command for publishing
		  CAT        => undef,          # local POOL catalogue contact
		  CATPREFIX  => undef,          # Catalogue prefix to use
		  PUBDIR     => undef,          # workdir for publish command
		  PUBLISHED  => undef,          # file with treated owner/datasets
		  AGENTID    => "Publication"); # Identity for activity logs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}



sub processDrop
{
    my ($self, $drop) = @_;

    # Sanity checking
    return if (! $self->inspectDrop ($drop));
    delete $self->{BAD}{$drop};
    &timeStart($self->{STARTTIME});

    # Read back file information
    my $dropdir = "$self->{WORKDIR}/$drop";
    my $block = do { no strict "vars"; eval &input ("$dropdir/packet") };
    if ($@ || !$block || !$block->{DATASET} || !$block->{OWNER} || !$block->{FILES})
    {
	&alert ("corrupt packet in $drop");
	$self->markBad ($drop);
	return;
    }


    # Do some consistency checks between RefDB and the local catalogue
    # prior to starting the publishing
    my $consistent = $self->checkConsistency($block);

    # Perform publication and validation.  If something fails, don't worry
    # we will get the drop once more.
    my $publishStart = &mytimeofday();
    my $publishOK = $self->publishBlock($block) if $consistent;

    # Mark drop done so it will be nuked
    &touch ("$dropdir/done");

    # Log transfer delay stats
    my $dtransfer = &mytimeofday() - $publishStart;
    &logmsg ("xstats: $block->{DATASET} 0 " . sprintf('%.2f', $dtransfer));

    # OK, got far enough to nuke and log it
    $self->relayDrop ($drop);
    if ($publishOK && $consistent)
    {
	&logmsg("stats: $drop @{[&formatElapsedTime($self->{STARTTIME})]} success");
    }
    else
    {
	&logmsg("publication and validation failed. Please check manually !!");
    }
}

sub checkConsistency {
    my ($self, $block) = @_;

    # check the amount of files we have in our MySQL POOL catalogue
    my @GuidPfnPOOL = ();
    my @cmd = ("FClistPFN",
	       " -u $self->{CAT}",
	       " -q \"dataset = \'$block->{DATASET}\' and owner = \'$block->{OWNER}\'\" ",
	       " |grep $self->{CATPREFIX} ");

    @GuidPfnPOOL = `@cmd`;

    if (scalar @GuidPfnPOOL != $block->{FILES})
    {
	&warn("Catalogue and TMDB disagree about the amount of files in this dataset" .
	      "owner: $block->{OWNER}\ndataset: $block->{DATASET}\n" .
	      "Catalogue files: ".scalar @GuidPfnPOOL." TMDB: $block->{FILES}");
	return 0; # report failure
    }
    return 1; #report success
}


sub getHistory
{
    my ($history) = @_;
    my @handeled = ();
    
    if (-d $history) {
	&getdir($history,\@handeled);
    }
    return @handeled;
}

sub addToHandeled
{
    my ($history, $dataset, $owner) = @_;

    &logmsg("adding entry $dataset:$owner to $history");
    system("mkdir $history") if (! -d $history);
    &touch("$history/$owner.$dataset");
 }

sub removeFromHandeled
{
    my ($history, $dataset, $owner) = @_;

    &logmsg("removing entry $dataset:$owner from history");
    &rmtree("$history/$owner.$dataset");
}

sub markBad
{
    my ($history, $dataset, $owner) = @_;

    &logmsg("marking bad $owner in history");
    &mv("$history/$owner.$dataset", "$history/$owner.$dataset.bad");
}

sub publishBlock
{
    my ($self, $block) = @_;

    my $history = $self->{PUBLISHED};

    # find out what we are dealing with (Hit, Digi, PileUp or DSTs)
    my $pileup = grep(m|MBforPU|,$block->{DATASET});
    my $digi = grep(m|PU|,$block->{OWNER}) if !$pileup;
    my $hit = grep(m|Hit|,$block->{OWNER});
    my $dst = grep(m|DST|,$block->{OWNER});
    
    # get the list of datasets/owners we already dealt with
    my @entriesHandeled = &getHistory($history);

    # check if we already handeled that dataset. If yes, that's all we do.
    my $handeled = grep(m|$block->{OWNER}.$block->{DATASET}|, @entriesHandeled);

    # declare the dataset/owner packet handeled,
    # if we are dealing with (not yet handeled) Hit or PU
    &addToHandeled($history, $block->{DATASET}, $block->{OWNER})
	if (! $handeled && ($hit || $pileup));

    # check if we have completely transfered Hit and PU
    my $havehit = grep(m|Hit|,@entriesHandeled);
    my $havePU = grep(m|MBforPU|,@entriesHandeled);

    # start publishing if:
    #                      1. we are dealing with a Digi owner and we have the corresponding Hits
    #                      2. we are dealing with a DST
    if (! $handeled && ( ($digi && $havehit) || $dst) )
    {
	eval {
	    
	    my @cmd = ('/bin/false');
	    &logmsg("triggering publishing of dataset: $block->{DATASET}");
	    my $assid = &listAssignments($block->{DATASET},$block->{OWNER});
	    
	    # add dataset/owner to handeled file list in order to lock it
	    &addToHandeled($history, $block->{DATASET}, $block->{OWNER});
	
	    @cmd = ($self->{SCRIPT},
		    $block->{DATASET},
		    $block->{OWNER},
		    $assid);
	    my $PubFailed = &runcmd(@cmd);
	    die if $PubFailed;
	};
	
	do {&alert ("publishing didn't succeed !!\n");
	    &markBad($history,$block->{DATASET}, $block->{OWNER});
	    return 0} if $@;
    }
    
    return 1 # report success
}

