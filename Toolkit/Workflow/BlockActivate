#! /usr/bin/env perl

#-----------------------------------------------------------------------------------------------
# agent name: block activate agent
# purpose:    recreate file level information if dataset/owner collections
#             are needed again (e.g. new subscriptions)
#-----------------------------------------------------------------------------------------------

BEGIN
{
  use warnings; use strict; use Getopt::Long;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


#---------------------------------------------
#     Argument parsing
#---------------------------------------------

my %args = (DBITYPE => 'Oracle',
	    WAITTIME => 60);

&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "node=s"           => \$args{MYNODE},
	     "db=s"		=> \$args{DBNAME},
	     "dbitype=s"	=> \$args{DBITYPE},
	     "dbuser=s"		=> \$args{DBUSER},
	     "dbpass=s"		=> \$args{DBPASS},
	     "wait=f"		=> \$args{WAITTIME},
	     "help"		=> \$args{HELPME});


if ($args{HELPME} || !$args{DBNAME} || !$args{DBUSER}
    || !$args{DBPASS} || !$args{DROPDIR})
{
    print STDERR "usage: $me -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
                 "       -state IN-DROP-BOX [-wait SECONDS]\n";
    exit 1;
}

my $agent = new BlockDeactivate (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{QUIT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{TERM} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package BlockDeactivate; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;
use DBI;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBITYPE => undef,		# Database driver binding
		  MYNODE => undef,              # my TMDB nodename
    		  DBNAME => undef,		# Database name
	  	  DBUSER => undef,		# Database user name
	  	  DBPASS => undef,		# Database user password
	  	  AGENTID => "BlockDeactivate");      # Identity for activity logs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}


# Pick up work from the database and start site specific scripts if necessary
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my @collectionsWanted = ();

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";
	
	# look for newly requested collections and make the files available in t_replica_state
	@collectionsWanted = $self->getGroupsWanted($dbh);
	if (scalar (@collectionsWanted) !=0) {
	    # make those collections available in t_replica_state if necessary
	    foreach my $collection (@collectionsWanted) {
		$self->makeAvailInTMDB($dbh, $collection);
	    }
	}
	
	# final commit
	$dbh->commit();
    };
    do { &alert ("database error: $@"); $dbh->rollback if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($self->{WAITTIME});
}


sub getGroupsWanted {
    my ($self, $dbh) = @_; 
    my @packet = ();
    
# any collections wanted, which are not in t_replica_state ? Let's check....    
# FIXME: really ugly SQL... I am wondering if this could be improved
    my $h_packet = &dbexec ($dbh, qq{
	select ts.dataset, ts.owner, ts.destination
        from t_subscription ts, t_file tf, t_block tb
        where tf.inblock=tb.name and 
        ts.dataset=tb.dataset and 
        ts.owner=tb.owner and 
        tf.guid not in (select guid from t_replica_state)});
    
    while (my ($owner, $dataset, $node) = $h_packet->fetchrow_array){
	my $exists = grep(|"$dataset:$owner:$node"|,@packet);
	push (@packet, "$dataset:$owner:$node") if ! $exists ;
    }
# return those dataset owner pairs
    return @packet;
    
}


sub makeAvailInTMDB {
    my ($self, $dbh, $collection) = @_;
    my ($dataset, $owner, $node) = split(':',$collection);
    
    my $now = time();
# we need the guids for the files belonging to the selected dataset-owner pairs
    my @guids = &getGUIDs($dataset, $owner);
    
    foreach my $guid (@guids) {
# let's check, if the guids are already in t_replica state and add them if they are not
	my $guid_exists = &dbexec($dbh, qq{
	    select count(*) from t_replica_state
	    where node=:node and guid=:guid},
	    ":node"=>$node, ":guid"=>$guid);

	&dbexec($dbh, qq{
	    insert into t_replica_state (timestamp,guid,node,state,state_timestamp)
      	    values ("$now","$guid","$node",'0',"$now")}) if !$guid_exists;

	$dbh->commit();
    }
}


sub getGUIDS {
    my ($dataset, $owner) = @_;
    my @guids = ();

    my $guids_h = &dbexec ($dbh, qq{
	select f.guid from t_dsb_fileid f, t_dsb_dataset d
	where  d.dataset=:dataset and d.owner=:owner and d.id=f.id},
	":dataset"=>$dataset, ":owner"=>$owner);
    
    while (my ($guid) = $guids_h->fetchrow() ) {
	push (@guids, $guid);
    }
    return @guids;
}
