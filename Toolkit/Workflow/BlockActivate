#! /usr/bin/env perl

##H Activate blocks when file-level information is needed again.
##H
##H Files belong to blocks; when the file replicas are no longer needed
##H they are collapsed to block replicas, which remember entire sets of
##H files.  When the files in the blocks are needed again, for instance
##H because subscriptions need to be activated again, this agent expands
##H the block replicas back into file replicas.
##H
##H Usage:
##H   BlockActivate -state DIRECTORY -node NAME -db FILE[:SECTION] [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -log       where to redirect logging information

BEGIN {
  use warnings; use strict; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{MYNODE} || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockActivate (%args))->process();

################################################
package BlockActivate; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MYNODE => undef,              # my TMDB nodename
    		  DBCONFIG => undef,		# Database configuration file
		  WAITTIME => 600 + rand(100));	# Agent cycle time

    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}


# Pick up work from the database and start site specific scripts if necessary
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Reactivate blocks with incomplete destinations or which
	# have been explicitly requested to be activated.
	my $now = &mytimeofday ();
        my $stmt = &dbexec ($dbh, qq{
	    select b.id, b.name, count(br.block), sum(decode(br.is_active,'y',1,0))
	    from t_dps_block b
	      join t_dps_block_replica br
	        on br.block = b.id
	    where exists (select bd.block
	    		  from t_dps_block_dest bd
	    		  where bd.block = b.id
			    and bd.time_complete is null)
	       or exists (select br.block
       			  from t_dps_block_delete br
			  where br.block = b.id)
	       or exists (select ba.block
       			  from t_dps_block_activate ba
			  where ba.block = b.id
			    and ba.time_request <= :now
			    and (ba.time_until is null
		    		 or ba.time_until >= :now))
	    group by b.id, b.name},
    	    ":now" => $now);
	while (my ($id, $block, $nreplica, $nactive) = $stmt->fetchrow())
	{
	    # Ignore active blocks
	    if ($nactive)
	    {
		&alert ("block $id ($block) has $nreplica replicas"
			. " of which only $nactive are active")
		    if $nreplica != $nactive;
	        next;
	    }

	    # Inactive and wanted.  Activate the file replicas.  However
	    # before we start, lock the block and check counts again in
	    # case something changes.
	    &dbexec ($dbh, qq{
		select * from t_dps_block where id = :block for update},
		":block" => $id);

	    my ($xnreplica, $xnactive) = &dbexec ($dbh, qq{
		select count(block), sum(isactive) from t_dps_block_replica
		where block = :block}, ":block" => $id)->fetchrow ();

	    if ($xnactive != $nactive || $xnreplica != $nreplica)
	    {
		&warn ("block $id ($block) changed, skipping activation");
		next;
	    }

	    # Proceed to activate.
	    my ($stmt, $nfile) = &dbexec ($dbh, qq{
		insert into t_xfer_file
		(id, inblock, logical_name, checksum, filesize)
		(select id, inblock, logical_name, checksum, filesize
		 from t_dps_file where inblock = :block)},
		":block" => $id);

	    my ($stmt2, $nreplica) = &dbexec ($dbh, qq{
		insert into t_xfer_replica
		(id, fileid, node, state, time_create, time_state)
		(select seq_xfer_replica.nextval, f.id, br.node,
		        0, br.time_create, :now
		 from t_dps_block_replica br
		 join t_xfer_file f on f.inblock = br.block
		 where br.block = :block)},
	   	 ":block" => $id, ":now" => $now);

	    &dbexec ($dbh, qq{
		update t_dps_block_replica
		set is_active = 'y', time_update = :now
		where block = :block},
		":block" => $id, ":now" => $now);

	    &logmsg ("block $id ($block) reactivated with $nfile files"
		     . " and $nreplica replicas");
	    $dbh->commit();
	}

	# Remove old activation requests
	&dbexec ($dbh, qq{
	    delete from t_dps_block_activate
	    where time_request < :now
	      and time_until is not null
	      and time_until < :now},
           ":now" => $now);
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}
