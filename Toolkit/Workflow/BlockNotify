#! /usr/bin/env perl

##H Notify the site about completely transferred blocks.
##H
##H The BlockMonitor agent periodically updates the transfer progress
##H of various blocks.  Once a block has been transferred completely,
##H this agent notifies the site.  It creates a drop with the data
##H about the block, and another agent, typically BlockPublish, uses
##H the information to update site-local information (e.g. PubDB).
##H
##H Usage:
##H   BlockNotify -state DIRECTORY -node NAME -db FILE[:SECTION -next DIRECTORY
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -next      state directory for the next agent; can be repeated

BEGIN {
  use warnings; use strict; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
use UtilsHelp;
use Getopt::Long;
my %args = (WAITTIME => 3600, NEXTDIR => []);
&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "next=s@"          => $args{NEXTDIR},
	     "node=s"		=> \$args{MYNODE},
	     "db=s"     	=> \$args{DBCONFIG},
     	     "help|h"		=> sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !@{$args{NEXTDIR}}
    || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockNotify (%args))->process();

################################################
package BlockNotify; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef);		# My TMDB node name

    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Pick up ready blocks from database and inform downstream agents.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Get order list of blocks we have.  This is always everything,
	# we keep no record of what has already been notified.  The
	# downstream users of this information must handle duplicates.
        my $completed = &dbexec ($dbh, qq{
	    select dbs.name dbs_name,
	           ds.name dataset_name,
		   b.name block_name,
		   b.files
	    from t_dps_block_replica br
	      join t_dps_block b on b.id = br.block
	      join t_dps_dataset ds on ds.id = b.dataset
	      join t_dps_dbs dbs on dbs.id = ds.dbs
	    where br.node = :node
  	      and b.is_open = 'n'
	      and br.dest_files = b.files
	      and br.node_files = b.files
	      and br.time_update < :now - 30
  	    order by ds.name asc, b.name asc},
	    ":node" => $$self{ID_MYNODE},
	    ":now" => &mytimeofday())
	    ->fetchall_arrayref({});

	# Pass on as one drop per dataset block.  Make sure the drop
	# names are unique in case the downstream agents are disabled
	# or otherwise have trouble keeping up.
	foreach my $block (@$completed)
        {
	    my $blockid = "@{[time()]}.$$block{BLOCK_NAME}"; $blockid =~ s|/|_|g;
	    my $dropdir = "$$self{WORKDIR}/$blockid";
	    do { &alert ("failed to create drop for $blockid");
		 &rmtree ($dropdir); last; }
    	       if (! mkdir ($dropdir)
                   || ! &output ("$dropdir/packet", Dumper ($block))
        	   || ! &touch ("$dropdir/done"));
	    $self->relayDrop ($blockid);
        }
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}
