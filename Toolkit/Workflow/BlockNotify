#! /usr/bin/env perl

##H Notify the site about completely transferred blocks.
##H
##H The BlockMonitor agent periodically updates the transfer progress
##H of various blocks.  Once a block has been transferred completely,
##H this agent notifies the site.  It creates a drop with the data
##H about the block, and another agent, typically BlockPublish, uses
##H the information to update site-local information (e.g. PubDB).
##H
##H Usage:
##H   BlockNotify
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-wait SECS]
##H      -next DIRECTORY
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans
##H -next      state directory for the next agent; can be repeated

BEGIN {
  use warnings; use strict;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
use UtilsHelp;
use Getopt::Long;
use Data::Dumper;
my %args = (WAITTIME => 3600, NEXTDIR => []);
&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "next=s@"          => $args{NEXTDIR},
	     "node=s"		=> \$args{MYNODE},
	     "db=s"     	=> \$args{DBCONFIG},
	     "wait=f"		=> \$args{WAITTIME},
     	     "help|h"		=> sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{NEXTDIR}
    || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

my $agent = new BlockNotify (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{QUIT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{TERM} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package BlockNotify; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
	  	  AGENTID => "BlockNotify");    # Identity for activity logs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}


# Get list of all entirely transferred blocks.  This is always
# everything; we keep no record of what has already been notified.
# The downstream local agent must handle duplicates gracefully.
sub completeBlocks
{
    my ($self, $dbh) = @_;
    my $result = {};

    my $complete = &dbexec ($dbh, qq{
	select b.dataset, b.owner, b.files
	from t_block_replica br
	left join t_block b
	  on b.name = br.name
	where br.node = :node
	  and br.files = b.files
	  and br.timestamp < :now - 30},
	":node" => $self->{MYNODE},
	":now" => &mytimeofday());
 

    # prepare the drop and fill in all informations required
    while (my ($dataset, $owner, $files) = $complete->fetchrow_array())
    {
	$result->{$dataset}{$owner} = {
	    DATASET => $dataset,
	    OWNER => $owner,
	    FILES => $files
	    };
    }

    return $result;
}

# Pick up ready blocks from database and send info to downstream agents.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Get owner/dataset for all completely transferred blocks,
	# Also get other information necessary for e.g. publishing
	# and other local bookkeeping such as consistency checks.
	# In particular, get the number of files, and pass down
	# other transferred owners for the same dataset, so the
	# site can tell whether they have Hits *and* Digis.
	my $completed = $self->completeBlocks ($dbh);
        foreach my $dataset (sort keys %$completed)
        {
	    foreach my $owner (sort keys %{$completed->{$dataset}})
	    {
		# Dump out a drop box packet for each block in our own
		# outbox, for agent core to copy downstream.
		my $block = $completed->{$dataset}{$owner};
		my $blockid = "$block->{OWNER}.$block->{DATASET}";
		my $drop = `mktemp -d $self->{DROPDIR}/outbox/$blockid.XXXXXXX`;
		chomp $drop;
		do { &alert ("failed to create drop for $blockid"); &rmtree ($drop); last; }
    	            if (! $drop
        		|| ! &output ("$drop/packet", Dumper ($block))
        		|| ! &touch ("$drop/go.pending"));

		# OK, kick it go
		&warn ("failed to mark $blockid ready to go")
		    if ! &mv ("$drop/go.pending", "$drop/go");
	    }
        }
    };
    do { &alert ("database error: $@"); $dbh->rollback() if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Explicitly pump drops we just created, otherwise they will stay
    # in outbox until next time we wake up (usually an hour later!).
    foreach my $drop ($self->readOutbox())
    {
        $self->relayDrop ($drop);
    }

    # Have a little nap
    $self->nap ($self->{WAITTIME});
}
