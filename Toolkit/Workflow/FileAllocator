#!/usr/bin/perl
#
# Allocation Agent
#
# $Date: 2004/07/29 11:19:49 $
# $Id: Allocator.pl,v 1.48 2004/07/29 11:19:49 barrass Exp $
#
# This agent handles the allocation of files to destinations. It allocates files
# to destinations based on replica metadata and destination subscription
# information, all which is stored in the TMDB.
#
# First it determines a list of guids that it hasn't yet dealt with (they have
# allocated = 1). It queries the metadata (dataset, owner) for each
# guid, then determines which destinations have subscribed to files characterised
# by that metadata. It makes a guid:destination mapping for each destination in
# the t_destinations table.
#
# The agent determines which node(s) in the network represent the first hop
# toward each subscribing destination. It then makes an advertisement for those
# first-hop nodes in the t_file_state table.
#
# If the dataset, owner combination is not present in the subscriptions table
# the agent makes a blank entry, indicating that the combination is as yet
# unallocated.
#
# If no destinations are found, no allocation is made.
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# Command line options
# -no-updates		will run through the allocation algo but not make final changes in tmdb
# -w <workdir>		sets the workdir for the agent
# -db <tns name>	sets the Oracle db to talk to
# -u <pool cat uri>	sets the catalogue from which the agent takes info
# -once             only run once
# -period           repeat period, seconds
# -user             db username
# -passwd           db password

use DBI;
use Getopt::Long;
use File::Path;
$| = 1; # set autoflush

my $time;	# holds current time
my $g_no_updates;	# 1 means will not make final updates in tmdb
my $g_work_dir = '';	# place pid and stop files here...
my $g_db = "devdb9";	# tnsname of Oracle db (tmdb)
my $g_pool_uri = 'edgcatalog_http://rlscms.cern.ch:7777/cms/v2.2/edg-local-replica-catalog/services/edg-local-replica-catalog';
						# uri of pool catalogue to use
my $g_once;             # 1 means will only run once
my $g_period = 600;     # repeat period of algorithm
my $g_max_guids = 500;  # max new guids to return per cycle
my $g_user = '';        # db username
my $g_passwd = '';      # db password

# ###############################################################
# Main loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system( "touch $g_work_dir/stop" ); }
    my $loop_start = time();

    my %dataset_by_new_guid = &get_new_guid_list;
    my @guids = keys %dataset_by_new_guid;
    my %source_node_by_guid = get_source_nodes( \@guids );
    # Do error checks!
    my $guid = '';
    my @sql = ();
    
    my %destinations_by_dataset = &get_current_subscriptions;
    # Do error check!
    
    foreach $guid ( keys %dataset_by_new_guid ) {
        
        if ( exists( $destinations_by_dataset{$dataset_by_new_guid{$guid}} ) ) {
            
            @destinations = split( / /, $destinations_by_dataset{$dataset_by_new_guid{$guid}} );
            foreach $dest ( @destinations ) {
            
                my $gateway = lookup_route( $source_node_by_guid{$guid}, $dest );
                if ( $gateway eq '' ) {
                    # Could be transient, leave it for later...
                    log_entry( "Ag, no route from $source_node_by_guid{$guid} to $dest for $guid" );
                } else {
                    my $time = time();
                    log_entry( "$guid source: $source_node_by_guid{$guid} dest: $dest via: $gateway" );
                    my $goal = "insert into t_destinations "
                            ."values ('$guid','$dest')";
                    my $advert = "insert into t_file_state "
                            ."values ('$guid','$gateway',1,'$source_node_by_guid{$guid}',$time)";
                    push( @sql, $advert, $goal );
                }
            }
            
            my $update = "update t_files_for_transfer set allocated = 1 where guid = '$guid'";
            push( @sql, $update );
            
        } else {
            log_entry( "New stream for subscriptions- $new_stream" );
            my $new_stream = "insert into t_subscriptions values ('','$dataset_by_new_guid{$guid}')";
            push( @sql, $new_stream );
        }
    }
    
    do_sql( \@sql );

    $time = time();
    sleep($g_period - $time + $loop_start);
}


# ###############################################################
# Subroutines
# ###############################################################

sub log_entry {
    my $entry = shift;
	my $time = time();
	my $localtime = localtime($time);
	print "$localtime [$$] $entry\n";
}

sub get_new_guid_list {
	my @row;
	my $count = 0;
	my $selection = "select t_files_for_transfer.guid,"
	       ."t_replica_metadata.value "
	       ."from t_files_for_transfer,"
	       ."t_replica_metadata "
	       ."where allocated = 0 "
	       ."and rownum < $g_max_guids "
	       ."and t_files_for_transfer.guid = t_replica_metadata.guid "
	       ."and key = 'POOL_dataset'";

    my %guid_list = ();

	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	$g_user, 
		      				 	$g_passwd, 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();while (@row = $query->fetchrow_array) {	
	       $count++;
	       $row[1] =~ s/\s+//g;
	       $guid_list{$row[0]}  = $row[1];
        }
        log_entry(  "Found $count new GUIDs" );
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }
	
	return (%guid_list);
}

sub get_current_subscriptions {
	my @row;
	my $selection = "select * from t_subscriptions";

    my %destinations = ();

	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	$g_user, 
		      				 	$g_passwd, 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();
        while (@row = $query->fetchrow_array) {	
	       $row[1] =~ s/\s+//g;
	       $destinations{$row[1]}  .= "$row[0] ";
        }
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }
	
	return ( %destinations );
}

sub do_sql {
    my $sql = shift;
    
    eval {
        my $dbh = DBI->connect(    "DBI:Oracle:$g_db",
	   				    $g_user,
		  			    $g_passwd,
	   				    { RaiseError=>1, AutoCommit =>1 });
    
        foreach $sql ( @$sql ) {
            $dbh->do($sql) if (!$g_no_updates);
        }

        $dbh->disconnect;    
    };
    
    if ( @_ ) {
        log_entry( "Database operation failed doing sql list... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }
}

sub get_source_nodes {
    my $guids = shift;
    my $selection = "select guid,source_node from t_files_for_transfer where ";
    foreach $guid ( @$guids ) {
        $selection .= "guid = '$guid' or ";
    }
    substr( $selection, -4 ) = '';
    my %sources = ();


	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	$g_user, 
		      				 	$g_passwd, 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();while (@row = $query->fetchrow_array) {	
	       $sources{$row[0]}  = $row[1];
        }
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed getting source nodes for guids... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }    
    
    return( %sources );
    
}

sub lookup_route {
    my $source = shift;
    my $dest = shift;
    my $selection = "select gateway from t_routing where from_node = '$source' and to_node = '$dest'";
    my $gateway = '';
    my @row = ();

	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	$g_user, 
		      				 	$g_passwd, 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();
        while (@row = $query->fetchrow_array) {	
	       $gateway = $row[0];
        }
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed looking up route... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }       
    
    return( $gateway );
    
}



sub parse_command_line () {
	GetOptions(	'w=s' => \$new_work_dir,
				'db=s' => \$g_db,
				"no-updates" => \$g_no_updates,
				'u=s' => \$g_pool_uri,
				"once" => \$g_once,
				'period=i' => \$g_period,
				'user=s' => \$g_user,
				'passwd=s' => \$g_passwd
				);
	
	my $entry = '';
	
	$g_work_dir = $g_work_dir.$new_work_dir;
	$entry = $entry."work dir is $g_work_dir,";
	if (-e "$g_work_dir/pid") {
		log_entry( "Removing old pid file");
		unlink("$g_work_dir/pid");
	} 
	if (-e "$g_work_dir/stop") {
		log_entry( "Removing old stop file" );
		unlink ("$g_work_dir/stop");
	}
	if (!$g_db) {
		$g_db = "devdb9";
		
	}
	$entry = $entry."database is $g_db,";
	if ($g_pool_uri) {
		$entry = $entry."using POOL cat $g_pool_uri, ";
	}	
	if ($g_no_updates) {
		$entry = $entry."not making final updates, ";
	}	
	if ($g_once) {
		$entry = $entry."only running once, ";
	}
    if ($g_period) {
		$entry = $entry."with period $g_period, ";
	}	
	
	$time = time();
	
	print "Unprocessed by Getopt::Long\n" if $ARGV[0];
	foreach (@ARGV) {
	  print "$_\n";
	}
	
	log_entry( $entry );
}
