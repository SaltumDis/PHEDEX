#!/usr/bin/perl
#
# Allocation Agent
#
# $Date: 2004/09/03 18:43:48 $
# $Id: Allocator.pl,v 1.63 2004/09/03 18:43:48 barrass Exp $
#
# This agent handles the allocation of files to destinations. It allocates files
# to destinations based on replica metadata and destination subscription
# information, all which is stored in the TMDB.
#
# First it determines a list of guids that it hasn't yet dealt with (they have
# allocated = 1). It queries the metadata (dataset, owner) for each
# guid, then determines which destinations have subscribed to files characterised
# by that metadata. It makes a guid:destination mapping for each destination in
# the t_destinations table.
#
# The agent determines which node(s) in the network represent the first hop
# toward each subscribing destination. It then makes an advertisement for those
# first-hop nodes in the t_file_state table.
#
# If the dataset, owner combination is not present in the subscriptions table
# the agent makes a blank entry, indicating that the combination is as yet
# unallocated.
#
# If no destinations are found, no allocation is made.
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# Command line options
# -w <workdir>		sets the workdir for the agent
# -db <tns name>	sets the Oracle db to talk to
# -once             only run once
# -period           repeat period, seconds
# -user             db username
# -passwd           db password

BEGIN { use strict; use warnings; }
use DBI;
use Getopt::Long;
use File::Path;
$| = 1; # set autoflush

my $g_work_dir = '';	# place pid and stop files here...
my $g_dbi = "Oracle";	# perl database interface
my $g_db = "devdb9";	# tnsname of Oracle db (tmdb)
my $g_once;             # 1 means will only run once
my $g_period = 600;     # repeat period of algorithm
my $g_user = '';        # db username
my $g_passwd = '';      # db password

# ###############################################################
# Main loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system( "touch $g_work_dir/stop" ); }
    my $now = time();

    eval
    {
	my $dbh = &connect_to_db();

	# Create new destinations for files not yet assigned.
	# Pick file/destination pairs where the file's dataset
	# matches a stream subscription, the destination isn't
	# yet entered into t_destinations nor is there a replica
	# already at that site (probably the data originator).
	my $rows = $dbh->do(qq{
			insert into t_destinations (
			   select f.guid, s.destination, $now
			   from t_files_for_transfer f
			   inner join t_replica_metadata r
			     on r.guid = f.guid and r.attribute = 'POOL_dataset'
			   inner join t_subscriptions s
			     on s.stream = r.value
			   left join t_destinations d
			     on d.guid = f.guid and d.destination_node = s.destination
			   left join t_replica_state rs
			     on rs.guid = f.guid and rs.node = s.destination
			   where d.guid is null and rs.guid is null)});

	&log_entry("$rows new file destinations allocated") if $rows > 0;
    };
    &log_entry("database operation failed: $@") if $@;
    sleep ($g_period);
}


# ###############################################################
# Subroutines
# ###############################################################

sub connect_to_db
{
    my $dbh = DBI->connect( "DBI:$g_dbi:$g_db", $g_user, $g_passwd,
			    {RaiseError => 1, AutoCommit => 1})
	or die "Couldn't connect to database $g_db @_";
    return $dbh;
}

sub log_entry
{
    my $entry = shift;
    my $time = time();
    my $localtime = localtime($time);
    print "$localtime [$$] $entry\n";
}

sub parse_command_line
{
    GetOptions ('w=s' => \$new_work_dir,
		'dbi=s' => \$g_dbi,
		'db=s' => \$g_db,
		"once" => \$g_once,
		'period=i' => \$g_period,
		'user=s' => \$g_user,
		'passwd=s' => \$g_passwd);
	
    my $entry = '';
    $g_work_dir = $g_work_dir.$new_work_dir;
    $entry .= "work dir is $g_work_dir, ";
    if (-e "$g_work_dir/pid") {
	log_entry( "Removing old pid file");
	unlink("$g_work_dir/pid");
    } 
    if (-e "$g_work_dir/stop") {
	log_entry( "Removing old stop file" );
	unlink ("$g_work_dir/stop");
    }
    $g_db = "devdb9" if !$g_db;
    $entry .= "database is $g_db, ";
    $entry .= "only running once, " if $g_once;
    $entry .= "with period $g_period, " if $g_period;
    die "Extra options: @ARGV\n" if @ARGV;
    log_entry( $entry );
}
