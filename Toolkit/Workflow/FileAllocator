#!/usr/bin/perl
#
# Allocation Agent
#
# $Date: 2004/07/29 09:39:48 $
# $Id: Allocator.pl,v 1.35 2004/07/29 09:39:48 barrass Exp $
#
# This agent handles the allocation of files to destinations. It allocates files
# to destinations based on replica metadata and destination subscription
# information, all which is stored in the TMDB.
#
# First it determines a list of guids that it hasn't yet dealt with (they have
# allocated = 1). It queries the metadata (dataset, owner) for each
# guid, then determines which destinations have subscribed to files characterised
# by that metadata. It makes a guid:destination mapping for each destination in
# the t_destinations table.
#
# The agent determines which node(s) in the network represent the first hop
# toward each subscribing destination. It then makes an advertisement for those
# first-hop nodes in the t_file_state table.
#
# If the dataset, owner combination is not present in the subscriptions table
# the agent makes a blank entry, indicating that the combination is as yet
# unallocated.
#
# If no destinations are found, no allocation is made.
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# Command line options
# -no-updates		will run through the allocation algo but not make final changes in tmdb
# -w <workdir>		sets the workdir for the agent
# -db <tns name>	sets the Oracle db to talk to
# -u <pool cat uri>	sets the catalogue from which the agent takes info
# -once             only run once
# -period           repeat period, seconds

use DBI;
use Getopt::Long;
use File::Path;
$| = 1; # set autoflush

my $time;	# holds current time
my $g_no_updates;	# 1 means will not make final updates in tmdb
my $g_work_dir = '';	# place pid and stop files here...
my $g_db = "devdb9";	# tnsname of Oracle db (tmdb)
my $g_pool_uri = 'edgcatalog_http://rlscms.cern.ch:7777/cms/v2.2/edg-local-replica-catalog/services/edg-local-replica-catalog';
						# uri of pool catalogue to use
my $g_once;             # 1 means will only run once
my $g_period = 600;     # repeat period of algorithm
my $g_max_guids = 500;  # max new guids to return per cycle

# ###############################################################
# Main loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system( "touch $g_work_dir/stop" ); }
    my $loop_start = time();

    my %dataset_by_new_guid = &get_new_guid_list;
    my %source_node_by_guid = get_source_nodes( keys %dataset_by_new_guid );
    # Do error checks!
    my $guid = '';
    
    my %destinations_by_dataset = &get_current_subscriptions;
    # Do error check!
    
    foreach $guid ( keys %dataset_by_new_guid ) {
        
        if ( exists( $destinations_by_dataset{$dataset_by_new_guid{$guid}} ) ) {
            log_entry( "$guid will go toward $destinations_by_dataset{$dataset_by_new_guid{$guid}}" );
            
            @destinations = split( / /, $destinations_by_dataset{$dataset_by_new_guid{$guid}} );
            foreach $dest ( @destinations ) {
            
                my $gateway = lookup_route( $source_node_by_guid{$guid}, $dest );
                my $time = time();
                log_entry( "$guid source: $source_node_by_guid{$guid} dest: $dest via: $gateway" );
                my $advert = "insert into t_file_state "
                        ."values ('$guid','$gateway',1,'$source_node_by_guid{$guid}',$time)";
                push( @adverts, $advert );
            
            }
            
        } else {
            add_new_stream_to_subscriptions( $dataset_by_new_guid{$guid} );
        }
    }
    
    

    $time = time();
    sleep($g_period - $time + $loop_start);
}


# ###############################################################
# Subroutines
# ###############################################################

sub log_entry {
    my $entry = shift;
	my $time = time();
	my $localtime = localtime($time);
	print "$localtime [$$] $entry\n";
}

sub get_new_guid_list {
	my @row;
	my $count = 0;
	my $selection = "select t_files_for_transfer.guid,"
	       ."t_replica_metadata.value "
	       ."from t_files_for_transfer,"
	       ."t_replica_metadata "
	       ."where allocated = 1 "
	       ."and rownum < $g_max_guids "
	       ."and t_files_for_transfer.guid = t_replica_metadata.guid "
	       ."and key = 'POOL_dataset'";

    my %guid_list = ();

	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	'CMS_TRANSFERMGMT_WRITER', 
		      				 	'threeBagsFULL', 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();while (@row = $query->fetchrow_array) {	
	       $count++;
	       $row[1] =~ s/\s+//g;
	       $guid_list{$row[0]}  = $row[1];
        }
        log_entry(  "Found $count new GUIDs" );
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }
	
	return (%guid_list);
}

sub get_current_subscriptions {
	my @row;
	my $selection = "select * from t_subscriptions";

    my %destinations = ();

	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	'CMS_TRANSFERMGMT_WRITER', 
		      				 	'threeBagsFULL', 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();
        while (@row = $query->fetchrow_array) {	
	       $row[1] =~ s/\s+//g;
	       $destinations{$row[1]}  .= "$row[0] ";
        }
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }
    
    foreach $sub ( keys %destinations ) {
        log_entry( "$sub: $destinations{$sub}" );
    }
	
	return (%guid_list);
}

sub do_sql {
    my @sql = shift;
    
    eval {
        my $dbh = DBI->connect(    "DBI:Oracle:$g_db",
	   				    'CMS_TRANSFERMGMT',
		  			    'smallAND_round',
	   				    { RaiseError=>1, AutoCommit =>1 });
    
        foreach $sql ( @sql ) {
            $dbh->do($sql) if (!$g_no_updates);
        }

        $dbh->disconnect;    
    };
    
    if ( @_ ) {
        log_entry( "Database operation failed doing sql list... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }
}

sub add_new_stream_to_subscriptions {
    my $new_stream = shift;

    my $insert = "insert into t_subscriptions values ('','$new_stream')";

    my $dbh = DBI->connect(    "DBI:Oracle:$g_db",
					    'CMS_TRANSFERMGMT',
					    'smallAND_round',
					    { RaiseError=>1, AutoCommit =>1 });

    log_entry( "New stream for subscriptions- $new_stream" );
    $dbh->do($insert) if (!$g_no_updates);

    $dbh->disconnect;
}

sub get_source_nodes {
    my @guids = shift;
    my $selection = "select guid,source_node from t_files_for_transfer where ";
    foreach $guid (@guids) {
        $selection .= "guid = '$guid' or ";
    }
    substr( $selection, -4 ) = '';
    my %sources = ();


	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	'CMS_TRANSFERMGMT_WRITER', 
		      				 	'threeBagsFULL', 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();while (@row = $query->fetchrow_array) {	
	       $sources{$row[0]}  .= $row[1];
        }
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed getting source nodes for guids... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }    
    
    return( %sources );
    
}

sub lookup_route {
    my $source = shift;
    my $dest = shift;
    my $selection = "select gateway from t_routing where from_node = $source and to_node = $dest";

	eval {
        my $dbh = DBI->connect(	"DBI:Oracle:$g_db",
		    				 	'CMS_TRANSFERMGMT_WRITER', 
		      				 	'threeBagsFULL', 
		  	       			 	{ RaiseError=>1, AutoCommit =>1 });
		  				 	
        my $query = $dbh->prepare($selection);	
		
        $query->execute();while (@row = $query->fetchrow_array) {	
	       $gateway = $row[0];
        }
        $query->finish();
        
        $dbh->disconnect();
	};
	
	if (@_) {
        log_entry( "Database operation failed looking up route... @_" );
        if ($dbh)
        {
            $dbh->rollback;
            $dbh->disconnect;
        }
        return 1;
    }       
    
    return $gateway;
    
}



sub parse_command_line () {
	GetOptions(	'w=s' => \$new_work_dir,
				'db=s' => \$g_db,
				"no-updates" => \$g_no_updates,
				'u=s' => \$g_pool_uri,
				"once" => \$g_once,
				'period=i' => \$g_period
				);
	
	my $entry = '';
	
	$g_work_dir = $g_work_dir.$new_work_dir;
	$entry = $entry."work dir is $g_work_dir,";
	if (-e "$g_work_dir/pid") {
		log_entry( "Removing old pid file");
		unlink("$g_work_dir/pid");
	} 
	if (-e "$g_work_dir/stop") {
		log_entry( "Removing old stop file" );
		unlink ("$g_work_dir/stop");
	}
	if (!$g_db) {
		$g_db = "devdb9";
		
	}
	$entry = $entry."database is $g_db,";
	if ($g_pool_uri) {
		$entry = $entry."using POOL cat $g_pool_uri, ";
	}	
	if ($g_no_updates) {
		$entry = $entry."not making final updates, ";
	}	
	if ($g_once) {
		$entry = $entry."only running once, ";
	}
    if ($g_period) {
		$entry = $entry."with period $g_period, ";
	}	
	
	$time = time();
	
	print "Unprocessed by Getopt::Long\n" if $ARGV[0];
	foreach (@ARGV) {
	  print "$_\n";
	}
	
	log_entry( $entry );
}

# JUNK FROM HERE DOWN










sub get_all_agent_names_of_type {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		TYPE => 'T1',
		@_
	);
	my $selection = "select agent_label from agentstate where agent_type = '$args{TYPE}'";
	my @list;
	
	my $return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'CMS_TRANSFERMGMT_WRITER', 
						 	'threeBagsFULL', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$statusquery = $dbh->prepare($selection);
	$statusquery->execute;
	while (@row = $statusquery->fetchrow_array) {
	    $row[0] =~ s/ //g;
	    push(@list,@row[0]);
	}
	$statusquery->finish();
	
	$return = $dbh->disconnect();
	
	return @list;
}



sub get_available_agents_of_type {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		TYPE => 'T1',
		@_
	);
	my $time = time();
	my $last_time = $time - 900;
	my $t1;
	my $return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'CMS_TRANSFERMGMT_WRITER', 
						 	'threeBagsFULL', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	my $selection = $selection = "select agent_label from agentstate where last_contact >= $last_time and agent_type = '$args{TYPE}'";
	my $statusquery = $dbh->prepare($selection);
	my $number = 0;
	my %available;

	$statusquery->execute;
	while (@row = $statusquery->fetchrow_array) {
	    $row[0] =~ s/ //g;
	    $available{$row[0]} = 1;
	$number++;
	}
	$statusquery->finish();
	$dbh->disconnect();
	
	my $log_entry = "$number available $args{TYPE} agents found: ";
	foreach (sort keys %available) { $log_entry .= "$_\t"; }
	
	log_entry( ENTRY => $log_entry );	
	return (\$number, \%available);
}





sub load_stream_config {
	my $stream;
	my $t1s;
	my %t1s_by_stream;
	my $entry;
	my $selection = "select * from cms_transfermgmt.subscriptions";
	my $dbh = DBI->connect(    "DBI:Oracle:$g_db",
                                                        'CMS_TRANSFERMGMT',
                                                        'smallAND_round',
                                                        { RaiseError=>1, AutoCommit =>1 });

        my $query = $dbh->prepare($selection);
        my %guid_list;
        $query->execute();
        while (@row = $query->fetchrow_array) {
	    $row[0] =~ s/ //g;
	    $row[1] =~ s/ //g; 
	    $t1s_by_stream{$row[1]} .= "$row[0]:";
        }
	
	chop(%t1s_by_stream);
	foreach $key (keys %t1s_by_stream) {
	    $entry .= "$key $t1s_by_stream{$key}, ";
	}
	log_entry( ENTRY => "$entry" );
	
	return %t1s_by_stream;
}

sub load_t1_eb_associations {
	my %t1s_by_eb;
	my %eb_by_t1;
	my @all_t1s;
	my @all_ebs;
	
	open (IN, "<eb_config.txt");
	while (<IN>) {
	    chop;
	    $t1s_by_eb = {};
	    my ($eb,$t1s) = split(/\//);
	    $t1s_by_eb{$eb} = $t1s;
	    foreach my $t1 (split/:/,$t1s) {
	    	$eb_by_t1{$t1} = $eb;
	    }
	}
	return (\%t1s_by_eb, \%eb_by_t1);
}


