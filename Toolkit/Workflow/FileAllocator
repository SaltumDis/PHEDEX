#!/usr/bin/perl
#
# Allocation Agent
#
# $Date: 2004/09/15 21:17:22 $
# $Id: Allocator.pl,v 1.64 2004/09/15 21:17:22 lat Exp $
#
# This agent allocates files to destinations based on subscriptions.
# It compares file replica metadata and destination subscriptons with
# current set of destinations assigned for files, and automatically
# creates new assignments when necessary.  All the information is
# stored in the TMDB.
#
# The whole operation is done in a single SQL statement that compares
# files and subscriptons with existing destination assignments and
# replicas.  If there is a data subscription but no existing replica
# (for the site originating the data) nor a destination assignmenet,
# a new assignment is created.  Note that file routing is handled
# elsewhere, so we don't care if or how the file can make it to the
# requested destination.
#
# Please provide a working directory name on the command line, it is
# used to store the pid file during running and is where the agent
# will look for the stop flag file "stop"; existence of the file will
# automatically stop the agent.
#
# Command line options
# -w <workdir>		sets the workdir for the agent
# -db <tns name>	sets the Oracle db to talk to
# -once             only run once
# -period           repeat period, seconds
# -user             db username
# -passwd           db password

BEGIN { use strict; use warnings; }
use DBI;
use Getopt::Long;
use File::Path;
$| = 1; # set autoflush

my $g_work_dir = '';	# place pid and stop files here...
my $g_dbi = "Oracle";	# perl database interface
my $g_db = "devdb9";	# tnsname of Oracle db (tmdb)
my $g_once;             # 1 means will only run once
my $g_period = 600;     # repeat period of algorithm
my $g_user = '';        # db username
my $g_passwd = '';      # db password

# ###############################################################
# Main loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system( "touch $g_work_dir/stop" ); }
    my $now = time();

    eval
    {
	my $dbh = &connect_to_db();

	# Create new destinations for files not yet assigned.
	# Pick file/destination pairs where the file's dataset
	# matches a stream subscription, the destination isn't
	# yet entered into t_destinations nor is there a replica
	# already at that site (probably the data originator).
	my $rows = $dbh->do(qq{
			insert into t_destinations (
			   select f.guid, s.destination, $now
			   from t_files_for_transfer f
			   inner join t_replica_metadata r
			     on r.guid = f.guid and r.attribute = 'POOL_dataset'
			   inner join t_subscriptions s
			     on s.stream = r.value
			   left join t_destinations d
			     on d.guid = f.guid and d.destination_node = s.destination
			   left join t_replica_state rs
			     on rs.guid = f.guid and rs.node = s.destination
			   where d.guid is null and rs.guid is null)});

	&log_entry("$rows new file destinations allocated") if $rows > 0;
    };
    &log_entry("database operation failed: $@") if $@;
    sleep ($g_period);
}


# ###############################################################
# Subroutines
# ###############################################################

sub connect_to_db
{
    my $dbh = DBI->connect( "DBI:$g_dbi:$g_db", $g_user, $g_passwd,
			    {RaiseError => 1, AutoCommit => 1})
	or die "Couldn't connect to database $g_db @_";
    return $dbh;
}

sub log_entry
{
    my $entry = shift;
    my $time = time();
    my $localtime = localtime($time);
    print "$localtime [$$] $entry\n";
}

sub parse_command_line
{
    GetOptions ('w=s' => \$new_work_dir,
		'dbi=s' => \$g_dbi,
		'db=s' => \$g_db,
		"once" => \$g_once,
		'period=i' => \$g_period,
		'user=s' => \$g_user,
		'passwd=s' => \$g_passwd);
	
    my $entry = '';
    $g_work_dir = $g_work_dir.$new_work_dir;
    $entry .= "work dir is $g_work_dir, ";
    if (-e "$g_work_dir/pid") {
	log_entry( "Removing old pid file");
	unlink("$g_work_dir/pid");
    } 
    if (-e "$g_work_dir/stop") {
	log_entry( "Removing old stop file" );
	unlink ("$g_work_dir/stop");
    }
    $g_db = "devdb9" if !$g_db;
    $entry .= "database is $g_db, ";
    $entry .= "only running once, " if $g_once;
    $entry .= "with period $g_period, " if $g_period;
    die "Extra options: @ARGV\n" if @ARGV;
    log_entry( $entry );
}
