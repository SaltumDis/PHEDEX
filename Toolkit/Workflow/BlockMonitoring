#! /usr/bin/env perl

#-----------------------------------------------------------------------------------------------
# agent name: global monitoring agent
# purpose: monitor replication status of blocks and update t_block_replica accordingly
#-----------------------------------------------------------------------------------------------

BEGIN
{
  use warnings; use strict; use Getopt::Long;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


#---------------------------------------------
#     Argument parsing
#---------------------------------------------

my %args = (DBITYPE => 'Oracle',
	    WAITTIME => 60);

&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "db=s"		=> \$args{DBNAME},
	     "dbitype=s"	=> \$args{DBITYPE},
	     "dbuser=s"		=> \$args{DBUSER},
	     "dbpass=s"		=> \$args{DBPASS},
	     "dbitype=s"        => \$args{DBITYPE},
	     "wait=f"		=> \$args{WAITTIME},
	     "node=s"           => \$args{MYNODE});


if (!$args{DBNAME} || !$args{DBUSER}
    || !$args{DBPASS} || !$args{DROPDIR})
{
    print STDERR "usage: $me -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
                 "       -state IN-DROP-BOX [-wait SECONDS]\n";
    exit 1;
}


my $agent = new BlockMonitor (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{QUIT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{TERM} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package BlockMonitor; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;
use UtilsTR;
use DBI;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBITYPE => undef,		# Database driver binding
		  MYNODE => undef,              # my TMDB nodename
    		  DBNAME => undef,		# Database name
	  	  DBUSER => undef,		# Database user name
	  	  DBPASS => undef,		# Database user password
	  	  AGENTID => "BlockMonitor");   # Identity for activity logs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# main routine 
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my @collectionsFinished = ();

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Update statistics in t_block_replica.
	# Get blockname, nodename, amount of files and total size.
        my $now = &mytimeofday ();
        my $qreplicas = &dbexec($dbh, qq{
	    select
    	    	f.inblock,
    	    	rs.node,
    	    	count (rs.guid),
    	    	sum (f.filesize)
    	    from t_replica_state rs
    	    left join t_file f on f.guid = rs.guid
    	    group by f.inblock, rs.node});

        while (my ($block, $node, $nfiles, $nbytes) = $qreplicas->fetchrow_array())
        {
	    # Check for an existing entry for current name and node,
	    # add new one if necessary.
	    my ($exists) = &dbexec($dbh, qq{
    	    	select count(name)
    	    	from t_block_replica
    	    	where name = :block
    	    	  and node = :node},
    	    	":block" => $block, ":node" => $node)
    	    	->fetchrow();
	    
	    # If entry doesn't exist yet in table, create a template entry.
	    &dbexec($dbh, qq{
    	    	 insert into t_block_replica
    	    	 (timestamp, name, node, files, bytes)
            	     values (:now, :block, :node, -1, -1)},
            	     ":now" => $now,
    	    	 ":block" => $block,
    	    	 ":node" => $node)
    	    if ! $exists;
	    
	    # Now update table values.
	    &dbexec($dbh, qq{
    	    	update t_block_replica
    	    	set timestamp = :now,
    	    	    files = :files,
    	    	    bytes = :bytes
    	    	where name = :block
    	    	  and node = :node},
    	    	":now" => $now,
    	    	":files" => $nfiles,
    	    	":bytes" => $nbytes,
    	    	":block" => $block,
    	    	":node" => $node);
        }

	$dbh->commit();
    };
    do { &alert ("database error: $@"); $dbh->rollback if $dbh } if $@;

    # Disconnect from the database.
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap.
    $self->nap ($self->{WAITTIME});
}
