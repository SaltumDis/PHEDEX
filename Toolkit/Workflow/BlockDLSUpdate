#! /usr/bin/env perl

##H Trigger DLS update once blocks were completely transferred.
##H
##H The BlockMonitor agent periodically updates the transfer progress
##H of various blocks.  Once a block has been transferred completely,
##H this agent triggers an update of the DLS.
##H
##H Usage:
##H   BlockDLSUpdate -state DIRECTORY -node NAME -db FILE[:SECTION]
##H                  -next DIRECTORY -se NAME [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -se        name of the storage element
##H -log       where to redirect logging information
##H

BEGIN {
  use warnings; use strict; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
	     "log=s"       => \$args{LOGFILE},
	     "se=s"        => \$args{SE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE}
    || !$args{DBCONFIG} || !$args{SE})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockDLSUpdate (%args))->process();

################################################
package BlockDLSUpdate; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  MYNODE => undef,		# My TMDB node name
		  WAITTIME => 600,		# Agent activity cycle
		  SE => undef,			# Storage element name
		  LAST_UPDATE => {});		# Cache of recent updates

    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Pick up ready blocks from database and inform downstream agents.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	# Purge recent update memory
	my $old = &mytimeofday() - 86400;
	delete $$self{LAST_UPDATE}{$_}
	    for grep($$self{LAST_UPDATE}{$_} < $old,
		     keys %{$$self{LAST_UPDATE}});

	# Connect to database
	$dbh = &connectToDatabase ($self);

	# Get order list of blocks we have.  This is always everything,
	# we keep no record of what has already been notified.  The
	# downstream users of this information must handle duplicates.
        my $completed = &dbexec ($dbh, qq{
	    select dbs.name dbs_name,
	           dbs.dls dls_name,
		   b.name block_name
	    from t_dps_block_replica br
	      join t_dps_block b on b.id = br.block
	      join t_dps_dataset ds on ds.id = b.dataset
	      join t_dps_dbs dbs on dbs.id = ds.dbs
	    where br.node = :node
  	      and b.is_open = 'n'
	      and br.dest_files = b.files
	      and br.node_files = b.files},
	    ":node" => $$self{ID_MYNODE})
	    ->fetchall_arrayref({});

	foreach my $block (@$completed)
        {
	    # If we've updated recently, pass this now
	    my $cachekey = "$$block{DBS_NAME} $$block{BLOCK_NAME}";
	    next if $$self{LAST_UPDATE}{$cachekey};
	    $$self{LAST_UPDATE}{$cachekey} = &mytimeofday();

	    # If this DBS has no associated DLS, ignore
	    next if ! $$block{DLS_NAME};

	    # Decompose DLS contact into arguments accepted by dls-add
	    my ($dlstype, $contact) = ($$block{DLS_NAME} =~ m|^([a-z]+)://(.*)|);
	    do { &alert ("dls contact $$block{DLS_NAME} not understood"); next }
	        if (! $dlstype || ($dlstype ne 'lfc' && $dlstype ne 'mysql'));

	    # Now register into DLS.  If the command fails, alert but keep going.
	    # We'll try to register the block in 24 hours anyway.
	    my @cmd = ("dls-add", "-i", ($dlstype eq 'lfc' ? "DLS_TYPE_LFC" : "DLS_TYPE_MYSQL"),
		       "-e", $contact, $$block{BLOCK_NAME}, $$self{SE});

	    my $rc = &runcmd (@cmd);
	    &alert ("failed to register block, exit code @{[&runerror($rc)]} from @cmd")
		if $rc;
        }
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}
