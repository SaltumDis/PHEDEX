#! /usr/bin/env perl

##H Trigger DLS update once blocks were completely transferred.
##H
##H The BlockMonitor agent periodically updates the transfer progress
##H of various blocks.  Once a block has been transferred completely,
##H this agent triggers an update of the DLS.
##H
##H Usage:
##H   BlockDLSUpdate -state DIRECTORY -db FILE[:SECTION]
##H
##H -state     agent state directory
##H -db        database connection configuration parameter file
##H -log       where to redirect logging information

BEGIN {
  use warnings; use strict; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
#use PHEDEX::Core::Help;
use PHEDEX::BlockConsistency::Core;

&GetOptions ("state=s"     => \$args{DROPDIR},
             "db=s"        => \$args{DBCONFIG},
	     "log=s"       => \$args{LOGFILE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockDLSUpdate (%args))->process();

################################################
package BlockDLSUpdate; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;
use UtilsJobManager;
#If you want to be brave, replace 'useUtils*' above with these :-)
#use PHEDEX::Core::Command;
#use PHEDEX::Core::Logging;
#use PHEDEX::Core::Timing;
#use PHEDEX::Core::DB;
#use PHEDEX::Core::JobManager;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  WAITTIME => 3600,		# Agent activity cycle
		  NODES => [ '%' ],		# Nodes this agent runs for
		  LAST_UPDATE => {});		# Cache of recent updates

    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Pick up ready blocks from database and inform downstream agents.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh;
    eval
    {
	# Purge recent update memory
	my $old = &mytimeofday() - 86400;
	delete $$self{LAST_UPDATE}{$_}
	    for grep($$self{LAST_UPDATE}{$_} < $old,
		     keys %{$$self{LAST_UPDATE}});
	
	# Connect to database
	my @nodes = ();
	$$self{NODES} = [ '%' ];
	($dbh, @nodes) = &expandNodesAndConnect ($self);
	my ($my_nodes, %my_args) = &myNodeFilter ($self, "br.node");

	# Get order list of blocks we have.  This is always everything,
	# we keep no record of what has already been notified.  The
	# downstream users of this information must handle duplicates.
        my $completed = &dbexec ($dbh, qq{
	    select dbs.name dbs_name,
	           dbs.dls dls_name,
	           b.name block_name,
	           b.id block_id,
	           n.name node_name,
		   n.se_name se_name,
	           'dls-add' command
	    from t_dps_block_replica br
	      join t_dps_block b on b.id = br.block
	      join t_dps_dataset ds on ds.id = b.dataset
	      join t_dps_dbs dbs on dbs.id = ds.dbs
	      join t_adm_node n on n.id = br.node
	    where $my_nodes
  	      and b.is_open = 'n'
	      and br.dest_files = b.files
	      and br.node_files = b.files
	      and dbs.dls is not null
	      and n.se_name is not null},
	    %my_args)
	    ->fetchall_arrayref({});


        my $deleted = &dbexec ($dbh, qq{
	    select dbs.name dbs_name,
	           dbs.dls dls_name,
	           b.name block_name,
	           b.id block_id,
	           n.name node_name,
		   n.se_name se_name,
	           'dls-delete' command
	    from t_dps_block_delete bd
	      join t_dps_block b on b.id = bd.block
              join t_dps_block_replica br on br.block = b.id
	      join t_dps_dataset ds on ds.id = b.dataset
	      join t_dps_dbs dbs on dbs.id = ds.dbs
	      join t_adm_node n on n.id = bd.node
	    where $my_nodes
  	      and b.is_open = 'n'
	      and bd.time_complete is not null
	      and dbs.dls is not null
	      and n.se_name is not null},
	    %my_args)
	    ->fetchall_arrayref({});

        # Get the ID for DBS test-requests from the t_dvs_test table.
	my $test = PHEDEX::BlockConsistency::SQL::get_TDVS_Tests($self,'dbs')->{ID};

	foreach my $block (@$completed, @$deleted)
        {
	    # If we've updated recently, pass this now.
	    my $cachekey = "$$block{DBS_NAME} $$block{BLOCK_NAME} $$block{NODE_NAME}";
	    next if $$self{LAST_UPDATE}{$cachekey};
	    $$self{LAST_UPDATE}{$cachekey} = &mytimeofday();

	    # Queue the block for consistency-checking. Ignore return values
            if ( $block->{COMMAND} eq 'dls-add' )
            {
              PHEDEX::BlockConsistency::Core::InjectTest
			( $dbh,
			  block       => $block->{BLOCK_NAME},
			  test        => $test,
			  node        => $block->{NODE_NAME},
			  n_files     => 0,
			  time_expire => 10 * 86400,
			  priority    => 1,
			  use_srm     => 0,
			);
            }

	    # Decompose DLS contact into arguments accepted by DLS API.
	    my ($dlstype, $sep, $contact) = ($$block{DLS_NAME} =~ m|^([a-z]+)(://)?(.*)|);

	    my $dls_iface;
	    if ($dlstype eq 'lfc') { $dls_iface = 'DLS_TYPE_LFC'; }
	    elsif ($dlstype eq 'mysql') { $dls_iface = 'DLS_TYPE_MYSQL'; }
	    elsif ($dlstype eq 'dbs') { 
		$dls_iface = 'DLS_TYPE_DBS';
		$contact = $$block{DBS_NAME} unless $contact;
	    } else {
		&alert ("dls contact $$block{DLS_NAME} not understood");
		next;
	    }

	    # Now modify DLS.  If the command fails, alert but
	    # keep going.  We'll try again in 24 hours anyway.
	    my $log = "$$self{DROPDIR}/@{[time()]}.$$block{SE_NAME}.$$block{BLOCK_ID}.log";
	    my @cmd = ("$$block{COMMAND}", "-i", $dls_iface,
		       "-e", $contact, $$block{BLOCK_NAME}, $$block{SE_NAME});
	    
	    $self->addJob(sub { $self->registered ($block, @_) },
		          { TIMEOUT => 30, LOGFILE => $log },
		          @cmd);
        }
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh, 1);

    # Wait for all jobs to finish
    while (@{$$self{JOBS}})
    {
        $self->pumpJobs();
        select (undef, undef, undef, 0.1);
    }

    # Have a little nap
    $self->nap ($$self{WAITTIME});
}

# Handle finished jobs.
sub registered
{
    my ($self, $block, $job) = @_;
    if ($$job{STATUS})
    {
	&warn("failed to $$block{COMMAND} block $$block{BLOCK_NAME} for"
	      . " $$block{NODE_NAME}, log in $$job{LOGFILE}");
    }
    else
    {
	&logmsg("Successfully issued $$block{COMMAND}"
		. " on block $$block{BLOCK_NAME} for $$block{NODE_NAME}");
	unlink ($$job{LOGFILE});
    }
}

1;
