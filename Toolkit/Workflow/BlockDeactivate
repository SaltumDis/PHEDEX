#! /usr/bin/env perl

##H Deactivate blocks when file-level information is not needed.
##H
##H Files belong to blocks; when the file replicas are no longer needed
##H they are collapsed to block replicas, which remember entire sets of
##H files.  This agent monitors completeness of blocks and triggers
##H removal of the file-level information in TMDB.
##H
##H Usage:
##H   BlockDeactivate
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-wait SECS]
##H      [-holdoff SECS]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans
##H -holdoff   time lag before deactivation (default: 86400 = day)

BEGIN {
  use warnings; use strict;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
use UtilsHelp;
use Getopt::Long;
my %args = (WAITTIME => 60);
&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "node=s"           => \$args{MYNODE},
	     "db=s"		=> \$args{DBCONFIG},
	     "wait=f"		=> \$args{WAITTIME},
	     "help|h"		=> sub { &usage() },
	     "holdoff=f"        => \$args{HOLDOFF});

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

my $agent = new BlockActivate (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{QUIT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{TERM} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package BlockActivate; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;
use DBI;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
	  	  AGENTID => "BlockActivate",   # Identity for activity logs
		  HOLDOFF => 86400);            # hold-off time for pruning (24h default)

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}


# Pick up work from the database and start site specific scripts if necessary
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my @collectionsFinished = ();

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# check if a group was transfered completely to all destinations and return group
	@collectionsFinished = $self->getGroupstoDelete($dbh); # got group to remove
	if (scalar(@collectionsFinished) != 0) {

	    
	    # let's get rid of that stuff block by block !!
	    foreach my $collection (@collectionsFinished) {
		$self->removeInTMDB($dbh, $collection);
	    }
	}
	
	# final commit
	$dbh->commit();
    };
    do { &alert ("database error: $@"); $dbh->rollback if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap
    $self->nap ($self->{WAITTIME});
}


sub getGroupstoDelete {
    my ($self, $dbh) = @_;
    my @packet = ();

    my $now = time();
# let's get all dataset-owner pairs, which got completely transfered
    my $h_packet = &dbexec ($dbh, qq{
	select tb.dataset, tb.owner
        from t_block tb, t_block_replica tbr left join on tb.name=tbr.name
        group by tb.dataset,tb.owner
	having sum(tb.files)=sum(tbr.files) and max(tbr.timestamp)<(:now-:holdoff)},
        ":now"=>$now, ":holdoff"=>$self->{HOLDOFF});

 
    while (my ($owner, $dataset) = $h_packet->fetchrow_array){
	push (@packet, "$dataset:$owner");
    }
# return those dataset owner pairs
    return @packet;
}


sub removeInTMDB {
    my ($self, $dbh, $collection) = @_;
    my ($dataset, $owner) = split(':',$collection);

# we need the guids for the files belonging to the selected dataset-owner pairs
    my @guids = &getGUIDs($dbh, $dataset, $owner);
    
     foreach my $guid (@guids) {
# let's remove all t_transfer and t_replica info for the chosen guids
	&dbexec ($dbh, qq{
		delete from t_transfer_state where
	        guid = :guid},
	        ":guid"=>$guid);
	    
	&dbexec ($dbh, qq{
		delete from t_replica_state where
	        guid = :guid},
	        ":guid"=>$guid);
	$dbh->commit();
    }
	
}

sub getGUIDs {
    my ($dbh, $dataset, $owner) = @_;
    my @guids = ();

    # fetch GUIDs from TMDB for given dataset and owner
    my $guids_h = &dbexec ($dbh, qq{
	select f.guid from t_dsb_fileid f, t_dsb_dataset d
	where  d.dataset=:dataset and d.owner=:owner and d.id=f.id},
	":dataset"=>$dataset, ":owner"=>$owner);
    
    while (my ($guid) = $guids_h->fetchrow() ) {
	push (@guids, $guid);
    }
    return @guids;
}
