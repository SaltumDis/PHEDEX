#! /usr/bin/env perl

#-----------------------------------------------------------------------------------------------
# agent name: site monitoring agent
# purpose: monitor completeness of dataset/owner collections and trigger site specific scripts
#-----------------------------------------------------------------------------------------------

BEGIN
{
  use warnings; use strict; use Getopt::Long;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


#---------------------------------------------
#     Argument parsing
#---------------------------------------------

my %args = (DBITYPE => 'Oracle',
	    WAITTIME => 60);

&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "node=s"		=> \$args{MYNODE},
	     "db=s"		=> \$args{DBNAME},
	     "dbitype=s"	=> \$args{DBITYPE},
	     "dbuser=s"		=> \$args{DBUSER},
	     "dbpass=s"		=> \$args{DBPASS},
	     "dbitype=s"        => \$args{DBITYPE},
	     "wait=f"		=> \$args{WAITTIME},

	     "sitescript=s"	=> \$args{SITESCRIPT});

if ($args{HELPME} || !$args{DBNAME} || !$args{DBUSER}
    || !$args{DBPASS} || !$args{MYNODE} || !$args{DROPDIR}
    || !$args{SITESCRIPT})
{
    print STDERR "usage: $me -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
                 "       -state IN-DROP-BOX -node NODE-NAME -sitescript SCRIPT\n",
                 "       [-wait SECONDS]\n";
    exit 1;
}


my $agent = new NotificationAgent (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{QUIT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{TERM} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package NotificationAgent; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;
use UtilsTR;
use DBI;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBITYPE => undef,		# Database driver binding
    		  DBNAME => undef,		# Database name
	  	  DBUSER => undef,		# Database user name
	  	  DBPASS => undef,		# Database user password
	  	  MYNODE => undef,		# My TMDB node name
	  	  AGENTID => "Notification",    # Identity for activity logs
		  SITESCRIPT => undef);	        # site specific actions after groups got transfered

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}


sub completeBlocks
{
    my ($self, $dbh) = @_;
    my $result = {};

    # Get all dataset-owner pairs, which were completely
    # transfered and not yet handled
    my $complete = &dbexec ($dbh, qq{
	select b.dataset, b.owner, b.files
	from t_block_replica br
	left join t_block b
	  on b.name = br.name
	where br.node = :node
	  and br.files = b.files
	  and br.timestamp < :now - 300},
	":node" => $self->{MYNODE},
	":now" => &mytimeofday());
 
    while (my ($dataset, $owner, $files) = $complete->fetchrow_array())
    {
	$result->{$dataset}{$owner} = {
	    DATASET => $dataset,
	    OWNER => $owner,
	    FILES => $files
	};
    }
    
    return $result;
}

# Pick up work from the database and start site specific scripts if necessary
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my $completed = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# get the owners for each dataset of all transfered collections
        # (info needed for publishing or maybe other reasons)
	$completed = $self->completeBlocks ($dbh);
    };
    do { &alert ("database error: $@"); $dbh->rollback() if $dbh } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Call external script to do publishing and site specific work (etc.)
    foreach my $dataset (sort keys %$completed)
    {
	foreach my $owner (sort keys %{$completed->{$dataset}})
	{
	    my @other = grep ($_ ne $owner, keys %{$completed->{$dataset}});
	    my $ret = &runcmd (@{$self->{SITESCRIPT}}, $dataset, $owner,
			       $completed->{$dataset}{$owner}{FILES},
			       @other);

	    &alert ("failed to notify site for $owner/$dataset: @{[&runnerror ($ret)]}")
		if $ret;
	}
    }
    
    # Have a little nap
    $self->nap ($self->{WAITTIME});
}


