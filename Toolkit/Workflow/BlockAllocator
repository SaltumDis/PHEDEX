#!/usr/bin/env perl

##H Allocate blocks to destinations based on subscriptions.
##H
##H Compare file blocks to subscription destinations and currently
##H existing block replicas, and automatically create new assignments
##H where necessary.
##H
##H Usage:
##H   BlockAllocator -state DIRECTORY -node NAME -db FILE[:SECTION]
##H                  [-once] [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -once      run the alogrithm once, then quit -- don't go into daemon mode
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
             "once"        => \$args{ONCE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockAllocator (%args))->process();

######################################################################
# Routines for this agent.
package BlockAllocator; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node
		  ONCE => 0,			# Quit after one run
		  WAITTIME => 300);		# Agent cycle time
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Do some work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self);
	my ($stmt, $nrows);

	# Remove all block subscriptions for a site, for which we have
        # dataset subscriptions containing those blocks already.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    delete from t_dps_subscription s where (s.block, s.destination) in
		(select b.id, s.destination from t_dps_subscription s
		 left join t_dps_block b on s.dataset=b.dataset
		 where s.DATASET is not null)} );
        &logmsg ("$nrows block subscriptions removed: ".
		 "superceded by dataset subscriptions")
	    if $nrows > 0;

	# Delete all subscriptions for which a move exists where the
	# subscription indicates a willingness to participate in the
	# move.  This is indicated by the "time_clear" field having a
	# value of -1
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    delete from t_dps_subscription s
	    where exists (select 1 from t_dps_subscription s2
                            join t_dps_block b on (b.id = s2.block or b.dataset = s2.dataset)
	    		  where (s2.dataset = b.dataset or s2.block = b.id)
                            and s.time_clear = -1
                            and s2.time_create >= s.time_create
                            and s2.destination != s.destination
			    and s2.is_move = 'y')});
        &logmsg ("$nrows subscriptions deleted: superceded by a move")
	    if $nrows > 0;

	# Remove block destinations we no longer have subscribed.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    delete from t_dps_block_dest bd where not exists
	      (select 1 from t_dps_subscription s
	       where s.destination = bd.destination
	         and (s.dataset = bd.dataset or s.block = bd.block))});
	&logmsg ("$nrows block destinations withdrawn: no subscription")
	    if $nrows > 0;

	# Remaining block destinations are valid.  Mark done the
	# block destinations which are of closed blocks and have all files fully replicated.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update (select bd.state, bd.time_complete
	            from t_dps_block_dest bd
		      join t_dps_block b
		        on b.id = bd.block
		      join t_dps_block_replica br
		        on br.block = bd.block
			and br.node = bd.destination
		    where b.is_open = 'n'
		      and br.node_files = b.files
		      and br.dest_files = b.files
		      and bd.state != 3)
	    set state = 3, time_complete = :now},
	    ":now" => &mytimeofday());
        &logmsg ("$nrows block destinations completed")
	    if $nrows > 0;

	# Reactivate subscriptions for datasets, blocks which are no
	# longer complete (deleted data)
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update t_dps_subscription s set time_complete = null, time_done = null
	     where (s.time_complete is not null or s.time_done is not null)
               and exists (select 1 from t_dps_block_replica br
			     join t_dps_block b on b.id = br.block
                            where br.node = s.destination
			      and (b.id = s.block or b.dataset = s.dataset)
			      and br.node_files != b.files)
	    });
	&logmsg ("$nrows subscriptions marked unfinished")
	    if $nrows > 0;

	# Reactivate block destinations which do not have all files
	# replicated (deleted data)
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update (select bd.state, bd.time_complete
	            from t_dps_block_dest bd
		      join t_dps_block b
		        on b.id = bd.block
		      join t_dps_block_replica br
		        on br.block = bd.block
			and br.node = bd.destination
		    where br.node_files != b.files
		      and br.dest_files != b.files
		      and bd.state = 3
		    )
		set state = 0, time_complete = NULL});
        &logmsg ("$nrows block destinations reactivated")
	    if $nrows > 0;

	# Update priority and suspended status on existing requests.
	&dbexec ($dbh, qq{
	    update t_dps_block_dest bd
	    set (priority, time_suspend_until)
	      = (select s.priority, s.time_suspend_until
		 from t_dps_subscription s
		 where (s.dataset = bd.dataset or s.block = bd.block)
		   and s.destination = bd.destination
	   	   and s.time_complete is null)
	    where bd.state != 3});

	# Manage routing state changes for suspended blocks
	&dbexec ($dbh, qq{
	    update t_dps_block_dest set state = 2
	    where time_suspend_until > :now and state != 3},
	    ":now" => &mytimeofday());

	&dbexec ($dbh, qq{
	    update t_dps_block_dest set state = 0
	    where state = 2
	      and (time_suspend_until is null
      		   or time_suspend_until <= :now)},
	    ":now" => &mytimeofday());

	# Create new block destinations for subscribed datasets at nodes where
	# - the block destination doesn't exist yet
	# - the subscription is still open
        # - the block is not scheduled for deletion
	($stmt, $nrows) = &dbexec($dbh, qq{
	   insert into t_dps_block_dest
	   (block, dataset, destination, priority, state,
	    time_subscription, time_create, time_suspend_until)
	   (select b.id, b.dataset, s.destination, s.priority, 0,
	           s.time_create, :now, s.time_suspend_until
	    from t_dps_subscription s
	      join t_dps_block b
	        on (b.dataset = s.dataset or b.id = s.block)
	    where s.time_done is null
	      and not exists
	        (select 1 from t_dps_block_dest bd
	         where bd.block = b.id
		   and bd.destination = s.destination)
	      and not exists
	        (select 1 from t_dps_block_delete bd
		 where bd.block = b.id
		   and bd.node = s.destination
		   and bd.time_complete is null)
	    )},
	    ":now" => &mytimeofday());
	&logmsg ("$nrows new block destinations allocated")
	    if $nrows > 0;

        # Mark fully transferred subscriptions as complete.  We consider
	# a subscription completed if all the files currently available for
	# that subscription are at the node. Note that in the case of
	# open blocks and datasets time_complete will change as new
	# files are made available.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update t_dps_subscription s
	    set time_complete = :now
	    where time_complete is null
	    and ((exists
                  (select b.id from t_dps_block b
                   where b.id = s.block)
	         and not exists
                  (select 1 from t_dps_block_dest bd
                   where bd.destination = s.destination 
		   and bd.block = s.block and bd.state != 3))
	        or (exists
		  (select 1 from t_dps_dataset ds 
		   where ds.id = s.dataset and ds.is_open = 'n')
                  and not exists
                   (select 1 from t_dps_block_dest bd
                   where bd.destination = s.destination
		     and bd.dataset = s.dataset and bd.state != 3)))},
	    ":now" => &mytimeofday());
	&logmsg ("$nrows subscriptions marked completed")
	    if $nrows > 0;

	# Issue requests to remove non-destination block replicas left
	# after move subscriptions have been completed.  Since we only
	# act on completed subscription, the blocks are known to be
	# closed and the remover knows all the files in the block.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    insert into t_dps_block_delete
	    (block, dataset, node, time_request)
	    with
	      move_done as
	        (select b.id block, b.dataset, s.destination
		 from t_dps_subscription s
		   join t_dps_block b
		     on (b.dataset = s.dataset or b.id = s.block)
		 where s.time_complete is not null
		   and s.time_clear is null
	           and s.is_move = 'y'),
	      move_available as
	        (select br.block, md.dataset, br.node
		 from move_done md
		   join t_dps_block_replica br
		     on br.block = md.block)
	    select ma.block, ma.dataset, ma.node, :now
	    from move_available ma
	      left join move_done md
		on md.block = ma.block
		and md.destination = ma.node
	      left join t_dps_block_delete bd
	        on bd.block = ma.block
		and bd.node = ma.node
	    where md.block is null
	      and bd.block is null},
	    ":now" => &mytimeofday())
	&logmsg ("$nrows block replicas scheduled for deletion due to a move")
	    if $nrows > 0;

        # Mark move requests with removals completed as cleared.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update t_dps_subscription s
	    set time_clear = :now
	    where is_move = 'y'
	      and time_clear is null
	      and time_complete is not null
              and not exists
		(select 1 from t_dps_block_delete bd
		 where (bd.dataset = s.dataset or bd.block = s.block)
		   and bd.time_complete is null)},
	    ":now" => &mytimeofday());
	&logmsg ("$nrows move subscriptions marked cleared")
	    if $nrows > 0;

	# Mark fully completed subscriptions done.  If it's a move,
	# require all sources to have been removed.  The subscriptions
	# are cleaned up asynchronously outside this system, as other
	# parties are notified of completion of transfer requests.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	   update t_dps_subscription
	   set time_done = :now
	   where time_complete is not null
	     and time_done is null
             and (is_move != 'y' or time_clear is not null)},
           ":now" => &mytimeofday());
	&logmsg ("$nrows subscriptions marked done")
	    if $nrows > 0;

	# Remove block destinations for subscriptions we just closed.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    delete from t_dps_block_dest bd where exists
	      (select 1 from t_dps_subscription s
	       where s.destination = bd.destination
	         and (s.dataset = bd.dataset or s.block = bd.block)
	 	 and s.time_done is not null)});
	&logmsg ("$nrows block destinations withdrawn: subscription done")
	    if $nrows > 0;

    	$dbh->commit();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a nap.
    $self->doStop() if $$self{ONCE};
    $self->nap ($$self{WAITTIME});
}
