#!/usr/bin/env perl

##H Allocate blocks to destinations based on subscriptions.
##H
##H Compare file blocks to subscription destinations and currently
##H existing block replicas, and automatically create new assignments
##H where necessary.
##H
##H Usage:
##H   BlockAllocator
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-wait SECS] [-once]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans
##H -once      run the alogrithm once, then quit -- don't go into daemon mode

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
use UtilsHelp;
my %args = (WAITTIME => 600);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MYNODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-once')
    { shift (@ARGV); $args{ONCE} = 1; }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockAllocator (%args))->process();

######################################################################
# Routines for this agent.
package BlockAllocator; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node
		  ONCE => 0,			# Quit after one run
	  	  AGENTID => "BlockAllocator");	# Identity for activity logs
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Do some work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    # Always mark all files ready to go immediately.
    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";
        # FIXME: Pick up and process messages to me

	# Create new destinations for blocks not yet assigned.
	# Pick block/destination pairs where the block matches
	# a subscription and destination isn't yet entered.
	my ($stmt, $rows) = &dbexec($dbh, qq{
	   insert into t_block_destination
	   (timestamp, name, node, completed)
	   (select :now, b.name, s.destination, null
	    from t_block b
	    join t_subscription s
	      on s.owner = b.owner and s.dataset = b.dataset
	    left join t_block_destination bd
	      on bd.name = b.name and bd.node = s.destination
	    where bd.name is null)},
	    ":now" => &mytimeofday());

    	$dbh->commit();
	&logmsg ("$rows new block destinations allocated") if $rows > 0;
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a nap.
    $self->doStop() if $self->{ONCE};
    $self->nap ($self->{WAITTIME});
}
