#!/usr/bin/env perl

##H Allocate blocks to destinations based on subscriptions.
##H
##H Compare file blocks to subscription destinations and currently
##H existing block replicas, and automatically create new assignments
##H where necessary.
##H
##H Usage:
##H   BlockAllocator -state DIRECTORY -node NAME -db FILE[:SECTION]
##H                  [-once] [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -once      run the alogrithm once, then quit -- don't go into daemon mode
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
             "once"        => \$args{ONCE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockAllocator (%args))->process();

######################################################################
# Routines for this agent.
package BlockAllocator; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node
		  ONCE => 0,			# Quit after one run
		  WAITTIME => 300);		# Agent cycle time
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Do some work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self);
	my ($stmt, $nrows);

	# FIXME: When files are deleted for whatever reason, we need
	# to reactive subscriptions and block destinations.

	# Mark done all subscriptions for which a later move exists.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update t_dps_subscription s
	    set time_complete = :now, time_clear = :now, time_done = :now
	    where exists (select 1 from t_dps_subscription s2
	    		  where s2.dataset = s.dataset
			    and s2.time_create > s.time_create
		            and s2.is_move = 'y')},
	    ":now" => &mytimeofday());
        &logmsg ("$nrows subscriptions deactivated: superceded by a move")
	    if $nrows > 0;

	# Remove block destinations we no longer have subscribed.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    delete from t_dps_block_dest bd where not exists
	      (select 1 from t_dps_subscription s
	       where s.destination = bd.destination
	         and s.dataset = bd.dataset)});
	&logmsg ("$nrows block destinations withdrawn: no subscription")
	    if $nrows > 0;

	# Remove block destinations for which there is a more recent
	# move subscription.   All subscriptions older than the most
	# recent move are ignored, however the move may involve many
	# destinations if they all have the same time stamp.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    delete from t_dps_block_dest bd where exists
	      (select 1 from t_dps_subscription s
	       where s.dataset = bd.dataset
	         and s.time_create > bd.time_subscription
	         and s.is_move = 'y')});
	&logmsg ("$nrows block destinations removed: superceded by a move")
	    if $nrows > 0;

	# Remaining block destinations are valid.  Mark complete the
	# block destinations which have all files fully replicated.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update (select bd.state, bd.time_complete
	            from t_dps_block_dest bd
		      join t_dps_block b
		        on b.id = bd.block
		      join t_dps_block_replica br
		        on br.block = bd.block
			and br.node = bd.destination
		    where b.is_open = 'n'
		      and br.node_files = b.files
		      and br.dest_files = b.files
		      and bd.state != 3)
	    set state = 3, time_complete = :now},
	    ":now" => &mytimeofday());
        &logmsg ("$nrows block destinations completed")
	    if $nrows > 0;

	# Update priority and suspended status on existing requests.
	&dbexec ($dbh, qq{
	    update t_dps_block_dest bd
	    set (priority, time_suspend_until)
	      = (select s.priority, s.time_suspend_until
		 from t_dps_subscription s
		 where s.dataset = bd.dataset
		   and s.destination = bd.destination
	   	   and s.time_complete is null)
	    where bd.state != 3});

	# Manage routing state changes for suspended blocks
	&dbexec ($dbh, qq{
	    update t_dps_block_dest set state = 2
	    where time_suspend_until > :now and state != 3},
	    ":now" => &mytimeofday());

	&dbexec ($dbh, qq{
	    update t_dps_block_dest set state = 0
	    where state = 2
	      and (time_suspend_until is null
      		   or time_suspend_until <= :now)},
	    ":now" => &mytimeofday());

	# Create new block destinations for subscribed datasets where
	# the block destination doesn't exist yet and the subscription
	# is still open.
	($stmt, $nrows) = &dbexec($dbh, qq{
	   insert into t_dps_block_dest
	   (block, dataset, destination, priority, state,
	    time_subscription, time_create, time_suspend_until)
	   (select b.id, s.dataset, s.destination, s.priority, 0,
	           s.time_create, :now, s.time_suspend_until
	    from t_dps_subscription s
	      join t_dps_block b
	        on b.dataset = s.dataset
	    where s.time_complete is null
	      and not exists
	        (select 1 from t_dps_block_dest bd
	         where bd.block = b.id
		   and bd.destination = s.destination))},
	    ":now" => &mytimeofday());
	&logmsg ("$nrows new block destinations allocated")
	    if $nrows > 0;

        # Mark fully transferred subscriptions as complete.  We consider
	# a subscription completed if the dataset and all its blocks are
	# known to be closed and all destinations have been fulfilled.
	# We don't allow a subscription to be closed if no blocks have
	# yet been registered for the dataset.  (FIXME: timelimit?)
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update t_dps_subscription s
	    set time_complete = :now
	    where time_complete is null
	      and exists
                (select b.id from t_dps_block b
		 where b.dataset = s.dataset)
	      and not exists
		(select 1 from t_dps_block_dest bd
		 where bd.dataset = s.dataset and bd.state != 3)
	      and not exists
      		(select 1 from t_dps_dataset ds, t_dps_block b
	         where b.dataset = s.dataset and ds.id = s.dataset
	   	   and not (ds.is_open = 'n' and b.is_open = 'n'))},
	    ":now" => &mytimeofday());
	&logmsg ("$nrows subscriptions marked completed")
	    if $nrows > 0;

	# Issue requests to remove non-destination block replicas left
	# after move subscriptions have been completed.  Since we only
	# act on completed subscription, the blocks are known to be
	# closed and the remover knows all the files in the block.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    insert into t_dps_block_delete
	    (block, dataset, node, time_request)
	    with
	      move_done as
	        (select b.id block, b.dataset, s.destination
		 from t_dps_subscription s
		   join t_dps_block b
		     on b.dataset = s.dataset
		 where s.time_complete is not null
		   and s.time_clear is null
	           and s.is_move = 'y'),
	      move_available as
	        (select br.block, md.dataset, br.node
		 from move_done md
		   join t_dps_block_replica br
		     on br.block = md.block)
	    select ma.block, ma.dataset, ma.node, :now
	    from move_available ma
	      left join move_done md
		on md.block = ma.block
		and md.destination = ma.node
	      left join t_dps_block_delete bd
	        on bd.block = ma.block
		and bd.node = ma.node
	    where md.block is null
	      and bd.block is null},
	    ":now" => &mytimeofday())
	&logmsg ("$nrows block replicas scheduled for deletion due to a move")
	    if $nrows > 0;

        # Mark move requests with removals completed as cleared.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    update t_dps_subscription s
	    set time_clear = :now
	    where is_move = 'y'
	      and time_clear is null
	      and time_complete is not null
              and not exists (select 1 from t_dps_block_delete bd
			      where bd.dataset = s.dataset
			        and bd.time_complete is null)},
	    ":now" => &mytimeofday());
	&logmsg ("$nrows move subscriptions marked cleared")
	    if $nrows > 0;

	# Mark fully completed subscriptions done.  If it's a move,
	# require all sources to have been removed.  The subscriptions
	# are cleaned up asynchronously outside this system, as other
	# parties are notified of completion of transfer requests.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	   update t_dps_subscription
	   set time_done = :now
	   where time_complete is not null
	     and time_done is null
             and (is_move != 'y' or time_clear is not null)},
           ":now" => &mytimeofday());
	&logmsg ("$nrows subscriptions marked done")
	    if $nrows > 0;

	# Remove block destinations for subscriptions we just closed.
	($stmt, $nrows) = &dbexec ($dbh, qq{
	    delete from t_dps_block_dest bd where exists
	      (select 1 from t_dps_subscription s
	       where s.destination = bd.destination
	         and s.dataset = bd.dataset
	 	 and s.time_done is not null)});
	&logmsg ("$nrows block destinations withdrawn: subscription done")
	    if $nrows > 0;

    	$dbh->commit();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a nap.
    $self->doStop() if $$self{ONCE};
    $self->nap ($$self{WAITTIME});
}
