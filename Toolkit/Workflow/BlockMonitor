#! /usr/bin/env perl

##H Monitor block-level transfer completeness.
##H
##H Usage:
##H   BlockMonitor
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-wait SECS]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans

BEGIN {
  use warnings; use strict;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
use UtilsHelp;
use Getopt::Long;
my %args = (WAITTIME => 180);
&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "db=s"             => \$args{DBCONFIG},
	     "wait=f"		=> \$args{WAITTIME},
	     "node=s"           => \$args{MYNODE},
     	     "help|h"		=> sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}


my $agent = new BlockMonitor (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package BlockMonitor; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MYNODE => undef,              # my TMDB nodename
		  DBCONFIG => undef,		# Database configuration file
	  	  AGENTID => "BlockMonitor");   # Identity for activity logs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub limitCheck
{
    my ($reason, $b, $ref) = @_;
    $ref ||= $b;
    &alert ("$reason $b->{NAME} at $b->{NODE} destined $b->{DEST_FILES} files,"
	    . " more than expected ($ref->{FILES})")
	if $b->{DEST_FILES} > $ref->{FILES};
    &alert ("$reason $b->{NAME} at $b->{NODE} destined $b->{DEST_BYTES} bytes,"
	    . " more than expected ($ref->{BYTES})")
	if $b->{DEST_BYTES} > $ref->{BYTES};
    &alert ("$reason $b->{NAME} at $b->{NODE} has $b->{NODE_FILES} files,"
	    . " more than expected ($ref->{FILES})")
	if $b->{NODE_FILES} > $ref->{FILES};
    &alert ("$reason $b->{NAME} at $b->{NODE} has $b->{NODE_BYTES} bytes,"
	    . " more than expected ($ref->{BYTES})")
	if $b->{NODE_BYTES} > $ref->{BYTES};
    &alert ("$reason $b->{NAME} at $b->{XFER} transferring $b->{XFER_FILES} files,"
	    . " more than expected ($ref->{FILES})")
	if $b->{XFER_FILES} > $ref->{FILES};
    &alert ("$reason $b->{NAME} at $b->{XFER} transferring $b->{XFER_BYTES} bytes,"
	    . " more than expected ($ref->{BYTES})")
	if $b->{XFER_BYTES} > $ref->{BYTES};
}

# Update statistics.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Read existing block replica information.
        my $now = &mytimeofday ();
	my %replicas = ();
	my $qexisting = &dbexec ($dbh, qq{
	    select br.name, br.node, br.isactive,
		   b.files, b.bytes, b.isopen,
	           br.dest_files, br.dest_bytes,
		   br.node_files, br.node_bytes,
		   br.xfer_files, br.xfer_bytes
	    from t_block_replica br
	    join t_block b on b.name = br.name});
        while (my $row = $qexisting->fetchrow_arrayref())
	{
	    $replicas{$row->[0]}{$row->[1]} = {
		NAME => $row->[0], NODE => $row->[1], ISACTIVE => $row->[2],
		FILES => $row->[3], BYTES => $row->[4], ISOPEN => $row->[5],
		DEST_FILES => $row->[6], DEST_BYTES => $row->[7],
		NODE_FILES => $row->[8], NODE_BYTES => $row->[9],
		XFER_FILES => $row->[10], XFER_BYTES => $row->[11]
	    };
	    &limitCheck ("existing block replica", $replicas{$row->[0]}{$row->[1]});
	}

	# Get file counts in currently active blocks: those still destined
	# at nodes, those still at the nodes, and those still in transfer.
	# Note that replicas at intermediate nodes show up as partial block
	# replicas, so it's important that replicas at those nodes are
	# either not cleaned at all, or that the cleaners are aggressive.
	# We consider the blocks alive even if all replicas are complete
	# and there are no transfers, but there are pending destination
	# assignments -- that just means file routing hasn't started.
	#
	# This query is really expensive if the tables are large.  We do
	# not want to execute this frequently, which is why we deactivate
	# blocks as soon as we can -- that will keep the tables smaller.
	my %active = ();
        my $qactive = &dbexec($dbh, qq{
	    select
	        f.inblock, n.name,
		count (f.guid), sum (f.filesize),
		count (d.guid), sum (decode (d.guid,null,0,f.filesize)),
		count (rs.guid), sum (decode (rs.guid,null,0,f.filesize)),
		count (ts.guid), sum (decode (ts.guid,null,0,f.filesize))
	    from t_file f
	    cross join t_node n
	    left join t_destination d
	      on d.guid = f.guid and d.node = n.name
	    left join t_replica_state rs
	      on rs.guid = f.guid and rs.node = n.name
	    left join t_transfer_state ts
	      on ts.guid = f.guid and ts.to_node = n.name
	    group by f.inblock, n.name
	    having count (d.guid) != 0
		or count (rs.guid) != 0
		or count (ts.guid) != 0});
        while (my $row = $qactive->fetchrow_arrayref())
        {
	    $active{$row->[0]}{$row->[1]} = {
		NAME => $row->[0], NODE => $row->[1],
		FILES => $row->[2], BYTES => $row->[3],
		DEST_FILES => $row->[4], DEST_BYTES => $row->[5],
		NODE_FILES => $row->[6], NODE_BYTES => $row->[7],
		XFER_FILES => $row->[8], XFER_BYTES => $row->[9]
	    };
	    &limitCheck ("active block", $replicas{$row->[0]}{$row->[1]});
	}

	# Compare differences I: start from previous replicas.
	foreach my $i (values %replicas)
	{
	    foreach my $b (values %{$replicas{$i}})
	    {
		# Check consistency of inactive blocks before ignoring
		# them: they can't be open or have active replicas or
		# transfers.
		if (! $b->{ISACTIVE})
		{
		    &alert ("$b->{NAME} at $b->{NODE} inactive but open")
		        if ! $b->{ISOPEN};
		    &alert ("$b->{NAME} at $b->{NODE} inactive but active")
		        if exists $active{$b->{NAME}}{$b->{NODE}};
		    next;
		}

		# Remove obsolete replicas
		if (! exists $active{$b->{NAME}}{$b->{NODE}})
		{
		    &logmsg ("removing $b->{NAME} at $b->{NODE}");
		    &dbexec ($dbh, qq{
			delete from t_block_replica
			where name = :block and node = :node},
			":block" => $b->{NAME}, ":node" => $b->{NODE});
		    next;
		}

		# Update statistics for active blocks
		my $new = $active{$b->{NAME}}{$b->{NODE}};
		if ($b->{DEST_FILES} != $new->{DEST_FILES}
		    || $b->{DEST_BYTES} != $new->{DEST_BYTES}
		    || $b->{NODE_FILES} != $new->{NODE_FILES}
		    || $b->{NODE_BYTES} != $new->{NODE_BYTES}
		    || $b->{XFER_FILES} != $new->{XFER_FILES}
		    || $b->{XFER_BYTES} != $new->{XFER_BYTES})
	        {
		    &limitCheck ("updated block", $new, $b);
		    &logmsg ("updating $b->{NAME} at $b->{NODE}");
		    &dbexec ($dbh, qq{
			update t_block_replica
			set last_update = :now, isactive = 1,
			    dest_files = :dest_files, dest_bytes = :dest_bytes,
			    node_files = :node_files, node_bytes = :node_bytes,
			    xfer_files = :xfer_files, xfer_bytes = :xfer_bytes
			where block = :block and node = :node},
			":now" => $now,
			":block" => $b->{NAME},
			":node" => $b->{NODE},
			":dest_files" => $new->{DEST_FILES},
			":dest_bytes" => $new->{DEST_BYTES},
			":node_files" => $new->{NODE_FILES},
			":node_bytes" => $new->{NODE_BYTES},
			":xfer_files" => $new->{XFER_FILES},
			":xfer_bytes" => $new->{XFER_BYTES});
		}
	    }
        }

	# Compare differences II: new ones.
	foreach my $i (values %active)
	{
	    foreach my $b (values %{$active{$i}})
	    {
		next if exists $replicas{$b->{NAME}}{$b->{NODE}};
		&limitCheck ("new block", $b);
		&logmsg ("creating $b->{NAME} at $b->{NODE}");
		&dbexec ($dbh, qq{
		    insert into t_block_replica
		    (timestamp, name, node, isactive, last_update,
		     dest_files, dest_bytes,
		     node_files, node_bytes,
		     xfer_files, xfer_bytes)
		    values (:now, :block, :node, 1, :now,
		            :dest_files, :dest_bytes,
			    :node_files, :node_bytes,
			    :xfer_files, :xfer_bytes)},
		    ":now" => $now,
		    ":block" => $b->{NAME},
		    ":node" => $b->{NODE},
		    ":dest_files" => $b->{DEST_FILES},
		    ":dest_bytes" => $b->{DEST_BYTES},
		    ":node_files" => $b->{NODE_FILES},
		    ":node_bytes" => $b->{NODE_BYTES},
		    ":xfer_files" => $b->{XFER_FILES},
		    ":xfer_bytes" => $b->{XFER_BYTES});
	    }
        }

	# All done.
	$dbh->commit ();

	# Now destinations
	&dbexec ($dbh, qq{
	    update (select bd.completed
	    	    from t_block_destination bd
		    join t_block b
		      on b.name = bd.name
		    join t_block_replica br
		      on br.name = bd.name
		     and br.node = bd.node
	     	    where b.isopen = 0
		      and br.node_files = b.files
	      	      and br.dest_files = b.files
	      	      and bd.completed is null)
	    set bd.completed = :now},
	    ":now" => &mytimeofday());
	$dbh->commit ();
    };
    do { &alert ("database error: $@"); $dbh->rollback if $dbh } if $@;

    # Disconnect from the database.
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap.
    $self->nap ($self->{WAITTIME});
}
