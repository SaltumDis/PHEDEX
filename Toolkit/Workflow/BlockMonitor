#! /usr/bin/env perl

##H Monitor block-level transfer completeness.
##H
##H Usage:
##H   BlockMonitor -state DIRECTORY -node NAME -db FILE[:SECTION]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -log       where to redirect logging information

BEGIN {
  use warnings; use strict; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{MYNODE} || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}


(new BlockMonitor (%args))->process();

################################################
package BlockMonitor; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MYNODE => undef,              # my TMDB nodename
		  DBCONFIG => undef,		# Database configuration file
		  WAITTIME => 120 + rand(30));	# Agent cycle period

    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub limitCheck
{
    my ($reason, $b, $ref) = @_;
    $ref ||= $b;
    &alert ("$reason block $$b{BLOCK} at node $$b{NODE} destined $$b{DEST_FILES} files,"
	    . " more than expected ($$ref{FILES})")
	if $$b{DEST_FILES} > $$ref{FILES};
    &alert ("$reason block $$b{BLOCK} at node $$b{NODE} destined $$b{DEST_BYTES} bytes,"
	    . " more than expected ($$ref{BYTES})")
	if $$b{DEST_BYTES} > $$ref{BYTES};
    &alert ("$reason block $$b{BLOCK} at node $$b{NODE} has $$b{NODE_FILES} files,"
	    . " more than expected ($$ref{FILES})")
	if $$b{NODE_FILES} > $$ref{FILES};
    &alert ("$reason block $$b{BLOCK} at node $$b{NODE} has $$b{NODE_BYTES} bytes,"
	    . " more than expected ($$ref{BYTES})")
	if $$b{NODE_BYTES} > $$ref{BYTES};
    &alert ("$reason block $$b{BLOCK} at node $$b{NODE} transferring $$b{XFER_FILES} files,"
	    . " more than expected ($$ref{FILES})")
	if $$b{XFER_FILES} > $$ref{FILES};
    &alert ("$reason block $$b{BLOCK} at node $$b{NODE} transferring $$b{XFER_BYTES} bytes,"
	    . " more than expected ($$ref{BYTES})")
	if $$b{XFER_BYTES} > $$ref{BYTES};
}

# Update statistics.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Guarantee full consistency.  We need to ensure that a) this
	# procedure is aborted if someone goes and makes block open
	# again and adds more files, b) we delete exactly as many
	# t_xfer_replica rows as we planned to.
	&dbexec ($dbh, q{set transaction isolation level serializable});

	# Read existing block replica information.
        my $now = &mytimeofday ();
	my %replicas = ();
	my $qexisting = &dbexec ($dbh, qq{
	    select br.block, br.node,
		   br.is_active, b.files, b.bytes, b.is_open,
	           br.dest_files, br.dest_bytes,
		   br.node_files, br.node_bytes,
		   br.xfer_files, br.xfer_bytes
	    from t_dps_block_replica br
	      join t_dps_block b on b.id = br.block
	    for update of b.id});
        while (my $row = $qexisting->fetchrow_hashref())
	{
	    $replicas{$$row{BLOCK}}{$$row{NODE}} = $row;
	    &limitCheck ("existing block", $row);
	}

	# Get file counts in currently active files: those destined at
	# nodes, those at the nodes, and those in transfer to nodes.
	# Note that file replicas at intermediate nodes show up as
	# partial block replicas, so it's important that replicas at
	# those nodes are either not cleaned at all, or cleaners clear
	# at least some files before all destinations are completed.
	# We consider the blocks alive even if all replicas are complete
	# and there are no transfers, but there are pending destination
	# assignments -- that just means file routing hasn't started.
	#
	# The actual data gathering is split into three separate queries
	# and post-processing pass to reset undefined counters to zero.
	# This avoids a single very expensive query -- the turnaround
	# from several queries is much lower.  Still, we don't want this
	# executed too often.
	my %active = ();
        my $qactive = &dbexec($dbh, qq{
	    select bd.block, bd.destination, count(f.id), sum(f.filesize)
	    from t_dps_block_dest bd join t_xfer_file f on f.inblock = bd.block
	    group by bd.block, bd.destination});
        while (my ($block, $node, $files, $bytes) = $qactive->fetchrow())
        {
	    $active{$block}{$node} ||= { BLOCK => $block, NODE => $node };
	    $active{$block}{$node}{DEST_FILES} = $files;
	    $active{$block}{$node}{DEST_BYTES} = $bytes;
	}

        $qactive = &dbexec($dbh, qq{
	    select f.inblock, xr.node, count(xr.fileid), sum(f.filesize)
	    from t_xfer_replica xr join t_xfer_file f on f.id = xr.fileid
	    group by f.inblock, xr.node});
        while (my ($block, $node, $files, $bytes) = $qactive->fetchrow())
        {
	    $active{$block}{$node} ||= { BLOCK => $block, NODE => $node };
	    $active{$block}{$node}{NODE_FILES} = $files;
	    $active{$block}{$node}{NODE_BYTES} = $bytes;
	}

        $qactive = &dbexec($dbh, qq{
	    select f.inblock, xs.to_node, count(xs.fileid), sum(f.filesize)
	    from t_xfer_state xs join t_xfer_file f on f.id = xs.fileid
	    group by f.inblock, xs.to_node});
        while (my ($block, $node, $files, $bytes) = $qactive->fetchrow())
        {
	    $active{$block}{$node} ||= { BLOCK => $block, NODE => $node };
	    $active{$block}{$node}{XFER_FILES} = $files;
	    $active{$block}{$node}{XFER_BYTES} = $bytes;
	}

	foreach my $b (map { values %$_ } values %active)
	{
	    $$b{DEST_FILES} ||= 0; $$b{DEST_BYTES} ||= 0;
	    $$b{NODE_FILES} ||= 0; $$b{NODE_BYTES} ||= 0;
	    $$b{XFER_FILES} ||= 0; $$b{XFER_BYTES} ||= 0;
	}

	# Compare differences I: start from previous replicas.
	foreach my $b (map { values %$_ } values %replicas)
	{
	    # Check consistency of inactive blocks before ignoring
	    # them: they can't be open or have active replicas or
	    # transfers.  Count block active if it has active
	    # file replicas or transfers; destinations alone do
	    # not make a block active.
	    if ($$b{IS_ACTIVE} ne 'y')
	    {
		&alert ("$$b{BLOCK} at $$b{NODE} inactive but open")
		    if $$b{IS_OPEN} eq 'y';
		&alert ("$$b{BLOCK} at $$b{NODE} inactive but active")
		    if (exists $active{$$b{BLOCK}}{$$b{NODE}}
			&& ($active{$$b{BLOCK}}{$$b{NODE}}{NODE_FILES}
			    || $active{$$b{BLOCK}}{$$b{NODE}}{XFER_FILES}));
		next;
	    }

	    # Remove obsolete replicas
	    if (! exists $active{$$b{BLOCK}}{$$b{NODE}})
	    {
		&logmsg ("removing block $$b{BLOCK} at node $$b{NODE}");
		&dbexec ($dbh, qq{
		    delete from t_dps_block_replica
		    where block = :block and node = :node},
		    ":block" => $$b{BLOCK}, ":node" => $$b{NODE});
		next;
	    }

	    # Update statistics for active blocks
	    my $new = $active{$$b{BLOCK}}{$$b{NODE}};
	    if ($$b{DEST_FILES} != $$new{DEST_FILES}
		|| $$b{DEST_BYTES} != $$new{DEST_BYTES}
		|| $$b{NODE_FILES} != $$new{NODE_FILES}
		|| $$b{NODE_BYTES} != $$new{NODE_BYTES}
		|| $$b{XFER_FILES} != $$new{XFER_FILES}
		|| $$b{XFER_BYTES} != $$new{XFER_BYTES})
	    {
		&limitCheck ("updated block", $new, $b);
		&logmsg ("updating block $$b{BLOCK} at node $$b{NODE}");
		&dbexec ($dbh, qq{
		    update t_dps_block_replica
		    set time_update = :now, is_active = 'y',
		        dest_files = :dest_files, dest_bytes = :dest_bytes,
			node_files = :node_files, node_bytes = :node_bytes,
			xfer_files = :xfer_files, xfer_bytes = :xfer_bytes
		    where block = :block and node = :node},
		    ":now" => $now,
		    ":block" => $$b{BLOCK},
		    ":node" => $$b{NODE},
		    ":dest_files" => $$new{DEST_FILES},
		    ":dest_bytes" => $$new{DEST_BYTES},
		    ":node_files" => $$new{NODE_FILES},
		    ":node_bytes" => $$new{NODE_BYTES},
		    ":xfer_files" => $$new{XFER_FILES},
		    ":xfer_bytes" => $$new{XFER_BYTES});
	    }
        }

	# Compare differences II: new ones.
	foreach my $b (map { values %$_ } values %active)
	{
	    if (exists $replicas{$$b{BLOCK}}{$$b{NODE}})
	    {
		# Already handled above
		next;
	    }
	    elsif (grep ($$_{IS_ACTIVE} ne 'y', values %{$replicas{$$b{BLOCK}}}))
	    {
		# This block has inactive replicas.  Make sure all the
		# replicas are inactive, then make sure this new replica
		# has nothing but destinations defined (everything else
		# is a consistency failure), and wait for BlockActivate
		# to reactivate the block.
		if (grep ($$_{IS_ACTIVE} eq 'y', values %{$replicas{$$b{BLOCK}}}))
		{
		    &alert ("block $$b{BLOCK} has inactive and active replicas");
		}
		elsif ($$b{NODE_FILES} || $$b{XFER_FILES})
		{
		    &alert ("block $$b{BLOCK} at node $$b{NODE} is active but the"
			    . " block is otherwise inactive");
		}
	  	else
		{
		    &logmsg ("block $$b{BLOCK} is inactive with new destinations"
			     . " for node $$b{NODE}, waiting for activation");
		}
	   	next;
	    }

	    &logmsg ("creating block $$b{BLOCK} at node $$b{NODE}");
	    &dbexec ($dbh, qq{
		insert into t_dps_block_replica
		(time_create, time_update,
		 block, node, is_active,
		 dest_files, dest_bytes,
		 node_files, node_bytes,
		 xfer_files, xfer_bytes)
		values (:now, :now,
		        :block, :node, 'y',
		        :dest_files, :dest_bytes,
			:node_files, :node_bytes,
			:xfer_files, :xfer_bytes)},
		":now" => $now,
		":block" => $$b{BLOCK},
		":node" => $$b{NODE},
		":dest_files" => $$b{DEST_FILES},
		":dest_bytes" => $$b{DEST_BYTES},
		":node_files" => $$b{NODE_FILES},
		":node_bytes" => $$b{NODE_BYTES},
		":xfer_files" => $$b{XFER_FILES},
		":xfer_bytes" => $$b{XFER_BYTES});
	}

	# All done.
	$dbh->commit ();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database.
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap.
    $self->nap ($$self{WAITTIME});
}
