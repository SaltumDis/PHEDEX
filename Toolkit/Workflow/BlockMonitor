#! /usr/bin/env perl

##H Monitor block-level transfer completeness.
##H
##H Usage:
##H   BlockMonitor
##H      -state DIRECTORY -node NAME -dbconfig FILE [-wait SECS]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -dbconfig  database connection configuration parameter file
##H -wait      time to wait in seconds between work scans

BEGIN {
  use warnings; use strict;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
use UtilsHelp;
use Getopt::Long;
my %args = (WAITTIME => 180);
&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "dbconfig=s"       => \$args{DBCONFIG},
	     "wait=f"		=> \$args{WAITTIME},
	     "node=s"           => \$args{MYNODE},
     	     "help|h"		=> sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}


my $agent = new BlockMonitor (%args);
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{QUIT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$SIG{TERM} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop() };
$agent->process();

################################################
package BlockMonitor; use strict; use warnings; use base 'UtilsAgent';
use File::Path;
use Data::Dumper;
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsCatalogue;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MYNODE => undef,              # my TMDB nodename
		  DBCONFIG => undef,		# Database configuration file
	  	  AGENTID => "BlockMonitor");   # Identity for activity logs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Update statistics.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Update statistics in t_block_replica with number of files
	# and total size in bytes using t_replica_state information.
	# first get handel
        my $now = &mytimeofday ();
        my $qreplicas = &dbexec($dbh, qq{
	    select
    	    	f.inblock,
    	    	rs.node,
    	    	count (rs.guid),
    	    	sum (f.filesize)
    	    from t_replica_state rs
    	    left join t_file f on f.guid = rs.guid
    	    group by f.inblock, rs.node});


	my $qexisting = &dbexec($dbh, qq{
	          select name, node, files, bytes
		  from t_block_replica});

	# Check for existing entries by dumping content of t_block_replica
	# now get content of t_block_replica
	my $BRDump = {};
	while (my ($block, $node, $nfiles, $nbytes)=$qexisting->fetchrow_array())
	{
	    $BRDump->{$block}{$node} = [$nfiles, $nbytes];
	}

	# get all info needed to update the blocks in t_block_replica
	my $RSChange = {};
        while (my ($block, $node, $nfiles, $nbytes) = $qreplicas->fetchrow_array())
        {

	    # only interested in the blocks which changed (nbytes or nfiles)
	    # and int the ones which don't exist yet
	    my $exists = $BRDump->{$block}{$node};
	    $RSChange->{$block}{$node} = [$nfiles, $nbytes, $exists]
		if ( ($exists
		    && ($BRDump->{$block}{$node}->[0] != $nfiles
			|| $BRDump->{$block}{$node}->[1] != $nbytes) )
		     || !$exists);
	}

	# will only modify or create blocks which changed
	# should reduce load on DB
	foreach my $block (sort keys(%$RSChange))
	{
	    foreach my $node (sort keys(%{$RSChange->{$block}}))
	    {
		# FIXME: Ignore t_replica_state with BlockDeactivate.  Add
		# a "isactive" flag to a block/block replica so we can
		# tell whether to look at t_replica_state for the block or
		# not.  BlockActivate/Deactivate must manage this flag.
		# Decide what to do in TMDBInject + DropTMDBPublisher.

		my $nfiles = $RSChange->{$block}{$node}->[0];
		my $nbytes = $RSChange->{$block}{$node}->[1];
		my $exists = $RSChange->{$block}{$node}->[2];
		# Create a template entry if none yet exists.
		&dbexec($dbh, qq{
    	    	     insert into t_block_replica
    	    	     (timestamp, name, node, files, bytes)
            	     values (:now, :block, :node, -1, -1)},
            	     ":now" => $now,
    	    	     ":block" => $block,
    	    	     ":node" => $node)
		     if ! $exists;
	    
		# Now update table values.
		&dbexec($dbh, qq{
    	    	    update t_block_replica
    	    	    set timestamp = :now,
    	    	    files = :files,
    	    	    bytes = :bytes
    	    	    where name = :block
    	    	    and node = :node},
    	    	    ":now" => $now,
    	    	    ":files" => $nfiles,
    	    	    ":bytes" => $nbytes,
    	    	    ":block" => $block,
    	    	    ":node" => $node);
        
		$dbh->commit();
	    }
	}
    };
    do { &alert ("database error: $@"); $dbh->rollback if $dbh } if $@;

    # Disconnect from the database.
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap.
    $self->nap ($self->{WAITTIME});
}
