#! /usr/bin/env perl

##H Monitor block-level transfer completeness.
##H
##H Usage:
##H   BlockMonitor
##H      -state DIRECTORY -node NAME -db FILE[:SECTION] [-wait SECS]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans

BEGIN {
  use warnings; use strict;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}


######################################################################
use UtilsHelp;
use Getopt::Long;
my %args = (WAITTIME => 180);
&GetOptions ("state=s"		=> \$args{DROPDIR},
	     "db=s"             => \$args{DBCONFIG},
	     "wait=f"		=> \$args{WAITTIME},
	     "node=s"           => \$args{MYNODE},
     	     "help|h"		=> sub { &usage() });

if (@ARGV || !$args{MYNODE} || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}


(new BlockMonitor (%args))->process();

################################################
package BlockMonitor; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (MYNODE => undef,              # my TMDB nodename
		  DBCONFIG => undef,		# Database configuration file
	  	  AGENTID => "BlockMonitor");   # Identity for activity logs

    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub limitCheck
{
    my ($reason, $b, $ref) = @_;
    $ref ||= $b;
    &alert ("$reason $b->{NAME} at $b->{NODE} destined $b->{DEST_FILES} files,"
	    . " more than expected ($ref->{FILES})")
	if $b->{DEST_FILES} > $ref->{FILES};
    &alert ("$reason $b->{NAME} at $b->{NODE} destined $b->{DEST_BYTES} bytes,"
	    . " more than expected ($ref->{BYTES})")
	if $b->{DEST_BYTES} > $ref->{BYTES};
    &alert ("$reason $b->{NAME} at $b->{NODE} has $b->{NODE_FILES} files,"
	    . " more than expected ($ref->{FILES})")
	if $b->{NODE_FILES} > $ref->{FILES};
    &alert ("$reason $b->{NAME} at $b->{NODE} has $b->{NODE_BYTES} bytes,"
	    . " more than expected ($ref->{BYTES})")
	if $b->{NODE_BYTES} > $ref->{BYTES};
    &alert ("$reason $b->{NAME} at $b->{NODE} transferring $b->{XFER_FILES} files,"
	    . " more than expected ($ref->{FILES})")
	if $b->{XFER_FILES} > $ref->{FILES};
    &alert ("$reason $b->{NAME} at $b->{NODE} transferring $b->{XFER_BYTES} bytes,"
	    . " more than expected ($ref->{BYTES})")
	if $b->{XFER_BYTES} > $ref->{BYTES};
    &alert ("$reason $b->{NAME} at $b->{NODE} transferring $b->{EXPT_FILES} files,"
	    . " more than expected ($ref->{FILES})")
	if $b->{EXPT_FILES} > $ref->{FILES};
    &alert ("$reason $b->{NAME} at $b->{NODE} transferring $b->{EXPT_BYTES} bytes,"
	    . " more than expected ($ref->{BYTES})")
	if $b->{EXPT_BYTES} > $ref->{BYTES};
}

# Update statistics.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Guarantee full consistency.  We need to ensure that a) this
	# procedure is aborted if someone goes and makes block open
	# again and adds more files, b) we delete exactly as many
	# t_replica_state rows as we planned to.
	&dbexec ($dbh, q{set transaction isolation level serializable});

	# Read existing block replica information.
        my $now = &mytimeofday ();
	my %replicas = ();
	my $qexisting = &dbexec ($dbh, qq{
	    select br.name, br.node, br.isactive,
		   b.files, b.bytes, b.isopen,
	           br.dest_files, br.dest_bytes,
		   br.node_files, br.node_bytes,
		   br.xfer_files, br.xfer_bytes,
		   br.expt_files, br.expt_bytes
	    from t_block_replica br
	    join t_block b on b.name = br.name});
        while (my $row = $qexisting->fetchrow_arrayref())
	{
	    $replicas{$row->[0]}{$row->[1]} = {
		NAME => $row->[0], NODE => $row->[1], ISACTIVE => $row->[2],
		FILES => $row->[3], BYTES => $row->[4], ISOPEN => $row->[5],
		DEST_FILES => $row->[6], DEST_BYTES => $row->[7],
		NODE_FILES => $row->[8], NODE_BYTES => $row->[9],
		XFER_FILES => $row->[10], XFER_BYTES => $row->[11],
		EXPT_FILES => $row->[12], EXPT_BYTES => $row->[13]
	    };
	    &limitCheck ("existing block", $replicas{$row->[0]}{$row->[1]});
	}

	# Get file counts in currently active files: those destined at
	# nodes, those at the nodes, and those in transfer to nodes.
	# Note that file replicas at intermediate nodes show up as
	# partial block replicas, so it's important that replicas at
	# those nodes are either not cleaned at all, or cleaners clear
	# at least some files before all destinations are completed.
	# We consider the blocks alive even if all replicas are complete
	# and there are no transfers, but there are pending destination
	# assignments -- that just means file routing hasn't started.
	#
	# The actual data gathering is split into three separate queries
	# and post-processing pass to reset undefined counters to zero.
	# This avoids a single very expensive query -- the turnaround
	# from several queries is much lower.  Still, we don't want this
	# executed too often.
	my %active = ();
        my $qactive = &dbexec($dbh, qq{
	    select bd.name, bd.node, count (f.guid), sum (f.filesize)
	    from t_block_destination bd
	    join t_file f on f.inblock = bd.name
	    group by bd.name, bd.node});
        while (my ($block, $node, $files, $bytes) = $qactive->fetchrow())
        {
	    $active{$block}{$node} ||= { NAME => $block, NODE => $node };
	    $active{$block}{$node}{DEST_FILES} = $files;
	    $active{$block}{$node}{DEST_BYTES} = $bytes;
	}

        $qactive = &dbexec($dbh, qq{
	    select f.inblock, rs.node, count (rs.guid), sum (f.filesize)
	    from t_replica_state rs
	    join t_file f on f.guid = rs.guid
	    group by f.inblock, rs.node});
        while (my ($block, $node, $files, $bytes) = $qactive->fetchrow())
        {
	    $active{$block}{$node} ||= { NAME => $block, NODE => $node };
	    $active{$block}{$node}{NODE_FILES} = $files;
	    $active{$block}{$node}{NODE_BYTES} = $bytes;
	}

        $qactive = &dbexec($dbh, qq{
	    select f.inblock, ts.to_node, count (ts.guid), sum (f.filesize)
	    from t_transfer_state ts
	    join t_file f on f.guid = ts.guid
	    where ts.to_state != 3
	    group by f.inblock, ts.to_node});
        while (my ($block, $node, $files, $bytes) = $qactive->fetchrow())
        {
	    $active{$block}{$node} ||= { NAME => $block, NODE => $node };
	    $active{$block}{$node}{XFER_FILES} = $files;
	    $active{$block}{$node}{XFER_BYTES} = $bytes;
	}

        $qactive = &dbexec($dbh, qq{
	    select f.inblock, ts.from_node, count (ts.guid), sum (f.filesize)
	    from t_transfer_state ts
	    join t_file f on f.guid = ts.guid
	    where ts.to_state != 3
	    group by f.inblock, ts.from_node});
        while (my ($block, $node, $files, $bytes) = $qactive->fetchrow())
        {
	    $active{$block}{$node} ||= { NAME => $block, NODE => $node };
	    $active{$block}{$node}{EXPT_FILES} = $files;
	    $active{$block}{$node}{EXPT_BYTES} = $bytes;
	}

	foreach my $b (map { values %$_ } values %active)
	{
	    $b->{DEST_FILES} ||= 0; $b->{DEST_BYTES} ||= 0;
	    $b->{NODE_FILES} ||= 0; $b->{NODE_BYTES} ||= 0;
	    $b->{XFER_FILES} ||= 0; $b->{XFER_BYTES} ||= 0;
	    $b->{EXPT_FILES} ||= 0; $b->{EXPT_BYTES} ||= 0;
	}

	# Compare differences I: start from previous replicas.
	foreach my $b (map { values %$_ } values %replicas)
	{
	    # Check consistency of inactive blocks before ignoring
	    # them: they can't be open or have active replicas or
	    # transfers.
	    if (! $b->{ISACTIVE})
	    {
		&alert ("$b->{NAME} at $b->{NODE} inactive but open")
		    if $b->{ISOPEN};
		&alert ("$b->{NAME} at $b->{NODE} inactive but active")
		    if exists $active{$b->{NAME}}{$b->{NODE}};
		next;
	    }

	    # Remove obsolete replicas
	    if (! exists $active{$b->{NAME}}{$b->{NODE}})
	    {
		&logmsg ("removing $b->{NAME} at $b->{NODE}");
		&dbexec ($dbh, qq{
		    delete from t_block_replica
		    where name = :block and node = :node},
		    ":block" => $b->{NAME}, ":node" => $b->{NODE});
		next;
	    }

	    # Update statistics for active blocks
	    my $new = $active{$b->{NAME}}{$b->{NODE}};
	    if ($b->{DEST_FILES} != $new->{DEST_FILES}
		|| $b->{DEST_BYTES} != $new->{DEST_BYTES}
		|| $b->{NODE_FILES} != $new->{NODE_FILES}
		|| $b->{NODE_BYTES} != $new->{NODE_BYTES}
		|| $b->{XFER_FILES} != $new->{XFER_FILES}
		|| $b->{XFER_BYTES} != $new->{XFER_BYTES}
		|| $b->{EXPT_FILES} != $new->{EXPT_FILES}
		|| $b->{EXPT_BYTES} != $new->{EXPT_BYTES})
	    {
		&limitCheck ("updated block", $new, $b);
		&logmsg ("updating $b->{NAME} at $b->{NODE}");
		&dbexec ($dbh, qq{
		    update t_block_replica
		    set last_update = :now, isactive = 1,
		        dest_files = :dest_files, dest_bytes = :dest_bytes,
			node_files = :node_files, node_bytes = :node_bytes,
			xfer_files = :xfer_files, xfer_bytes = :xfer_bytes,
			expt_files = :expt_files, expt_bytes = :expt_bytes
		    where name = :block and node = :node},
		    ":now" => $now,
		    ":block" => $b->{NAME},
		    ":node" => $b->{NODE},
		    ":dest_files" => $new->{DEST_FILES},
		    ":dest_bytes" => $new->{DEST_BYTES},
		    ":node_files" => $new->{NODE_FILES},
		    ":node_bytes" => $new->{NODE_BYTES},
		    ":xfer_files" => $new->{XFER_FILES},
		    ":xfer_bytes" => $new->{XFER_BYTES},
		    ":expt_files" => $new->{EXPT_FILES},
		    ":expt_bytes" => $new->{EXPT_BYTES});
	    }
        }

	# Compare differences II: new ones.
	foreach my $b (map { values %$_ } values %active)
	{
	    next if exists $replicas{$b->{NAME}}{$b->{NODE}};
	    &logmsg ("creating $b->{NAME} at $b->{NODE}");
	    &dbexec ($dbh, qq{
		insert into t_block_replica
		(timestamp, name, node, isactive, last_update,
		 dest_files, dest_bytes,
		 node_files, node_bytes,
		 xfer_files, xfer_bytes,
		 expt_files, expt_bytes)
		values (:now, :block, :node, 1, :now,
		        :dest_files, :dest_bytes,
			:node_files, :node_bytes,
			:xfer_files, :xfer_bytes,
			:expt_files, :expt_bytes)},
		":now" => $now,
		":block" => $b->{NAME},
		":node" => $b->{NODE},
		":dest_files" => $b->{DEST_FILES},
		":dest_bytes" => $b->{DEST_BYTES},
		":node_files" => $b->{NODE_FILES},
		":node_bytes" => $b->{NODE_BYTES},
		":xfer_files" => $b->{XFER_FILES},
		":xfer_bytes" => $b->{XFER_BYTES},
		":expt_files" => $b->{EXPT_FILES},
		":expt_bytes" => $b->{EXPT_BYTES});
	}

	# All done.
	$dbh->commit ();

	# Now destinations
	&dbexec ($dbh, qq{
	    update (select bd.completed
	    	    from t_block_destination bd
		    join t_block b
		      on b.name = bd.name
		    join t_block_replica br
		      on br.name = bd.name
		     and br.node = bd.node
	     	    where b.isopen = 0
		      and br.node_files = b.files
	      	      and br.dest_files = b.files
	      	      and bd.completed is null)
	    set completed = :now},
	    ":now" => &mytimeofday());
	$dbh->commit ();
    };
    do { &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh } if $@;

    # Disconnect from the database.
    &disconnectFromDatabase ($self, $dbh);

    # Have a little nap.
    $self->nap ($self->{WAITTIME});
}
