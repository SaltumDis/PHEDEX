#!/usr/bin/env perl

##H Issue deletions for files in blocks scheduled for deletion.
##H
##H Usage:
##H   BlockDelete -state DIRECTORY -node NAME -db FILE[:SECTION]
##H               [-once] [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -once      run the alogrithm once, then quit -- don't go into daemon mode
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
             "once"        => \$args{ONCE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockDelete (%args))->process();

######################################################################
# Routines for this agent.
package BlockDelete; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node
		  ONCE => 0,			# Quit after one run
		  WAITTIME => 120 + rand(30));	# Agent cycle time
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Do some work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self);

	# Issue file deletion requests for block replicas scheduled
	# for deletion and for which no deletion request yet exists.
	my ($stmt, $nrow) = &dbexec($dbh, qq{
	   insert into t_xfer_delete (fileid, node, time_request)
	   (select f.id, bd.node, bd.time_request
	    from t_dps_block_delete bd
	      join t_xfer_file f
	        on f.inblock = bd.block
	      left join t_xfer_delete xd
	        on xd.fileid = f.id and xd.node = bd.node
	    where xd.fileid is null and bd.time_complete is null)});
        &logmsg ("$nrow file deletions scheduled") if $nrow > 0;

        # Mark the block deletion request completed if all its file
	# deletion requests have been completed.  NOTE: for now we
	# assume block removals are issued only for blocks known to
	# be closed, otherwise we can't know when to close the delete
	# request, new files could appear at any time.  The allocator
	# issues removals only for completed subscriptions, so the
	# blocks must indeed be closed.
	($stmt, $nrow) = &dbexec ($dbh, qq{
	    update t_dps_block_delete bd
	    set time_complete = :now
	    where time_complete is null and not exists
	      (select 1 from t_xfer_delete xd
	       join t_xfer_file f on f.id = xd.fileid
	       where xd.time_complete is null
	         and xd.node = bd.node
	         and f.inblock = bd.block)},
	    ":now" => &mytimeofday());

    	$dbh->commit();

        &logmsg ("$nrow blocks marked deleted") if $nrow > 0;
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a nap.
    $self->doStop() if $$self{ONCE};
    $self->nap ($$self{WAITTIME});
}
