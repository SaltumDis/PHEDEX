#!/usr/bin/env perl

##H Issue deletions for files in blocks scheduled for deletion.
##H
##H Usage:
##H   BlockDelete -state DIRECTORY -node NAME -db FILE[:SECTION]
##H               [-once] [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -once      run the alogrithm once, then quit -- don't go into daemon mode
##H -log       where to redirect logging information

######################################################################
my %args;
use Getopt::Long;
use PHEDEX::Core::Help;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
             "once"        => \$args{ONCE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockDelete (%args))->process();

######################################################################
# Routines for this agent.
package BlockDelete; use strict; use warnings; use base 'PHEDEX::Core::Agent';
use PHEDEX::Core::Logging;
use PHEDEX::Core::Timing;
use PHEDEX::Core::DB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node
		  ONCE => 0,			# Quit after one run
		  WAITTIME => 120 + rand(30));	# Agent cycle time
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Do some work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self);
	my $now = &mytimeofday();

	# Trigger deletion of finished blocks at the source end of a complete "move" subscription
	# We trigger for blocks which:
	#   1. Have a block replica at some potential source node
	#   2. Do not have a subscription
	#   3. Are not already in the deletion table (TODO:  faster cleanup of deletion table?)
        #   4. Are not the buffer node of the destination
        #   5. Are not a T1 node
	my ($stmt, $nrow) = &dbexec($dbh, qq{
	    insert into t_dps_block_delete
                   (block, dataset, node, time_request)
	    select distinct sb.id, sb.dataset, br.node, :now
              from t_dps_subscription s
              join t_dps_block sb on sb.dataset = s.dataset or sb.id = s.block
              join t_dps_block_dest bd on bd.destination = s.destination
                                      and bd.block = sb.id
              join t_dps_block_replica br on br.node != s.destination
	                                 and br.block = sb.id
              join t_adm_node n on n.id = br.node
         left join t_dps_block_delete bdel on bdel.node = br.node
                                          and bdel.block = br.block
         left join t_dps_subscription s2 on s2.destination = br.node
                                        and (s2.dataset = sb.dataset or s2.block = sb.id)
             where s.is_move = 'y'
	       and bd.state = 3
	       and bdel.block is null
	       and s2.destination is null
               and n.name not like 'T1_%'
               and not exists (select 1 from t_adm_node buf
                                 join t_adm_link loc on loc.from_node = buf.id and loc.is_local = 'y'
                                 join t_adm_node mss on mss.id = loc.to_node
                                where buf.kind = 'Buffer' and mss.kind = 'MSS'
                                  and buf.id = br.node and mss.id = s.destination)
	   }, ':now' => $now);

	# Log what we just triggered
	my $q_move = &dbexec($dbh, qq{
	    select n.name, b.name
              from t_dps_block_delete bd
	      join t_adm_node n on n.id = bd.node
              join t_dps_block b on b.id = bd.block
	     where bd.time_request = :now
	 }, ':now' => $now);

	while (my ($node, $block) = $q_move->fetchrow()) {
	    &logmsg("triggered deletion of $block at $node due to a move");
	}

	# Issue file deletion requests for block replicas scheduled
	# for deletion and for which no deletion request yet exists.
	($stmt, $nrow) = &dbexec($dbh, qq{
	   insert into t_xfer_delete (fileid, node, time_request)
	   (select f.id, bd.node, bd.time_request
	    from t_dps_block_delete bd
	      join t_xfer_file f
	        on f.inblock = bd.block
	      left join t_xfer_delete xd
	        on xd.fileid = f.id and xd.node = bd.node
	    where xd.fileid is null and bd.time_complete is null)});
	&logmsg ("$nrow file deletions scheduled") if $nrow > 0;

        # Mark the block deletion request completed if it has file
        # deletion requests and they are all completed.
	($stmt, $nrow) = &dbexec ($dbh, qq{
          merge into t_dps_block_delete bd
          using (select xd.node, xf.inblock, count(*) n_exist, sum(nvl2(xd.time_complete, 1, 0)) n_complete
                   from t_xfer_delete xd
	           join t_xfer_file xf on xf.id = xd.fileid
                   join t_dps_block_delete bd on xd.node = bd.node and bd.block = xf.inblock
		  where bd.time_complete is null
	          group by xd.node, xf.inblock) d_check
             on (d_check.node = bd.node
                 and d_check.inblock = bd.block
                 and d_check.n_exist != 0
                 and d_check.n_exist = d_check.n_complete)
          when matched then update set bd.time_complete = :now
      }, ':now' => $now);

	# Log what we just finished deleting
	my $q_done = &dbexec($dbh, qq{
	    select n.name, b.name
              from t_dps_block_delete bd
	      join t_adm_node n on n.id = bd.node
              join t_dps_block b on b.id = bd.block
	     where bd.time_complete = :now
	 }, ':now' => $now);

	while (my ($node, $block) = $q_done->fetchrow()) {
	    &logmsg("deletion of $block at $node finished");
	}

    	$dbh->commit();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a nap.
    $self->doStop() if $$self{ONCE};
    $self->nap ($$self{WAITTIME});
}
