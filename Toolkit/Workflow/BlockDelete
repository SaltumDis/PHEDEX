#!/usr/bin/env perl

##H Issue deletions for files in blocks scheduled for deletion.
##H
##H Usage:
##H   BlockDelete -state DIRECTORY -node NAME -db FILE[:SECTION]
##H               [-once] [-log OUT]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -db        database connection configuration parameter file
##H -once      run the alogrithm once, then quit -- don't go into daemon mode
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "node=s"      => \$args{MYNODE},
             "once"        => \$args{ONCE},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new BlockDelete (%args))->process();

######################################################################
# Routines for this agent.
package BlockDelete; use strict; use warnings; use base 'UtilsAgent';
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node
		  ONCE => 0,			# Quit after one run
		  WAITTIME => 120 + rand(30));	# Agent cycle time
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Do some work.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    eval
    {
	$dbh = &connectToDatabase ($self);

	# Clear block destinations for blocks we are going to delete from a node
	my ($stmt, $nrow) = &dbexec($dbh, qq{
	    delete from t_dps_block_dest bd where (block, destination) in
	      (select block, node from t_dps_block_delete where time_complete is null)});
	&logmsg ("$nrow block destinations cleared for blocks to be deleted") if $nrow > 0;

	# Issue file deletion requests for block replicas scheduled
	# for deletion and for which no deletion request yet exists.
	($stmt, $nrow) = &dbexec($dbh, qq{
	   insert into t_xfer_delete (fileid, node, time_request)
	   (select f.id, bd.node, bd.time_request
	    from t_dps_block_delete bd
	      join t_xfer_file f
	        on f.inblock = bd.block
	      left join t_xfer_delete xd
	        on xd.fileid = f.id and xd.node = bd.node
	    where xd.fileid is null and bd.time_complete is null)});
        &logmsg ("$nrow file deletions scheduled") if $nrow > 0;

        # Mark the block deletion request completed if it has file
        # deletion requests and they are all completed.
	($stmt, $nrow) = &dbexec ($dbh, qq{
          merge into t_dps_block_delete bd
          using (select xd.node, xf.inblock, count(*) n_exist, sum(nvl2(xd.time_complete, 1, 0)) n_complete
                   from t_xfer_delete xd
	           join t_xfer_file xf on xf.id = xd.fileid
                   join t_dps_block_delete bd on bd.block = xf.inblock
		  where bd.time_complete is null
	          group by xd.node, xf.inblock) d_check
             on (d_check.node = bd.node
                 and d_check.inblock = bd.block
                 and d_check.n_exist != 0
                 and d_check.n_exist = d_check.n_complete)
          when matched then update set bd.time_complete = :now
      },
				  ":now" => &mytimeofday());
    	$dbh->commit();

        &logmsg ("$nrow blocks marked deleted") if $nrow > 0;
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a nap.
    $self->doStop() if $$self{ONCE};
    $self->nap ($$self{WAITTIME});
}
