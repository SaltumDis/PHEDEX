#!/usr/bin/env perl

##H Routing helper agent that issues transfer tasks.
##H
##H Usage:
##H   FileIssue -state DIRECTORY -db FILE[:SECTION] [-log OUT]
##H
##H -state     agent state directory
##H -db        database connection configuration parameter file
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileIssue (%args))->process();

######################################################################
# Routines for this agent.
package FileIssue; use strict; use warnings; use base 'UtilsAgent';
use List::Util qw(max);
use UtilsLogging;
use UtilsCatalogue;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My node name
		  WAITTIME => 60 + rand(10));	# Agent activity cycle
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my @nodes;

    eval
    {
	$$self{NODES} = [ '%' ];
	($dbh, @nodes) = &expandNodesAndConnect ($self, { "FileDownload" => 5400 });

	# Route files.
	$self->confirm($dbh);
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little rest
    $self->nap ($$self{WAITTIME});
}

# Confirm transfers for all nodes.
sub confirm
{
    my ($self, $dbh) = @_;
    my $now = &mytimeofday();
    my $cats = {};
    my $finished = 0;
    my $alldone = 0;
    my $rank = 0;

    # Confirm transfers on valid hop destinations where the source
    # replica exists, but not the destination nor is there transfer.
    # Read link parameter information in the same go.  "Valid" hop
    # destinations include those where there is a live download
    # agent at the destination and an export agent at the source,
    # or specific combinations we always handle automatically.
    my $q = &dbexec($dbh, qq{
	select
          xp.fileid, f.logical_name,
          xp.from_node, ns.name from_node_name, ns.kind from_kind,
          xr.id replica, xp.to_node, nd.name to_node_name,
	  xso.protocols from_protos, xsi.protocols to_protos,
          xp.priority, xp.is_local, xp.time_expire
        from t_xfer_path xp
          join t_xfer_replica xr
            on xr.fileid = xp.fileid
            and xr.node = xp.from_node
          left join t_xfer_replica xdr
            on xdr.fileid = xp.fileid
            and xdr.node = xp.to_node
          join t_adm_node ns
            on ns.id = xp.from_node
	  join t_adm_node nd
	    on nd.id = xp.to_node
          left join t_xfer_exclude xe
            on xe.from_node = ns.id
            and xe.to_node = nd.id
            and xe.fileid = xp.fileid
          left join t_xfer_task xt
            on xt.fileid = xp.fileid
            and xt.to_node = xp.to_node
          join t_xfer_file f
            on f.id = xp.fileid
	  left join t_adm_link_param p
	    on p.from_node = xp.from_node
	    and p.to_node = xp.to_node
	  left join t_xfer_source xso
	    on xso.from_node = ns.id
	    and xso.to_node = nd.id
	    and xso.time_update >= :recent
	  left join t_xfer_sink xsi
	    on xsi.from_node = ns.id
	    and xsi.to_node = nd.id
	    and xsi.time_update >= :recent
	  left join t_xfer_delete xd
	    on xd.fileid = f.id
            and xd.node = ns.id
        where xp.is_valid = 1
          and xdr.id is null
          and xe.fileid is null
          and xt.id is null
          and xd.fileid is null
	  and ((ns.kind = 'MSS' and nd.kind = 'Buffer')
	       or (ns.kind = 'Buffer' and nd.kind = 'MSS'
       	           and xsi.from_node is not null)
	       or (xso.from_node is not null
       	           and xsi.from_node is not null))
	 /* order by priority asc, time_expire asc */ },
	":recent" => $now - 5400);

    while (! $finished)
    {
	$finished = 1;
        my @tasks;
        while (my $task = $q->fetchrow_hashref())
        {
	    $$task{PRIORITY} = 2*$$task{PRIORITY} + (1-$$task{IS_LOCAL});
	    $self->makeTransferTask($dbh, $task, $cats);
	    push(@tasks, $task);
	    do { $finished = 0; last } if scalar @tasks >= 10_000;
        }

        my ($done, %did, %iargs) = 0;
        my $istmt = &dbprep($dbh, qq{
	    insert into t_xfer_task (id, fileid, from_replica, priority, rank,
	      from_node, to_node, from_pfn, to_pfn, time_expire, time_assign)
	    values (seq_xfer_task.nextval, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)});
        foreach my $task (sort { $$a{PRIORITY} <=> $$b{PRIORITY}
		                 || $$a{LOGICAL_NAME} cmp $$b{LOGICAL_NAME} }
		          @tasks)
        {
	    my $n = 1;
	    next if ! $$task{FROM_PFN};
	    next if ! $$task{TO_PFN};
	    push(@{$iargs{$n++}}, $$task{FILEID});
	    push(@{$iargs{$n++}}, $$task{REPLICA});
	    push(@{$iargs{$n++}}, $$task{PRIORITY});
	    push(@{$iargs{$n++}}, $rank++);
	    push(@{$iargs{$n++}}, $$task{FROM_NODE});
	    push(@{$iargs{$n++}}, $$task{TO_NODE});
	    push(@{$iargs{$n++}}, $$task{FROM_PFN});
	    push(@{$iargs{$n++}}, $$task{TO_PFN});
	    push(@{$iargs{$n++}}, $$task{TIME_EXPIRE});
	    push(@{$iargs{$n++}}, $now);
	    $did{$$task{TO_NODE_NAME}} = 1;
	    $done++;
        }

        &dbbindexec($istmt, %iargs) if %iargs;
        $dbh->commit();

	&logmsg ("issued $done transfers to the destinations"
		 . " @{[sort keys %did]}") if $done;
	$alldone += $done;

	$self->maybeStop();
    }

    &logmsg ("no transfer tasks to issue") if ! $alldone;
}

# Expand transfer task information and insert into the database.
sub makeTransferTask
{
    my ($self, $dbh, $task, $cats) = @_;
    my ($from, $to) = @$task{"FROM_NODE", "TO_NODE"};
    my @from_protos = split(/\s+/, $$task{FROM_PROTOS} || '');
    my @to_protos   = split(/\s+/, $$task{TO_PROTOS} || '');
    my $from_cat    = $self->catalogue($dbh, $cats, $from);
    my $to_cat      = $self->catalogue($dbh, $cats, $to);
    my $protocol    = undef;

   &logmsg ("From_Node: $from, To_Node: $to");


    # Find matching protocol.
    foreach my $p (@to_protos)
    {
	next if ! grep($_ eq $p, @from_protos);
	$protocol = $p;
	last;
    }

    &logmsg ("Protocol: $protocol");

    # If this is MSS->Buffer transition, pretend we have a protocol.
    $protocol = 'srm' if ! $protocol && $$task{FROM_KIND} eq 'MSS';

    # Check that we have prerequisite information to expand the file names.
    return if (! $from_cat
	       || ! $to_cat
	       || ! $protocol
	       || ! $$from_cat{$protocol}
	       || ! $$to_cat{$protocol});

    # Try to expand the file name.
    $$task{FROM_PFN} = &applyStorageRules($from_cat, $protocol, $to, 'pre', $$task{LOGICAL_NAME});
    $$task{TO_PFN}   = &applyStorageRules($to_cat, $protocol, $from, 'pre', $$task{LOGICAL_NAME});
}

# Build and cache storage mapping catalogue for a node.
sub catalogue
{
    my ($self, $dbh, $cats, $node) = @_;

    # If we haven't yet built the catalogue, fetch from the database.
    if (! exists $$cats{$node})
    {
        $$cats{$node} = {};

        my $q = &dbexec($dbh, qq{
	    select protocol, chain, destination_match, path_match, result_expr
	    from t_xfer_catalogue
	    where node = :node and rule_type = 'lfn-to-pfn'
	    order by rule_index asc},
	    ":node" => $node);

        while (my ($proto, $chain, $dest, $path, $result) = $q->fetchrow())
        {
	    # Check the pattern is valid.  If not, abort.
            my $pathrx = eval { qr/$path/ };
	    return $$cats{$node} = {} if $@;

            my $destrx = defined $dest ? eval { qr/$dest/ } : undef;
	    return $$cats{$node} = {} if $@;

	    # Add the rule to our list.
	    push(@{$$cats{$node}{$proto}}, {
		    (defined $chain ? ('chain' => $chain) : ()),
		    (defined $dest ? ('destination-match' => $destrx) : ()),
		    'path-match' => $pathrx,
		    'result' => eval "sub { \$_[0] =~ s!\$_[1]!$result! }" });
        }
    }

    return $$cats{$node};
}

1;
