#!/usr/bin/env perl

##H Routing helper agent that issues transfer tasks.
##H
##H Usage:
##H   FileIssue -state DIRECTORY -db FILE[:SECTION] [-log OUT]
##H
##H -state     agent state directory
##H -db        database connection configuration parameter file
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileIssue (%args))->process();

######################################################################
# Routines for this agent.
package FileIssue; use strict; use warnings; use base 'UtilsAgent';
use List::Util qw(max);
use UtilsLogging;
use UtilsCatalogue;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My node name
		  WAITTIME => 60 + rand(10));	# Agent activity cycle
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my @nodes;

    eval
    {
	$$self{NODES} = [ '%' ];
	($dbh, @nodes) = &expandNodesAndConnect ($self, { "FileDownload" => 5400 });

	# Route files.
	$self->confirm($dbh);
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little rest
    $self->nap ($$self{WAITTIME});
}

sub confirm
{
    my ($self, $dbh) = @_;

    # Read links and their parameters.  Only consider links which
    # are "alive", i.e. have a live download agent at destination
    # and an export agent at the source.
    my %nodes;
    my $links = {};
    my $q = &dbexec($dbh, qq{
	select l.from_node, ns.name from_node_name,
	       l.to_node, nd.name to_node_name,
	       l.distance, l.is_local,
	       p.xfer_rate, p.xfer_latency,
	       xso.protocols, xsi.protocols
	from t_adm_link l
	  join t_adm_node ns on ns.id = l.from_node
	  join t_adm_node nd on nd.id = l.to_node
	  left join t_adm_link_param p
	    on p.from_node = l.from_node
	    and p.to_node = l.to_node
	  left join t_xfer_source xso
	    on xso.from_node = ns.id
	    and xso.to_node = nd.id
	    and xso.time_update >= :recent
	  left join t_xfer_sink xsi
	    on xsi.from_node = ns.id
	    and xsi.to_node = nd.id
	    and xsi.time_update >= :recent
	where (ns.kind = 'MSS' and nd.kind = 'Buffer')
	   or (ns.kind = 'Buffer' and nd.kind = 'MSS'
       	       and xsi.from_node is not null)
	   or (xso.from_node is not null
       	       and xsi.from_node is not null)},
	":recent" => &mytimeofday() - 5400);
    while (my ($from, $fromname, $to, $toname, $hops, $local, $rate, $latency,
	       $src_protos, $dest_protos) = $q->fetchrow())
    {
	$nodes{$to} = $toname;
	$$links{$from}{$to} = { HOPS => $hops,
				IS_LOCAL => $local eq 'y' ? 1 : 0,
				XFER_RATE => $rate,
			    	XFER_LATENCY => $latency,
			    	FROM_PROTOS => $src_protos,
			    	TO_PROTOS => $dest_protos };
    }

    # Now route for the nodes
    my $cats = {};
    foreach my $nodeid (sort keys %nodes)
    {
	$self->confirmNode($dbh, $nodeid, $links, $cats);
	$self->maybeStop();
    }

    if (%nodes)
    {
	&logmsg ("issued for @{[sort values %nodes]}");
    }
    else
    {
	&logmsg ("nothing to issue for");
    }
}

# Confirm transfers for one node.
sub confirmNode
{
    my ($self, $dbh, $node, $links, $cats) = @_;
    my $now = &mytimeofday();

    # Confirm transfers where I am the path hop destination, the
    # source replica exists and there is no transfer yet.
    my $q = &dbexec($dbh, qq{
	with files_for_me as
	  (select
	       xp.fileid, f.logical_name,
	       xp.from_node, ns.kind from_kind,
	       xp.to_node, xr.id replica,
	       min(xp.priority) priority, max(xp.is_local) is_local,
	       max(xp.time_expire) time_expire
	   from t_xfer_path xp
	     join t_xfer_replica xr
	       on xr.fileid = xp.fileid
	       and xr.node = xp.from_node
             join t_xfer_file f
	       on f.id = xp.fileid
	     join t_adm_node ns
	       on ns.id = xp.from_node
           where xp.to_node = :me
	     and xp.is_valid = 1
	     and xp.time_expire > :now
	   group by xp.fileid, f.logical_name,
		    xp.from_node, ns.kind,
		    xp.to_node, xr.id)
	select
	   fileid, logical_name, replica, from_node, from_kind, to_node,
	   2*priority + 1-is_local priority, time_expire
	from files_for_me ffm
	where not exists
	   (select 1 from t_xfer_task xt
	    where xt.fileid = ffm.fileid
	      and xt.to_node = ffm.to_node)
          and not exists
	   (select 1 from t_xfer_replica xr
	    where xr.fileid = ffm.fileid
	      and xr.node = ffm.to_node)},
	":me" => $node, ":now" => $now);

    my @tasks;
    while (my $task = $q->fetchrow_hashref())
    {
	$self->makeTransferTask($dbh, $task, $cats, $links);
	push(@tasks, $task);
    }

    my $rank = 0;
    my %iargs = ();
    my $istmt = &dbprep($dbh, qq{
	insert into t_xfer_task (id, fileid, from_replica, priority, rank,
	  from_node, to_node, from_pfn, to_pfn, time_expire, time_assign)
	values (seq_xfer_task.nextval, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)});
    foreach my $task (sort { $$a{PRIORITY} <=> $$b{PRIORITY}
		             || $$a{LOGICAL_NAME} cmp $$b{LOGICAL_NAME} }
		      @tasks)
    {
	my $n = 1;
	next if ! $$task{FROM_PFN};
	next if ! $$task{TO_PFN};
	push(@{$iargs{$n++}}, $$task{FILEID});
	push(@{$iargs{$n++}}, $$task{REPLICA});
	push(@{$iargs{$n++}}, $$task{PRIORITY});
	push(@{$iargs{$n++}}, $rank++);
	push(@{$iargs{$n++}}, $$task{FROM_NODE});
	push(@{$iargs{$n++}}, $$task{TO_NODE});
	push(@{$iargs{$n++}}, $$task{FROM_PFN});
	push(@{$iargs{$n++}}, $$task{TO_PFN});
	push(@{$iargs{$n++}}, $$task{TIME_EXPIRE});
	push(@{$iargs{$n++}}, $now);
    }

    &dbbindexec($istmt, %iargs) if %iargs;
    $dbh->commit();
}

# Expand transfer task information and insert into the database.
sub makeTransferTask
{
    my ($self, $dbh, $task, $cats, $links) = @_;
    my ($from, $to) = @$task{"FROM_NODE", "TO_NODE"};
    my @from_protos = split(/\s+/, $$links{$from}{$to}{FROM_PROTOS} || '');
    my @to_protos   = split(/\s+/, $$links{$from}{$to}{TO_PROTOS} || '');
    my $from_cat    = $self->catalogue($dbh, $cats, $from);
    my $to_cat      = $self->catalogue($dbh, $cats, $to);
    my $protocol    = undef;

    # Find matching protocol.
    foreach my $p (@to_protos)
    {
	next if ! grep($_ eq $p, @from_protos);
	$protocol = $p;
	last;
    }

    # If this is MSS->Buffer transition, pretend we have a protocol.
    $protocol = 'srm' if ! $protocol && $$task{FROM_KIND} eq 'MSS';

    # Check that we have prerequisite information to expand the file names.
    return if (! $from_cat
	       || ! $to_cat
	       || ! $$links{$from}
	       || ! $$links{$from}{$to}
	       || ! $protocol
	       || ! $$from_cat{$protocol}
	       || ! $$to_cat{$protocol});

    # Try to expand the file name.
    $$task{FROM_PFN} = &applyStorageRules($from_cat, $protocol, $to, 'pre', $$task{LOGICAL_NAME});
    $$task{TO_PFN}   = &applyStorageRules($to_cat, $protocol, $from, 'pre', $$task{LOGICAL_NAME});
}

# Build and cache storage mapping catalogue for a node.
sub catalogue
{
    my ($self, $dbh, $cats, $node) = @_;

    # If we haven't yet built the catalogue, fetch from the database.
    if (! exists $$cats{$node})
    {
        $$cats{$node} = {};

        my $q = &dbexec($dbh, qq{
	    select protocol, chain, destination_match, path_match, result_expr
	    from t_xfer_catalogue
	    where node = :node and rule_type = 'lfn-to-pfn'
	    order by rule_index asc},
	    ":node" => $node);

        while (my ($proto, $chain, $dest, $path, $result) = $q->fetchrow())
        {
	    # Check the pattern is valid.  If not, abort.
            my $pathrx = eval { qr/$path/ };
	    return $$cats{$node} = {} if $@;

            my $destrx = defined $dest ? eval { qr/$dest/ } : undef;
	    return $$cats{$node} = {} if $@;

	    # Add the rule to our list.
	    push(@{$$cats{$node}{$proto}}, {
		    (defined $chain ? ('chain' => $chain) : ()),
		    (defined $dest ? ('destination-match' => $destrx) : ()),
		    'path-match' => $pathrx,
		    'result' => eval "sub { \$_[0] =~ s!\$_[1]!$result! }" });
        }
    }

    return $$cats{$node};
}

1;
