#!/usr/bin/env perl

## Maintain links between a parent node and its neighbours, and
## maintain routing information for agents operating under the
## same parent node.
##
## This agent implements a version of the Routing Internet Protocol
## algorithm (RFC 2543).

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args = (DBITYPE => "Oracle", WAITTIME => 600);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $master = 1; $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBNAME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbi' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBITYPE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbuser' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBUSER} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbpass' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBPASS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-nodes' && scalar @ARGV > 1)
    { shift (@ARGV); $args{NODES} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-infinity' && scalar @ARGV > 1)
    { shift (@ARGV); $args{INFINITY} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-timeout' && scalar @ARGV > 1)
    { shift (@ARGV); $args{TIMEOUT} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dryrun')
    { shift (@ARGV); $args{DRYRUN} = 1; }
    elsif ($ARGV[0] eq '-once')
    { shift (@ARGV); $args{ONCE} = 1; }
    else
    { last; }
}

if (scalar @ARGV || !$args{DROPDIR} || !$args{DBNAME} || !$args{DBUSER}
    || !$args{DBPASS} || !$args{DBITYPE} || !$args{NODES})
{
    print STDERR
	"usage: $me -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
	"    -nodes TMDB-NODE[,NODE...] -state IN-DROP-BOX [-wait SECS-TO-WAIT]\n",
	"    [-infinity MAX-DISTANCE] [-timeout MAX-LINK-AGE] [-dryrun] [-once]\n";
    exit (1);
}

my $agent = new NodeRouter (%args);
# Recapture interrupt signal, oracle swallows it.
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop (); };
$agent->process ();

######################################################################
# Routines for this agent.
package NodeRouter; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBITYPE => undef,		# Database driver binding
    		  DBNAME => undef,		# Database name
	  	  DBUSER => undef,		# Database user name
	  	  DBPASS => undef,		# Database user password
		  MYNODE => undef,		# My TMDB node (temporary)
		  NODES => undef,		# Nodes to process
		  INFINITY => 1000,		# Infinite distance
		  TIMEOUT => 0,			# Route time out
		  DRYRUN => 0,			# Prevent database updates
		  ONCE => 0,			# Quit after one run
	  	  AGENTID => "Routing");	# Identity for activity logs
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub refreshNeighbourLinks
{
    my ($self, $dbh) = @_;
    &dbexec($dbh, qq{
	update t_routing set timestamp = :now
	where to_node = :node and gateway = :node},
	":now" => &mytimeofday(), ":node" => $self->{MYNODE});
}

sub updateTable
{
    my ($self, $dbh, $routes) = @_;
    my $mynode = $self->{MYNODE};
    foreach my $route (@$routes)
    {
	my ($from, $to, $time, $hops, $status) = split (":", $route);
	if ($status eq "I")
	{
	    &dbexec($dbh, qq{
		insert into t_routing
		(timestamp, from_node, to_node, gateway, hops)
		values (:timestamp, :from_node, :to_node, :gateway, :hops)},
		":timestamp" => $time,
		":from_node" => $mynode,
		":to_node" => $to,
		":gateway" => $from,
		":hops" => $hops);
	}
	else
	{
	    &dbexec($dbh, qq{
		update t_routing
		set timestamp = :timestamp,
		    gateway = :gateway,
		    hops = :hops
		where from_node = :from_node
		  and to_node = :to_node},
		":timestamp" => $time,
  		":gateway" => $from,
		":hops" => $hops,
		":from_node" => $mynode,
		":to_node" => $to);
	}
    }
}

sub getNewRoutes
{
    my ($self, $dbh) = @_;

    # Get all routes
    my %routes = ();
    my $query = &dbexec($dbh, qq{
	select from_node, to_node, gateway, timestamp, hops from t_routing});
    while (my ($from, $to, $gateway, $stamp, $hops) = $query->fetchrow())
    {
	$from =~ s/\s+//g; $to =~ s/\s+//g;
	$routes{$from}{$to}
	    = { GATEWAY => $gateway, HOPS => $hops, STAMP => $stamp };
    }

    # Build the list of routes we want to process.  First get our immediate
    # neighbours: routes with from=me and to=gateway.  Then obtain the routes
    # for all those immediate neighbours, excluding routes with myself as the
    # destination.  Finally prune out routes we have already established and
    # which are still valid.
    my @new = ();
    my $mynode = $self->{MYNODE};
    my @neighbours = grep ($routes{$mynode}{$_}{GATEWAY} eq $_,
	    		   keys %{$routes{$mynode}});
    foreach my $from (@neighbours)
    {
	foreach my $to (keys %{$routes{$from}})
	{
	    my $gateway = $routes{$from}{$to}{GATEWAY};
	    my $stamp = $routes{$from}{$to}{STAMP};
	    my $hops = $routes{$from}{$to}{HOPS}
	    	       + $routes{$mynode}{$from}{HOPS};

	    next if $to eq $mynode;
	    next if (exists $routes{$mynode}{$to}
		     && $routes{$mynode}{$to}{GATEWAY} eq $from
		     && $routes{$mynode}{$to}{HOPS} eq $hops
		     && $routes{$mynode}{$to}{STAMP} eq $stamp);

	    # Handle split horizon with poisoned reverse.  Split horizon
	    # means that routes with myself as the gateway are ignored.
	    # Split horizon with poisoned reverse means such routes are
	    # accepted, but the number of hops is set to infinity.
	    $hops = $self->{INFINITY} if $gateway eq $mynode;
	    push (@new, "$from:$to:$stamp:$hops");
	}
    }

    return @new;
}

sub getMyRouteHash
{
    my ($self, $dbh) = @_;
    my %table = ();
    my $query = &dbexec($dbh, qq{
	select gateway, to_node, timestamp, hops from t_routing
	where from_node = :node}, ":node" => $self->{MYNODE});

    while (my @row = $query->fetchrow_array())
    {
        map { s/\s+//g; $_ } @row;
	&alert ("multiple routes from $self->{MYNODE} to $row[1]") if exists $table{$row[1]};
        $table{$row[1]} = "$row[0]:$row[2]:$row[3]:U";
    }

    return %table;
}

sub compareWithExistingRoutes
{
    my ($self, $dbh, $new_routes) = @_;
    my %gate_time_hops_by_dest = $self->getMyRouteHash ($dbh);
    my $new_gate_time_hops;

    my $new_time = &mytimeofday();
    foreach my $route (@$new_routes)
    {
	my ($new_gate,$new_to,$dummy_time,$new_hops) = split (/:/,$route);
	$new_gate_time_hops = "$new_gate:$new_time:$new_hops";
	if (exists $gate_time_hops_by_dest{$new_to})
	{
	    $new_gate_time_hops = $new_gate_time_hops.":U";
	    my ($gate,$time,$hops) = split ( /:/,$gate_time_hops_by_dest{$new_to} );
	    $gate_time_hops_by_dest{$new_to} = $new_gate_time_hops
	        if (($gate eq $new_gate) || ($new_hops < $hops)); # replace blindly OR minimise
	}
	else
	{
	    &logmsg ("new route found $self->{MYNODE} $route");
	    $new_gate_time_hops = $new_gate_time_hops.":I"; 
	    $gate_time_hops_by_dest{$new_to} = $new_gate_time_hops;
	}
    }

    # timeout routes, check infinity
    foreach my $dest (keys %gate_time_hops_by_dest)
    {
	my ($gate,$time,$hops,$status) = split (/:/,$gate_time_hops_by_dest{$dest});
	my $infinity = $self->{INFINITY};
	my $check = &mytimeofday() - $self->{TIMEOUT};
	$hops = $infinity if $hops > $infinity;
	if ($time < $check && $self->{TIMEOUT} != 0)
	{
	    $hops = $self->{INFINITY};
	    # trigger update if it's a neighbour timeout
	    # easy for us as we can pass the update message to
	    # everyone in the network at the same time
	    $dbh->do(qq{
		update t_routing set hops = :infinity where to_node = :dest},
		":infinity" => $infinity, ":dest" => $dest);
	    &warning ("route timed out: $gate:$dest:$time:$hops:$status");
	}
	$gate_time_hops_by_dest{$dest} = "$gate:$time:$hops:$status";
    }

    # Build complete merged table
    my @routes = ();
    foreach my $destination (keys %gate_time_hops_by_dest)
    {
        my ($gate, $time, $hops, $status) = split (/:/, $gate_time_hops_by_dest{$destination});
        my $route = "$gate:$destination:$time:$hops:$status";
        push (@routes, $route);
    }
    return @routes;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    # Always mark all files ready to go immediately.
    eval
    {
	foreach my $node (split(/,/, $self->{NODES}))
	{
	    $self->{MYNODE} = $node;
	    $dbh = &connectToDatabase ($self) or die "failed to connect";

            $self->refreshNeighbourLinks ($dbh);
            my @new_routes = $self->getNewRoutes ($dbh);
            my @all_routes = $self->compareWithExistingRoutes ($dbh, \@new_routes);
            $self->updateTable ($dbh, \@all_routes);
	    $dbh->commit();
	    &disconnectFromDatabase ($self, $dbh);
	}

	$self->{MYNODE} = undef;
    };
    do { &alert ("database error: $@"); $dbh->rollback() if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);
    $self->{MYNODE} = undef;

    # Check children are still running and then wait
    &touch ($self->{STOPFLAG}) if $self->{ONCE};
    $self->nap ($self->{WAITTIME});
}
