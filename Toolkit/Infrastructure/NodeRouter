#!/usr/bin/perl

# Node Routing Agent
#
# This agent is responsible for making links between its parent
# and neighbour nodes, and maintaining routing information for 
# agents operating under the same parent node.
#
# The agent implements a version of the Routing Internet Protocol
# algorithm (RFC 2543), detailed in X.
#
# Command line options
# -name	<parent node>	parent node name
# -db <tns name>		sets the Oracle db to talk to
# -w <workdir>			sets the workdir for the agent
# -no-updates			disables database updates
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# The agent determines who its neighbours are from the routing
# table. It then refreshes its entry in its neighbours routing
# information to maintain the link. It then compares the routing
# information of each of its neighbours with its own, and modifies
# it accordingly ( a hard bit ).

use DBI;
use Getopt::Long;
$| = 1; # set autoflush

my $g_no_updates;		# 1 means will not make final updates in tmdb
my $g_work_dir = '';	# place pid and stop files here...
my $g_db = "devdb9";	# tnsname of Oracle db (tmdb)
my $g_db_user;			# Oracle user
my $g_db_passwd;		# Oracle password
my $g_parent_node = 'default_parent';		# parent node name
my $g_once;				# 1 means will only run once
my @g_known_routes = ();        # routes that this node knows about 

# ###############################################################
# Main agent loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system("touch $g_work_dir/stop"); }
    
    my @g_known_routes = &get_routes_for_node( $g_parent_node );

    foreach $neighbour (&get_neighbours) {
	refresh_acquaintance( $neighbour );

	my @neighbours_routes = &get_routes_for_node( $neighbour );
	my @neighbours_routes = &increment_hops( \@neighbours_routes );

	my @routes_to_update = &get_shared_routes( \@neighbours_routes );
	my @routes_to_insert = &get_new_routes( \@neighbours_routes );
	if (@routes_to_insert) { log_entry( "Found new routes" ); &display_routing_table( \@routes_to_insert ); }
	my @route_to_clean = &get_dead_routes( \@neighbours_routes );
	if (@routes_to_clean) { log_entry( "Found dead routes" ); &display_routing_table( \@routes_to_clean ); }
    }
}





# ###############################################################
# Non-agent specific subroutines
# ###############################################################
sub log_entry {
    my $entry = shift;
    my $localtime = localtime(time());
    print "$localtime: $entry\n";
}

sub publish_availability {
	my %args = (
		NODE => 'default_node_label',
		AGENT => 'default_agent_label',	
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		@_
	);
	my $time = time();

	$return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'$args{DB_USER}', 
						 	'$args{DB_PASSWD}', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$log = "update t_Lookup "
			."set last_contact=$time "
			."where agent='$args{AGENT}' "
			."and node='$args{NODE}'";
	$return = $dbh->do($log);

	$return = $dbh->disconnect();
}

sub direct_db_transaction {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		SQL => 'some_sql',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$dbh->do($args{SQL});
	
	$dbh->disconnect();
}

# ###############################################################
# Subroutines
# ###############################################################
sub refresh_acquaintance {
    my $neighbour = shift;
    my $time = time();
    my $update = "update t_Routing "
	."set timestamp = $time "
	."where from_node = '$neighbour' "
	."and to_node = '$g_parent_node' "
	."and gateway = '$g_parent_node'";
    direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
}

sub display_routing_table {
    my $table = shift;
    foreach $route (@$table) {
        log_entry( "$route" );
    }

}

sub get_shared_routes {
    my $table = shift;
    my @shared_routes = ();
    foreach $my_route (@g_known_routes) {
	my ($my_from, $my_to, $my_gate, $my_time, $my_hops) = &split_route( $my_route ); 
	foreach $other_route (@$table) {
	    my ($from, $to, $gate, $time, $hops) = &split_route( $other_route );
	    if ($to eq $my_to && $from eq $my_gate) {
		# TODO: Here we just say we have a match. At some stage we might need to determine
		# whether one route is shorter, older...?
		push( @shared_routes, $my_route );
	    }
	}
    }
    return @shared_routes;
}

sub get_new_routes {
    my $table = shift;
    my @new_routes = ();
    my $new_flag = 1;
    foreach $other_route (@$table) {
	my ($from, $to, $gate, $time, $hops) = &split_route( $other_route );
	foreach $my_route (@g_known_routes) {
	    my ($my_from, $my_to, $my_gate, $my_time, $my_hops) = &split_route( $my_route );
	    $new_flag = 0 if ($to eq $my_to && $from eq $my_gate); 
	}
	push( @new_routes, $other_route ) if ($new_flag == 1 && $to ne $g_parent_node);
    }
    return @new_routes;
}

sub get_dead_routes {
    my $table = shift;
    my @dead_routes = ();
    my $dead_flag = 0;
    foreach $my_route (@g_known_routes) {
        my ($my_from, $my_to, $my_gate, $my_time, $my_hops) = &split_route( $my_route );
        foreach $other_route (@$table) {
            my ($from, $to, $gate, $time, $hops) = &split_route( $other_route );
	    $dead_flag = 1 if ($to eq $my_to && $from eq $my_gate);
	}
	push( @dead_routes, $my_route ) if ($dead_flag == 1);
    }
    return @dead_routes;
}


sub split_route {
    my $route = shift;
    my ($to_node,$gateway,$timestamp,$hops) = split( ":", $route ); 
}

sub increment_hops {
    my $table = shift;
    
    foreach $route (@$table) {
	@bits = &split_route( $route );
	@bits[4]++;
	$route = join( ":",@bits );
	push( @new_table, $route );
    }
    return @new_table;
}

sub get_routes_for_node {
    my $node = shift;
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });
    
    my $selection = "select from_node,to_node,gateway,timestamp,hops "
        ."from t_Routing "
        ."where from_node = '$node'";
    my @routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }
        push(@routes,join(':',@row));
    }
    $query->finish();

    $dbh->disconnect();

    return @routes;
}

sub get_neighbours {
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
			    "$g_db_user", 
			    "$g_db_passwd", 
			    { RaiseError=>1, AutoCommit =>1 });
    
    my @neighbours = ();
    my $selection = "select gateway "
	."from t_Routing "
	."where from_node = '$g_parent_node' "
	."and to_node = gateway";
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
	$row[0] =~ s/ //g;
	push(@neighbours,@row[0]);
    }
    $query->finish();
    
    $dbh->disconnect();
    
    return @neighbours;	
}

sub parse_command_line {
    GetOptions(	'name=s' => \$g_parent_node,
		'w=s' => \$new_work_dir,
		'db=s' => \$g_db,
		'dbuser=s' => \$g_db_user,
		'dbpasswd=s' => \$g_db_passwd,
		"no-updates" => \$g_no_updates,
		"once" => \$g_once
		);
    
    if ($g_once) {
	log_entry( "only running once" );
    }
    if ($g_parent_node) {
	log_entry( "parent node is $g_parent_node" );
    }
    if (!$new_work_dir) {
	$g_work_dir = ".";
    } else {
	$g_work_dir = $g_work_dir.$new_work_dir;
    }
    log_entry( "work dir is $g_work_dir" );
    if (-e "$g_work_dir/pid") {
	log_entry( "Removing old pid file");
	unlink("$g_work_dir/pid");
    } 
    if (-e "$g_work_dir/stop") {
	log_entry( "Removing old stop file" );
	unlink ("$g_work_dir/stop");
    }
    if (!$g_db) {
	$g_db = "devdb9";
    }
    log_entry( "database is $g_db" );
    if ($g_no_updates) {
	log_entry( "not making final updates " );
    }	
    
    log_entry( "Following arguments unprocessed by Getopt::Long" ) if $ARGV[0];
    foreach (@ARGV) {
	log_entry( "$_" );
    }
}
