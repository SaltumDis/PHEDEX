#!/usr/bin/perl

# Node Routing Agent
#
# This agent is responsible for making links between its parent
# and neighbour nodes, and maintaining routing information for 
# agents operating under the same parent node.
#
# The agent implements a version of the Routing Internet Protocol
# algorithm (RFC 2543).
#
# Command line options
# -node	<parent node>	parent node name
# -db <tns name>		sets the Oracle db to talk to
# -w <workdir>			sets the workdir for the agent
# -no-updates			disables database updates
# -once                 only runs once
# -period               period over which the agent will loop
# -infinity             max expected route length
# -timeout              timeout routes after this many sec
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.

use DBI;
use Getopt::Long;
$| = 1; # set autoflush

$g_no_updates;		# 1 means will not make final updates in tmdb
$g_work_dir = '';	# place pid and stop files here...
$g_db = "devdb9";	# tnsname of Oracle db (tmdb)
$g_db_user;			# Oracle user
$g_db_passwd;		# Oracle password
$g_parent_node = 'default_parent';		# parent node name
$g_once;				# 1 means will only run once
$g_period = 1;              # time between iterations
$g_infinity = 10;            # maximum expected route length
$g_timeout = 180;           # route timeout, secs

# ###############################################################
# Main agent loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system("touch $g_work_dir/stop"); }
    my $start = time();
    
    # TODO: publish availability

    &refresh_neighbour_links;

    @new_routes = &get_new_routes;
    @all_routes = &compare_with_existing_routes( \@new_routes  );
    &update_table( \@all_routes );

    my $pause = $g_period - (time() - $start);
    sleep($pause);
}





# ###############################################################
# Non-agent specific subroutines
# ###############################################################
sub log_entry {
    my $entry = shift;
    my $localtime = localtime(time());
    print "$localtime [$$]: $entry\n";
}

sub publish_availability {
	my %args = (
		NODE => 'default_node_label',
		AGENT => 'default_agent_label',	
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		@_
	);
	my $time = time();

	$return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'$args{DB_USER}', 
						 	'$args{DB_PASSWD}', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$log = "update t_Lookup "
			."set last_contact=$time "
			."where agent='$args{AGENT}' "
			."and node='$args{NODE}'";
	$return = $dbh->do($log);

	$return = $dbh->disconnect();
}

sub direct_db_transaction {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		SQL => 'some_sql',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$dbh->do($args{SQL});
	
	$dbh->disconnect();
}

# ###############################################################
# Subroutines
# ###############################################################
sub refresh_neighbour_links {
    my $time = time();
    my $update = "update t_Routing "
	."set timestamp = $time "
	."where to_node = '$g_parent_node' "
	."and gateway = '$g_parent_node'";
    direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
}

sub update_table {
    my $routes = shift;
    foreach $route (@$routes) {
	my ($from, $to, $time, $hops, $status) = split( ":", $route );
	my $sql = "";
	if ($status eq "I") {
	    $sql = "insert into t_Routing "
		."values ('$g_parent_node','$to','$from',$time,$hops)";
	} else {
	    $sql = "update t_Routing "
		."set gateway = '$from', "
		."timestamp = $time, "
		."hops = $hops "
		."where from_node = '$g_parent_node' "
		."and to_node = '$to'";
	}
	direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $sql );
    }
}

sub get_new_routes {
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });

    my $selection = "select from_node,to_node,timestamp,hops from t_Routing "
	."where from_node in (select from_node from t_Routing where to_node = '$g_parent_node' and gateway = '$g_parent_node') "
	."and not to_node = '$g_parent_node' "
	."minus "
	."select gateway,to_node,timestamp,hops-1 from t_Routing "
	."where from_node = '$g_parent_node'";

    my @new_routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }
	$row[3]++;

	# Here we handle split horizon with poisoned reverse
	# Split horizon means that if we detect a route for
	# which we are the gateway, we ignore it. Split 
	# horizon with poisoned reverse means that we accept
	# routes through us, but set the number of hops to
	# "infinity".
	if ($row[0] eq $g_parent_node) {
	    $row[3] = $g_infinity;
	} else {
	    push( @new_routes, join( ":",@row ) );
	}

    }
    $query->finish();
    $dbh->disconnect();

    return @new_routes;
}

sub clear_my_table {
    my $neighbour = shift;
    my $time = time();
    my $update = "delete from t_Routing "
	."where from_node = '$g_parent_node' ";
    direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
}

sub get_my_route_hash {
    my $selection = "select gateway,to_node,timestamp,hops from t_Routing "
        ."where from_node = '$g_parent_node'";
    my %gate_time_hops_by_dest = ();

    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }
        if (exists $gate_time_hops_by_dest{$row[1]} ){ log_entry( "Something wrong in routing: multiple entries for $row[1] \
under $g_parent_node table!" ); }
        my $gate_time_hops;
        $gate_time_hops_by_dest{$row[1]} = "$row[0]:$row[2]:$row[3]:U";
    }
    $query->finish();
    $dbh->disconnect();

    return %gate_time_hops_by_dest;
}

sub compare_with_existing_routes {
    my $new_routes = shift;
    my $new_gate_time_hops;
    my %gate_time_hops_by_dest = &get_my_route_hash();

    my $new_time = time();
    foreach $route (@$new_routes) {
	my ($new_gate,$new_to,$dummy_time,$new_hops) = split( /:/,$route );
	$new_gate_time_hops = "$new_gate:$new_time:$new_hops";
	if (exists $gate_time_hops_by_dest{$new_to}) {
	    $new_gate_time_hops = $new_gate_time_hops.":U";
	    my ($gate,$time,$hops) = split ( /:/,$gate_time_hops_by_dest{$new_to} );
	    if (($gate eq $new_gate) || ($new_hops < $hops)) { # replace blindly OR minimise
		$gate_time_hops_by_dest{$new_to} = $new_gate_time_hops;
	    } 
	} else {
	    log_entry( "New route found $route" );
	    $new_gate_time_hops = $new_gate_time_hops.":I"; 
	    $gate_time_hops_by_dest{$new_to} = $new_gate_time_hops;
	}
    }

    # timeout routes
    foreach $dest (keys %gate_time_hops_by_dest) {
	my ($gate,$time,$hops,$status) = split( /:/,$gate_time_hops_by_dest{$dest} );
	my $check = time() - $g_timeout;
	if ($time < $check) {
	    $hops = $g_infinity;
	    log_entry( "Timeout for $gate:$dest:$time:$hops:$status" );
	}
	$gate_time_hops_by_dest{$dest} = "$gate:$time:$hops:$status";
    }

    # Build complete merged table
    my @routes = ();
    foreach $destination (keys %gate_time_hops_by_dest) {
        my ($gate, $time, $hops, $status) = split( /:/, $gate_time_hops_by_dest{$destination} );
        my $route = "$gate:$destination:$time:$hops:$status";
        push( @routes, $route );
    }
    return @routes;
}

sub min {
    my ($a, $b) = @_;
    if ($a >= $b) { return $b; } else { return $a; }
}

sub parse_command_line {
    GetOptions(	'node=s' => \$g_parent_node,
		'w=s' => \$new_work_dir,
		'db=s' => \$g_db,
		'dbuser=s' => \$g_db_user,
		'dbpasswd=s' => \$g_db_passwd,
		"no-updates" => \$g_no_updates,
		"once" => \$g_once,
		"period=s" => \$g_period,
		"infinity=s" => \$g_infinity,
		"timeout=s" => \$g_timeout
		);
    
    if ($g_once) {
	log_entry( "only running once" );
    }
    if ($g_timeout) {
	log_entry( "will timeout routes after $g_timeout s" );
    }
    if ($g_period) {
        log_entry( "loop period is $g_period" );
    }
    if ($g_infinity) {
        log_entry( "max expected route length is $g_infinity" );
    }
    if ($g_parent_node) {
	log_entry( "parent node is $g_parent_node" );
    }
    if (!$new_work_dir) {
	$g_work_dir = ".";
    } else {
	$g_work_dir = $g_work_dir.$new_work_dir;
    }
    log_entry( "work dir is $g_work_dir" );
    if (-e "$g_work_dir/pid") {
	log_entry( "Removing old pid file");
	unlink("$g_work_dir/pid");
    } 
    if (-e "$g_work_dir/stop") {
	log_entry( "Removing old stop file" );
	unlink ("$g_work_dir/stop");
    }
    if (!$g_db) {
	$g_db = "devdb9";
    }
    log_entry( "database is $g_db" );
    if ($g_no_updates) {
	log_entry( "not making final updates " );
    }	
    
    log_entry( "Following arguments unprocessed by Getopt::Long" ) if $ARGV[0];
    foreach (@ARGV) {
	log_entry( "$_" );
    }
}
