#!/usr/bin/env perl

##H NodeRouter
##H
##H Creates minimum spanning trees for given nodes, then uses trees to
##H fill the routing table. Uses Dijkstra's algorithm to determine 
##H shortest-path tree from a given source node.
##H
##H All hop information is taken from t_node_neighbour (which acts as
##H an adjacency list), and complete, current routes are determined in 
##H a single iteration-- therefore this approach should remove the
##H dependency on convergence that we see when using other iterative
##H algorithms.
##H
##H      -state DIRECTORY -node NAME -nodes PATTERN[,PATTERN...]
##H      -db FILE[:SECTION] [-wait SECS]
##H
##H -state     agent state directory
##H -node      the node where this agent runs
##H -nodes     comma-separated list of node name patterns to route for;
##H            pattern wildcards are '%' (any string) and '_' (any character)
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
use UtilsHelp;
my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MYNODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-nodes' && scalar @ARGV > 1)
    { shift (@ARGV); push(@{$args{NODES}}, split(/,/, shift(@ARGV))); }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

if (@ARGV || !$args{DROPDIR} || !$args{MYNODE} || !$args{NODES} || !$args{DBCONFIG})
{
    die "Insufficient (or unknown: @ARGV) parameters, use -h for help.\n";
}

(new DijkstraNodeRouter (%args))->process();

######################################################################
# Routines for this agent.
package DijkstraNodeRouter; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My node name
		  NODES => [],			# Nodes to route for
		  INFINITY => 1000,		# Avoid replicas this far away
	  	  AGENTID => "Routing");       	# Identity for activity logs
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	# Connect to the database.
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	foreach my $source ( @{$self->{NODES}} ) 
	{
	    my %distance = ();
	    my %precedent = ();
	    my %seen = ();
	    my %todo = ();

	    $todo{ $source } = 1;
	    $distance{ $source } = 0;

	    while ( keys %todo )
	    {
		# First we need to find the closest node to this node
		# of all the currently known nodes
		my $infinity = 999999;
		my $closest = $infinity;
		my $closestNode = '';
		foreach my $n ( keys %todo )
		{
		    if ( $distance{ $n } < $closest )
		    {
			$closest = $distance{ $n };
			$closestNode = $n;
		    }
		}
		delete $todo{ $closestNode };
		$seen{ $closestNode } = 1;

		# Now we need to find the neighbours of the current node,
		# Additionally, we can ignore nodes here whose
		# NodeRouters aren't currently up--
		my %neighbours = ();
		my $now = &mytimeofday();
		my $query = &dbexec( $dbh,
                                     qq{select n.neighbour,n.hops 
					    from t_node_neighbour n, 
					    t_agent_status s 
					where n.node = :node
					and n.neighbour = s.node 
					and s.agent = 'Routing' 
					and s.timestamp > :limit},
				     ":node" => $closestNode,
				     ":limit" => $now - (15 * 60) );

		while ( my @row = $query->fetchrow_array() )
		{
		    $neighbours{ $row[0] } = $row[1];
		}
		my @tempNeighbours = keys %neighbours;

		# Now we 'relax' our neighbours-- basically we compare
		# currently known distance with the newly calculated one
		# and minimise
		foreach my $neighbour ( keys %neighbours )
		{
		    if ( ! exists $seen{ $neighbour } )
		    {
			# If $neighbour is new then it's not in
			# %todo or %seen;  we set the distance to inf
			if ( ! exists $todo{ $neighbour } )
			{
			    $distance{ $neighbour } = $infinity;
			}

			if ( $distance{ $neighbour } > 
			     $distance{ $closestNode } + 
			     $neighbours{ $neighbour } )
			{
			    $distance{ $neighbour } =
				$distance{ $closestNode } +
				$neighbours{ $neighbour };
			    $precedent{ $neighbour } = $closestNode;
			    $todo{ $neighbour } = 1;
			}
		    }
		}
	    }
	
	    # At this stage we have the minimum spanning
	    # tree for this node. Need to work out gateway for each
	    # by cycling back through precedents
	    my %gateway = ();
	    delete $distance{ $source };
	    foreach my $node ( keys %distance )
	    {
		my $gate = $node;
		if ( $precedent{$gate} ne $source )
		{
		    $gate = $precedent{$gate};
		}
		$gateway{ $node } = $gate;
		&logmsg( "$source $node $gateway{$node} $distance{$node}" );
	    }
	    
	    # FIXME: the only thing remaining to do is actually put
	    # this into the database. Check to see if the route exists
	    # already, and either insert or update
	    my %established = ();
	    my $query = &dbexec($dbh, qq{select to_node 
					     from t_routing
					     where from_node = :node},
				":node" => $source);
	    while (my ($to) = $query->fetchrow())
	    {
		$to =~ s/\s+//g; 
		if ( $distance{ $to } ) {
		    $established{ $to } = 1;
		}
	    }
	    
	    my $time = &mytimeofday();
	    foreach my $to ( keys %distance ) 
	    {
		&dbexec($dbh, qq{ select * from t_routing
				      where from_node = :from_node 
				      for update},
			":from_node" => $source);
		if ( ! exists $established{$to} ) {
		    &dbexec($dbh, qq{ insert into t_routing 
					  (timestamp,from_node,
					   to_node,gateway,hops) 
					  values 
					  (:time,:from_node,:to_node,
					   :gate,:hops)},
			    ":time" =>$time,
			    ":from_node" => $source,
			    ":to_node" => $to,
			    ":gate" => $gateway{ $to },
			    ":hops" => $distance{ $to });
		} else {
		    &dbexec($dbh, qq{ update t_routing 
					  set timestamp = :now, 
					  hops = :hops, 
					  gateway = :gate
					  where to_node = :to_node 
					  and from_node = :from_node},
			    ":now" => $time,
			    ":to_node" => $to,
			    ":from_node" => $source,
			    ":gate" => $gateway{ $to },
			    ":hops" => $distance{ $to });
		    &logmsg( "Found FROM $source TO $to VIA $gateway{$to} HOPS $distance{$to}" );
		}
		
#		$dbh->commit();
	
	    }
	}

        undef $self->{STMT_CACHE};

	$self->maybeStop();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Check children are still running and then wait
    $self->nap ($self->{WAITTIME});
}
