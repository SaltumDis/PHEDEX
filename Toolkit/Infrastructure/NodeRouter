#!/usr/bin/env perl

##H Maintain routing links between a node and its neighbours, and routing
##H vectors for visible horizon.  The routing table info is used by other
##H agents working at the same node.
##H
##H This agent implements a version of the Routing Internet Protocol
##H algorithm (RFC 2543).
##H
##H Usage:
##H   NodeRouter
##H      -state DIRECTORY -nodes NAME[,NAME...] [-infinity MAX-DISTANCE]
##H      [-timeout MAX-LINK-AGE] [-dryrun] [-once]
##H      -db FILE[:SECTION] [-wait SECS]
##H
##H -state     agent state directory
##H -nodes     comma-separated list of the node names to maintain routes for
##H -infinity  maximum route distance, used to mark bad routes (default: 1000)
##H -timeout   limit in seconds for dead routes (default: 1800; 0 = no timeout)
##H -dryrun    run the algorithm but do not change the database
##H -once      run the alogrithm once, then quit -- don't go into daemon mode
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
use UtilsHelp;
my %args = (WAITTIME => 600, TIMEOUT => 1800);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-nodes' && scalar @ARGV > 1)
    { shift (@ARGV); $args{NODES} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-infinity' && scalar @ARGV > 1)
    { shift (@ARGV); $args{INFINITY} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-timeout' && scalar @ARGV > 1)
    { shift (@ARGV); $args{TIMEOUT} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dryrun')
    { shift (@ARGV); $args{DRYRUN} = 1; }
    elsif ($ARGV[0] eq '-once')
    { shift (@ARGV); $args{ONCE} = 1; }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

if (@ARGV || !$args{DROPDIR} || !$args{NODES} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new NodeRouter (%args))->process();

######################################################################
# Routines for this agent.
package NodeRouter; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My TMDB node (temporary)
		  NODES => undef,		# Nodes to process
		  INFINITY => 1000,		# Infinite distance
		  TIMEOUT => 0,			# Route time out
		  DRYRUN => 0,			# Prevent database updates
		  ONCE => 0,			# Quit after one run
	  	  AGENTID => "Routing");	# Identity for activity logs
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

sub refreshNeighbourLinks
{
    my ($self, $dbh) = @_;
    my $mynode = $self->{MYNODE};
    my %distances = ();

    # First cache our _fixed_ neighbour routes- redo every time in case something
    # changes. These are used to recover correct hop link values after a failure
    my $query = &dbexec($dbh, qq{
	select neighbour, hops from t_node_neighbour where node = :me},
	":me" => $mynode);
    while (my ($neighbour, $hops) = $query->fetchrow())
    {
	$neighbour =~ s/\s+//g;
	$distances{$neighbour} = $hops;
    }

    # Now I need to lock my and my neighbours' tables
    my $sql = "select * from t_routing where from_node = '$mynode' ";
    foreach my $neighbour ( keys %distances ) {
	$sql .= "or from_node = '$neighbour' ";
    }
    $sql .= " for update";

    # We need to check to see if a direct route is already there
    my %established = ();
    $query = &dbexec($dbh, qq{
        select from_node, to_node, gateway, timestamp, hops from t_routing});
    while (my ($from, $to, $gateway, $stamp, $hops) = $query->fetchrow())
    {
        $from =~ s/\s+//g; $to =~ s/\s+//g;
	if ( $to eq $mynode && exists $distances{$from} ) {
	    $established{$from} = 1;
	}
    }

    # Now for every neighbour, refresh our link. Check to see if a link exists first!
    my $time = &mytimeofday();
    foreach my $neighbour ( keys %distances ) {
	if ( ! exists $established{$neighbour} ) {
	    &dbexec($dbh, qq{
		insert into t_routing
		    (timestamp,from_node,to_node,gateway,hops)
		    values
		    (:time,:neighbour,:me,:me,:hops)},
		    ":time" =>$time,
		    ":neighbour" => $neighbour,
		    ":me" => $mynode,
		    ":hops" => $distances{$neighbour});
	} else {
	    &dbexec($dbh, qq{
		update t_routing set timestamp = :now, hops = :hops
		    where to_node = :to_node and gateway = :to_node and from_node = :from_node},
		    ":now" => $time,
		    ":to_node" => $mynode,
		    ":from_node" => $neighbour,
		    ":hops" => $distances{$neighbour});
	}
    }
    $dbh->commit();
}

sub updateTable
{
    my ($self, $dbh, $routes) = @_;
    my $mynode = $self->{MYNODE};
    
    # Trying just dropping the whole of our routing table here ...
    &dbexec($dbh, qq{
	select * from t_routing where from_node = :from_node for update},
	    ":from_node" => $mynode);
    &dbexec($dbh, qq{
	delete from t_routing
	    where from_node = :from_node},
	    ":from_node" => $mynode);
    
    foreach my $route (@$routes)
    {
	my ($from, $to, $time, $hops, $status) = split (":", $route);
	
	# And here, just inserting the new routes
	&dbexec($dbh, qq{
	    insert into t_routing
		(timestamp, from_node, to_node, gateway, hops)
		values (:timestamp, :from_node, :to_node, :gateway, :hops)},
		":timestamp" => $time,
		":from_node" => $mynode,
		":to_node" => $to,
		":gateway" => $from,
		":hops" => $hops);
    }
    $dbh->commit();
}

sub getNewRoutes
{
    my ($self, $dbh) = @_;
    
    # Get all routes
    my %routes = ();
    my $query = &dbexec($dbh, qq{
	select from_node, to_node, gateway, timestamp, hops from t_routing});
    while (my ($from, $to, $gateway, $stamp, $hops) = $query->fetchrow())
    {
	$from =~ s/\s+//g; $to =~ s/\s+//g;
	$routes{$from}{$to}
	= { GATEWAY => $gateway, HOPS => $hops, STAMP => $stamp };
    }
    
    # Build the list of routes we want to process.  First get our immediate
    # neighbours: routes with from=me and to=gateway.  Then obtain the routes
    # for all those immediate neighbours, excluding routes with myself as the
    # destination.  Finally prune out routes we have already established and
    # which are still valid.
    my @new = ();
    my $mynode = $self->{MYNODE};
    my @neighbours = grep ($routes{$mynode}{$_}{GATEWAY} eq $_,
	    		   keys %{$routes{$mynode}});
    foreach my $from (@neighbours)
    {
	foreach my $to (keys %{$routes{$from}})
	{
	    my $gateway = $routes{$from}{$to}{GATEWAY};
	    my $stamp = $routes{$from}{$to}{STAMP};
	    my $hops = $routes{$from}{$to}{HOPS}
	    	       + $routes{$mynode}{$from}{HOPS};

	    next if $to eq $mynode;
	    next if (exists $routes{$mynode}{$to}
		     && $routes{$mynode}{$to}{GATEWAY} eq $from
		     && $routes{$mynode}{$to}{HOPS} eq $hops
		     && $routes{$mynode}{$to}{STAMP} eq $stamp);

	    # Handle split horizon with poisoned reverse.  Split horizon
	    # means that routes with myself as the gateway are ignored.
	    # Split horizon with poisoned reverse means such routes are
	    # accepted, but the number of hops is set to infinity.
	    $hops = $self->{INFINITY} if $gateway eq $mynode;
	    push (@new, "$from:$to:$stamp:$hops");
	}
    }

    return @new;
}

sub getMyRouteHash
{
    my ($self, $dbh) = @_;
    my %table = ();
    my $query = &dbexec($dbh, qq{
	select gateway, to_node, timestamp, hops from t_routing
	where from_node = :node}, ":node" => $self->{MYNODE});

    while (my @row = $query->fetchrow_array())
    {
        map { s/\s+//g; $_ } @row;
	&alert ("multiple routes from $self->{MYNODE} to $row[1]") if exists $table{$row[1]};
        $table{$row[1]} = "$row[0]:$row[2]:$row[3]:U";
    }

    return %table;
}

# Here we compare neighbours' routing tables with what we know, and build our new
# routing table from the information. The in-memory routing table comprises a set of
# rows, one for each route, with infomation :-separated. The information includes a 
# status field: U => an existing route for update, I => a new route for insertion,
# UN => an existing route with a new gateway
sub compareWithExistingRoutes
{
    my ($self, $dbh, $new_routes) = @_;
    my %gate_time_hops_by_dest = $self->getMyRouteHash ($dbh);
    my $new_gate_time_hops;

    my $new_time = &mytimeofday();
    foreach my $route (@$new_routes)
    {
	my ($new_gate,$new_to,$dummy_time,$new_hops) = split (/:/,$route);
	$new_gate_time_hops = "$new_gate:$new_time:$new_hops";
	if (exists $gate_time_hops_by_dest{$new_to})
	{
	    $new_gate_time_hops = $new_gate_time_hops.":U";
	    my ($gate,$time,$hops) = split ( /:/,$gate_time_hops_by_dest{$new_to} );
	    if (($gate eq $new_gate) || ($new_hops < $hops)) {
		$new_gate_time_hops = $new_gate_time_hops."N";
		$gate_time_hops_by_dest{$new_to} = $new_gate_time_hops; # replace blindly OR minimise
	    }
	}
	else
	{
	    &logmsg ("new route found $self->{MYNODE} $route");
	    $new_gate_time_hops = $new_gate_time_hops.":I"; 
	    $gate_time_hops_by_dest{$new_to} = $new_gate_time_hops;
	}
    }

    # timeout routes, check infinity
    foreach my $dest (keys %gate_time_hops_by_dest)
    {
	my ($gate,$time,$hops,$status) = split (/:/,$gate_time_hops_by_dest{$dest});
	my $infinity = $self->{INFINITY};
	my $check = &mytimeofday() - $self->{TIMEOUT};
	$hops = $infinity if $hops > $infinity;
	if ($time < $check && $self->{TIMEOUT} != 0)
	{
	    $hops = $infinity;
	    # trigger update if it's a neighbour timeout
	    # easy for us as we can pass the update message to
	    # everyone in the network at the same time
	    &dbexec($dbh, qq{
		update t_routing set hops = :infinity where to_node = :dest},
		":infinity" => $infinity, ":dest" => $dest);
	    &warn ("route timed out: $gate:$dest:$time:$hops:$status");
	}
	$gate_time_hops_by_dest{$dest} = "$gate:$time:$hops:$status";
    }

    # Build complete merged table
    my @routes = ();
    foreach my $destination (keys %gate_time_hops_by_dest)
    {
        my ($gate, $time, $hops, $status) = split (/:/, $gate_time_hops_by_dest{$destination});
        my $route = "$gate:$destination:$time:$hops:$status";
        push (@routes, $route);
    }
    return @routes;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    # Always mark all files ready to go immediately.
    eval
    {
	foreach my $node (split(/,/, $self->{NODES}))
	{
	    $self->{MYNODE} = $node;
	    $dbh = &connectToDatabase ($self) or die "failed to connect";

            $self->refreshNeighbourLinks ($dbh);
            my @new_routes = $self->getNewRoutes ($dbh);
            my @all_routes = $self->compareWithExistingRoutes ($dbh, \@new_routes);
            $self->updateTable ($dbh, \@all_routes);
	    $dbh->commit();
	    &disconnectFromDatabase ($self, $dbh);
	}

	$self->{MYNODE} = undef;
    };
    do { &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);
    $self->{MYNODE} = undef;

    # Check children are still running and then wait
    $self->doStop () if $self->{ONCE};
    $self->nap ($self->{WAITTIME});
}
