#!/usr/bin/perl

# Node Routing Agent
#
# This agent is responsible for making links between its parent
# and neighbour nodes, and maintaining routing information for 
# agents operating under the same parent node.
#
# The agent implements a version of the Routing Internet Protocol
# algorithm (RFC 2543).
#
# Command line options
# -node	<parent node>	parent node name
# -db <tns name>		sets the Oracle db to talk to
# -w <workdir>			sets the workdir for the agent
# -no-updates			disables database updates
# -once                 only runs once
# -period               period over which the agent will loop
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# The agent determines who its neighbours are from the routing
# table. It then refreshes its entry in its neighbours routing
# information to maintain the link. It then compares the routing
# information of each of its neighbours with its own, and modifies
# it accordingly ( a hard bit ).

use DBI;
use Getopt::Long;
$| = 1; # set autoflush

$g_no_updates;		# 1 means will not make final updates in tmdb
$g_work_dir = '';	# place pid and stop files here...
$g_db = "devdb9";	# tnsname of Oracle db (tmdb)
$g_db_user;			# Oracle user
$g_db_passwd;		# Oracle password
$g_parent_node = 'default_parent';		# parent node name
$g_once;				# 1 means will only run once
$g_period;              # time between iterations

# ###############################################################
# Main agent loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system("touch $g_work_dir/stop"); }
    my $start = time();
    
    # TODO: publish availability

    &refresh_neighbour_links;
    
    if (@new_routes = &get_new_routes) { 
	log_entry( "Found new routes" ); 
	foreach $route (@new_routes) { log_entry( $route ); }
	&insert_routes( \@new_routes );
    }

    my @min_routes = &minimise_routes;
    &clear_my_table;
    &insert_routes( \@min_routes );

    # TODO: Timeout direct links
    
    my $pause = $g_period - (time() - $start);
    sleep($pause);
}





# ###############################################################
# Non-agent specific subroutines
# ###############################################################
sub log_entry {
    my $entry = shift;
    my $localtime = localtime(time());
    print "$localtime [$$]: $entry\n";
}

sub publish_availability {
	my %args = (
		NODE => 'default_node_label',
		AGENT => 'default_agent_label',	
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		@_
	);
	my $time = time();

	$return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'$args{DB_USER}', 
						 	'$args{DB_PASSWD}', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$log = "update t_Lookup "
			."set last_contact=$time "
			."where agent='$args{AGENT}' "
			."and node='$args{NODE}'";
	$return = $dbh->do($log);

	$return = $dbh->disconnect();
}

sub direct_db_transaction {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		SQL => 'some_sql',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$dbh->do($args{SQL});
	
	$dbh->disconnect();
}

# ###############################################################
# Subroutines
# ###############################################################
sub refresh_neighbour_links {
    my $time = time();
    my $update = "update t_Routing "
	."set timestamp = $time "
	."where to_node = '$g_parent_node' "
	."and gateway = '$g_parent_node'";
    direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
}

sub insert_routes {
    my $table = shift;
    foreach $route (@$table) {
        my $time = time();
        my ($from, $to, $hops) = split( ":", $route );
        my $insert = "insert into t_Routing "
            ."values ('$g_parent_node','$to','$from',$time,$hops)";
	direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $insert );
    }
}

sub get_new_routes {
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });

    my $selection = "select from_node,to_node,hops from t_Routing "
	."where from_node in (select from_node from t_Routing where to_node = '$g_parent_node' and gateway = '$g_parent_node') "
	."and not to_node = '$g_parent_node' "
#	."and not gateway = '$g_parent_node' "
	."minus "
	."select gateway,to_node,hops-1 from t_Routing "
	."where from_node = '$g_parent_node'";

    my @new_routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }
	$row[2]++;
	push( @new_routes, join( ":",@row ) );
    }
    $query->finish();
    $dbh->disconnect();

    return @new_routes;
}

sub clear_my_table {
    my $neighbour = shift;
    my $time = time();
    my $update = "delete from t_Routing "
	."where from_node = '$g_parent_node'";
    direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
}

sub minimise_routes {
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });

    my $selection = "select gateway,to_node,hops from t_Routing "
	."where from_node = '$g_parent_node'";

    my %hops_by_route = ();
    my @routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }

	my $route = "$row[0]:$row[1]";
	
	if (exists $hops_by_route{$route}) {
	    $hops_by_route{$route} = min( $row[2], $hops_by_route{$route} );
	} else {
	    $hops_by_route{$route} = $row[2];
	}

    }
    $query->finish();
    $dbh->disconnect();

    foreach $route (keys %hops_by_route) {
	push( @routes, join( ":",$route,$hops_by_route{$route} ) );
    }

    return @routes;
}

sub min {
    my ($a, $b) = @_;
    if ($a >= $b) { return $b; } else { return $a; }
}

sub parse_command_line {
    GetOptions(	'node=s' => \$g_parent_node,
		'w=s' => \$new_work_dir,
		'db=s' => \$g_db,
		'dbuser=s' => \$g_db_user,
		'dbpasswd=s' => \$g_db_passwd,
		"no-updates" => \$g_no_updates,
		"once" => \$g_once,
		"period=s" => \$g_period
		);
    
    if ($g_once) {
	log_entry( "only running once" );
    }
    if ($g_period) {
        log_entry( "loop period is $g_period" );
    }
    if ($g_parent_node) {
	log_entry( "parent node is $g_parent_node" );
    }
    if (!$new_work_dir) {
	$g_work_dir = ".";
    } else {
	$g_work_dir = $g_work_dir.$new_work_dir;
    }
    log_entry( "work dir is $g_work_dir" );
    if (-e "$g_work_dir/pid") {
	log_entry( "Removing old pid file");
	unlink("$g_work_dir/pid");
    } 
    if (-e "$g_work_dir/stop") {
	log_entry( "Removing old stop file" );
	unlink ("$g_work_dir/stop");
    }
    if (!$g_db) {
	$g_db = "devdb9";
    }
    log_entry( "database is $g_db" );
    if ($g_no_updates) {
	log_entry( "not making final updates " );
    }	
    
    log_entry( "Following arguments unprocessed by Getopt::Long" ) if $ARGV[0];
    foreach (@ARGV) {
	log_entry( "$_" );
    }
}
