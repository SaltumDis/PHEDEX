#!/usr/bin/perl

# Node Routing Agent
#
# This agent is responsible for making links between its parent
# and neighbour nodes, and maintaining routing information for 
# agents operating under the same parent node.
#
# The agent implements a version of the Routing Internet Protocol
# algorithm (RFC 2543), detailed in X.
#
# Command line options
# -name	<parent node>	parent node name
# -db <tns name>		sets the Oracle db to talk to
# -w <workdir>			sets the workdir for the agent
# -no-updates			disables database updates
# -once                 only runs once
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# The agent determines who its neighbours are from the routing
# table. It then refreshes its entry in its neighbours routing
# information to maintain the link. It then compares the routing
# information of each of its neighbours with its own, and modifies
# it accordingly ( a hard bit ).

use DBI;
use Getopt::Long;
$| = 1; # set autoflush

$g_no_updates;		# 1 means will not make final updates in tmdb
$g_work_dir = '';	# place pid and stop files here...
$g_db = "devdb9";	# tnsname of Oracle db (tmdb)
$g_db_user;			# Oracle user
$g_db_passwd;		# Oracle password
$g_parent_node = 'default_parent';		# parent node name
$g_once;				# 1 means will only run once

# ###############################################################
# Main agent loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system("touch $g_work_dir/stop"); }

    # TODO: Refresh acquanitance with neighbours
    
    if (@new_routes = &get_new_routes) { 
	log_entry( "Found new routes" ); 
	foreach $route (@new_routes) { log_entry( $route ); }
	&insert_routes( \@new_routes );
    }

#    if (@changed_routes = &get_changed_routes) { 
#	log_entry( "Found changed routes, or new routes to existing destinations" ); 
#	foreach $route (@changed_routes) { log_entry( $route ); }
#	&update_routes( \@changed_routes );
#    }

    # TODO: Timeout direct links
}





# ###############################################################
# Non-agent specific subroutines
# ###############################################################
sub log_entry {
    my $entry = shift;
    my $localtime = localtime(time());
    print "$localtime [$$]: $entry\n";
}

sub publish_availability {
	my %args = (
		NODE => 'default_node_label',
		AGENT => 'default_agent_label',	
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		@_
	);
	my $time = time();

	$return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'$args{DB_USER}', 
						 	'$args{DB_PASSWD}', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$log = "update t_Lookup "
			."set last_contact=$time "
			."where agent='$args{AGENT}' "
			."and node='$args{NODE}'";
	$return = $dbh->do($log);

	$return = $dbh->disconnect();
}

sub direct_db_transaction {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		SQL => 'some_sql',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$dbh->do($args{SQL});
	
	$dbh->disconnect();
}

# ###############################################################
# Subroutines
# ###############################################################
sub refresh_acquaintance {
    my $neighbour = shift;
    my $time = time();
    my $update = "update t_Routing "
	."set timestamp = $time "
	."where from_node = '$neighbour' "
	."and to_node = '$g_parent_node' "
	."and gateway = '$g_parent_node'";
    direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
}

sub update_routes {
    my $table = shift;
    foreach $route (@$table) {
	my $time = time();
	my ($to, $gate, $hops) = split( ":", $route );
	my $delete = "delete from t_Routing "
	    ."where to_node = '$to' "
	    ."and from_node = '$g_parent_node' "
	    ."and gateway = '$gate' ";
	direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $delete );
	my $insert = " insert into t_Routing "
	    ."values ('$g_parent_node','$to','$gate',$time,$hops)";
	direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $insert );
    }
}

sub insert_routes {
    my $table = shift;
    foreach $route (@$table) {
        my $time = time();
        my ($from, $to, $hops) = split( ":", $route );
        my $insert = "insert into t_Routing "
            ."values ('$g_parent_node','$to','$from',$time,$hops)";
	direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $insert );
    }
}

sub get_changed_routes {
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });

    my $selection = "select to_node,from_node,hops from t_Routing "
	."where to_node in (select unique to_node from t_Routing where from_node = '$g_parent_node') "
	."and from_node in (select from_node from t_Routing where to_node = '$g_parent_node' and gateway = '$g_parent_node') "
	."and not to_node = '$g_parent_node' "
	."and not gateway = '$g_parent_node' "
	."minus "
	."select to_node,gateway,hops-1 from t_Routing "
	."where to_node in (select unique to_node from t_Routing where from_node = '$g_parent_node') "
	."and from_node = '$g_parent_node' "
	."and not to_node = '$g_parent_node' "
	."and not gateway = '$g_parent_node'";

    my @changed_routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }

	$row[2]++;   # increment the number of hops here!

        push(@changed_routes,join(':',@row));
    }
    $query->finish();
    $dbh->disconnect();

    return @changed_routes;
}

sub get_new_routes {
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });

#    my $selection = "select from_node,to_node,hops+1 from t_Routing "
#	."where not to_node in (select unique to_node from t_Routing where from_node = '$g_parent_node') "
#	."and from_node in (select from_node from t_Routing where to_node = '$g_parent_node' and gateway = '$g_parent_node') "
#	."and not to_node = '$g_parent_node' "
#	."and not gateway = '$g_parent_node'";

    my $selection = "select from_node,to_node,hops from t_Routing "
	."where from_node in (select from_node from t_Routing where to_node = '$g_parent_node' and gateway = '$g_parent_node') "
	."and not to_node = '$g_parent_node' "
	."and not gateway = '$g_parent_node' "
	."minus "
	."select gateway,to_node,hops-1 from t_Routing "
	."where from_node = '$g_parent_node'";


    my @new_routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }
	$row[2]++;
        push(@new_routes,join(':',@row));
    }
    $query->finish();
    $dbh->disconnect();
    
    return @new_routes;
}

sub parse_command_line {
    GetOptions(	'name=s' => \$g_parent_node,
		'w=s' => \$new_work_dir,
		'db=s' => \$g_db,
		'dbuser=s' => \$g_db_user,
		'dbpasswd=s' => \$g_db_passwd,
		"no-updates" => \$g_no_updates,
		"once" => \$g_once
		);
    
    if ($g_once) {
	log_entry( "only running once" );
    }
    if ($g_parent_node) {
	log_entry( "parent node is $g_parent_node" );
    }
    if (!$new_work_dir) {
	$g_work_dir = ".";
    } else {
	$g_work_dir = $g_work_dir.$new_work_dir;
    }
    log_entry( "work dir is $g_work_dir" );
    if (-e "$g_work_dir/pid") {
	log_entry( "Removing old pid file");
	unlink("$g_work_dir/pid");
    } 
    if (-e "$g_work_dir/stop") {
	log_entry( "Removing old stop file" );
	unlink ("$g_work_dir/stop");
    }
    if (!$g_db) {
	$g_db = "devdb9";
    }
    log_entry( "database is $g_db" );
    if ($g_no_updates) {
	log_entry( "not making final updates " );
    }	
    
    log_entry( "Following arguments unprocessed by Getopt::Long" ) if $ARGV[0];
    foreach (@ARGV) {
	log_entry( "$_" );
    }
}
