#!/usr/bin/env perl

##H NodeRouter
##H
##H Creates minimum spanning trees for given nodes, then uses trees to
##H fill the routing table. Uses Dijkstra's algorithm to determine 
##H shortest-path tree from a given source node.
##H
##H All hop information is taken from t_node_neighbour (which acts as
##H an adjacency list), and complete, current routes are determined in 
##H a single iteration-- therefore this approach should remove the
##H dependency on convergence that we see when using other iterative
##H algorithms.
##H
##H      -state DIRECTORY -nodes PATTERN[,PATTERN...]
##H      -db FILE[:SECTION] [-wait SECS]
##H
##H -state     agent state directory
##H -nodes     comma-separated list of node name patterns to route for;
##H            pattern wildcards are '%' (any string) and '_' (any character)
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
use UtilsHelp;
my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-nodes' && scalar @ARGV > 1)
    { shift (@ARGV); push(@{$args{NODES}}, split(/,/, shift(@ARGV))); }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

if (@ARGV || !$args{DROPDIR} || !$args{NODES} || !$args{DBCONFIG})
{
    die "Insufficient (or unknown: @ARGV) parameters, use -h for help.\n";
}

(new DijkstraNodeRouter (%args))->process();

######################################################################
# Routines for this agent.
package DijkstraNodeRouter; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  NODES => [],			# Nodes to route for
		  INFINITY => 1000,		# Avoid replicas this far away
	  	  AGENTID => "Routing");       	# Identity for activity logs
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	foreach my $source ( @{$self->{NODES}} ) 
	{
	    # As this agent represents several nodes directly, we want
	    # it to appear as if a NodeRouter for each node is up and
	    # running in the component status page. Therefore we cycle
	    # the value of MYNODE and connect each time-- the connect
	    # refreshes the status for the agent at MYNODE.
	    $self->{MYNODE} = $source;
	    $dbh = &connectToDatabase ($self) or die "failed to connect";
	    
	    my %distance = ();
	    my %precedent = ();
	    my %seen = ();
	    my %todo = ();

	    $todo{ $source } = 1;
	    $distance{ $source } = 0;

	    while ( keys %todo )
	    {
		# First we need to find the closest node to this node
		# of all the currently known nodes
		my $infinity = 999999;
		my $closest = $infinity;
		my $closestNode = '';
		foreach my $n ( keys %todo )
		{
		    if ( $distance{ $n } < $closest )
		    {
			$closest = $distance{ $n };
			$closestNode = $n;
		    }
		}
		delete $todo{ $closestNode };
		$seen{ $closestNode } = 1;

		# Now we need to find the neighbours of the current node,
		# Additionally, we can ignore nodes here whose
		# NodeRouters aren't currently up-- see limitquery
		# defined below
		my %neighbours = ();
		my $now = &mytimeofday();
		my $query = &dbexec( $dbh,
				     qq{select n.neighbour,n.hops
                                            from t_node_neighbour n
					    where n.node = :node},
                                     ":node" => $closestNode);
		my $limitquery = &dbexec( $dbh,
                                     qq{select n.neighbour,n.hops 
					    from t_node_neighbour n, 
					    t_agent_status s 
					where n.node = :node
					and n.neighbour = s.node 
					and s.agent = 'Routing' 
					and s.timestamp > :limit},
				     ":node" => $closestNode,
				     ":limit" => $now - (15 * 60) );

		while ( my @row = $query->fetchrow_array() )
		{
		    $neighbours{ $row[0] } = $row[1];
		}
		my @tempNeighbours = keys %neighbours;

		# Now we 'relax' our neighbours-- basically we compare
		# currently known distance with the newly calculated one
		# and minimise
		# Effect of sorting here is that if equivalent length
		# routes are found then one will be chosen on an
		# alphabetic basis
		foreach my $neighbour ( sort keys %neighbours )
		{
		    if ( ! exists $seen{ $neighbour } )
		    {
			# If $neighbour is new then it's not in
			# %todo or %seen; we set the distance to inf
			if ( ! exists $todo{ $neighbour } )
			{
			    $distance{ $neighbour } = $infinity;
			}

			if ( $distance{ $neighbour } > 
			     $distance{ $closestNode } + 
			     $neighbours{ $neighbour } )
			{
			    $distance{ $neighbour } =
				$distance{ $closestNode } +
				$neighbours{ $neighbour };
			    $precedent{ $neighbour } = $closestNode;
			    $todo{ $neighbour } = 1;
			}
		    }
		}
	    }
	
	    # At this stage we have the minimum spanning
	    # tree for this node. Need to work out gateway for each
	    # by cycling back through precedents
	    my %gateway = ();
	    delete $distance{ $source };
	    foreach my $node ( keys %distance )
	    {
		my $gate = $node;
		if ( $precedent{$gate} ne $source )
		{
		    $gate = $precedent{$gate};
		}
		$gateway{ $node } = $gate;
	    }
	    
	    # Lock, predelete all routes from $source and then insert
	    # new routes. This means we don't know if new routes have
	    # been found since last time, but means that we can easily
	    # drop dead or irrelevant routes.
	    my $time = &mytimeofday();
	    &dbexec($dbh, qq{ select * from t_routing
                                      where from_node = :from_node
                                      for update},
		    ":from_node" => $source);
	    &dbexec($dbh, qq{ delete from t_routing
				  where from_node = :from_node},
		    ":from_node" => $source);
	    foreach my $to ( keys %distance ) 
	    {
		&dbexec($dbh, qq{ insert into t_routing 
				      (timestamp,from_node,
				       to_node,gateway,hops) 
				      values 
				      (:time,:from_node,:to_node,
				       :gate,:hops)},
			    ":time" =>$time,
			":from_node" => $source,
			":to_node" => $to,
			":gate" => $gateway{ $to },
			":hops" => $distance{ $to });
	    }
	    $dbh->commit();
	
	}
	
        undef $self->{STMT_CACHE};

	$self->maybeStop();
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Check children are still running and then wait
    $self->nap ($self->{WAITTIME});
}
