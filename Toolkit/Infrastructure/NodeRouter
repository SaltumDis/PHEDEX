#!/usr/bin/perl

# Node Routing Agent
#
# This agent is responsible for making links between its parent
# and neighbour nodes, and maintaining routing information for 
# agents operating under the same parent node.
#
# The agent implements a version of the Routing Internet Protocol
# algorithm (RFC 2543), detailed in X.
#
# Command line options
# -name	<parent node>	parent node name
# -db <tns name>		sets the Oracle db to talk to
# -w <workdir>			sets the workdir for the agent
# -no-updates			disables database updates
# -once                 only runs once
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# The agent determines who its neighbours are from the routing
# table. It then refreshes its entry in its neighbours routing
# information to maintain the link. It then compares the routing
# information of each of its neighbours with its own, and modifies
# it accordingly ( a hard bit ).

use DBI;
use Getopt::Long;
$| = 1; # set autoflush

$g_no_updates;		# 1 means will not make final updates in tmdb
$g_work_dir = '';	# place pid and stop files here...
$g_db = "devdb9";	# tnsname of Oracle db (tmdb)
$g_db_user;			# Oracle user
$g_db_passwd;		# Oracle password
$g_parent_node = 'default_parent';		# parent node name
$g_once;				# 1 means will only run once

# ###############################################################
# Main agent loop
# ###############################################################

parse_command_line();

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
    if ($g_once) { system("touch $g_work_dir/stop"); }
    
    my @new_routes = &get_new_routes;
    &insert_routes( \@new_routes );
}





# ###############################################################
# Non-agent specific subroutines
# ###############################################################
sub log_entry {
    my $entry = shift;
    my $localtime = localtime(time());
    print "$localtime [$$]: $entry\n";
}

sub publish_availability {
	my %args = (
		NODE => 'default_node_label',
		AGENT => 'default_agent_label',	
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		@_
	);
	my $time = time();

	$return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'$args{DB_USER}', 
						 	'$args{DB_PASSWD}', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$log = "update t_Lookup "
			."set last_contact=$time "
			."where agent='$args{AGENT}' "
			."and node='$args{NODE}'";
	$return = $dbh->do($log);

	$return = $dbh->disconnect();
}

sub direct_db_transaction {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		SQL => 'some_sql',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$dbh->do($args{SQL});
	
	$dbh->disconnect();
}

# ###############################################################
# Subroutines
# ###############################################################
sub refresh_acquaintance {
    my $neighbour = shift;
    my $time = time();
    my $update = "update t_Routing "
	."set timestamp = $time "
	."where from_node = '$neighbour' "
	."and to_node = '$g_parent_node' "
	."and gateway = '$g_parent_node'";
    direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
}

sub update_routes {
    my $table = shift;
    foreach $route (@$table) {
	my $time = time();
	my ($from, $to, $gate, $timestamp, $hops) = &split_route( $route );
	my $update = "update t_Routing "
	    ."set timestamp = $time "
	    ."where from_node = '$from' "
	    ."and to_node = '$to'"
	    ."and gateway = '$gate' "
	    ."and hops = '$hops'";
	direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
    }
}

sub insert_routes {
    my $table = shift;
    foreach $route (@$table) {
        my $time = time();
        my ($from, $to, $hops) = split( ":", $route );
        my $insert = "insert into t_Routing "
            ."values ('$g_parent_node','$to','$from','$time','$hops')";
	log_entry( "$insert" );
	direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $insert );
    }
}

sub clean_routes {
    my $table = shift;
    foreach $route (@$table) {
        my $time = time();
        my ($from, $to, $gate, $timestamp, $hops) = &split_route( $route );
	my $delete = "delete from t_Routing "
            ."where from_node = '$g_parent_node' "
            ."and to_node = '$to'"
            ."and gateway = '$gate' "
            ."and hops = '$hops'";
        direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $delete );
    }
}

sub display_routing_table {
    my $table = shift;
    foreach $route (@$table) {
        log_entry( "$route" );
    }

}

sub get_shared_routes {
    my $table = shift;
    my @shared_routes = ();
    foreach $my_route (@g_known_routes) {
	my ($my_from, $my_to, $my_gate, $my_time, $my_hops) = &split_route( $my_route ); 
	foreach $other_route (@$table) {
	    my ($from, $to, $gate, $time, $hops) = &split_route( $other_route );
	    if ($to ne $g_parent_node && $gate ne $g_parent_node) {
		if ($to eq $my_to && $from eq $my_gate && $hops == $my_hops) {
		    log_entry( "shared route $other_route" );
		    push( @shared_routes, $my_route );
		}
	    }
	}
    }
    return @shared_routes;
}

# A route is new if the destination is new, the dest + hops is new, the dest + gate
# is new, how about d + g + h? (oh, covered by previous two).
sub get_new_routes {
    my @new_routes;

    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });

    my $selection = "select from_node,to_node,hops+1 from t_Routing "
	."where not to_node in (select unique to_node from t_Routing where from_node = 'A') "
	."and from_node in (select from_node from t_Routing where hops = 1) "
	."and not to_node = 'A' "
	."and not gateway = 'A'";

    my @new_routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }
        push(@new_routes,join(':',@row));
    }
    $query->finish();
    $dbh->disconnect();
    
    return @new_routes;
}

sub get_dead_routes {
    my $table = shift;
    my @dead_routes = ();
    my $dead_flag = 0;
    foreach $my_route (@g_known_routes) {
        my ($my_from, $my_to, $my_gate, $my_time, $my_hops) = &split_route( $my_route );
        foreach $other_route (@$table) {
            my ($from, $to, $gate, $time, $hops) = &split_route( $other_route );
	    $dead_flag = 1 if ($to eq $my_to && $from eq $my_gate);
	}
	push( @dead_routes, $my_route ) if ($dead_flag == 1);
    }
    return @dead_routes;
}


sub split_route {
    my $route = shift;
    my @bits  = split( ":", $route ); 
    return @bits;
}

sub alter_routes_for_my_table {
    my $table = shift;
    my @new_table = ();
    foreach $route (@$table) {
        @bits = &split_route( $route );
	$bits[2] = $bits[0];
        $bits[0] = $g_parent_node;
	$bits[4]++;
        $route = join( ":",@bits );
        push( @new_table, $route );
    }
    return @new_table;
}

sub get_routes_for_node {
    my $node = shift;
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
                            "$g_db_user",
                            "$g_db_passwd",
                            { RaiseError=>1, AutoCommit =>1 });
    
    my $selection = "select from_node,to_node,gateway,timestamp,hops "
        ."from t_Routing "
        ."where from_node = '$node'";
    my @routes = ();
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
        foreach (@row) { s/ //g; }
        push(@routes,join(':',@row));
    }
    $query->finish();

    $dbh->disconnect();

    return @routes;
}

sub get_neighbours {
    my $dbh = DBI->connect( "DBI:Oracle:$g_db",
			    "$g_db_user", 
			    "$g_db_passwd", 
			    { RaiseError=>1, AutoCommit =>1 });
    
    my @neighbours = ();
    my $selection = "select gateway "
	."from t_Routing "
	."where from_node = '$g_parent_node' "
	."and to_node = gateway";
    my $query = $dbh->prepare($selection);
    $query->execute;
    while (@row = $query->fetchrow_array) {
	$row[0] =~ s/ //g;
	push(@neighbours,@row[0]);
    }
    $query->finish();
    
    $dbh->disconnect();
    
    return @neighbours;	
}

sub parse_command_line {
    GetOptions(	'name=s' => \$g_parent_node,
		'w=s' => \$new_work_dir,
		'db=s' => \$g_db,
		'dbuser=s' => \$g_db_user,
		'dbpasswd=s' => \$g_db_passwd,
		"no-updates" => \$g_no_updates,
		"once" => \$g_once
		);
    
    if ($g_once) {
	log_entry( "only running once" );
    }
    if ($g_parent_node) {
	log_entry( "parent node is $g_parent_node" );
    }
    if (!$new_work_dir) {
	$g_work_dir = ".";
    } else {
	$g_work_dir = $g_work_dir.$new_work_dir;
    }
    log_entry( "work dir is $g_work_dir" );
    if (-e "$g_work_dir/pid") {
	log_entry( "Removing old pid file");
	unlink("$g_work_dir/pid");
    } 
    if (-e "$g_work_dir/stop") {
	log_entry( "Removing old stop file" );
	unlink ("$g_work_dir/stop");
    }
    if (!$g_db) {
	$g_db = "devdb9";
    }
    log_entry( "database is $g_db" );
    if ($g_no_updates) {
	log_entry( "not making final updates " );
    }	
    
    log_entry( "Following arguments unprocessed by Getopt::Long" ) if $ARGV[0];
    foreach (@ARGV) {
	log_entry( "$_" );
    }
}
