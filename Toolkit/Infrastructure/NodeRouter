#!/usr/bin/perl

# Node Routing Agent
#
# This agent is responsible for making links between its parent
# and neighbour nodes, and maintaining routing information for 
# agents operating under the same parent node.
#
# The agent implements a version of the Routing Internet Protocol
# algorithm (RFC 2543), detailed in X.
#
# Command line options
# -name	<parent node>	parent node name
# -db <tns name>		sets the Oracle db to talk to
# -w <workdir>			sets the workdir for the agent
# -no-updates			disables database updates
#
# You should provide a working dir name on the command line:
# a pid file will be stored there during running, and to stop the
# agent you should touch a file named "stop" within it.
#
# The agent determines who its neighbours are from the routing
# table. It then refreshes its entry in its neighbours routing
# information to maintain the link. It then compares the routing
# information of each of its neighbours with its own, and modifies
# it accordingly ( a hard bit ).

use DBI;
use Getopt::Long;
$| = 1; # set autoflush

my $g_no_updates;		# 1 means will not make final updates in tmdb
my $g_work_dir = '';	# place pid and stop files here...
my $g_db = "devdb9";	# tnsname of Oracle db (tmdb)
my $g_db_user;			# Oracle user
my $g_db_passwd;		# Oracle password
my $g_parent_node = 'default_parent';		# parent node name
my $g_once;				# 1 means will only run once

# ###############################################################
# Main agent loop
# ###############################################################

my $entry = parse_command_line();
log_entry( ENTRY => $entry );

open (PID, ">$g_work_dir/pid") || die "Pid file error $! $g_work_dir/pid\n";
print PID "$$\n";
close(PID);

while(!(-e "$g_work_dir/stop")) {
	if ($g_once) { system("touch $g_work_dir/stop"); }
	
	my @neighbours = &get_neighbours( DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, NODE => $g_parent_node );
	log_entry( ENTRY => "Neighbours: @neighbours" );

	log_entry( ENTRY => "$g_parent_node known routes" );
	my %my_hops_by_destination = get_routes( DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, MY_NODE => $g_parent_node, NODE => $g_parent_node  );
	foreach $destination (keys %my_hops_by_destination) {
	    log_entry( ENTRY => "$destination $my_hops_by_destination{$destination}" );
	}

	foreach $neighbour (@neighbours) {
	    log_entry( ENTRY => "Refreshing link $g_parent_node : $neighbour" );
	    refresh_acquaintance( DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, MY_NODE => $g_parent_node, NODE => $neighbour );
	
		log_entry( ENTRY => "$g_parent_node querying routes known by $neighbour" );
		my %hops_by_destination = get_routes( DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, MY_NODE => $g_parent_node, NODE => $neighbour );
		foreach $destination (keys %hops_by_destination) {
		    log_entry( ENTRY => "$destination $hops_by_destination{$destination}" );
			$hops_by_destination{$destination} += 1;
			
			if (exists $my_hops_by_destination{$destination}) {
				log_entry( ENTRY => "$destination already known to $g_parent_node" );
				my $time = time();
				my $update = "update t_Routing "
								."set timestamp = $time, "
								."hops = $hops_by_destination{$destination} "
								."where from_node = '$g_parent_node' "
								."and to_node = '$destination' "
								."and gateway = '$neighbour'";
				direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $update );
			} else {
				log_entry( ENTRY => "$destination new to $g_parent_node" );
				my $time = time();
				my $insert = "insert into t_Routing "
								."values ('$g_parent_node','$destination','$neighbour',$time,%hops_by_destination{$neighbour})";
				direct_db_transaction(  DB => $g_db, DB_USER => $g_db_user, DB_PASSWD => $g_db_passwd, SQL => $insert );
			}
			
		}
		
		
	}
	
}





# ###############################################################
# Non-agent specific subroutines
# ###############################################################
sub log_entry {
	my %args = (
		ENTRY => 'default_log_entry',
		@_
	);
	my $time = time();
	my $localtime = localtime($time);
	print "$localtime: $args{ENTRY}\n";
}

sub publish_availability {
	my %args = (
		NODE => 'default_node_label',
		AGENT => 'default_agent_label',	
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		@_
	);
	my $time = time();

	$return = my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	'$args{DB_USER}', 
						 	'$args{DB_PASSWD}', 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$log = "update t_Lookup "
			."set last_contact=$time "
			."where agent='$args{AGENT}' "
			."and node='$args{NODE}'";
	$return = $dbh->do($log);

	$return = $dbh->disconnect();
}

sub direct_db_transaction {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		SQL => 'some_sql',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	$dbh->do($args{SQL});
	
	$dbh->disconnect();
}

# ###############################################################
# Subroutines
# ###############################################################
sub get_routes{
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		MY_NODE => 'some_node',
		NODE => 'some_other_node',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	my %hops_by_destination = ();
	my $selection = "select to_node, hops "
					."from t_Routing "
					."where from_node = '$args{NODE}' "
					."and not to_node = '$args{MY_NODE}'"; 
	my $query = $dbh->prepare($selection);
	$query->execute;
	while (@row = $query->fetchrow_array) {
	    $row[0] =~ s/ //g;
	    $hops_by_destination{$row[0]} = $row[1];
	}
	$query->finish();
	
	$dbh->disconnect();
	
	return %hops_by_destination;
}

sub refresh_acquaintance {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		MY_NODE => 'some_node',
		NODE => 'some_other_node',
		@_
	);
	
	my $time = time();
	my $update = "update t_Routing "
				."set timestamp = $time "
				."where from_node = '$args{NODE}' "
				."and to_node = '$args{MY_NODE}' "
				."and gateway = '$args{MY_NODE}'";
	direct_db_transaction(  DB => $args{DB}, DB_USER => $args{DB_USER}, DB_PASSWD => $args{DB_PASSWD}, SQL => $update );
}

sub get_neighbours {
	my %args = (
		DB => 'edit_me_with_default_db_tns_name_for_sub_log_entry',
		DB_USER => 'some_user',
		DB_PASSWD => 'some_password',
		NODE => 'some_node',
		@_
	);
	
	my $dbh = DBI->connect(	"DBI:Oracle:$args{DB}",
						 	"$args{DB_USER}", 
						 	"$args{DB_PASSWD}", 
						 	{ RaiseError=>1, AutoCommit =>1 });
	
	my @neighbours = ();
	my $selection = "select gateway "
					."from t_Routing "
					."where from_node = '$args{NODE}' "
					."and to_node = gateway";
	my $query = $dbh->prepare($selection);
	$query->execute;
	while (@row = $query->fetchrow_array) {
	    $row[0] =~ s/ //g;
	    push(@neighbours,@row[0]);
	}
	$query->finish();
	
	$dbh->disconnect();

	return @neighbours;	
}

sub parse_command_line () {
	GetOptions(	'name=s' => \$g_parent_node,
				'w=s' => \$new_work_dir,
				'db=s' => \$g_db,
				'dbuser=s' => \$g_db_user,
				'dbpasswd=s' => \$g_db_passwd,
				"no-updates" => \$g_no_updates,
				"once" => \$g_once
				);
	
	my $entry = '';
	
	if ($g_once) {
		$entry = $entry."only running once,";
	}
	if ($g_parent_node) {
		$entry = $entry."parent node is $g_parent_node,";
	}
	if (!$new_work_dir) {
		$g_work_dir = ".";
	} else {
		$g_work_dir = $g_work_dir.$new_work_dir;
	}
	$entry = $entry."work dir is $g_work_dir,";
	if (-e "$g_work_dir/pid") {
		log_entry( ENTRY => "Removing old pid file");
		unlink("$g_work_dir/pid");
	} 
	if (-e "$g_work_dir/stop") {
		log_entry( ENTRY => "Removing old stop file" );
		unlink ("$g_work_dir/stop");
	}
	if (!$g_db) {
		$g_db = "devdb9";
	}
	$entry = $entry."database is $g_db,";
	if ($g_no_updates) {
		$entry = $entry."not making final updates, ";
	}	
	
	print "Unprocessed by Getopt::Long\n" if $ARGV[0];
	foreach (@ARGV) {
	  print "$_\n";
	}
	
	return $entry;
}
