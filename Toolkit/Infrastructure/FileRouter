#!/usr/bin/env perl

##H Route files toward destination nodes.
##H
##H Usage:
##H   FileRouter
##H      -state DIRECTORY -nodes PATTERN[,PATTERN...]
##H      -db FILE[:SECTION] [-log OUT]
##H
##H -state     agent state directory
##H -nodes     comma-separated list of node name patters to route for
##H              '%' is wildcard for any string, '_' for any character
##H -db        database connection configuration parameter file
##H -log       where to redirect logging information

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args;
use Getopt::Long;
use UtilsHelp;
&GetOptions ("state=s"     => \$args{DROPDIR},
	     "log=s"       => \$args{LOGFILE},
             "db=s"        => \$args{DBCONFIG},
             "nodes=s"     => sub { push(@{$args{NODES}}, split(/,/, $_[1])) },
	     "help|h"      => sub { &usage() });

if (@ARGV || !$args{DROPDIR} || !$args{NODES} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new FileRouter (%args))->process();

######################################################################
# Routines for this agent.
package FileRouter; use strict; use warnings; use base 'UtilsAgent';
use List::Util qw(max);
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

use constant TERABYTE => 1024**4;
use constant GIGABYTE => 1024**3;
use constant MEGABYTE => 1024**2;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
		  MYNODE => undef,		# My node name
		  WAITTIME => 60 + rand(10),	# Agent activity cycle
		  NODES => []);			# Nodes to route for
    my %args = (@_);
    map { $$self{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    my @nodes;

    eval
    {
	# All of this must run in a single agent to avoid database
	# connection proliferation.  The execution order for the
	# phases is important in that it balances progress for this
	# node (destination) and requests by other nodes (relaying).
	# Some of the steps feed to the next one.
	#
	# New requests begin in open state.  Offers will then begin to
	# build.  Once first offer reaches the destination, we mark
	# the request to go active in twice the time elapsed from the
	# opening.  Once a request is active, we confirm the path that
	# Has least total cost.
	#
	# Consider running only one instance of this agent for all
	# nodes.  If the agent passes one loop quickly enough, this
	# will reduce number of connections and database load
	# significantly.

	($dbh, @nodes) = &expandNodesAndConnect ($self, { "FileDownload" => 900 });

	# Read links and their parameters
	my $links = {};
	my $q = &dbexec($dbh, qq{
	    select l.from_node, l.to_node, l.distance, l.local_boost
	    from t_link l});
	while (my ($from, $to, $hops, $boost) = $q->fetchrow())
	{
	    $$links{$from}{$to} = { HOPS => $hops,
				    LOCAL_BOOST => $boost,
				    PENALTY => 1 };
	}

	# Now route for the nodes
	my $costs = {};
	foreach my $node (@nodes)
	{
	    my $nodeid = $$self{NODES_ID}{$node};
	    $self->route ($dbh, $nodeid, $links, $costs);
	    $self->maybeStop();
	}

	&logmsg ("routed for @nodes");
    };
    do { chomp ($@); &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Have a little rest
    $self->nap ($$self{WAITTIME});
}

# Run the routing algorithm for one node.
sub route
{
    my ($self, $dbh, $node, $links, $costs) = @_;

    ######################################################################
    # Phase 1: Issue file requests for blocks pending some of their files.
    #
    # In this phase, we request files for blocks in the order of the block
    # priority.  We first check how many files are a) currently in transfer
    # to this node, and b) (un)confirmed for transfer to this node.  If
    # these do not exceed defined limits (a: 1 TB, b: 10 TB), we issue new
    # requests for files with no outstanding request.
    #
    # Note that files which cannot be routed in reasonable amount of time
    # leave requests in "inactive" state for some time.  This deliberately
    # prevents this phase from issuing a request for that file again, thus
    # preventing database churn when routing requests fail to complete in
    # reasonable amount of time.  This behaviour blocks routing for files
    # and sites that do not function properly, but avoids loading database
    # servers and allows other sites to make timely progress.
    # (Do this every five minutes or so.)

    # Update priority on existing requests
    &dbexec ($dbh, qq{
        update (select xq.priority req_priority, bd.priority cur_priority
                from t_xfer_request xq
                  join t_dps_block_dest bd
                    on bd.block = xq.inblock
                    and bd.destination = xq.destination
                where xq.destination = :node)
        set req_priority = cur_priority},
	":node" => $node);

    # Clear completed requests.
    &dbexec($dbh, qq{
        delete from t_xfer_request xq
        where destination = :node and exists
          (select 1 from t_xfer_replica xr
	   where xr.fileid = xq.fileid and xr.node = xq.destination)},
	":node" => $node);

    # Clear requests for files no longer wanted
    &dbexec($dbh, qq{
        delete from t_xfer_request xq
        where destination = :node and not exists
          (select 1 from t_dps_block_dest bd
	   where bd.destination = xq.destination
	     and bd.block = xq.inblock
	     and bd.state = 1)},
	":node" => $node);
    $dbh->commit();

    # Get current transfer load parameters.
    my (%pend_bytes, %confirm_bytes);
    my $now = &mytimeofday();
    my $q = &dbexec($dbh, qq{
	select xs.priority, nvl(sum(f.filesize),0)
        from t_xfer_state xs join t_xfer_file f on f.id = xs.fileid
        where xs.to_node = :node group by xs.priority},
	":node" => $node);
    while (my ($priority, $bytes) = $q->fetchrow())
    {
	$pend_bytes{$priority} = $bytes;
    }

    $q = &dbexec($dbh, qq{
	select xp.priority, nvl(sum(f.filesize),0)
        from t_xfer_path xp join t_xfer_file f on f.id = xp.fileid
        where xp.to_node = :node group by xp.priority},
	":node" => $node);
    while (my ($priority, $bytes) = $q->fetchrow())
    {
	$confirm_bytes{$priority} = $bytes;
    }

    # FIXME: What we need is flexible bandwidth management, in proportions
    # 4:3:2:1 for P0:P1:P2:P3 (P0 = me/high, P1 = others/high, P2 = me/low,
    # P3 = others/low).  (If less actual priority levels needed, just
    # chop proportions from left, e.g. 2:1 for P1:P3 actual need.)
    #
    # We should limit the number of requests, confirmations and transfers
    # roughly in these proportions.
    my ($pend_me, $pend_all, $confirm_me, $confirm_all) = (0) x 4;
    foreach (keys %pend_bytes)
    {
	my $x = $pend_bytes{$_} || 0;
	$pend_me += $x if $_ % 2 == 0;
	$pend_all += $x;
    }
    foreach (keys %confirm_bytes)
    {
	my $x = $confirm_bytes{$_} || 0;
	$confirm_me += $x if $_ % 2 == 0;
	$confirm_all += $x;
    }

    
    if (($pend_all < 5 * TERABYTE
	 && $confirm_all < 5 * TERABYTE
	 && $confirm_me < 1 * TERABYTE)
	|| ($confirm_me < 0.25 * TERABYTE))
    {
	# Find block destinations we can activate.  The activation
	# takes a lock on the block itself so files cannot be added
	# while we are creating file requests; any files added after
	# that will automatically add file requests as well.  Keep
	# adding blocks until we've added at least 500 files; select
	# the blocks in order of priority and age (highest priority
	# = smallest priority value).
	my @blocks;
	my $nbytes = 0;
	my $i = &dbprep($dbh, qq{
	    insert into t_xfer_request
	      (fileid, inblock, destination, priority, state,
	       attempt, time_create, time_expire)
	      select
	        id, :block inblock, :node destination, :priority priority,
		0 state, 1 attempt, :now, :now + 8*3600
	      from t_xfer_file
	      where inblock = :block});
	my $u = &dbprep($dbh, qq{
	    update t_dps_block_dest
	    set state = 1, time_active = :now
	    where block = :block and destination = :node});
	my $q = &dbexec($dbh, qq{
	    select bd.block, bd.priority, b.bytes
	    from t_dps_block_dest bd
	      join t_dps_block b on b.id = bd.block
	    where bd.destination = :node and bd.state = 0
	    order by bd.priority asc, bd.time_create asc},
	    ":node" => $node);
        while (my ($block, $priority, $bytes) = $q->fetchrow())
	{
	    &dbbindexec($u,
		        ":block" => $block,
		    	":node" => $node,
			":now" => $now);
	    push(@blocks, [ $block, $priority ]);
	    last if ($nbytes += $bytes) >= TERABYTE;
	}

	# Commit first phase so any concurrent modification of t_xfer_file
	# and t_xfer_replica is handled by our triggers.
	$dbh->commit();

	foreach my $item (@blocks)
	{
	    &dbbindexec($i,
		        ":block" => $$item[0],
		    	":node" => $node,
			":priority" => $$item[1],
			":now" => $now);
	}

	# Now commit second phase.
	$dbh->commit();
    }

    ######################################################################
    # Phase 2: Expand file requests into transfer paths through the
    # network.  For each request we build a minimum cost path from
    # available replicas using a routing table of network links and
    # current traffic conditions.  The transfer paths are refreshed
    # regularly to account for changes in network conditions.
    #
    # In other words, each destination node decides the entire path
    # for each file, using network configuration information it
    # obtains from other nodes.  For correctness it is important that
    # the entire route is built by one node using a consistent network
    # snapshot, building routes piecewise at each node using only
    # local information does not produce correct results.
    #
    # We begin with file replicas for each active file request and
    # current network conditions.  We calculate a least-cost transfer
    # path for each file.  We then update the database.

    # Clear old paths and those missing a request
    &dbexec($dbh, qq{
        delete from t_xfer_path xp
        where destination = :node
         and (xp.time_confirm < :now - 20*60
	      or not exists (select 1 from t_xfer_request xq
	                     where xq.destination = xp.destination
			       and xq.fileid = xp.fileid))},
	":node" => $node, ":now" => $now);
    
    # Read requests and replicas for requests without paths
    my $requests = {};
    $q = &dbexec($dbh, qq{
	select
	    xq.fileid, f.filesize,
	    xq.priority, xq.time_create, xq.time_expire,
	    xr.node, xr.state
	from t_xfer_request xq
	  join t_xfer_file f
	    on f.id = xq.fileid
	  join t_xfer_replica xr
	    on xr.fileid = xq.fileid
	where xq.state = 0
	  and xq.destination = :node
	  and xq.time_expire > :now
	  and not exists (select 1 from t_xfer_path xp
			  where xp.destination = xq.destination
			    and xp.fileid = xq.fileid)},
	":node" => $node, ":now" => $now);
    while (my ($file, $size, $priority, $create, $expire,
	       $rnode, $state) = $q->fetchrow())
    {
	$$requests{$file} ||= { FILEID => $file,
				FILESIZE => $size,
				PRIORITY => $priority,
				TIME_CREATE => $create,
				TIME_EXPIRE => $expire };
	$$requests{$file}{REPLICAS}{$rnode} = $state;
	$self->routeCost($links, $costs, $rnode, $state);
    }

    # Build optimal file paths
    $self->routeFile($node, $links, $costs, $_) for values %$requests;

    # Update database
    my %iargs;
    my $istmt = &dbprep($dbh, qq{
	insert into t_xfer_path
	(fileid, destination, hop, src_node, from_node, to_node,
	 priority, local_boost, cost, total_cost, penalty,
	 time_request, time_confirm, time_expire)
	values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)});

    foreach my $req (values %$requests)
    {
	foreach my $hop (@{$$req{PATH}})
	{
	    my $n = 1;
	    push(@{$iargs{$n++}}, $$req{FILEID});
	    push(@{$iargs{$n++}}, $node);
	    push(@{$iargs{$n++}}, $$hop{INDEX});
	    push(@{$iargs{$n++}}, $$hop{SRC_NODE});
	    push(@{$iargs{$n++}}, $$hop{FROM_NODE});
	    push(@{$iargs{$n++}}, $$hop{TO_NODE});
	    push(@{$iargs{$n++}}, $$req{PRIORITY});
	    push(@{$iargs{$n++}}, $$hop{LOCAL_BOOST});
	    push(@{$iargs{$n++}}, $$hop{COST});
	    push(@{$iargs{$n++}}, $$hop{TOTAL_COST});
	    push(@{$iargs{$n++}}, $$hop{PENALTY});
	    push(@{$iargs{$n++}}, $$req{TIME_CREATE});
	    push(@{$iargs{$n++}}, $now);
	    push(@{$iargs{$n++}}, $$req{TIME_EXPIRE});
	}
    }

    &dbbindexec($istmt, %iargs) if %iargs;
    $dbh->commit();
    undef $requests;

    ######################################################################
    # Phase 3: Confirm requests for which there are valid offers.

    # Discard duplicate confirmations for me for the same file.  Keep
    # the best alternative: local one, or least cost one, or pick one.
    &dbexec($dbh, qq{
	delete from t_xfer_path this
	where to_node = :node and exists
	  (select 1 from t_xfer_path better
	   where this.fileid = better.fileid
	     and this.to_node = better.to_node
	     and ((this.local_boost = 0 and better.local_boost > 0)
		  or this.total_cost > better.total_cost
		  or (this.total_cost = better.total_cost
		      and this.rowid > better.rowid)))},
	":node" => $node);

    # Confirm transfers where I am the path hop destination, the
    # source replica exists and there is no transfer yet.  However
    # remove inactive transfers no longer requested, but in a way
    # that avoids database contention with PFN export.
    &dbexec($dbh, qq{
        delete from t_xfer_state xs
	where to_node = :me
          and to_state != 2
	  and (from_state = 1 or time_assign < :now - 1200)
	  and time_expire >= :now
          and not exists
	    (select 1 from t_xfer_path xp
	     where xp.to_node = xs.to_node
	       and xp.from_node = xs.from_node
	       and xp.fileid = xs.fileid)},
	":me" => $node, ":now" => $now);

    &dbexec($dbh, qq{
        insert into t_xfer_state
          (fileid, errors, priority, weight, age,
           from_replica, from_node, from_state,
           to_node, to_state, time_expire, time_assign)

	  with files_for_me as
	    (select
		 xp.fileid, xp.from_node, xp.to_node, xr.id replica,
		 min(xp.priority) priority,
		 max(xp.local_boost * nvl(l.local_boost,0)) local_boost,
		 count(xp.fileid) weight,
		 min(xp.time_request) time_request,
		 min(xp.time_confirm) time_confirm,
		 max(xp.time_expire) time_expire
	     from t_xfer_path xp
	       left join t_link l
		 on l.to_node = xp.from_node
		 and l.from_node = xp.to_node
               join t_xfer_replica xr
                 on xr.fileid = xp.fileid
                 and xr.node = xp.from_node
	     where xp.to_node = :me and xp.time_expire > :now
	     group by xp.fileid, xp.from_node, xp.to_node, xr.id)
          select
             fileid, 0, 2*priority + 1-local_boost, weight, time_request,
             replica, from_node, 0, to_node, 0, time_expire, :now
           from files_for_me ffm
           where not exists
               (select 1 from t_xfer_state xs
                where xs.fileid = ffm.fileid
                  and xs.to_node = ffm.to_node)
	     and not exists
               (select 1 from t_xfer_replica xr
                where xr.fileid = ffm.fileid
                  and xr.node = ffm.to_node)},
	":me" => $node, ":now" => $now);
    $dbh->commit();

    ######################################################################
    # Phase 4: Deactivate unsuccessful expired requests.

    # (Do this every ten minutes or so.)

    # The request can fail either because the tender never completed with
    # a successful route, or the transfers don't complete in time.  In the
    # former case we might just as well wait for a while.  In latter, the
    # t_xfer_expired handling picks up details and translates them to link
    # penalties.  So all we do here is put the request to sleep.
    
    &dbexec($dbh, qq{
        update t_xfer_request
        set state = 1, time_expire = :now + 6*3600*least(attempt,8)
        where destination = :node
          and state = 0
          and :now >= time_expire},
	":node" => $node, ":now" => $now);
    # $dbh->commit();

    ######################################################################
    # Phase 5: Wake previously failed requests from sleep.

    # (Do this every ten minutes or so.)

    &dbexec($dbh, qq{
        update t_xfer_request
        set state = 0,
            attempt = attempt + 1,
            time_expire = :now + 8*3600*(1+least(attempt-1,6)/2)
        where destination = :node
          and state = 1
          and :now >= time_expire},
	":node" => $node, ":now" => $now);
    # $dbh->commit();
    
    ######################################################################
    $dbh->commit();

    ######################################################################
    # Phase X: Update transfer parameters.

    # (This should be done by other code.)

    ######################################################################
    # Phase X: Update statistics.

    # (This should be done by other code.)

    # update t_dest_histogram (t_xfer_{request,offer,confirmation,expired})
    # update t_xfer_histogram (t_xfer_{state,completed,tracking})
    # clean t_xfer_expired
    # copy t_xfer_tracking to t_xfer_history?
    # clean t_xfer_tracking

}

# Calculate prototype file transfer cost.  The only factor affecting
# the cost of a file in the network is its source node and whether
# the file is staged in; the rest is determined by link parameters.
# So there is no reason to calculate the full minimum-spanning tree
# algorithm for every file -- we just calculate prototype costs for
# "staged file at node n", and propagate those costs to the entire
# network.  The actual file routing then just picks cheapest paths.
sub routeCost
{
    my ($self, $links, $costs, $node, $state) = @_;

    # If we already have a cost for this prototype, return immediately
    return if exists $$costs{$node} && exists $$costs{$node}{$state};

    # Initialise the starting point: 1 for staged file, 100 for not staged.
    my %todo = ($node => 1);
    my $cost = $state ? 1 : 100;
    my $paths = $$costs{$node}{$state} = {};
    $$paths{$node} = {
	SRC_NODE => $node,
	FROM_NODE => $node,
	TO_NODE => $node,
	SRC_COST => $cost,
	XFER_COST => 0,
	COST => $cost,
	LOCAL_BOOST => 1,
	PENALTY => 1,
	HOPS => 0
    };

    # Now use Dijkstra's algorithm to compute minimum spanning tree.
    while (%todo)
    {
	foreach my $from (keys %todo)
	{
	    # Remove from list of nodes to do.
	    delete $todo{$from};

	    # Compute cost at each neighbour.
	    foreach my $to (keys %{$$links{$from}})
	    {
		my $penalty = $$links{$from}{$to}{PENALTY};
		my $cost = ($$links{$from}{$to}{HOPS} * $penalty);
		my $totcost = $$paths{$from}{XFER_COST} + $cost;
	        my $local = ($$paths{$from}{LOCAL_BOOST}
			     * ((! exists $$links{$to}
			         || ! exists $$links{$to}{$from})
		                ? 0 : $$links{$to}{$from}{LOCAL_BOOST}));

		# Update the path if there is none yet, if we have local
		# path and existing is not local, or if we now have a
		# better cost without changing local attribute.
		if (! exists $$paths{$to}
		    || ($local && ! $$paths{$to}{LOCAL_BOOST})
		    || ($local == $$paths{$to}{LOCAL_BOOST}
			&& $totcost < $$paths{$to}{XFER_COST}))
		{
		    # No existing path or it's more expensive.
		    $$paths{$to} = { SRC_NODE => $$paths{$from}{SRC_NODE},
				     FROM_NODE => $from,
				     TO_NODE => $to,
				     SRC_COST => $$paths{$from}{SRC_COST},
				     XFER_COST => $totcost,
				     COST => $cost,
				     LOCAL_BOOST => $local,
				     PENALTY => $penalty,
				     HOPS => $$paths{$from}{HOPS} + 1 };
		    $todo{$to} = 1;
		}
	    }
	}
    }
}

# Computes the optimal route for the file.
sub routeFile
{
    my ($self, $dest, $links, $costs, $request) = @_;

    # Use the precomupted replica path costs to pick the cheapest
    # available file we could transfer.  The costs are scaled by the
    # size of the file (it doesn't affect the result, but goes into
    # the tables on output).
    my $best = undef;
    my $bestcost = undef;
    my $sizefactor = max(1, $$request{FILESIZE}/(100 * MEGABYTE));
    foreach my $node (keys %{$$request{REPLICAS}})
    {
	my $state = $$request{REPLICAS}{$node};
	my $this = $$costs{$node}{$state};
	next if ! exists $$this{$dest};

	my $thiscost
	    = $$this{$dest}{SRC_COST} + $$this{$dest}{XFER_COST} * $sizefactor;
	if (! defined $best
	    || $$this{$dest}{LOCAL_BOOST} > $$best{$dest}{LOCAL_BOOST}
	    || ($$this{$dest}{LOCAL_BOOST} == $$best{$dest}{LOCAL_BOOST}
		&& $thiscost <= $bestcost))
	{
	    $best = $this;
	    $bestcost = $thiscost;
	}
    }

    # Now record path to the cheapest replica found, if we found one.
    delete $$request{PATH};
    if (defined $best)
    {
	my $index = 0;
	my $node = $dest;
	my $local = 1;
	while ($$best{$node}{FROM_NODE} != $$best{$node}{TO_NODE})
	{
	    my $from = $$best{$node}{FROM_NODE};
	    my $item = { %{$$best{$node}} };
	    $$item{INDEX} = $index++;
	    $$item{TOTAL_COST} = $$item{SRC_COST} + $$item{XFER_COST} * $sizefactor;
	    $$item{COST} *= $sizefactor;
	    push(@{$$request{PATH}}, $item);
	    $node = $from;
	}
	
	delete $$self{WARNED}{$dest}{$$request{FILEID}};
    }
    elsif (keys %{$$request{REPLICAS}})
    {
	&warn ("failed to route file $$request{FILEID} to destination $dest"
	       . ": none of the source replicas are reachable ("
	       . (scalar keys %{$$request{REPLICAS}}) . " at: "
	       . "@{[ keys %{$$request{REPLICAS}} ]})")
           if ! $$self{WARNED}{$dest}{$$request{FILEID}};
	$$self{WARNED}{$dest}{$$request{FILEID}} = 1;
    }
    else
    {
	&warn ("failed to route file $$request{FILEID} to destination $dest"
	       . ": no source replica available")
           if ! $$self{WARNED}{$dest}{$$request{FILEID}};
	$$self{WARNED}{$dest}{$$request{FILEID}} = 1;
    }
}
