#!/usr/bin/env perl

## Assign the next hops to files that have arrived to a node.
##
## This agent scans the transfer state table in TMDB.  When it finds
## files that have arrived to a node (to_state = 3), it determines
## the next hops for the file considering the final destinations, all
## current replicas and the distances in the routing table.  Given
## all the candidate source replicas and the paths to the destination,
## the best next hop alternative is assigned (if one doesn't already
## exist).
##
## This agent manages the routing for all files regardless of nodes.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args = (DBITYPE => "Oracle");
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBNAME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbi' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBITYPE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbuser' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBUSER} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbpass' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBPASS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MYNODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-nodes' && scalar @ARGV > 1)
    { shift (@ARGV); push(@{$args{NODES}}, split(/,/, shift(@ARGV))); }
    else
    { last; }
}

if (scalar @ARGV || !$args{DROPDIR} || !$args{DBNAME} || !$args{DBUSER}
    || !$args{DBPASS} || !$args{DBITYPE} || !$args{MYNODE} || !$args{NODES})
{
    print STDERR
	"usage: $me -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
	"    -state IN-DROP-BOX [-wait SECS-TO-WAIT]\n",
	"    -node TMDB-NODE-NAME -nodes PATTERN[,PATTERN...]\n";
    exit (1);
}

my $agent = new FileRouter (%args);
# Recapture interrupt signal, oracle swallows it.
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop (); };
$agent->process ();

######################################################################
# Routines for this agent.
package FileRouter; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBITYPE => undef,		# Database driver binding
    		  DBNAME => undef,		# Database name
	  	  DBUSER => undef,		# Database user name
	  	  DBPASS => undef,		# Database user password
		  MYNODE => undef,		# My node name
		  NODES => [],			# Nodes to route for
	  	  AGENTID => "Router");		# Identity for activity logs
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;

    # Always mark all files ready to go immediately.
    eval
    {
	$dbh = &connectToDatabase ($self) or die "failed to connect";
        # FIXME: Pick up and process messages to me

	# Select files that are not at destination yet.  We need two
	# SQL statements, one to select files not yet at destination,
	# another for each such file to select the best replica, the
	# route to the next hop, and possibly existing transfer on
	# that path.  If no such transfer exists, we create a new one.
	foreach my $nodepat (@{$self->{NODES}})
	{
	    my ($now, $nincomplete, $nrouted) = (&mytimeofday(), 0, 0);
            my ($rstmt) = &dbprep ($dbh, qq{
	        select
	          rs.node,
	          r.hops,
	          r.gateway,
	          r.timestamp,
	          ts.to_node
	        from t_replica_state rs
	        left join t_routing r
	          on r.from_node = rs.node and r.to_node = :dest
	        left join t_transfer_state ts
	          on ts.guid = rs.guid and ts.to_node = r.gateway
	        where rs.guid = :guid
	        order by r.hops asc nulls last});
            my ($tstmt) = &dbprep ($dbh, qq{
	        insert into t_transfer_state
	        (guid, from_node, from_state, to_node, to_state,
	         insert_time_stamp, from_time_stamp, to_time_stamp)
	        values (:guid, :from_node, 0, :to_node, 0, :now, :now, :now)});
            my ($dstmt) = &dbexec ($dbh, qq{
	        select d.guid, d.destination_node
	        from t_destinations d
	        left join t_replica_state rs
	          on rs.guid = d.guid and rs.node = d.destination_node
	        where rs.node is null and d.destination_node like :pat},
		":pat" => $nodepat);
            while (my ($guid, $dest) = $dstmt->fetchrow())
	    {
	        ++$nincomplete;

	        # Find best replica and route from there
	        &dbbindexec($rstmt, ":guid" => $guid, ":dest" => $dest);
	        my $routes = 0;
	        while (1)
	        {
		    ++$routes;
		    my ($node, $hops, $gw, $live, $transfer) = $rstmt->fetchrow();
		    if (! defined $node && $routes == 1)
		    {
		        # Oops, there's no replica anywhere
	    	        &alert ("$dest $guid: no source replica available")
	    		    if ! $self->{WARNINGS}{UNAVAILABLE}{$guid}{$dest};
	    	        $self->{WARNINGS}{UNAVAILABLE}{$guid}{$dest} = 1;
		        last;
		    }
		    elsif (! defined $gw)
		    {
		        # We've exhausted available routes, complain
	    	        &alert ("$dest $guid: no replica routable to destination"
		    	        . " ($routes routes considered)")
	    		    if ! $self->{WARNINGS}{NO_ROUTE}{$guid}{$dest};
	    	        $self->{WARNINGS}{NO_ROUTE}{$guid}{$dest} = 1;
		        last;
		    }
		    elsif (0 && $now - $live > 15*60)
		    {
		        # Best available route is down, warn and ignore it
		        &warn ("$dest $guid: best replica at $node"
			       . " ($hops hops via $gw) is unreachable,"
			       . " route is @{[$now - $live]} seconds old")
	    		    if ! $self->{WARNINGS}{ROUTE}{$guid}{$dest}{$node}{$gw};
	    	        $self->{WARNINGS}{ROUTE}{$guid}{$dest}{$node}{$gw} = 1;
		    }
		    elsif (! defined $transfer)
		    {
		        # Live route, no existing transfer, create one
		        &logmsg ("routing $guid to $dest from $node via $gw"
			         . " ($hops hops, route $routes)");
		        &dbbindexec($tstmt, ":guid" => $guid, ":now" => $now,
			            ":from_node" => $node, ":to_node" => $gw);
		        delete $self->{WARNINGS}{ROUTE}{$guid}{$dest}{$node}{$gw};
		        delete $self->{WARNINGS}{UNAVAILABLE}{$guid}{$dest};
		        delete $self->{WARNINGS}{NO_ROUTE}{$guid}{$dest};
		        ++$nrouted;
		        last;
		    }
		    else
		    {
		        # Route exists already
		        last;
		    }
	        }
	    }

	    $dbh->commit ();
	    &logmsg ("$nodepat: considered $nincomplete destinations,"
		     . " $nrouted routes created in"
		     . " @{[sprintf '%.1f', &mytimeofday() - $now]} seconds")
	        if $nincomplete;
	}
    };
    do { &alert ("database error: $@"); $dbh->rollback() if $dbh; } if $@;

    # Disconnect from the database
    $dbh->disconnect() if $dbh;
    undef $dbh;

    # Check children are still running and then wait
    $self->maybeStop ();
    sleep ($self->{WAITTIME});
}
