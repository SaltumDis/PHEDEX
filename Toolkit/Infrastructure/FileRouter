#!/usr/bin/env perl

## Assign the next hops to files that have arrived to a node.
##
## This agent scans the transfer state table in TMDB.  When it finds
## files that have arrived to a node (to_state = 3), it determines
## the next hops for the file considering the final destinations, all
## current replicas and the distances in the routing table.  Given
## all the candidate source replicas and the paths to the destination,
## the best next hop alternative is assigned (if one doesn't already
## exist).
##
## This agent manages the routing for all files regardless of nodes.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
my %args = (DBITYPE => "Oracle");
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBNAME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbi' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBITYPE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbuser' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBUSER} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbpass' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBPASS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MYNODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-nodes' && scalar @ARGV > 1)
    { shift (@ARGV); push(@{$args{NODES}}, split(/,/, shift(@ARGV))); }
    else
    { last; }
}

if (scalar @ARGV || !$args{DROPDIR} || !$args{DBNAME} || !$args{DBUSER}
    || !$args{DBPASS} || !$args{DBITYPE} || !$args{MYNODE} || !$args{NODES})
{
    print STDERR
	"usage: $me -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
	"    -state IN-DROP-BOX [-wait SECS-TO-WAIT]\n",
	"    -node TMDB-NODE-NAME -nodes PATTERN[,PATTERN...]\n";
    exit (1);
}

my $agent = new FileRouter (%args);
# Recapture interrupt signal, oracle swallows it.
$SIG{INT} = sub { system "touch $agent->{STOPFLAG}"; $agent->maybeStop (); };
$agent->process ();

######################################################################
# Routines for this agent.
package FileRouter; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBITYPE => undef,		# Database driver binding
    		  DBNAME => undef,		# Database name
	  	  DBUSER => undef,		# Database user name
	  	  DBPASS => undef,		# Database user password
		  MYNODE => undef,		# My node name
		  NODES => [],			# Nodes to route for
	  	  AGENTID => "Router");		# Identity for activity logs
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Called by agent main routine before sleeping.  Pick up work
# assignments from the database here and pass them to slaves.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	# Connect to the database.
	$dbh = &connectToDatabase ($self) or die "failed to connect";

	# Read routing table into memory.
	my $start = &mytimeofday ();
	my $routes = $self->currentRoutes ($dbh);

	# Route all files not yet at destination.
	foreach my $nodepat (@{$self->{NODES}})
	{
	    my $nrouted = 0;
	    my $nincomplete = 0;
	    my $now = &mytimeofday ();
	    foreach my $file (@{$self->pendingFiles ($dbh, $nodepat)})
	    {
		++$nincomplete;
		++$nrouted if $self->routeNextHop ($dbh, $file, $routes);
		$routes = $self->currentRoutes ($dbh)
		    if (&mytimeofday () - $start > 10*60);
	    }

	    &logmsg ("$nodepat: considered $nincomplete destinations,"
		     . " $nrouted routes created in"
		     . " @{[sprintf '%.1f', &mytimeofday() - $now]} seconds")
	        ; #if $nincomplete;
	
	    $self->maybeStop();
	}

	# Clear SQL statement cache
	undef $self->{STMT_CACHE};
    };
    do { &alert ("database error: $@"); $dbh->rollback() if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Check children are still running and then wait
    $self->nap ($self->{WAITTIME});
}

# Read routing table into memory.  This avoids having to go to the
# database each time around for each file.  Returns a hash table
# representing the routing information.
sub currentRoutes
{
    my ($self, $dbh) = @_;
    my $routes = {};
    my $stmt = &dbexec ($dbh, qq{
	select from_node, to_node, gateway, hops, timestamp from t_routing});
    while (my ($from, $to, $gw, $hops, $time) = $stmt->fetchrow ())
    {
	$routes->{$from}{$to} = {
	    FROM	=> $from,
	    TO		=> $to,
	    GATEWAY	=> $gw,
	    HOPS	=> $hops,
	    TIME	=> $time
    	};
    }

    return $routes;
}


# Determine which files destined for nodes matching PATTERN are not
# yet at the destination and thus still require routing.
sub pendingFiles
{
    my ($self, $dbh, $pattern) = @_;
    my $result = [];
    my $dstmt = $self->{STMT_CACHE}{DEST} ||= &dbprep ($dbh, qq{
	select d.guid, d.node
	from t_destination d
	left join t_replica_state rs
	  on rs.guid = d.guid and rs.node = d.node
	where rs.node is null and d.node like :pattern});

    &dbbindexec ($dstmt, ":pattern" => $pattern);
    while (my ($guid, $dest) = $dstmt->fetchrow())
    {
	push (@$result, { GUID => $guid, DEST => $dest });
    }

    return $result;
}

# Check if we should try routing FILE.  Currently always returns true.
# To be amended to recall last routing decision (pending transfer edge)
# and to quickly check if that one is completed; there is no point in
# further routing until replicas and transfers change.  Routing data
# will be purged periodically to allow database to override.
sub shouldRouteFile
{
    my ($self, $dbh, $file) = @_;
    return 1;
}

# Route file to the next hop.
sub routeNextHop
{
    my ($self, $dbh, $file, $routes) = @_;
    my $guid = $file->{GUID};
    my $dest = $file->{DEST};
    my $now = &mytimeofday ();
    my $oldroute = $now - 15*60;

    # Do a quick check if we should be routing this file
    # return 0 if ! $self->shouldRouteFile ($dbh, $file);

    # Get statements we need
    my $rstmt = $self->{STMT_CACHE}{RS} ||= &dbprep ($dbh, qq{
	select rs.node, ts.to_node
	from t_replica_state rs
	left join t_transfer_state ts
	  on ts.guid = rs.guid and ts.from_node = rs.node
	where rs.guid = :guid});
    my $istmt = $self->{STMT_CACHE}{INS} ||= &dbprep ($dbh, qq{
	insert into t_transfer_state
	(timestamp, guid, to_node, to_state, to_timestamp,
	 from_node, from_state, from_timestamp)
	values (:now, :guid, :to_node, 0, :now, :from_node, 0, :now)});

    # Determine replicas and transfers for this file.
    my (%replicas, %transfers) = ();
    &dbbindexec ($rstmt, ":guid" => $guid);
    while (my ($node, $to) = $rstmt->fetchrow()) {
	$replicas{$node} = 1;
	$transfers{$to} = 1 if $to;
    }
    $rstmt->finish ();

    # Determine nearest replica
    my @best = sort { $a->{HOPS} <=> $b->{HOPS} }
    	       map { $routes->{$_}{$dest} }
    	       grep (exists $routes->{$_}{$dest},
		     keys %replicas);

    # Check the routes are valid
    while (@best)
    {
	my $route = shift (@best);

	# Done if there is an existing transfer already.
	return 0 if exists $transfers{$route->{GATEWAY}};

	# Ignore this one if the route is too old
	my $age = sprintf ('%.1f', $now - $route->{TIME});
	if ($route->{TIME} < $oldroute)
	{
	    &warn ("$dest $guid: best replica at $route->{FROM}"
		   . " ($route->{HOPS} hops away via $route->{GATEWAY})"
		   . " is unreachable, route is $age seconds old")
	        if ! $self->{WARNINGS}{ROUTE}{$guid}{$dest}{$route->{FROM}}{$route->{GATEWAY}};
	    $self->{WARNINGS}{ROUTE}{$guid}{$dest}{$route->{FROM}}{$route->{GATEWAY}} = 1;
	    next;
	}

	# Make sure no replica exists at destination
	if (exists $replicas{$route->{GATEWAY}})
	{
	    &warn ("$dest $guid: best replica at $route->{FROM}"
		   . " ($route->{HOPS} hops away via $route->{GATEWAY})"
		   . " is untransferrable, destination replica exists")
	        if ! $self->{WARNINGS}{ROUTE}{$guid}{$dest}{$route->{FROM}}{$route->{GATEWAY}};
	    $self->{WARNINGS}{ROUTE}{$guid}{$dest}{$route->{FROM}}{$route->{GATEWAY}} = 1;
	    next;
	}

	# OK, usable route
	&logmsg ("routing $guid to $dest from $route->{FROM} via $route->{GATEWAY}"
	         . " ($route->{HOPS} hops, $age seconds ago)");

	&dbbindexec ($istmt,
		     ":now" => $now,
		     ":guid" => $guid,
		     ":from_node" => $route->{FROM},
		     ":to_node" => $route->{GATEWAY});

	delete $self->{WARNINGS}{ROUTE}{$guid}{$dest};
	delete $self->{WARNINGS}{UNAVAILABLE}{$guid}{$dest};
	delete $self->{WARNINGS}{NO_ROUTE}{$guid}{$dest};
	$dbh->commit ();
	return 1;
    }

    # Oops, something went wrong.  Diagnose.
    if (! keys %replicas)
    {
	&alert ("$dest $guid: no source replica available")
	    if ! $self->{WARNINGS}{UNAVAILABLE}{$guid}{$dest};
	$self->{WARNINGS}{UNAVAILABLE}{$guid}{$dest} = 1;
    }
    else
    {
	&alert ("$dest $guid: no replica routable to destination")
	    if ! $self->{WARNINGS}{NO_ROUTE}{$guid}{$dest};
	$self->{WARNINGS}{NO_ROUTE}{$guid}{$dest} = 1;
    }

    return 0;
}
