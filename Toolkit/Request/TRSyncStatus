#!/usr/bin/env perl

##H Update file transfer progress for a transfer request.
##H
##H Usage: TRSyncStatus -dbs TYPE [-dbsdb FILE[:SECTION]]
##H                     -db FILE[:SECTION] [REQUEST...]
##H
##H REQUEST is the pattern for request name.  The requests are taken
##H from the database, no the request tickets created with TRNew,
##H although if TRSyncWeb has been ran, the two are the same.
##H The default is to update all requests.
##H
##H -dbs TYPE specifies the DBS to contact, either "RefDB" or "PhEDEx".
##H -dbsdb defines database contact parameters for "PhEDEx" DBS.
##H -db defines the database contact parameters for request database.

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}
use UtilsHelp;
use UtilsDBS;
use UtilsDB;
use UtilsTiming;
use TextGlob 'glob_to_regex';

my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h') {
	&usage();
    } elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBCONFIG} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-dbs' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBS}{TYPE} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-dbsdb' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBS}{DBCONFIG} = shift (@ARGV);
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

if (!$args{DBCONFIG} || !$args{DBS}{TYPE}
    || !($args{DBS}{TYPE} eq 'RefDB' || $args{DBS}{TYPE} eq 'PhEDEx')
    || !($args{DBS}{TYPE} ne 'PhEDEx' || $args{DBS}{DBCONFIG}))
{
    die "Incorrect parameters, use -h for help.\n";
}

# Initialise
$TextGlob::strict_wildcard_slash = 0;
my $now = &mytimeofday();
my %blockstats = ();
my @reqpats = map { glob_to_regex($_) } @ARGV;
my $dbh = &connectToDatabase (\%args, 0);
my $dbs = ($args{DBS}{TYPE} eq 'RefDB'
	   ? new UtilsDBS::RefDB ($args{DBS})
	   : new UtilsDBS::PhEDEx ($args{DBS}));
my $dbsitems = $dbs->fetchPublishedData();

my $requests = &dbexec ($dbh, qq{select id, name from t_request})
    ->fetchall_arrayref({});
foreach my $request (@$requests)
{
    next if (@reqpats && ! grep ($request->{NAME} =~ /$_/, @reqpats));
    do { local $| = 1; print "Updating file transfer status for $request->{NAME}\n" };

    # Read blocks and destinations
    my @blocks = ();
    my $qblocks = &dbexec ($dbh, qq{
	select operation, owner, dataset, block
	from t_request_dataspec
	where request = :reqid
	order by timestamp asc},
	":reqid" => $request->{ID});
    while (my ($op, $owner, $dataset, $block) = $qblocks->fetchrow())
    {
	if ($op eq 'CANCEL') {
	    @blocks = ();
	} elsif ($op =~ /XPATS.[a-z]/) {
	    push (@blocks, [ $block, $owner, $dataset ])
	        if ! grep ($_->[0] eq $block, @blocks);
	} elsif ($op =~ /UPATS.[a-z]/) {
	    # Ignore user input patterns
	} else {
	    die "$request->{NAME} (id=$request->{ID}): unrecognised "
	        . "data request operation `$op'\n";
	}
    }

    my @dests = ();
    my $qdests = &dbexec ($dbh, qq{
	select operation, destination
	from t_request_subscription
	where request = :reqid
	order by timestamp asc},
	":reqid" => $request->{ID});
    while (my ($op, $dest) = $qdests->fetchrow())
    {
	if ($op eq 'CANCEL') {
	    @dests = ();
	} elsif ($op eq 'LOC') {
	    push (@dests, $dest) if ! grep ($_ eq $dest, @dests);
	} else {
	    die "$request->{NAME} (id=$request->{ID}): unrecognised "
	        . "data location operation `$op'\n";
	}
    }

    # Fetch block stats if we have not already obtained them.
    foreach my $b (@blocks)
    {
	my ($block, $o, $ds) = @$b;
	next if exists $blockinfo{$block};

	# We haven't yet seen this block.  Fill in the information
	$blockinfo{$block} = {
	    TMDB => { FILES => 0, SIZE => 0, ISOPEN => 'X', GUIDS => {} },
	    DBS  => { FILES => 0, SIZE => 0, ISOPEN => 'X', GUIDS => {} },
    	    SITE => {} };

        do { local $| = 1; print " Updating block $block: DBS" };

        # Fetch file information from DBS
	my $item = (grep ($_->{OWNER} eq $o && $_->{DATASET} eq $ds, @$dbsitems))[0];
	if (defined $item)
	{
            eval { $dbs->fillDatasetInfo ($item); $dbs->fillDatasetInfo ($item); };
            do { chomp ($@); warn ($@); next } if $@;

	    $blockinfo{$block}{DBS}{ISOPEN}
	        = (($item->{DSINFO}{CollectionStatus} || 0) eq 6 ? 0 : 1);
	    foreach my $file (@{$item->{FILES}})
	    {
	        $blockinfo{$block}{DBS}{GUIDS}{$file->{GUID}} = 1;
	        $blockinfo{$block}{DBS}{FILES}++;
	    }

            $item->{FILES} = [];
            $item->{BLOCKS} = {};
            $item->{RUNS} = {};
	}

	# Fetch file information from PhEDEx
        do { local $| = 1; print ", PhEDEx files" };
	my ($files, $bytes, $isopen) = &dbexec ($dbh, qq{
	    select files, bytes, isopen from t_block where name = :block},
	    ":block" => $block)->fetchrow();
    	$blockinfo{$block}{TMDB}{SIZE} = $bytes;
    	$blockinfo{$block}{TMDB}{FILES} = $files;
    	$blockinfo{$block}{TMDB}{ISOPEN} = $isopen;

	my $qfile = &dbexec ($dbh, qq{
	    select guid from t_file where inblock = :block},
	    ":block" => $block);
    	while (my ($guid) = $qfile->fetchrow())
	{
	    $blockinfo{$block}{TMDB}{GUIDS}{$guid} = 1;
        }
        $qfile->finish();

	# Fetch block replication status from PhEDEx
        do { local $| = 1; print ", PhEDEx blocks" };
	my $qblockr = &dbexec ($dbh, qq{
	    select node, node_files, node_bytes
	    from t_block_replica where name = :block},
	    ":block" => $block);
        while (my ($node, $files, $bytes) = $qblockr->fetchrow())
	{
	    $blockinfo{$block}{SITE}{$node} = { SIZE => $bytes, FILES => $files };
	}
        $qblockr->finish();

        do { local $| = 1; print "\n" };
    }

    # Compare the file sets and update database
    &dbexec ($dbh, qq{delete from t_request_status where request = :reqid},
	":reqid" => $request->{ID});

    foreach my $b (@blocks)
    {
	my ($block, $o, $ds) = @$b;
	my $info = $blockinfo{$block};

        my (%common, %dbsonly, %tmdbonly) = ();
        foreach my $guid (keys %{$info->{DBS}{GUIDS}})
        {
            if (exists $info->{TMDB}{GUIDS}{$guid})
            { $common{$guid} = 1; }
            else
            { $dbsonly{$guid} = 1; }
        }

        foreach my $guid (keys %{$info->{TMDB}{GUIDS}})
        {
            if (exists $info->{DBS}{GUIDS}{$guid})
            { $common{$guid} = 1; }
            else
            { $tmdbonly{$guid} = 1; }
        }

        # Update database and print out stats
	foreach my $dest (@dests)
	{
	    &dbexec ($dbh, qq{
	        insert into t_request_status
	        (timestamp, request, block, destination,
	         dbs_isopen, dbs_files, dbs_bytes,
	         tmdb_isopen, tmdb_files, tmdb_bytes,
	         dest_files, dest_bytes, 
	         common_files, dbs_only_files, tmdb_only_files)
	        values
	        (:stamp, :reqid, :block, :dest,
	         :dbs_isopen, :dbs_files, :dbs_bytes,
	         :tmdb_isopen, :tmdb_files, :tmdb_bytes,
	         :dest_files, :dest_bytes, 
	         :common_files, :dbs_only_files, :tmdb_only_files)},
	        ":stamp" => $now,
	        ":reqid" => $request->{ID},
	        ":block" => $block,
	        ":dest" => $dest,
	        ":dbs_isopen" => $info->{DBS}{ISOPEN},
	        ":dbs_files" => $info->{DBS}{FILES},
		":dbs_bytes" => $info->{DBS}{SIZE},
	        ":tmdb_isopen" => $info->{TMDB}{ISOPEN},
	        ":tmdb_files" => $info->{TMDB}{FILES},
		":tmdb_bytes" => $info->{TMDB}{SIZE},
	        ":dest_files" => $info->{SITE}{$dest}{FILES} || 0,
		":dest_bytes" => $info->{SITE}{$dest}{SIZE} || 0, 
	        ":common_files" => scalar keys %common,
	        ":dbs_only_files" => scalar keys %dbsonly,
	        ":tmdb_only_files" => scalar keys %tmdbonly);
        }
    }
    $dbh->commit();
}

exit 0;
