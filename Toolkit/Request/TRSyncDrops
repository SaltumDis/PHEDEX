#!/usr/bin/env perl

##H FIXME: Brief intro
##H
##H Usage: TRSyncDrops REQUEST...
##H
##H REQUEST is the request directory previously created with TRNew.
##H Generates drops in each request directory from the assignment
##H information previously added with TRNewData, simulating the
##H outcome from real running jobs.  The drops will be created
##H under REQUEST/Drops/Pending.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}
use UtilsTR;
use UtilsNet;
use UtilsCommand;
use File::Path;
use Cwd;

my $now = time();

while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h') {
	&usage();
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

foreach my $request (@ARGV)
{
    -f "$request/Request/Ticket"
        or die "$request: not a transfer request\n";

    # Find out the assignments
    my @assids = ();
    open(TICKET, "< $request/Request/Ticket") or die "Cannot read ticket: $!\n";
    while (<TICKET>)
    {
	if (/^\d+ CANCEL DATA$/) {
	    @assids = ();
	} elsif (/^\d+ DATA ASSIDS ([\d\s]*)$/) {
	    push(@assids, split(/\s+/, $1));
	}
    }
    close (TICKET) or die "Cannot read ticket: $!\n";

    # Process each assignment
    foreach my $assid (@assids)
    {
        print "Generating drops for $assid\n";
        my $destdir = "$request/Drops/Pending";
        my $drops = eval { &assignmentDrops ($assid); };
	do { print STDERR "Warning: $@", "Warning: $assid: skipped\n"; next; }
	    if $@; # FIXME: is this handling enough/ok?

        foreach my $drop (sort keys %$drops)
        {
	    my $xmlfile = "$destdir/$drop/XMLCatFragment.$drop.xml";
	    my $smryfile = "$destdir/$drop/Smry.$drop.txt";

	    print "Generating drop $drop\n";
	    -d "$destdir/$drop"
	        && print(STDERR "Warning: removing existing $drop\n")
		&& &rmtree ("$destdir/$drop");

            &mkpath ("$destdir/$drop");
	    &output ($xmlfile, $drops->{$drop}{XML}) or die "$xmlfile: cannot write: $!\n";
	    &output ($smryfile, $drops->{$drop}{SMRY}) or die "$smryfile: cannot write: $!\n";
        }
    }
}
