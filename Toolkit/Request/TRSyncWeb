#!/usr/bin/env perl

##H Synchronise web database for the requests.
##H
##H Usage: TRSyncWeb -db FILE[:SECTION] REQUEST...
##H
##H REQUEST is the request ticket previously created with TRNew.

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}
use UtilsHelp;
use UtilsDB;

my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h') {
	&usage();
    } elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBCONFIG} = shift (@ARGV);
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

if (!$args{DBCONFIG})
{
    die "Incorrect parameters, use -h for help.\n";
}

foreach my $request (@ARGV)
{
    -f "$request" or die "$request: not a transfer request\n";
    my ($reqname) = ($request =~ m|/([^/]+)$|);
    print "Updating database for $request\n";

    # Read ticket
    my @cmds = ();
    my @locs = ();
    my @data = ();
    open(TICKET, "< $request") or die "Cannot read ticket: $!\n";
    while (<TICKET>)
    {
	if (/^(\d+) CMD (\S+) (\S+)/) {
	    push(@cmds, { STAMP => $1, COMMAND => $2, ARG => $3 });
	}
	elsif (/^(\d+) CANCEL LOC$/) {
	    push(@locs, { STAMP => $1, COMMAND => "CANCEL" });
	}
	elsif (/^(\d+) LOC (.*)$/) {
	    foreach my $loc (split(/\s+/, $2)) {
		push(@locs, { STAMP => $1, COMMAND => "LOC", ARG => $loc });
	    }
	}
	elsif (/^(\d+) CANCEL DATA$/) {
	    push(@data, { STAMP => $1, COMMAND => "CANCEL" });
        }
	elsif (/^(\d+) DATA ([A-Z]PATS\.[a-z]) (.*)$/) {
	    foreach my $pat (split(/\s+/, $3)) {
		push(@data, { STAMP => $1, COMMAND => $2, ARG => $pat });
	    }
        }
    }
    close (TICKET) or die "Cannot read ticket: $!\n";

    # Obtain status of drops
    my $dbh = &connectToDatabase (\%args, 0);

    # Check if the request is known.  If so, delete all info about it
    my ($reqid) = &dbexec ($dbh, qq{select id from t_request where name = :req},
	":req" => $reqname)->fetchrow();

    if (defined $reqid)
    {
	my %args = (":reqid" => $reqid);
	map { &dbexec ($dbh, qq{delete from $_ where request = :reqid}, %args) }
            qw(t_request_dataspec t_request_subscription t_request_operation);
    }
    else
    {
	($reqid) = &dbexec ($dbh, qq{select seq_request_id.nextval from dual})
	    ->fetchrow();
	&dbexec ($dbh, qq{insert into t_request values (:reqid, :req)},
	    ":reqid" => $reqid, ":req" => $reqname);
    }

    # Then add new info
    foreach my $op (@cmds) {
	&dbexec ($dbh, qq{
	    insert into t_request_operation
	    (timestamp, request, operation, identity)
	    values (:stamp, :reqid, :op, :arg)},
	    ":reqid" => $reqid, ":stamp" => $op->{STAMP},
	    ":op" => $op->{COMMAND}, ":arg" => $op->{ARG});
    }

    foreach my $op (@locs) {
	&dbexec ($dbh, qq{
	    insert into t_request_subscription
	    (timestamp, request, operation, destination)
	    values (:stamp, :reqid, :op, :arg)},
	    ":reqid" => $reqid, ":stamp" => $op->{STAMP},
	    ":op" => $op->{COMMAND}, ":arg" => $op->{ARG});
    }

    foreach my $op (@data) {
	my ($ow, $ds) = ($op->{ARG} =~ m|(.*)/(.*)|);
	&dbexec ($dbh, qq{
	    insert into t_request_dataspec
	    (timestamp, request, operation, owner, dataset, block)
	    values (:stamp, :reqid, :op, :ow, :ds, :block)},
	    ":reqid" => $reqid, ":stamp" => $op->{STAMP}, ":op" => $op->{COMMAND},
	    ":ow" => $ow, ":ds" => $ds, ":block" => $op->{ARG});
    }

    $dbh->commit();
    $dbh->disconnect();
}
