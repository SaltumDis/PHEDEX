#!/usr/bin/env perl

##H FIXME: Brief intro
##H
##H Usage: TRSyncWeb REQUEST...
##H
##H REQUEST is the request directory previously created with TRNew.
##H Synchronises the web database for the requests.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}
use UtilsTR;
use UtilsDB;
use UtilsNet;
use File::Path;
use Cwd;

my %args;
my $now = time();
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h') {
	&usage();
    } elsif ($ARGV[0] eq '-dbconfig' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBCONFIG} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-mouth' && scalar @ARGV > 1) {
	shift (@ARGV); $args{MOUTH} = shift (@ARGV);
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

if (!$args{MOUTH} || ! -d $args{MOUTH} || !$args{DBCONFIG})
{
    die "Incorrect parameters, use -h for help.\n";
}

foreach my $request (@ARGV)
{
    $request =~ s|/+$||;
    -f "$request/Request/Ticket"
        or die "$request: not a transfer request\n";

    # Read ticket
    my @cmds = ();
    my @locs = ();
    my @data = ();
    open(TICKET, "< $request/Request/Ticket") or die "Cannot read ticket: $!\n";
    while (<TICKET>)
    {
	if (/^(\d+) CMD (\S+) (\S+)/) {
	    push(@cmds, { STAMP => $1, COMMAND => $2, ARG => $3 });
	}
	elsif (/^(\d+) CANCEL LOC$/) {
	    push(@locs, { STAMP => $1, COMMAND => "CANCEL" });
	}
	elsif (/^(\d+) LOC (.*)$/) {
	    foreach my $loc (split(/\s+/, $2)) {
		push(@locs, { STAMP => $1, COMMAND => "LOC", ARG => $loc });
	    }
	}
	elsif (/^(\d+) CANCEL DATA$/) {
	    push(@data, { STAMP => $1, COMMAND => "CANCEL" });
        }
	elsif (/^(\d+) DATA ([A-Z]PATS\.[a-z]) (.*)$/) {
	    foreach my $pat (split(/\s+/, $3)) {
		push(@data, { STAMP => $1, COMMAND => $2, ARG => $pat });
	    }
        }
    }
    close (TICKET) or die "Cannot read ticket: $!\n";

    # Obtain status of drops
    my $dbh      = &connectToDatabase (\%args, 0);
    my @pending  = <$request/Drops/Pending/*>;
    my @notready = <$request/Drops/NotReady/*>;
    my @done	 = <$request/Drops/Done/*>;
    my @drops	 = (@pending, @notready, @done);
    my $status   = &checkAssignmentFiles ($args{MOUTH}, $dbh, @drops);
    map { $status->{$_}{DROP_CATEGORY} = 'Pending' } @pending;
    map { $status->{$_}{DROP_CATEGORY} = 'NotReady' } @notready;
    map { $status->{$_}{DROP_CATEGORY} = 'Done' } @done;

    # Reflect information back into database
    # First delete old information about this request
    my %args = (":req" => $request);
    map { &dbexec ($dbh, qq{delete from $_ where request_name = :req}, %args) }
        qw(t_request_file_status t_request_file t_request_drop
	   t_request_data t_request_subscription t_request_operation
	   t_request);

    # Then add new info
    &dbexec ($dbh, qq{insert into t_request values (:req)}, %args);
    foreach my $op (@cmds) {
	&dbexec ($dbh, qq{
	    insert into t_request_operation
	    (request_name, timestamp, operation, identity)
	    values (:req, :stamp, :op, :arg)},
	    ":req" => $request, ":stamp" => $op->{STAMP},
	    ":op" => $op->{COMMAND}, ":arg" => $op->{ARG});
    }

    foreach my $op (@locs) {
	&dbexec ($dbh, qq{
	    insert into t_request_subscription
	    (request_name, timestamp, operation, destination)
	    values (:req, :stamp, :op, :arg)},
	    ":req" => $request, ":stamp" => $op->{STAMP},
	    ":op" => $op->{COMMAND}, ":arg" => $op->{ARG});
    }

    foreach my $op (@data) {
	&dbexec ($dbh, qq{
	    insert into t_request_data
	    (request_name, timestamp, operation, selection)
	    values (:req, :stamp, :op, :arg)},
	    ":req" => $request, ":stamp" => $op->{STAMP},
	    ":op" => $op->{COMMAND}, ":arg" => $op->{ARG});
    }

    foreach my $drop (@drops) {
	&dbexec ($dbh, qq{
	    insert into t_request_drop
	    (request_name, drop_name, drop_category)
	    values (:req, :drop_name, :drop_cat)},
	    ":req" => $request,
	    ":drop_name" => $status->{$drop}{DROPNAME},
	    ":drop_cat" => $status->{$drop}{DROP_CATEGORY});

    	foreach my $file (@{$status->{$drop}{FILES}}) {
	    &dbexec ($dbh, qq{
		insert into t_request_file
		(request_name, guid, drop_name)
		values (:req, :guid, :drop_name)},
		":req" => $request,
		":guid" => $file->{GUID},
		":drop_name" => $status->{$drop}{DROPNAME});

	    &dbexec ($dbh, qq{
		insert into t_request_file_status
		(request_name, guid, location,
		 is_available, is_pending, is_transferred)
		values (:req, :guid, 'CERN_MSS', :av, :pend, :trans)},
		":req" => $request,
		":guid" => $file->{GUID},
		":av" => $file->{IN_MSS} ? '1' : '0',
		":pend" => $file->{PENDING} ? '1' : '0',
		":trans" => $file->{TRANSFERRED} ? '1' : '0');
	}
    }

    $dbh->commit();
    $dbh->disconnect();
}
