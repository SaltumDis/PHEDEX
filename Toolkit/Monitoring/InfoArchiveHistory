#!/usr/bin/env perl

##H Archive transfer history data into tape store.
##H
##H Usage:
##H   InfoArchiveHistory
##H      -state DIRECTORY -db FILE[:SECTION] [-wait SECS]
##H      -command COPY-COMMAND -archive DIRECTORY -pattern PATTERN
##H
##H -state     agent state directory
##H -db        database connection configuration parameter file
##H -wait      time to wait in seconds between work scans
##H -command   command to use to copy into archive (e.g. rfcp, cp)
##H -archive   destination directory to copy into
##H -pattern   pattern to be used for the archive file names; in
##H             the pattern @MONTH@ will be replaced by the month
##H             for which the data is for (in the form "YYYYMM"),
##H             and @STAMP@ with current date as of archiving (in
##H             the form "YYYYMMDDZhhmm")
##H
##H The archive files will be DIRECTORY/PATTERN-REPLACEMENT. where
##H the PATTERN-REPLACEMENT is result of making the replacements
##H described above.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}

######################################################################
use UtilsHelp;
my %args = (WAITTIME => 86400);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-wait' && scalar @ARGV > 1)
    { shift (@ARGV); $args{WAITTIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-state' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DROPDIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-command' && scalar @ARGV > 1)
    { shift (@ARGV); push(@{$args{COPY_COMMAND}}, split(/,/, shift(@ARGV))); }
    elsif ($ARGV[0] eq '-archive' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DEST_DIR} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-pattern' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DEST_PATTERN} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

if (@ARGV || !$args{DROPDIR} || !$args{DBCONFIG}
    || !$args{COPY_COMMAND} || !$args{DEST_DIR}
    || !$args{DEST_PATTERN})
{
    die "Insufficient parameters, use -h for help.\n";
}

(new InfoArchiveHistory (%args))->process();

######################################################################
# Routines for this agent.
package InfoArchiveHistory; use strict; use warnings; use base 'UtilsAgent';
use UtilsCommand;
use UtilsLogging;
use UtilsTiming;
use UtilsDB;
use POSIX; # strftime

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new(@_);
    my %params = (DBCONFIG => undef,		# Database configuration file
    		  COPY_COMMAND => undef,	# Command to copy into archive
	  	  DEST_DIR => undef,		# Destination directory for archives
	  	  DEST_PATTERN => undef);	# Destination file name pattern
    my %args = (@_);
    map { $self->{$_} = $args{$_} || $params{$_} } keys %params;
    bless $self, $class;
    return $self;
}

# Save the output file by flushing data out, then copying it into safe storage.
sub saveFile
{
    my ($self, $fname, $outputfh) = @_;
    eval
    {
	close ($outputfh) or die "$fname: cannot write: $!\n";
	my $destfile = $fname;
	$destfile =~ s|.*/||;
	$destfile = "$self->{DEST_DIR}/$destfile";
	my $rc = &runcmd (@{$self->{COPY_COMMAND}}, $fname, $destfile);
	die "$fname: cannot copy to destination $destfile: @{[&runerror ($rc)]}\n" if $rc;
    };
    unlink ($fname);
    die $@ if $@;
}

# Called by agent main routine before sleeping.  Update database.
sub idle
{
    my ($self, @pending) = @_;
    my $dbh = undef;
    eval
    {
	$dbh = &connectToDatabase ($self, 0) or die "failed to connect";
        # FIXME: Pick up and process messages to me

	# Create monthly archives of past transfer history
	my $thismonth = strftime ('%Y%m', gmtime (time()));
	my $lastmonth = undef;
	my $lasttime = undef;
	my $outputfh = undef;
	my $fname = undef;

	my $cachemonth = undef;
	my $cachetime = undef;

	# Lock the table so we can sweep at the end without having to
	# worry about phantom reads.
	&dbexec ($dbh, qq{lock table t_transfer_history in exclusive mode});

	my $qhistory = &dbexec ($dbh, qq{
	    select timestamp, guid, to_node, to_old_state, to_new_state,
	           from_node, from_old_state, from_new_state
	    from t_transfer_history
	    order by timestamp asc, guid asc});
    	while (my ($time, $guid, $to_node, $to_old_state, $to_new_state,
		   $from_node, $from_old_state, $from_new_state)
	       = $qhistory->fetchrow())
        {
	    my $month;
	    if ($cachetime && int($cachetime/86400) == int($time/86400))
	    {
		$month = $cachemonth;
	    }
	    else
	    {
		$cachemonth = $month = strftime ('%Y%m', gmtime (int ($time)));
		$cachetime = $time;
	    }

	    # Don't archive into this month
	    last if $month eq $thismonth;

	    # See if we need to open a new archive
	    if (! $lastmonth || $lastmonth ne $month)
	    {
		# Flush previous file
		$self->saveFile ($fname, $outputfh) if $outputfh;
		$outputfh = undef;

		# Create a new one
		my $now = strftime ('%Y%m%dZ%H%M%S', gmtime(time()));
		$fname = $self->{DEST_PATTERN};
		$fname =~ s/\@MONTH\@/$month/g;
		$fname =~ s/\@STAMP\@/$now/g;
		$fname = "$self->{WORKDIR}/$fname";
		! -f $fname || die "$fname: already exists\n";
		open ($outputfh, "| gzip --best > $fname") or die "$fname: cannot open: $!\n";
		print $outputfh "TIMESTAMP,GUID,TO_NODE,TO_OLD_STATE,TO_NEW_STATE,",
				"FROM_NODE,FROM_OLD_STATE,FROM_NEW_STATE\n";
	    }

	    # Write out the data
	    print $outputfh "$time,\"$guid\",\"$to_node\",",
	    		    (defined $to_old_state ? $to_old_state : ()), ",",
	    		    (defined $to_new_state ? $to_new_state : ()), ",",
			    "\"$from_node\",",
	    		    (defined $from_old_state ? $from_old_state : ()), ",",
	    		    (defined $from_new_state ? $from_new_state : ()), "\n";

	    $lasttime = $time;
	    $lastmonth = $month;
	}

	# Flush the file
	$self->saveFile ($fname, $outputfh) if $outputfh;

	# Now delete the rows we processed
	if (defined $lasttime)
	{
	    &dbexec($dbh, qq{
		delete from t_transfer_history where timestamp <= :last},
		":last" => $lasttime);
	}

	$dbh->commit();
    };
    do { &alert ("database error: $@");
	 eval { $dbh->rollback() } if $dbh; } if $@;

    # Disconnect from the database
    &disconnectFromDatabase ($self, $dbh);

    # Check children are still running and then wait
    $self->nap ($self->{WAITTIME});
}

1;
