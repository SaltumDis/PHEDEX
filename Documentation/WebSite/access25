#!/usr/bin/env perl

######################################################################
package Web25::Common; use strict; use warnings; use base "Exporter";
use CGI qw(:standard unescape);
use Net::hostent;
require Socket;
use POSIX qw(strftime mktime);
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} || "./"; $__scriptdir =~ s,[^/]+$,,; unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;


our @EXPORT = qw(urlencode dblink toclink pagelink
		 alert warning breakAtSlash note help
		 age format_num format_size format_timespan
		 badcolor warncolor pendcolor goodcolor altcolor
		 dbexec dbprep dbbindexec dbinlist makeObjWithAttrs
		 timeSeries formatTime timegm sizeValue
		 alert_auth
                 fetch_identity_id set_auth_vars 
		 fetch_dbses fetch_nodes fetch_sites fetch_users
                 create_default_email send_email dn_to_human_name
		 yesno striplabels
		 dump_params dump_var
);

# Various useful colours
our $badcolor = '#ff9e9e';
our $warncolor = '#ffd89e';
our $pendcolor = '#ccccff'; # ececff
our $goodcolor = '#ccffcc';
our $altcolor = '#f0f0f0';

# Encode arguments into a URL query string.
sub urlencode
{
  eval "use CGI '-oldstyle_urls'";
  my %args = @_; return new CGI (\%args)->query_string();
}

# Generate a HTML <a> link for a database instance.
sub dblink
{
  my ($self, $dbname, $db) = @_;
  return "<a href='" . $self->myurl('db' => $$db{ID})
    . "' title='$$db{TITLE} database instance'>$$db{TITLE}</a>";
}

# Generate a HTML <a> link for a category.  For now this is just a
# link to the first page of the category.
sub toclink
{
  my ($self, $category) = @_;

  # Scan pages for this category
  no strict "refs";
  my @pages = ();
  my $scope = \%{*{$category}{PACKAGE} . "::"};
  foreach (keys %$scope)
  {
    next if ! /::$/;
    next if ! exists ${$$scope{$_}}{INDEX};
    push(@pages, ${$$scope{$_}}{INDEX});
  }

  @pages = sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @pages;
  return &pagelink($self, $pages[0], ${$$category}{TITLE});
}

# Generate a HTML <a> link for a page.
sub pagelink
{
  my ($self, $page, $label) = @_;
  my $title = "";
  my $url = ${$$page}{LINK};
  my $name = *{$page}{PACKAGE}; $name =~ s/Web25:://;
  $label = ${$$page}{TITLE} if ! defined $label;

  # If the page has a title, stuff into a link attribute.
  if (${$$page}{LINK_TITLE})
  {
    $title = " title='@{[&escapeHTML(${$$page}{LINK_TITLE})]}'";
  }

  # If the page has a URL, convert relative one; otherwise generate a URL.
  if ($url && $url !~ /^[a-z]+:/ && substr($url,0,1) ne '/') 
  {
    $url = "$$self{CONFIG}{SERVICE_PATH}/$url";
  }
  elsif (! $url)
  {
    $url = $self->myurl("page" => $name);
  }

  # Return final link.
  return "<a href='$url'$title>" .  &escapeHTML($label) . "</a>";
}

# Convert a time difference into human-friendly short age string.
sub age
{
  my ($diff, $precision) = @_;
  $precision = 'minute' if !defined $precision;
  if (! grep ($precision eq $_, qw(second minute)) ) {
      die "Bad args to age()\n";
  }

  my $str = "";
  my $full = 0;

  if ($precision ne 'minute' &&  abs($diff) <= 3600) {
      $str .= sprintf("%dm", $diff / 60);
      $diff %= 60;
      $str .=  sprintf("%02d", $diff);
      return $str;
  }

  if (abs($diff) >= 86400)
  {
    $str .= sprintf("%dd", $diff / 86400);
    $diff %= 86400;
    $full = 1;
  }
  $str .= sprintf("%dh", $diff / 3600);
  $diff %= 3600;
  $str .= sprintf("%02d", $diff / 60);
  return $str;
}

# Convert a time span into human-friendly long string.
sub format_timespan
{
  my $span = shift;
  if ($span >= 86400)
  {
    $span /= 86400;
    return $span == 1 ? "day" : "$span days";
  }
  elsif ($span >= 3600)
  {
    $span /= 3600;
    return $span == 1 ? "hour" : "$span hours";
  } elsif ($span >= 60) {
    $span /= 60;
    return $span == 1 ? "minute" : "$span minutes";
  } else {
    return $span == 1 ? "second" : "$span seconds";
  }
}

sub breakAtSlash
{
  my ($val) = @_;
  return unless $val;
  my $agent = $ENV{HTTP_USER_AGENT} || "";
  $val =~ s,/,/&\#8203;,g if ($agent =~ /Mozilla/ && $agent !~ /MSIE/);
  return $val;
}

# Generate an alert into the output.
sub alert
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='alert'>",
    "<p><b>Error:</b> ", @_, "</p></div></center>\n";
}

# Generate a warning into the output.
sub warning
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='warning'>",
    "<p><b>Warning:</b> ", @_, "</p></div></center>\n";
}

# Generate a note into the output.
sub note
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='note'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate hide/show help
sub help
{
    my ($linktext, $helpsubject, @help) = @_;
    my $id = 'help'.rand();
    return 
	"<a class='help' href='#' onclick='return hideshow(this,\"$id\",0)'>$linktext</a>",
	"<div id='$id' style='display:none' class='help'>",
	"<a href='#' class='closelink' onclick='return hideshow(this, \"$id\", 0)'>[close]</a>",
	"<p class='title'>$helpsubject</p>",
	"<p class='body'>",
	@help,
	"</p>",
	"</div>";
}


# Format a number as a string.  Zero is converted into a dash.
sub format_num
{
  my ($n) = @_;
  return $n ? "$n" : '&#8211;';
}

# Format a file size as a string.  The value is automatically
# abbreviated with a k/M/G/T/P/E suffix, either the first that
# applies or a minimum scale requested by the caller.  The default
# precision is one decimal point, but the caller can change this.
sub format_size {
  my ($bytes, $nodash, $precision, $minscale) = @_;
  my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		[ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
  my ($val, $unit, $minus) = ($bytes, '', $bytes < 0 ? "-" : "");
  do { $val = -$val; $bytes = -$bytes; } if $minus;
  while (@bounds && ($bytes >= $bounds [0][0] || defined $minscale))
  {
    $val = $bytes / $bounds[0][0];
    $unit = $bounds[0][1];
    undef $minscale if (defined $minscale && $minscale eq $unit);
    shift (@bounds);
  }

  $precision = "1" if ! defined $precision;
  return $bytes || $nodash
    ? sprintf("%s%.${precision}f&nbsp;%sB", $minus, $val, $unit)
    : '&#8211;';
}

# Tidy up SQL statement
sub dbsql
{
  my ($sql) = @_;
  $sql =~ s/--.*//mg;
  $sql =~ s/^\s+//mg;
  $sql =~ s/\s+$//mg;
  $sql =~ s/\n/ /g;
  return $sql;
}

# Simple utility to prepare a SQL statement
sub dbprep
{
  my ($dbh, $sql) = @_;
  return $dbh->prepare (&dbsql ($sql));
}

# Simple utility to prepare, bind and execute a SQL statement.
sub dbexec
{
  my ($dbh, $sql, %params) = @_;
  my $stmt = &dbprep ($dbh, $sql);
  my $rv = &dbbindexec ($stmt, %params);
  return wantarray ? ($stmt, $rv) : $stmt;
}

# Simple bind and execute a SQL statement.
sub dbbindexec
{
  my ($stmt, %params) = @_;
  my $isarray = 0;
  while (my ($param, $val) = each %params)
  {
    if (ref $val eq 'ARRAY')
    {
      $stmt->bind_param_array ($param, $val);
      $isarray++;
    }
    elsif (ref $val)
    {
      $stmt->bind_param_inout ($param, $val, 4096);
    }
    else
    {
      $stmt->bind_param ($param, $val);
    }
  }

  return $isarray
    ? $stmt->execute_array({ ArrayTupleResult => [] })
    : $stmt->execute();
}

# Retrun an sql fragment and a bind hash for an SQL "IN" list
sub dbinlist
{
    my ($prefix, @binds) = @_;
    my $in_list = join(', ', map { ":${prefix}_".($_+1) } (0..$#binds));                                                            
    my %in_binds = map { (":${prefix}_".($_+1) => $binds[$_]) } (0..$#binds); 
    return $in_list, %in_binds;
}


# Convenience wrapper for automatically constructing an object
# with requested set of attributes.
sub makeObjWithAttrs
{
  my ($dbh, $kind, $link, $obj, @attrs) = @_;
  my ($tname, $sname) = ("t_$kind", "seq_$kind");
  my @objfields = keys %$obj;
  my %objattrs = map { (":attr_$_" => $$obj{$_}) } @objfields;

  my $objsql =
    "insert into $tname ("
    . join(", ", "id", @objfields)
    . ")\n values ("
    . join(", ", "$sname.nextval", map { ":attr_$_" } @objfields)
    . ")\n returning id into :id";
  my $id = undef;
  &dbexec($dbh, $objsql, ":id" => \$id, %objattrs);

  $tname .= "_attr"; $sname .= "_attr";
  while (@attrs)
  {
    my ($name, $value) = splice(@attrs, 0, 2);
    &dbexec($dbh, qq{
      insert into $tname (id, $link, name, value)
      values ($sname.nextval, :Id, :name, :value)},
      ":id" => $id, ":name" => $name, ":value" => $value);
  }

  return $id;
}


sub alert_auth 
{
    my ($self, %args) = @_;
    my $need = $args{need};
    my $power = $args{power};
    unless (grep $need eq $_, qw(anycert gridcert registered siteadmin globaladmin)) { 
	die "Bad requirement '$need' to auth function", $!; 
    }

    my $login_url = $self->myurl("secure" => 1);
    my $reg_url = $self->myurl(page => "Administration::SignUp");
    my $gridcert_help_url = 'http://lcg.web.cern.ch/LCG/users/registration/load-cert.html';

    if ($need eq 'anycert' && !$$self{SSL_IDENTITY}) {
	$self->alert("You are not <a href='$gridcert_help_url'>authenticated in with a certificate</a>.  ",
		     "If you are authenticated ",
		     "it is possible to $power from this page.");
	return 0;
    } elsif ($need eq 'gridcert' && (!$$self{SSL_IDENTITY} && !$$self{SSL_VERIFIED})) {
	$self->alert("You are not <a href='$gridcert_help_url'>authenticated with a valid grid certificate</a>.  ",
		    "If you are logged in ",
		    "it is possible to $power from this page.");
	return 0;
    } elsif ($need eq 'registered' && (!$$self{SSL_IDENTITY} && !$$self{SSL_VERIFIED})) {
	$self->alert("You are not <a href='$gridcert_help_url'>authenticated with a valid grid certificate</a>.  ",
		    "If you are logged in and <a href='$reg_url'>registered</a> ",
		    "it is possible to $power from this page.");
	return 0;
    } elsif ($need eq 'registered' && !$$self{DB_IDENTITY_ID} ) {
	$self->alert("You are authenticated with a valid grid certificate but are not ",
		    "<a href='$reg_url'>registered</a>.  If you are registered ",
		    " it is possible to $power from this page.");
	return 0;
    } elsif (($need eq 'siteadmin' || $need eq 'globaladmin') && (!$$self{SSL_IDENTITY} && !$$self{SSL_VERIFIED})) {
	$self->alert("You are not <a href='$gridcert_help_url'>authenticated with a valid grid certificate</a>.  ",
		    "If you are authenticated and <a href='$reg_url'>registered as an admin</a> ",
		    "it is possible to $power from this page.");
	return 0;
    } elsif ($need eq 'siteadmin' && (!$$self{AUTH_SITE_ADMIN} && !$$self{AUTH_GLOBAL_ADMIN})) {
	$self->alert("You are authenticated with a valid grid certificate but are not ",
		     "authorized as a site admin.  If you are an authorized site admin ",
		     " it is possible to $power from this page.");
	return 0;
    } elsif ($need eq 'globaladmin' && !$$self{AUTH_GLOBAL_ADMIN} ) {
	$self->alert("You are not authorized as a global admin. ",
		     "Only the global admins may $power from this page");
	return 0;
    } else {
	return 1;
    }
}


# returns the ID number given a distinguished name
sub fetch_identity_id
{
    my ($self, $client_dn) = @_;
    return undef if (!$client_dn);

     my ($id) = &dbexec($$self{DBH}, 
			qq{ select identity
				from t_adm_identity_attr ia
				where ia.name  = 'Distinguished name'
				and ia.value = :client_dn},
			":client_dn" => $client_dn)->fetchrow_array();
    return $id;
}

# sets AUTH_SITE_ADMIN and AUTH_GLOBAL_ADMIN
sub set_auth_vars
{
    my ($self) = @_;

    $$self{AUTH_SITE_ADMIN} = 0;
    $$self{AUTH_GLOBAL_ADMIN} = 0;

    if (!$$self{DB_IDENTITY_ID}) { return; }

    $$self{AUTH_SITE_ADMIN} = 1
	if &dbexec($$self{DBH},
		   qq{ select 1 from t_adm_site_admin where identity = :id },
		   ':id' => $$self{DB_IDENTITY_ID})->fetchrow_array();
    
    $$self{AUTH_GLOBAL_ADMIN} = 1
	if &dbexec($$self{DBH},
		   qq{ select 1 from t_adm_global_admin where identity = :id },
		   ':id' => $$self{DB_IDENTITY_ID})->fetchrow_array();

    return undef;
}



# Returns a list of nodes
# If argument 'with_ids' is true, returns a hash of node_name => node_id
# else it returns an array of nodes
#
# If either user_auth or identity is set, then it returns nodes from
# the t_adm_site_node table for which either the current user or the given
# identity is authorized to admin
#
# Otherwise it returns from t_adm_node table, which contains all nodes.
# The default behavior is to return an array of all nodes from t_adm_node.
sub fetch_nodes
{
    my ($self, %args) = @_;

    if (exists $args{user_auth} && $args{user_auth} ||
	exists $args{identity_auth}) {
	my %sites = $self->fetch_sites(%args);

	if (exists $args{with_ids} && $args{with_ids}) {
	    my %nodes;
	    foreach my $site (keys %sites) {
		while (my ($node, $node_id) = each %{$sites{$site}{NODES}}) {
		    $nodes{$node} = $node_id;
		}
	    }
	    return %nodes;
	} else {
	    my %nodes;
	    foreach my $site (keys %sites) {
		$nodes{$_} = 1  foreach @{$sites{$site}};
	    }
	    return keys %nodes;
	}
    } else {
	my $sql = qq{select name, id from t_adm_node};
	my $q = &dbexec($$self{DBH}, $sql);
	
	my %nodes;
	while (my ($node, $node_id) = $q->fetchrow()) {
	    $nodes{$node} = $node_id;
	}
	if (exists $args{with_ids} && $args{with_ids}) {
	    return %nodes;
	} else {
	    return keys %nodes;
	}
    }
}


# Returns a hash of sites pointing to an array of nodes
# Options are 'with_ids', 'identity_auth', 'user_auth', 'for_nodes', 'all'
# Default behavior is to return all sites
# if with_ids is true, the returned structure is 
#   $sites{site_name} = { ID => site_id, NODES => { node_name => node_id } }
# else the returned structure is $sites{site_name} = [ node_name ]
# if 'identity_auth' is given, then only sites for which the given identity is the admin are returned
# if 'user_auth' is true, then only sites for which the webpage user is the admin are returned
# if for_nodes is true, then only sites containing the given list of nodes is returned
sub fetch_sites
{
    my ($self, %args) = @_;
    my ($with_ids, $identity, $all) = (0, undef, 1);  # Defaults
    my @for_nodes;
    if (exists $args{all})           { $all      = $args{all}; }
    if (exists $args{with_ids})      { $with_ids = $args{with_ids}; }
    if (exists $args{user_auth}
	&& $args{user_auth})         { $identity = $$self{DB_IDENTITY_ID}; $all = 0; }
    if (exists $args{identity_auth}) { $identity = $args{identity_auth}; $all = 0;   }
    if (exists $args{for_nodes})     { @for_nodes = @{$args{for_nodes}}; }

    my ($sql, %binds);
    
    my $nodes_list = '';
    my %nodes_binds;
    if (@for_nodes) {
	($nodes_list, %nodes_binds) = &dbinlist('node', @for_nodes);
    }

    if ($identity && !$all) {
	my $nodes_sql = '';
	if (@for_nodes) { $nodes_sql = " and node.name in ($nodes_list)"; }
	$sql = qq{ select site.name, site.id, node.name, node.id
		     from t_adm_site_admin site_admin 
		     join t_adm_site site on site.id = site_admin.site
		     join t_adm_site_node site_node on site_node.site = site_admin.site
		     join t_adm_node node on node.id = site_node.node
		     join t_adm_identity ident on ident.id = site_admin.identity
		    where ident.id = :adm_id $nodes_sql
		    union
                   select site.name, site.id, node.name, node.id
		    from t_adm_site site
		    join t_adm_site_node site_node on site_node.site = site.id
		    join t_adm_node node on node.id = site_node.node
		   where exists (select identity from t_adm_global_admin
				 where identity = :glb_id) $nodes_sql };
	%binds = ( ':adm_id' => $identity, ':glb_id' => $identity, %nodes_binds );
    } elsif ($all) {
	my $nodes_sql = '';
	if (@for_nodes) { 
	    $nodes_sql = "where node.name in ($nodes_list)"; 
	    %binds = %nodes_binds;
	}
	$sql = qq{ select site.name, site.id, node.name, node.id
		     from t_adm_site site
		     join t_adm_site_node site_node on site_node.site = site.id
		     join t_adm_node node on node.id = site_node.node $nodes_sql};
    } else { return; }

    my $q = &dbexec($$self{DBH}, $sql, %binds);
    
    my %sites;
    if ($with_ids) {
	while (my ($site, $site_id, $node, $node_id) = $q->fetchrow()) {
	    if (!exists $sites{$site}) {
		$sites{$site} = { ID => $site_id, NODES => {} };
	    }
	    $sites{$site}{NODES}{$node} = $node_id;
	}
    } else {
	while (my ($site, $site_id, $node, $node_id) = $q->fetchrow()) {
	    if (!exists $sites{$site}) {
		$sites{$site} = [];
	    }
	    push @{$sites{$site}}, $node;
	}
    }
    return %sites;
}


# Returns a list of DBSes.
# If argument 'with_ids' is true, then return a hash of name => id
# else return an array of DBS names
sub fetch_dbses
{
    my ($self, %args) = @_;

    my %dbses;
    my $q = &dbexec($$self{DBH}, qq{select name, id from t_dps_dbs});
    while (my ($dbs, $dbs_id) = $q->fetchrow()) {
	$dbses{$dbs} = $dbs_id;
    }
    
    if (exists $args{with_ids} && $args{with_ids}) {
	return %dbses;
    } else {
	return keys %dbses;
    }
}


# Return a hash of users
# Options are 'site_admins', 'global_admins', 'admin_of'
# By default returns a hash like $users{$dn} = { ID => $id, EMAIL => $email, GLOBAL_ADMIN => $is_global_admin,
#   SITE_ADMIN => $is_site_admin } for all users
# if 'site_admins' is true, then the list is limited to users who are site admins
# if 'global_admins' is true, then only users who are global admins are returned
# if 'admin_of' is true and is an arrayref containing a list of sites or nodes, then only users who are 
#   explicitly admins of those sites or nodes are returned 
# if 'web_user' is true, then only the user for this current session is returned
sub fetch_users
{
    my ($self, %args) = @_;
    my ($site_admins, $admin_things, $global_admins, $user) = (0, undef, 0, 0); # Defaults
    if (exists $args{site_admins} && $args{site_admins}) { $site_admins = 1; }
    if (exists $args{admin_of} && ref $args{admin_of} eq 'ARRAY') { $site_admins = 1; $admin_things = $args{admin_of}; }
    if (exists $args{global_admins} && $args{global_admins}) { $global_admins = 1; }
    if (exists $args{web_user} && $args{web_user}) { $user = $$self{DB_IDENTITY_ID}; }

    my %users;
    my $sql;
    my %binds;
    my @where;

    my $admin_where;
    if ($global_admins) {
	$admin_where = 'global_admin.identity is not null';
    } elsif ($site_admins) {
	$admin_where = 'site_admin.identity is not null';
	if ($admin_things) {
	    my ($sites_in, %site_binds) = &dbinlist('site', @{$admin_things});
	    my ($nodes_in, %node_binds) = &dbinlist('node', @{$admin_things});
	    $admin_where .= " and (site.name in ($sites_in) or node.name in ($nodes_in))";
	    $binds{$_} = $site_binds{$_} foreach keys %site_binds;
	    $binds{$_} = $node_binds{$_} foreach keys %node_binds;
	}
    }
    push @where, $admin_where if $admin_where;

    my $user_where;
    if ($user) {
	$user_where = 'ident.id = :id';
	$binds{':id'} = $user;
    }
    push @where, $user_where if $user_where;

    my $where = 'where '.join(' and ', @where);
    
    
    $sql = qq{ select dn.value dn, ident.id, email.value email, 
	              NVL2(global_admin.identity, 1, 0) is_global_admin,
	              NVL2(site_admin.identity, 1, 0) is_site_admin,
	              site.name site, node.name node
	         from t_adm_identity ident 
		 join t_adm_identity_attr dn on dn.identity = ident.id and dn.name = 'Distinguished name'
		 join t_adm_identity_attr email on email.identity = ident.id and email.name = 'E-mail' 
	    left join t_adm_global_admin global_admin on global_admin.identity = ident.id
	    left join t_adm_site_admin site_admin on site_admin.identity = ident.id
	    left join t_adm_site site on site.id = site_admin.site
            left join t_adm_site_node site_node on site_node.site = site.id
            left join t_adm_node node on node.id = site_node.node
		 $where
		order by site, node
	     };

    my $q = &dbexec($$self{DBH}, $sql, %binds);
    while (my ($dn, $id, $email, $is_global_admin, $is_site_admin, $site, $node) = $q->fetchrow()) {
	$users{$dn} = { ID => $id, EMAIL => $email, 
			GLOBAL_ADMIN => $is_global_admin, SITE_ADMIN => $is_site_admin };
	if ($is_site_admin) {
	    $users{$dn}->{SITES} = [] unless exists $users{$dn}->{SITES};
	    push @{$users{$dn}->{SITES}}, $site;
	    $users{$dn}->{NODES} = [] unless exists $users{$dn}->{NODES};
	    push @{$users{$dn}->{NODES}}, $node;
	}
    }
    return %users;
}



# Get the client's e-mail address.  By default, use an e-mail
# from the database if we have one.  Failing that, use the
# address from the certificate itself.  This order allows the
# users to change their preferred e-mail address and make the
# choice sticky.
sub create_default_email
{
  my ($self) = @_;

  my ($email) = &dbexec($$self{DBH}, qq{
    select email.value
    from t_adm_identity_attr dn
      join t_adm_identity_attr email
        on email.identity = dn.identity
        and email.name = 'E-mail'
    where dn.name = 'Distinguished name'
    and dn.value = :client_dn},
    ':client_dn' => $$self{SSL_IDENTITY})->fetchrow();

  return $email if ($email);

  return undef if ! $ENV{SSL_CLIENT_CERT};
  $email = "";

  use File::Temp ':mktemp';
  if (my ($fh, $file) = mkstemp ('/tmp/certXXXXXXXXXX'))
  {
    if ((print $fh $ENV{SSL_CLIENT_CERT}) && close($fh))
    {
      chomp($email = qx(openssl x509 -in $file -noout -email));
    }
    unlink ($file);
  }
  return $email;
}



sub send_email
{
    my (%args) = @_;

    # Required arguments
    foreach (qw(subject from to message)) {
	return 0 unless exists $args{$_};
    }

    # Make to and cc arrays unique
    foreach (qw(to cc)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    my %unique;
	    $unique{$_} = 1 foreach @{$args{$_}};
	    $args{$_} = [keys %unique];
	}
    }

    # Ensure names are not duplicated from to to cc
    if (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	&& ref $args{to} eq 'ARRAY') {
	my @uniquecc;
	foreach my $mail (@{$args{cc}}) {
	    push @uniquecc, $mail unless grep $_ eq $mail, @{$args{to}};	    
	}
	$args{cc} = [ @uniquecc ];
    } elsif (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	     && ref $args{to} ne 'ARRAY') {
	$args{cc} = [ grep $_ ne $args{to}, @{$args{cc}} ];
    } elsif (exists $args{cc}
	     && ref $args{to} eq 'ARRAY') {
	delete $args{cc} if grep $_ eq $args{cc}, @{$args{to}};
    } elsif (exists $args{cc}) {
	delete $args{cc} if $args{cc} eq $args{to};
    }
    
    foreach (qw(from to cc replyto)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    $args{$_} = join(', ', @{$args{$_}});
	} elsif ( exists $args{$_} && ! $args{$_} ) {
	    $args{$_} = '';
	}
    }
    
    foreach (qw(from to cc replyto)) {
	next unless exists $args{$_};
	return 0 unless &validlist($args{$_});
    }

#     # For debugging without bothering people
#     $args{message} .= "\n\n$args{to}\n\n"; $args{to} = 'Ricky.Egeland@cern.ch';
#     $args{message} .= "\n\n$args{cc}\n\n"; delete $args{cc};

    (open (MAIL, "| /usr/sbin/sendmail -t")
     && (print MAIL
 	 "Subject: $args{subject}\n",
 	 "From: $args{from}\n",
 	 (exists $args{replyto} ? "Reply-To:  $args{replyto}\n" : ''),
 	 "To: $args{to}\n",
 	 (exists $args{cc} ? "Cc: $args{cc}\n" : ''),
 	 "\n",
 	 $args{message},
 	 "\n" )
     && close(MAIL))
 	or do { return 0; };
    
    return %args;
}


sub dn_to_human_name
{
    my $dn = shift @_;
    return undef unless $dn;
    my ($name) = ($dn =~ m:/CN=([^/]+?)[\s\d]*(/|$):);
    $name =~ s/\b(\w)/\U$1/g;
    return $name;
}	      

    
sub yesno 
{ 
    $_ = shift @_;
    return undef unless $_;
    s/^y$/Yes/; s/^n$/No/; 
    return $_; 
}



sub striplabels 
{ 
    my @stripped =  map { s:<[/]*label>::g; $_; } @_; 
    return wantarray ? @stripped : shift @stripped;
}



sub dump_params
{
    my $fh = shift @_;
    use Data::Dumper;
    print { $fh } "<pre>$_:\n", Dumper(param($_)), "</pre>" foreach param();

}


sub dump_var
{
    my ($fh, $name, $var) = @_;
    use Data::Dumper;
    print { $fh } "<pre>$name:\n", Dumper($var), "</pre>";
}


# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
  my ($first, $range, $now) = @_;
  $now ||= time();
  my @series = ();
  $first = int($first);

  if ($range eq 'hour') {
    # Convert first time to UTC hour in units of half a day.  Then
    # make a time series of hours until end of current 4 hours.
    my $low = int($first / 3600);
    my $high = int($now / 3600) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
    }
  } elsif ($range eq 'day') {
    # Convert first time to UTC day at 00:00.  Then make a
    # time series of days until end of today.
    my $low = int($first / 86400);
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
    }
  } elsif ($range eq 'week') {
    # Convert first time to previous Monday.  Then make a
    # time series of weeks until we pass today.
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $low = int($first/86400) - $diff{$wday};
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; $low += 7) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
    }
  } elsif ($range eq 'month') {
    # Convert first time to first of the month.  Then convert
    # into a time-series of months.  This is a bit dodgy, we
    # go by day so we don't need to worry about month dates.
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $start = int(($first - ($mday-1)*86400)/86400);
    my $limit = int($now / 86400) + 1;
    while ($start < $limit)
    {
      my $low = $start;
      my ($prevyear, $prevmon) = ($year, $mon);
      while ($year == $prevyear && $mon == $prevmon)
      {
	($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
	  = gmtime ((++$start) * 86400);
      }
      push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
    }
  }

  return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
  my ($time, $range) = @_;
  if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
  elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
  elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
  elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
  elsif ($range eq 'stamp') { return strftime ('%Y-%m-%d %H:%M:%S UTC', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
  my @args = @_;
  my $t1 = mktime (@args);
  my @gmt = gmtime ($t1);
  my $t2 = mktime (@gmt);
  return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
  my ($value) = @_;
  if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
  {
    my %scale = ('k' => 2**10, 'M' => 2**20, 'G' => 2**30,
		 'T' => 2**40, 'P' => 2**50, 'E' => 2**60);
    $value = $1 * $scale{$2};
  }
  return $value * 1.0;
}

1;


######################################################################
# A tool to print an html table
# many options for formatting cell data, row style and cell style
# based on given subrefs

# TODO Make TableSpool able to filter rows given a subref
# TODO Make TableSpool able to compute and display sums of columns

package Web25::TableSpool;
use strict; use warnings;
use CGI qw(param);



sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{FH} = *STDOUT;
  $$self{STRIPE} = undef;
  $$self{ROWCNT} = 0;
  $$self{COLCNT} = 0;
  $$self{TABLECOLS}   = undef;
  $$self{TABLEHEAD}   = undef;
  $$self{TABLECLASS}  = undef;
  $$self{STRIPECLASS} = undef;
  $$self{DATAFORMATS} = undef;
  $$self{ROWFORMATS}  = undef;
  $$self{CELLFORMATS} = undef;
  $$self{PSEUDOCOLS}  = undef;
  $$self{QUERYCOLS}   = undef;

  bless $self, $class;
  return $self;
}

# Set filehandle to print to 
sub set_filehandle
{
    my ($self, $fh) = @_;
    $$self{FH} = $fh;
}

# $cols: array ref of DB_column_names to output (others are ignored)
sub set_tablecols
{
    my ($self, $cols) = @_;
    $$self{TABLECOLS} = $cols;
}

# Sets columns to display based on CGI query parameters
# takes a list of column descriptions of the form
# (label, querykey, columnkeys, is_default)
# If no specified query variables are found, the 'is_default' columns are shown
sub set_querycols
{
    my ($self, @column_descriptions) = @_;
    $$self{QUERYCOLS} = [@column_descriptions];
    my %checked_querykeys;
    my @foundcols;
    my @defaultcols;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	unless (exists $checked_querykeys{$querykey}) {
	    foreach my $param_columnkeys (param($querykey)) {
		push @foundcols, split( /:/, $param_columnkeys);
	    }
	}
	$checked_querykeys{$querykey} = 1;
	push @defaultcols, split( /:/, $columnkeys ) if $is_default;
    }

    if (@foundcols) { $self->set_tablecols([ @foundcols ]); }
    else { $self->set_tablecols([ @defaultcols ]); }
}


# $th : hash of DB_column_name=>Pretty_column_name for table headers
sub set_tablehead
{
    my ($self, $th) = @_;
    $$self{TABLEHEAD} = $th;
}

# $class :  CSS class for the HTML table
sub set_tableclass
{
    my ($self, $class) = @_;
    $$self{TABLECLASS} = $class;
}

# $stripe :  CSS class for striped rows
sub set_stripeclass
{
    my ($self, $class) = @_;
    $$self{STRIPECLASS} = $class;
}
# $dataformats : hash of DB_column_name=>formatting_subroutine($data, $rowref) for formatting data
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_dataformats
{
    my ($self, $df) = @_;
    $$self{DATAFORMATS} = $df;
}

# $cellformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the cell (<td>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_cellformats
{
    my ($self, $cf) = @_;
    $$self{CELLFORMATS} = $cf;
}

# $rowformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the row (<tr>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_rowformats
{
    my ($self, $rf) = @_;
    $$self{rowformats} = $rf;
}

# $pseudocols : hash with key 'name' (column name) and value 'generator' (sub ref)
# for generating a pseudocolumn in the table.  Requires 'name' to be in TABLEHEAD for output.
# 'generator' is passed the hash of the current row data, before any processing
sub add_pseudocolumn
{
    my ($self, $name, $generator) = @_;
    $$self{PSEUDOCOLS} = {} unless $$self{PSEUDOCOLS};
    $$self{PSEUDOCOLS}->{$name} = $generator;
}



# $class is the CSS class of the table, $stripe is the class of striped <tr>'s
sub start
{
    my ($self) = @_;
    print { $$self{FH} }
    "<table ", $$self{TABLECLASS} ? "class='$$self{TABLECLASS}'" : '', ">\n";
}

# Print the title columns
sub head
{
    my ($self, @headers) = @_;

    if ($$self{TABLECOLS} && $$self{TABLEHEAD}) {
	@headers = @{$$self{TABLEHEAD}}{@{$$self{TABLECOLS}}};
    }

    if (!@headers) {
	die "TableSpool::head called without any column information\n";
    }

    print { $$self{FH} } "<tr>";
    print { $$self{FH} } "<th>$_</th>" foreach (@headers);
    print { $$self{FH} } "</tr>\n";

    $$self{COLCNT} = scalar @headers;
}

# Prints a row, taking either an array of data
# or a hashref of labled data (name=>val)
sub row
{
    my ($self, @row) = @_;
    if (ref $row[0] eq 'HASH') {
	$self->hash_row($row[0]);
    } else {
	if (ref $row[0] eq 'ARRAY') {
	    @row = @{$row[0]};
	}

	my $rowclass = '';
	if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	    $rowclass = " class='$$self{STRIPECLASS}'";
	}
	
	print { $$self{FH} } "<tr$rowclass>";
	print { $$self{FH} } "<td>$_</td>" foreach (@row);
	print { $$self{FH} } "</tr>";
    }
    $$self{ROWCNT}++;
    return $$self{ROWCNT};
}

sub rows
{
    my ($self, $row_ary) = @_;
    foreach my $row (@{$row_ary}) {
	$self->row($row);
    }
}

# Print a row from a hash applying all features
sub hash_row
{
    my ($self, $row, $rowclass) = @_;
    $rowclass = '' if !defined $rowclass;

    # Copy the row
    my $myrow = {%{$row}};

    # Add the pseudocolumns to the row
    if ($$self{PSEUDOCOLS}) {
	foreach my $name (keys %{$$self{PSEUDOCOLS}}) {
	    $myrow->{$name} = &{$$self{PSEUDOCOLS}->{$name}}(undef, $myrow);
	}
    }

    # Format data row if format sub provided   
    if ($$self{ROWFORMATS}) {
	my $rowclass_ary = [];
	foreach my $name (keys %{$$self{ROWFORMATS}}) {
	    push @{$rowclass_ary}, &{$$self{ROWFORMATS}->{$name}}($row->{$name}, $myrow);
	}
	$rowclass = join(' ', $rowclass, @{$rowclass_ary});
    }

    # Format data cell if format sub provided
    my $cellclass_hash = {};
    if ($$self{CELLFORMATS}) {
	foreach my $name (keys %{$$self{CELLFORMATS}}) {
	    $cellclass_hash->{$name} = &{$$self{CELLFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Format data columns if format sub provided
    if ($$self{DATAFORMATS}) {
	foreach my $name (keys %{$$self{DATAFORMATS}}) {
	    $myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Print out the row with the appropriate classes
    if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	$rowclass .= ' '.$$self{STRIPECLASS};
    }

    if ($rowclass) { $rowclass = " class='$rowclass'"; }
  
    print { $$self{FH} } "<tr$rowclass>";

    foreach my $name (@{$$self{TABLECOLS}}) {
	my $cellclass = '';
	if (exists $cellclass_hash->{$name}) {
	    $cellclass = " class='".$cellclass_hash->{$name}."'";
	}
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td$cellclass>$val</td>";
    }
    print { $$self{FH} } "</tr>\n";
}

# Finish, returns number of rows printed
sub finish
{
    my ($self) = @_;
    print { $$self{FH} } "</table>";
    return $$self{ROWCNT};
}

# Returns form inputs for column selection
# requires set_querycols
sub columns_form
{
    my ($self) = @_;

    my @checked;
    my @defaults;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	foreach my $param_columnkeys (param($querykey)) {
	    push @checked, $label if ($param_columnkeys eq $columnkeys);
	}
	push @defaults, $label if ($is_default);
    }

    unless (@checked) {
	@checked = @defaults;
    }


    my $form = "";
    $form .= "<p><i>Display Columns</i></p>\n";
    foreach my $desc (@{$$self{QUERYCOLS}})
    {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	$form .= "<input type='checkbox' name='$querykey' value='$columnkeys'";
	$form .= (grep $_ eq $label, @checked) ? " checked='checked'" : "";
	$form .= " />&nbsp;$label<br/>\n";
    }
    
    return $form;
}


1;



######################################################################
# A simple class to print an HTML table of a DB query
package Web25::DBTable;
use strict; use warnings;
use base "Web25::TableSpool";

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  bless $self, $class;
  return $self;
}



# Output a table given a statement handle $sth,
# $sth : database handle to iterate on
sub output
{
    my ($self, $sth) = @_;

    if (! $$self{TABLECOLS}) {
	$self->set_tablecols($sth->{NAME});
    }

    if (! $$self{TABLEHEAD}) {
	my $th = {};
	$th->{$_} = $_ foreach (@{$sth->{NAME}});
	$self->set_tablehead($th);
    }

    $self->start();    
    $self->head();
    while (my $row = $sth->fetchrow_hashref()) {
	$self->row($row);
    }
    return $self->finish();
}

1;



######################################################################
package Web25::OptsPane;
use strict; use warnings;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{TABS} = [];
  $$self{HIDDEN} = [];
  $$self{TARGET} = "#";

  bless $self, $class;
  return $self;
}

sub set_form_target
{
    my ($self, $target) = @_;
    $$self{TARGET} = $target;
}

sub add_tab
{
    my ($self, $name, $form) = @_;
    my $id = scalar @{$$self{TABS}};
    push @{$$self{TABS}}, { id => $id, name => $name, form => $form };
}

sub add_hidden
{
    my ($self, $form) = @_;
    push @{$$self{HIDDEN}}, $form;
}

sub output
{
    my ($self) = @_;

    my $html = "";

    $html .= "<form method='get' action='$$self{TARGET}'>\n";

    $html .= "<div id='optsnav'>\n";
    foreach my $tab (@{$$self{TABS}}) {
	my $class = $tab->{id} == 0 ? 'raised' : 'lowered';
	$html .= "<div class='$class' onclick='return showtab($tab->{id})' id='optstab$tab->{id}'><a href='#'>$tab->{name}</a></div>\n";
    }
    $html .= "</div>\n";


    foreach my $tab (@{$$self{TABS}}) {
	my $display = $tab->{id} == 0 ? '' : 'style=\'display:none;\'';
	$html .= "<div class='optscontent' $display id='optspane$tab->{id}'>\n";
	$html .= $tab->{form};
	$html .= "</div>\n";
    }
    foreach my $hidden (@{$$self{HIDDEN}}) {
	$html .= $hidden;
    }

    $html .= "<div id='optsfoot'>\n";
    $html .= "<input type='submit' value='Cancel' onclick='return hideshow(this,\"opts\",0)'/>&nbsp;\n";
    $html .= "<input type='submit' value='Apply' />\n";
    $html .= "</div>\n";

    $html .= "</form>\n";


    return $html;
}

sub link
{
    my ($self, $linkname) = @_;
    "<a href='#' onclick='return hideshow(this,\"opts\",0)'>$linkname</a><br/>\n";
}



1;


######################################################################
package Web25::Page;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

our $TEMPLATE_DEFAULT = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style25.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }

    function showtab(tab) {
	var i=0;
	var tabobj;
	var paneobj;
	for (i=0;i<10;i++) {
	    tabobj = document.getElementById('optstab'+i);
	    paneobj = document.getElementById('optspane'+i);
	    if (tab == i) {
		tabobj.className = 'raised';
		paneobj.style.display = '';
	    } else {
		tabobj.className = 'lowered';
		paneobj.style.display = 'none';
	    }
        }
	return false;
    }

function select_all(form_id, name, value) {
    var formblock= document.getElementById(form_id);
    var forminputs = formblock.getElementsByTagName('input');
    for (i = 0; i < forminputs.length; i++) {
	if (forminputs[i].getAttribute('name') == name) {
	    if (value == '1') {
		forminputs[i].checked = true;
	    } else {
		forminputs[i].checked = false;
	    }
	}
    }
}

--></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
'>
<div id="page">
<div id="header">
 <!-- Logo and page title -->
 <div id="logo">
  <a href="http://cern.ch/cms-project-phedex/" title="PhEDEx Home Page"
    ><img src="@ROOTURL@phedex-logo-small.gif" alt="PhEDEx" height="80" /></a>
 </div> <!-- /logo -->

 <div id="heading">
  <h1 class="title">@PAGEHEADING@</h1>
  <div class="pagenav">
   @TOCSELECTOR@
   @PAGESELECTOR@
  </div> <!-- /pagenav -->
 </div> <!-- /heading -->
</div> <!-- /header -->

<!-- main content -->
<div id="content">
@THIS_IS_A_TEST@
@CONTENT@
</div>
</div> <!-- /page -->

<!-- side navigation panel -->
<div class="viewnav">
@DBSELECTOR@
@IDENTITY@
@MYPAGE@
</div>

<!-- options panel -->
<div id="opts" style="display:none;">
@OPTIONS@
</div>


</body>
</html>
END_OF_TEMPLATE

our $TEMPLATE_BARE = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }
   --></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
' style='background: none; margin: .5em'>

<!-- main content -->
<div id="content" style='border: none'>
@CONTENT@
</div>
</body>
</html>
END_OF_TEMPLATE

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};
  bless $self, $class;
  return $self;
}

sub toc
{
  my ($self) = @_;
  my @result = ();
  foreach (keys %{Web25::})
  {
    next if ! /::$/;
    next if ! exists ${$Web25::{$_}}{TOC};
    push (@result, ${$Web25::{$_}}{TOC});
  }
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

sub index
{
  my ($self) = @_;
  my @result = ();

  # Get the type of dynamic type of this page and navigate to
  # the namespace scope just above it (e.g. Web25::Request::).
  no strict "refs";
  my $scope = ref $self;
  $scope =~ s/[^:]+$//;

  # Search the scope for sub-types with $INDEX.  These are
  # web pages we'll offer to make visible.
  foreach (keys %$scope)
  {
    push (@result, ${$$scope{$_}}{INDEX})
      if /::$/ && exists ${$$scope{$_}}{INDEX};
  }

  # Sort the pages by order tag.
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

# Return a hash of existing valid parameters
sub urlparams
{
  my ($self, @names) = @_;
  my %known = map { $_ => 1 } param();
  my %result = ();

  foreach my $name (@names)
  {
    $result{$name} = [ param($name) ]
      if exists $known{$name};
  }
  return %result;
}

# Return a URL to this page, i.e. a URL which would come back to this
# page, plus additional query parameters.  The page can be changed
# with "page" parametre and database instance with "db" parametre;
# these are automatically converted into script path components such
# that the final URL is "/path/to/script[/DB[/PAGE]][?QUERY]".
sub myurl
{
  my $self = shift(@_);

  my $curpage = param('page');
  my $curview = param('view');
  my $curlayout = param('layout');
  my $currefresh = param('refresh');
  my $cursecure = (($ENV{HTTPS} || 'nope') eq 'on' ? 1 : 0);
  my $curquery = query_string();
  my %args = ('db' => $$self{DBID},
	      ($cursecure ? ('secure' => 1) : ()),
	      ($curview ? ('view' => $curview) : ()),
	      ($curpage ? ('page' => $curpage) : ()),
	      ($curlayout ? ('layout' => $curlayout) : ()),
	      ($currefresh ? ('refresh' => $currefresh) : ()),
	      @_);
  my $page = $args{'page'}; delete $args{'page'};
  my $db = $args{'db'}; delete $args{'db'};
  my $secure = $args{'secure'}; delete $args{'secure'};
  my $fullurl = $args{'fullurl'}; delete $args{'fullurl'};

  my $newcgi = new CGI ("");
  $newcgi->param ($_, ref $args{$_} ? @{$args{$_}} : $args{$_}) for keys %args;
  my $url = $$self{CONFIG}{SERVICE_PATH};
  my $q = $newcgi->query_string();

  if (($cursecure || 0) != ($secure || 0)) {
      $url = $$self{CONFIG}{$secure ? "SSL_SERVER_ROOT" : "SERVER_ROOT"} . $url;
  } elsif ($fullurl) {
      $url = $$self{CONFIG}{"SERVER_ROOT"} . $url;
  }

  $url .= "/$db";
  $url .= "/$page" if $page;
  $url .= "?$q" if $q;
  
  return $url;
}

sub generate
{
  my ($self, $config, $db) = @_;
  $$self{CONFIG} = $config;
  $$self{DBID} = $db;

  # Find the class cope index of this page instance.
  my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

  # Do we have SSL login information from a secure proxy, but none
  # direcly?  If so, grab the headers from the proxy and use them
  # here.  *WARNING* This can potentially open up a security hole
  # the size of an elephant!  We are taking "trusted" values from
  # the HTTP headers, and need to be aboslutely sure nobody does
  # e.g. "wget" with faked header values.  It's paramount to trust
  # the proxy source.

  if (! $ENV{SSL_CLIENT_VERIFY} && ! $ENV{HTTPS}
      && grep($ENV{REMOTE_HOST} eq $_, qw(cms.cern.ch cmslcgse02.cern.ch))
      && ($ENV{HTTP_HTTPS} || 'nope') eq 'on'
      && $ENV{HTTP_SSL_CLIENT_VERIFY})
  {
    my ($pre, $data, $post);
    $ENV{HTTPS} = "on";
    $ENV{SSL_CLIENT_VERIFY} = $ENV{HTTP_SSL_CLIENT_VERIFY};
    if ($ENV{HTTP_SSL_CLIENT_S_DN})
    {
      $ENV{SSL_CLIENT_S_DN} = $ENV{HTTP_SSL_CLIENT_S_DN};
    }
    if ($ENV{HTTP_SSL_CLIENT_CERT})
    {
      my ($pre, $data, $post)
        = ($ENV{HTTP_SSL_CLIENT_CERT} =~ /^(-+[A-Z ]+-+) (.*) (-+[A-Z ]+-+)$/);
      $ENV{SSL_CLIENT_CERT} = "$pre\n" . join("\n", split(" ", $data)) . "\n$post\n";
    }
  }

  # Force redirect to https if using http
  if ($$index{SECURE} && ($ENV{HTTPS} || 'nope') ne 'on')
  {
    print redirect(-url => $self->myurl("secure" => 1));
    return;
  }

  # Check if the client's identity was verified
  my $idurl = $self->myurl('page' => 'Administration::Identities');
  if ($ENV{SSL_CLIENT_S_DN} && ($ENV{SSL_CLIENT_VERIFY} || '') eq 'SUCCESS')
  {
    $$self{SSL_VERIFIED} = 1;
    $$self{SSL_IDENTITY} = $ENV{SSL_CLIENT_S_DN};
    $$self{SSL_CERT} = $ENV{SSL_CLIENT_CERT};
    ($$self{USER_NAME}) = &dn_to_human_name($$self{SSL_IDENTITY});
    $$self{SSL_MSG_STATUS} =
      "<p><a href='$idurl'>" . &escapeHTML($$self{USER_NAME}) . "</a>";
    $$self{SSL_MSG_CHANGE} =
      " | <a href='" . $self->myurl("secure" => 0) . "'>Sign out</a></p>";
  }
  else
  {
    $$self{SSL_VERIFIED} = 0;
    $$self{SSL_IDENTITY} = undef;
    $$self{DB_IDENTITY_ID} = undef;
    $$self{SSL_CERT} = undef;
    if (($ENV{HTTPS} || "nope") eq 'on')
    {
      $$self{SSL_MSG_STATUS} =
       "<p><span style='color:#666'>Sign in <a href='$idurl'>failed</a>";
      $$self{SSL_MSG_CHANGE} =
       " | <a href='" . $self->myurl("secure" => 0) . "'>Sign out</a></p>";
    }
    else
    {
      $$self{SSL_MSG_STATUS} =
        "<p><span style='color:#666'>Not signed in</span>";
      $$self{SSL_MSG_CHANGE} =
        " | <a href='" . $self->myurl("secure" => 1) . "'>Sign in</a></p>";
    }
  }

  # Check whether we are looking at our vs. global view
  if (! $$self{SSL_VERIFIED})
  {
      $$self{MY_VIEW} = 0;
      param('view', 'global');
      $$self{VIEW_MESSAGE} = "<h3 style='color:#666'>Global view</h3><p style='color:#666'>(Sign in to change)</p>";
  }
    elsif (!param('view') || param('view') eq 'my')
  {
      $$self{MY_VIEW} = 1;
      my $otherurl = $self->myurl('view' => 'global');
      $$self{VIEW_MESSAGE} = "<h3>Your view</h3><p>Switch to <a href='$otherurl'>global view</a></p>";
  }
  else
  {
      $$self{MY_VIEW} = 0;
      my $otherurl = $self->myurl('view' => 'my');
      $$self{VIEW_MESSAGE} = "<h3>Global view</h3><p>Switch to <a href='$otherurl'>your view</a></p>";
  }

  # Select page we are visiting
  my %pagemap;
  my @pages = grep(${$$_}{LIST}, $self->index());
  foreach (@pages)
  {
    my ($name) = (*{$_}{PACKAGE} =~ /Web25::(.*)/);
    $pagemap{$_} = $name;
  }

  my $page = param('page');
  my @toc = $self->toc();
  my $cat = do {
    no strict "refs";
    my $scope = ref $self;
    $scope =~ s/[^:]+$//;
    exists $$scope{TOC} ? ${"${scope}TOC"} : undef
  };

  # Check if this is running against a test location and obnoxiously warn if so
  my $testwarn = "";
  my $pageheading = 'PhEDEx &#8211; CMS Data Transfers';
  if ($ENV{PHEDEX_DEV}) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $prod =~ s!/dev/$ENV{PHEDEX_DEV}/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a development server for <b>$ENV{PHEDEX_DEV}</b>. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>($ENV{PHEDEX_DEV}'s Development)</blink>";
  } elsif ($ENV{SCRIPT_NAME} =~ m!/test/!) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a test server for the developers. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>(TEST)</blink>";
  }

  # Initialise page template
  my $ndb = 0;
  my $replacements = {
    'THIS_IS_A_TEST' => $testwarn,
    'CONTENT' => '',
    'PAGETITLE' =>
      ($cat ? $$cat{TITLE} . " &#8211; " . $$index{TITLE} : $$index{TITLE}),
    'PAGEHEADING' => $pageheading,
    'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
    'DBTITLE' => $$config{INSTANCES}{$db}{TITLE},
    'ROOTURL' => "$$self{CONFIG}{SERVICE_PATH}/",
    'REFRESH' => (param('refresh') ? "<meta http-equiv='refresh' content='600'>" : ""),
    'DBSELECTOR' =>
      (" <div class='dbopt'>\n" .
       "  <h3 style='margin-top:0'>Instance</h3>\n" .
       "  <i>$$config{INSTANCES}{$db}{TITLE}</i>&nbsp;" .
       "<a href='@{[$self->myurl('page'=>'DB')]}'" .
       " onclick='return hideshow(this,\"dbopts\",0)'>&#187;&#187;</a>\n" .
       "  <div id='dbopts' style='display:none'>\n" .
       "   <a href='#' onclick='return hideshow(this,\"dbopts\",0)'><img" .
       " border='0' src='$$self{CONFIG}{SERVICE_PATH}/x.gif'" .
       " width='13' height='13' alt='Close menu' align='right'" .
       " style='position:relative;margin:.5ex -.5ex .1ex 1ex' /></a>\n" .
       join ("",
             map { "   " . &dblink ($self, $db, $_) . "<br />\n" }
	     sort { $$a{RANK} <=> $$b{RANK} }
	     grep($$_{ID} ne $db, values %{$$config{INSTANCES}})) .
       "  </div>\n" .
       " </div>"),
    'TOCSELECTOR' =>
      (@toc ?
       "<div class='catopt'>\n" .
       " <ul>\n" .
       join("", map { "  <li"
		      . ($$_ == $cat
			 ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
			 : (">" . &toclink($self, $_)))
		      . "</li>\n" } @toc) .
       " </ul>\n" .
       "</div>" : ""),
    'PAGESELECTOR' =>
      (@pages ?
       "<div class='menuopt'>\n" .
       " <ul>\n" .
       join("",
	    map { "  <li" .
		  ("Web25::$page" eq *{$_}{PACKAGE}
		   ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
		   : (">" . &pagelink($self, $_)))
		  . "</li>\n" }
	    @pages) .
       " </ul>\n" .
       "</div>" : ""),
    'IDENTITY' =>
      (" <div>\n" .
       # "  <h3>Identity</h3>\n" .
       "  $$self{SSL_MSG_STATUS}$$self{SSL_MSG_CHANGE}\n" .
       " </div>"),
    'MYPAGE' => "<div>$$self{VIEW_MESSAGE}</div>",
  };

  # Execute the desired page.  We save old STDOUT to print to it
  # later, then redirect the page routine's output to CONTENT.
  my ($output, $options) = ("", "");
  open ($$self{CONTENT}, ">", \$output);
  open ($$self{OPTIONS}, ">", \$options);
  eval
  {
    # Connect to the database, do the page, the disconnect
    if (! $$index{NOLOGIN})
    {
      eval
      {
	my $dbtns = $$config{INSTANCES}{$db}{DATABASE_NAME};
        my $dbuser = $$config{INSTANCES}{$db}{USER_NAME};
        my $dbpass = $$config{INSTANCES}{$db}{PASSWORD};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;

	if (exists $$config{INSTANCES}{$db}{ROLE_NAME}) {
	    my $role_name = $$config{INSTANCES}{$db}{ROLE_NAME};
	    my $role_pass = $$config{INSTANCES}{$db}{ROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}

	# Fetch the user ID from the DB, if we can
	$$self{DB_IDENTITY_ID} = $self->fetch_identity_id($$self{SSL_IDENTITY});
	# Set other PhEDEx authorization variables
	$self->set_auth_vars();
      };
      if ($@)
      {
	my $msg = $@;
	my $feedbackurl =
	  "mailto:cms-phedex-admins\@cern.ch?subject="
	  . "PhEDEx%20web%20is%20inaccessible";

	print { $$self{CONTENT} }
	  "<center><div class='alert'>\n",
	  " <p>This PhEDEx instance is not available at this time.",
	  " Please try again at another time, or if the problem",
	  " persists and this is an instance you should be using,",
	  " please <a href='$feedbackurl'>notify the administrators</a>.",
	  "</p>",
          # "<p>The database error was: <i>", &escapeHTML($@), "</i></p>",
          "</div></center>\n";

	print STDERR "$0: Internal error: $msg\n";
	return;
      }
    }
    $self->output();
    if ($$self{DBH})
    {
      $$self{DBH}->disconnect() if $$self{DBH};
      delete $$self{DBH};
    }
  };
  if ($@)
  {
    my $message = $@;
    $message = &escapeHTML($message);

    my $feedbackurl =
      "mailto:cms-phedex-admins\@cern.ch?subject="
      . "PhEDEx%20web%20server%20trouble";

    if ($message =~ /ORA-00942/) # table or view doesn't exist
    {
      print { $$self{CONTENT} }
        "<center><div class='warning'>\n",
        " <p>This PhEDEx instance is not capable of providing",
        " this feature.  Perhaps you meant to select another PhEDEx",
        " instance in the instance menu above?</p></div></center>\n";
    }
    else
    {
      print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Apologies, looks like we have an internal server error,",
        " details of which below.  If the problem persists, please",
        " <a href='$feedbackurl'>notify the administrators</a>.</p>\n",
        " <p><i>$message</i></p>\n",
        "</div></center>\n";
    }
  }
  close($$self{CONTENT});
  close($$self{OPTIONS});
  $$replacements{CONTENT} = join("\n", $output);
  $$replacements{OPTIONS} = join("\n", $options);

  # Instantiate the desired template and spit it out
  my $template = param('layout');
  $template = 'default'
    if (! $template || ! grep($template eq $_, qw(default bare)));

  my $result = ($template eq 'bare' ? $TEMPLATE_BARE : $TEMPLATE_DEFAULT);
  while (my ($key, $value) = each %$replacements)
  {
    $result =~ s/\@$key\@/$value/g;
  }

  print header(-type => 'text/html'), $result;
}


1;

######################################################################
package Web25::Info::Main;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 1, ORDER => 0, NOLOGIN => 1, TITLE => "Overview" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  no strict "refs";
  foreach my $toc ($self->toc())
  {
    next if ! ${$$toc}{LIST};
    my $type = *{$toc}{PACKAGE};
    print { $$self{CONTENT} }
      (${$$toc}{ORDER} % 4 ? "" : "<p style='clear: left'></p>\n"),
      "<div class='toc'>\n",
      " <h2>", &escapeHTML(${$$toc}{TITLE}), "</h2>\n",
      " <ul>\n";

    my @pages = ();
    my $scope = "${type}::";
    foreach (keys %$scope)
    {
      next if ! /::$/;
      next if ! exists ${$$scope{$_}}{INDEX};
      push(@pages, ${$$scope{$_}}{INDEX});
    }

    print { $$self{CONTENT} }
      map { "  <li>" . &pagelink($self, $_) . "</li>\n" }
      sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} }
      grep (${$$_}{LIST}, @pages);

    print { $$self{CONTENT} } " </ul>\n</div>";
  }
}

1;

######################################################################
package Web25::Info; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 0, TITLE => "Info" }; 1;

package Web25::Activity; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 1, TITLE => "Activity" }; 1;

package Web25::Data; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 2, TITLE => "Data" }; 1;

package Web25::Request; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 3, TITLE => "Requests" }; 1;

package Web25::Components; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 4, TITLE => "Components" }; 1;

package Web25::Reports; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 5, TITLE => "Reports" }; 1;

package Web25::Administration; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 6, TITLE => "Administration" }; 1;


######################################################################
package Web25::Info::About; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "About",
	       LINK => "about.html",
	       LINK_TITLE => "General Information" };
1;

package Web25::Info::Documentation; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Documentation",
	       LINK => "documents.html",
	       LINK_TITLE => "READMEs and Other Documentation" };
1;

package Web25::Info::Presentations; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Presentations",
	       LINK => "presentations.html",
	       LINK_TITLE => "PhEDEx Presentations" };
1;

package Web25::Info::HyperNews; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "HyperNews Forum",
	       LINK => "https://hypernews.cern.ch/HyperNews/CMS/get/phedex.html",
	       LINK_TITLE => "Mailing List and HyperNews Forum" };
1;

package Web25::Info::Developers; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Developers",
	       LINK => "developers.html",
	       LINK_TITLE => "Developer info" };
1;

######################################################################
package Web25::Request::Page;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

our @reqstates = (
    { STATE => 0, RANK => 0, LABEL => "In preparation" },
    { STATE => 1, RANK => 2, LABEL => "Pending approval" },
    { STATE => 2, RANK => 1, LABEL => "Pending feedback" },
    { STATE => 3, RANK => 3, LABEL => "Approved" },
    { STATE => 4, RANK => 9, LABEL => "Disapproved" },
    { STATE => 5, RANK => 5, LABEL => "Active" },
    { STATE => 6, RANK => 6, LABEL => "Suspended" },
    { STATE => 7, RANK => 7, LABEL => "Completed" },
    { STATE => 8, RANK => 8, LABEL => "Disabled" } );

our %reqstatenames = map { ($$_{STATE} => $$_{LABEL}) } @reqstates;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub logClientInfo
{
    my ($self) = @_;

    # Is there a case for logging anonymous access?
    # If so we will want to change this function...
    if (!$$self{SSL_IDENTITY}) { return undef; }

    my $identity = $$self{DB_IDENTITY_ID};
    if (!$identity) {
	$identity = &makeObjWithAttrs
	    ($$self{DBH}, "adm_identity", "identity", {},
	     "Distinguished name" => $$self{SSL_IDENTITY},
	     "E-mail" => $self->create_default_email(),
	     "Certificate" => $$self{SSL_CERT});
    }

    my $cid = &makeObjWithAttrs
	($$self{DBH}, "adm_contact", "contact", {},
	 "Remote host" => $ENV{HTTP_X_FORWARDED_FOR},
	 "User agent" => user_agent());
    
    my $client = &makeObjWithAttrs
	($$self{DBH}, "adm_client", undef,
	 { "identity" => $identity, "contact" => $cid });
    
    return $client;
}


sub getClientData 
{
    my ($self, $clientid) = @_;
    my $contactsql = qq{ select name, value 
                             from t_adm_contact_attr con_attr 
                             join t_adm_contact con on con.id = con_attr.contact
                             join t_adm_client cli on cli.contact = con.id
			     where cli.id = :id order by con_attr.id};
    my $identsql  = qq{ select ident_attr.name, ident_attr.value 
                            from t_adm_identity_attr ident_attr
                            join t_adm_identity ident on ident_attr.identity = ident.id
                            join t_adm_client cli on cli.identity = ident.id
			    where cli.id = :id order by ident_attr.id};
    my $sitesql  = qq{ select site.name, node.name
			   from t_adm_site_admin site_admin 
			   join t_adm_site site on site.id = site_admin.site
			   join t_adm_site_node site_node on site_node.site = site_admin.site
			   join t_adm_node node on node.id = site_node.node
			   join t_adm_identity ident on ident.id = site_admin.identity
			   join t_adm_client cli on cli.identity = ident.id
			   where cli.id = :id order by site.name, node.name };
    my $globalsql = qq{ select 1 
			    from t_adm_global_admin global_admin
			    join t_adm_identity ident on global_admin.identity = ident.id
                            join t_adm_client cli on cli.identity = ident.id
			    where cli.id = :id };
    
    
    my %types = ('CONTACT_ATTR'  => $contactsql, 
		 'IDENTITY_ATTR' => $identsql, 
		 'SITE_ADMIN'    => $sitesql,
		 'GLOBAL_ADMIN'  => $globalsql);
    
    my $result = {};
    
    while (my ($type, $sql) = each %types) {
	my $q = &dbexec($$self{DBH}, $sql, ':id' => $clientid);
	if ($type eq 'CONTACT_ATTR' || $type eq 'IDENTITY_ATTR') {
	    $result->{$type} = {};
	    while (my ($name, $value) = $q->fetchrow_array()) {
		$result->{$type}->{$name} = $value;
	    }
	} elsif ($type eq 'SITE_ADMIN') {
	    $result->{$type} = {};
	    while (my ($site, $node) = $q->fetchrow_array()) {
		if (!exists $result->{$type}->{$site}) {
		    $result->{$type}->{$site} = [];
		}
		push @{$result->{$type}->{$site}}, $node;
	    }
	} elsif ($type eq 'GLOBAL_ADMIN') {
	    if ($q->fetchrow_array()) { $result->{$type} = 1; }
	    else                      { $result->{$type} = 0; }
	}
    }
    return $result;
}

sub formatClientData
{
    my ($self, $data) = @_;
    my @html;
    
    foreach my $name (sort keys %{$data->{IDENTITY_ATTR}}) {
	if ($name ne 'Certificate') {
	    push @html, "<label>$name:</label><span class='labeled'>", 
	    ($data->{IDENTITY_ATTR}->{$name} or 'Unknown'), "</span><br/>";
	} else {
	    push @html, 
	    "<label>$name:</label>",
	    "<div class='labeled' style='height:100px;overflow:scroll;'><pre>", 
	    ($data->{IDENTITY_ATTR}->{$name} or 'Unavailable'),
	    "</pre></div><br/>";
	}
    }
    
    foreach my $name (sort keys %{$data->{CONTACT_ATTR}}) {
	push @html, "<label>$name:</label><span class='labeled'>", 
	($data->{CONTACT_ATTR}->{$name} or 'Unknown'), "</span><br/>";
    }
    
    my $sites = join(', ', sort keys %{$data->{SITE_ADMIN}});
    push @html, 
    "<label>Site admin privs:</label><span class='labeled'>",
    ($sites ? $sites : 'None'),
    "</span><br/>";
    
    push @html,
    "<label>Global admin:</label><span class='labeled'>",
    ($data->{GLOBAL_ADMIN} ? 'Yes' : 'No'),
    "</span><br/>";
    
    return @html;
}


sub formatAction
{
    my ($self, $aid, $action, $tid) = @_;
    my @html;

    my $actionid = "action$aid";
    my $actionclientid = "actionclient$aid";
    if ($tid) {
	$actionid = "task$tid".$actionid;
	$actionclientid = "task$tid".$actionclientid;
    }

    push @html,
    "<h1><a href='#' onclick='return hideshow(this,\"$actionid\",0)'>",
    $$action{ACTION_NAME}, "</a></h1>",
    "<div id='$actionid' style='display:none;'>",
    "<label>Time:</label>", "<span class='labeled'>", &formatTime($$action{ACTION_TIME}, 'stamp'), "</span><br/>",
    "<label>Client:</label>", "<span class='labeled'>",
    "<a href='#' onclick='return hideshow(this, \"$actionclientid\", 0)'>",
    (&dn_to_human_name($$action{ACTION_CREATOR}{IDENTITY_ATTR}{'Distinguished name'}) or 'Unknown'), "</a></span><br/>",
    "<div id='$actionclientid' class='hideaway' style='display:none;'>",
    $self->formatClientData($$action{ACTION_CREATOR}),
    "</div>";
    
    sub formatAttr
    {
	my $attr = shift;
	if ($$attr{NAME} eq 'Priority') {
	    my $fmt = { 0 => 'High', 1 => 'Normal', 2 => 'Low' };
	    return $$fmt{$$attr{VALUE}};
	} elsif ($$attr{NAME} eq 'Transient' or 'Move') {
	    return &yesno($$attr{VALUE});
	}
	return $$attr{VALUE};
    }

    foreach my $attr (@{ $$action{ATTR} } ) {
	next unless $$attr{VALUE};
	my $commentclass = $$attr{NAME} eq 'Comment' ? ' comment' : '';
	push @html, "<label>$$attr{NAME}:</label><span class='labeled$commentclass'>", &formatAttr($attr),"</span><br/>";
    }
    
    push @html, "</div>";

    return @html;
}

1;

######################################################################
package Web25::Request::Main;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 0, TITLE => "Overview",
	       LINK_TITLE => "Quick overview of transfer requests",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my ($qtask, $qreq, $qsite);
  if ($$self{MY_VIEW})
  {
    $qtask = &dbexec($$self{DBH}, qq{
      select count(t.id)
      from t_adm_identity_attr ia
        join t_req_task t
          on t.person = ia.identity
      where ia.name = 'Distinguished name'
        and ia.value = :client_dn},
      ":client_dn" => $$self{SSL_IDENTITY});

    $qreq = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_adm_identity_attr ia
        join t_adm_client c
          on c.identity = ia.identity
        join t_req_request req
          on req.creator = c.id
      where ia.name = 'Distinguished name'
        and ia.value = :client_dn
      group by req.state},
      ":client_dn" => $$self{SSL_IDENTITY});

    $qsite = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      where exists
        (select 1
         from t_req_action ra
	   join t_req_action_attr raa on raa.action = ra.id
	   join t_adm_node n on n.name = raa.value
	   join t_adm_site_node sn on sn.node = n.id
	   join t_adm_site_admin sa on sa.site = sn.site
	   join t_adm_identity_attr ia on ia.identity = sa.identity
	 where ra.request = req.id
	   and raa.name = 'Destination'
	   and ia.name = 'Distinguished name'
	   and ia.value = :client_dn)
	 group by req.state},
	 ":client_dn" => $$self{SSL_IDENTITY});
  }
  else
  {
    $qtask = &dbexec($$self{DBH}, qq{
      select count(t.id) from t_req_task t});

    $qreq = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      group by req.state});

    $qsite = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      group by req.state});
  }

  my ($tasks) = $qtask->fetchrow();
  my $your = $$self{MY_VIEW} ? "Your" : "All";
  print { $$self{CONTENT} }
    "<div align='left'>",
    "<p><a href='@{[$self->myurl('page' => 'Request::Admin')]}'>$your pending tasks</a></p>\n",
    "<ul>\n",
    " <li> ", ($tasks ? "$tasks Tasks" : "None"), "</li>\n",
    "</ul>\n",
    "<p><a href='@{[$self->myurl('page' => 'Request::Requests')]}'>$your transfer requests</a></p>\n",
    "<ul>\n";

  my $n = 0;
  my %status = ();
  while (my ($state, $count) = $qreq->fetchrow())
  {
    $status{$state} = $count;
  }

  foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
  {
    my $s = $$state{STATE};
    next if ! $status{$s};
    print { $$self{CONTENT} } " <li> $status{$s} $$state{LABEL}</li>\n";
    $n += $status{$s};
  }

  print { $$self{CONTENT} }
    " <li> ", ($n ? "$n Total" : "None"), "</li>\n",
    "</ul>\n",
    "<p>Site activity for @{[lc($your)]} sites</p>\n",
    "<ul>\n";

  $n = 0;
  %status = ();
  while (my ($state, $count) = $qsite->fetchrow())
  {
    $status{$state} = $count;
  }

  foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
  {
    my $s = $$state{STATE};
    next if ! $status{$s};
    print { $$self{CONTENT} } " <li> $status{$s} $$state{LABEL}</li>\n";
    $n += $status{$s};
  }

  print { $$self{CONTENT} }
    " <li> ", ($n ? "$n Total" : "None"), "</li>\n",
    "</ul>\n",
    "</div>\n";
}

1;

######################################################################
package Web25::Request::Admin;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Administer Requests",
	       LINK_TITLE => "Browse and carry out pending tasks",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $task = param('task');

  my ($where, $identity);
  if ($$self{MY_VIEW}) {
      $where = qq{ t.person = :identity };
      $identity = $$self{DB_IDENTITY_ID};
  } else {
      # A short cut to the global view;
      # Use a condition that is always true
      $where = '1 = :identity';
      $identity = 1;
  }

  my $qtask = &dbexec($$self{DBH}, qq{
      select t.id, a.id, r.id, tp.value assigned_to, t.time_create, r.state, r.creator, a.action, a.time_apply, a.client, a_attr.name, a_attr.value
      from t_req_task t
      join t_adm_identity_attr tp on t.person = tp.identity and tp.name = 'Distinguished name'
      join t_req_action a on a.id = t.action
      join t_req_request r on r.id = a.request
      left join t_req_action_attr a_attr on a_attr.action = a.id
      where $where
      order by t.id desc, a.time_apply, a_attr.id},
      ":identity" => $identity);

  my $n = 0;
  my $oldtid = -1;
  my $oldaid = -1;
  my %task;
  while (my ($tid, $aid, $rid, $tassigned, $tcreate, $rstate, $rcreator, $action, $atime, $aclient, $name, $value) = $qtask->fetchrow()) {
      next if ($task && $tid != $task);  # XXX improve later...

      if ($oldtid != $tid) {
	  $task{$tid}{TASK_ASSIGNED} = $tassigned;
	  $task{$tid}{TASK_CREATED}  = $tcreate;
	  $task{$tid}{REQUEST_ID} = $rid;
	  $task{$tid}{REQUEST_STATE} = $rstate;
	  $task{$tid}{REQUEST_CREATOR} = $self->getClientData($rcreator);
      }
      if ($oldtid != $tid || $oldaid != $aid) {
	  $task{$tid}{ACTIONS}{$aid}{ACTION_NAME} = $action;
	  $task{$tid}{ACTIONS}{$aid}{ACTION_TIME} = $atime;
	  $task{$tid}{ACTIONS}{$aid}{ACTION_CREATOR} = $self->getClientData($aclient);
	  $task{$tid}{ACTIONS}{$aid}{ATTR} = [];
      }
      push @{$task{$tid}{ACTIONS}{$aid}{ATTR}}, {NAME=> $name, VALUE=> $value};
      $oldtid = $tid;
      $oldaid = $aid;
      ++$n;
  }

  if (! $n) {
      print { $$self{CONTENT} } "<p>No pending tasks to show.</p>";
      return;
  }

  

  foreach my $tid (reverse sort { $a <=> $b } keys %task) {
      my $details_url = $self->myurl(page => 'Request::Detail', 'request' => $task{$tid}{REQUEST_ID});

      print { $$self{CONTENT} } 
      "<div class='nice paramblock lev1'>",
      "<h1>Task $tid</h1>",
      "<label>Task Assigned to:</label>", "<span class='labeled'>", &dn_to_human_name($task{$tid}{TASK_ASSIGNED}), "</span><br/>",
      "<label>Task Created:</label>", "<span class='labeled'>", &formatTime($task{$tid}{TASK_CREATED}, 'stamp' ), "</span><br/>",
      "<label>Request #:</label><span class='labeled'>", $task{$tid}{REQUEST_ID}, "<a href='$details_url'>(details)</a></span><br/>",
      "<label>Requestor:</label>", "<span class='labeled'>",
      "<a href='#' onclick='return hideshow(this, \"creator$tid\", 0)'>",
      (&dn_to_human_name($task{$tid}{REQUEST_CREATOR}{IDENTITY_ATTR}{'Distinguished name'}) or 'Unknown'), "</a></span><br/>",
      "<div id='creator$tid' class='hideaway' style='display:none;'>",
      $self->formatClientData($task{$tid}{REQUEST_CREATOR}),
      "</div>",
      "<label>Request State:</label>", "<span class='labeled'>", $reqstatenames{$task{$tid}{REQUEST_STATE}}, "</span><br/>";

      foreach my $aid (keys %{$task{$tid}{ACTIONS}}) {
	  print { $$self{CONTENT} }
	  "<div class='paramblock lev2'>",
	  $self->formatAction($aid, $task{$tid}{ACTIONS}{$aid}, $tid),
	  "</div>";

	  if ($$self{MY_VIEW}) {
	      my $formurl = $self->myurl(page=>'Request::NewAction');
	      print { $$self{CONTENT} }
	      "<form method='get' action='$formurl'>",
	      hidden(-name=>'request', -value=>$task{$tid}{REQUEST_ID}),
	      hidden(-name=>'task', -value=>$tid),
	      hidden(-name=>'action', -value=>$aid),
	      "<label>Next Action:</label>",
	      popup_menu(-name=>'newaction', 
			 -values=>['subscribe', 'disapprove'],
			 -labels=>{'subscribe' => 'Subscribe',
				   'disapprove' => 'Disapprove'},
			 -class=>'labeled'
			 ),
	      "<br/><label>Comment:<br/><span class='note'>(Optional)</span></label>",
	      textarea(-name=>'comment', -rows=>10, -cols=>60, -class=>'labeled'), "<br/>",
			     "<label>&nbsp;</label>",
			     submit(-value=>'Submit', -class=>'labeled'), "<br/>",
	      "</form>";
	  }
      }
      print { $$self{CONTENT} } "</div>"; # close task
  }

}



1;

######################################################################
package Web25::Request::NewAction;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 0, ORDER => 100, TITLE => "New Action",
	       LINK_TITLE => "Create a new action on a task",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    
    my $newaction = param('newaction');
    my $oldaction = param('action');
    my $request = param('request');
    my $task = param('task');
    my $comment = param('comment');

    if (!$newaction || !$request || !$task) {
	alert('Missing parameters');
	return;
    }

    if (!$self->alert_auth('need' => 'globaladmin', 'power' => 'add a new action to a request')) {
	return;
    }

    my %action_attr;
    my $newactionname;
    my $newstate;
    my $now = time();
    
    if ($comment) {
	%action_attr = ('Comment' => $comment);
    }
    
    if ($newaction eq 'subscribe') {
	$newactionname = 'Subscribed';
	unless (&subscribe_request($$self{DBH}, $request, $now)) {
	    $self->alert("Subscription failed.  No subscription was made.  ",
			 "Was any of the data known to this PhEDEx instance?");
	    return;
	}
	$newstate = 5;
    } elsif ($newaction eq 'disapprove') {
	unless (&disapprove_request($$self{DBH}, $request, $now)) {
	    $self->alert("Disapproval failed.  Please notify the developers.");
	    return;
	}
	$newactionname = 'Disapproved';
	$newstate = 4;
    } else { &alert("Unknown action type '$newaction'"); return; }
    
    my $client = $self->logClientInfo();

    my $aid = &makeObjWithAttrs
	($$self{DBH}, "req_action", "action",
	 { "request" => $request,
	   "action" => $newactionname,
	   "client" => $client,
	   "time_apply" => $now },
	 %action_attr
	 );

    &dbexec($$self{DBH}, qq{update t_req_request set state = :newstate where id = :req_id},
	    ':newstate' => $newstate, ':req_id' => $request);
    
    &dbexec($$self{DBH}, qq{delete from t_req_task where action = :aid},
	    ':aid' => $oldaction);

    $$self{DBH}->commit();
    
    print { $$self{CONTENT} }
    "<h1>Task Completed</h1>",
    "<p>You have $newactionname request \#$request.</p>";
    
    my $q = &dbexec($$self{DBH}, 
		    qq{ select creator from t_req_request where id = :id },
		    ':id' => $request);

    my ($creator_id) = $q->fetchrow();
    my $creator_data = $self->getClientData($creator_id);
    my $creator_name = &dn_to_human_name($$creator_data{IDENTITY_ATTR}{'Distinguished name'});
    my $creator_email = $$creator_data{IDENTITY_ATTR}{'E-mail'};
    my $detail_url = $self->myurl(page => 'Request::Requests', request => $request, fullurl => 1);
    my $admin_email = $self->create_default_email();
    my $msg_comment = ($comment ? "\nThe admin who handled this had the following comment:\n\n\"$comment\"\n" : '');

    my $message=<<ENDEMAIL;
Dear $creator_name,

Your request \#$request has been $newactionname by $$self{USER_NAME}.
$msg_comment
To review details of the request, please go to:

$detail_url

To inquire further about this request, you may reply to this email.

Yours truly,
  PhEDEx transfer request webpage

ENDEMAIL

    send_email(subject => "PhEDEx Request $newactionname (request \#$request)",
	       to => [ $creator_email ],
	       from => "PhEDEx Web Requests <cms-phedex-admins\@cern.ch>",
	       replyto => [ $admin_email ],
	       message => $message
	      );
}


sub subscribe_request
{
    my ($dbh, $request, $now) = @_;
    my ($sth, $rv) = &dbexec($dbh,
	    qq[ insert into t_dps_subscription 
		  (dataset, block, destination, priority, is_move, is_transient, time_create)
		select ds.id, NULL, dest.destination, priority, is_move, is_transient, :now
		  from t_req_info_dest dest
		  join t_req_info_dataset req_ds on dest.request = req_ds.request
		  join t_dps_dataset ds on req_ds.dataset = ds.name
                  join t_dps_dbs dbs on ds.dbs = dbs.id
		 where dest.request = :rid and dbs.name = req_ds.dbs
                   and req_ds.dps_isknown = 'y' and req_ds.dbs_isknown = 'y'
                union
                select NULL, b.id, destination, priority, is_move, is_transient, :now
                  from t_req_info_dest dest
		  join t_req_info_block req_b on dest.request = req_b.request
                  join t_dps_block b on req_b.block = b.name
		  join t_dps_dataset ds on b.dataset = ds.id
                  join t_dps_dbs dbs on ds.dbs = dbs.id
		 where dest.request = :rid and dbs.name = req_b.dbs
                   and req_b.dps_isknown = 'y' and req_b.dbs_isknown = 'y' ],
	    ':now' => $now,
	    ':rid' => $request,
	    ':now' => $now,
	    ':rid' => $request);

    return (!$rv || $rv == 0) ? 0 : $rv;
}


sub disapprove_request
{
    return 1;
}

1;



######################################################################
package Web25::Request::Requests;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "View Requests",
	       LINK_TITLE => "Browse requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $request = param('request');


    my ($where, $identity);
    if ($$self{MY_VIEW}) {
	$where = qq{ ident.id = :identity };
	$identity = $$self{DB_IDENTITY_ID};
    } else {
	# A short cut to the global view;
	# Use a condition that is always true
	$where = '1 = :identity';
	$identity = 1;
    }

    my $qreq = &dbexec($$self{DBH}, qq{
      select r.id, r.state, r.creator, a.id, a.action, a.time_apply, a.client, a_attr.name, a_attr.value
      from t_req_request r
      join t_req_action a on a.request = r.id
      join t_adm_client client on client.id = r.creator
      join t_adm_identity ident on ident.id = client.identity
      left join t_req_action_attr a_attr on a_attr.action = a.id
      where $where
      order by r.id desc, a.time_apply, a_attr.id},
      ":identity" => $identity);

  my $n = 0;
  my $oldrid = -1;
  my $oldaid = -1;
  my %req;
  while (my ($rid, $rstate, $rcreator, $aid, $action, $atime, $aclient, $name, $value) = $qreq->fetchrow()) {
      next if ($request && $rid != $request);  # XXX improve later...
      if ($oldrid != $rid) {
	  $req{$rid}{REQUEST_STATE} = $rstate;
	  $req{$rid}{REQUEST_CREATOR} = $self->getClientData($rcreator);
      }
      if ($oldaid != $aid) {
	  $req{$rid}{ACTIONS}{$aid}{ACTION_NAME} = $action;
	  $req{$rid}{ACTIONS}{$aid}{ACTION_TIME} = $atime;
	  $req{$rid}{ACTIONS}{$aid}{ACTION_CREATOR} = $self->getClientData($aclient);
	  $req{$rid}{ACTIONS}{$aid}{ATTR} = [];
      }
      push @{$req{$rid}{ACTIONS}{$aid}{ATTR}}, {NAME=> $name, VALUE=> $value} if ($name);
      $oldrid = $rid;
      $oldaid = $aid;
      ++$n;
  }

  if (! $n) {
      print { $$self{CONTENT} } "<p>No requests to show.</p>";
      return;
  }

  foreach my $rid (reverse sort { $a <=> $b } keys %req) {
      my $details_url = $self->myurl(page => 'Request::Detail', 'request' => $rid);
      print { $$self{CONTENT} } 
      "<div class='nice paramblock lev1'>",
      "<h1>Request $rid <a href='$details_url'>(details)</a></h1>",
      "<label>Requestor:</label>", "<span class='labeled'>",
      "<a href='#' onclick='return hideshow(this, \"creator$rid\", 0)'>",
      (&dn_to_human_name($req{$rid}{REQUEST_CREATOR}{IDENTITY_ATTR}{'Distinguished name'}) or 'Unknown'), "</a></span><br/>",
      "<div id='creator$rid' class='hideaway' style='display:none;'>",
      $self->formatClientData($req{$rid}{REQUEST_CREATOR}),
      "</div>",
      "<label>Request State:</label>", "<span class='labeled'>", $reqstatenames{$req{$rid}{REQUEST_STATE}}, "</span><br/>";

      foreach my $aid (sort { $a <=> $b } keys %{$req{$rid}{ACTIONS}}) {
 	  print { $$self{CONTENT} }
 	  "<div class='paramblock lev2'>",
	  $self->formatAction($aid, $req{$rid}{ACTIONS}{$aid}),
 	  "</div>";
      }

      print { $$self{CONTENT} } "</div>";
  }
}


1;

######################################################################
package Web25::Request::Detail;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Request Details",
	       LINK_TITLE => "Explore request details",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $request = param('request');

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $req_info = {};
  my $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id, req.creator creator_id, req.state req_state,
                             creator_name.value requestor,
		             req_info.time_update updated
		        from t_req_request req
                        join t_adm_client client on client.id = req.creator
                        join t_adm_identity ident on ident.id = client.identity
                        join t_adm_identity_attr creator_name on creator_name.identity = ident.id and creator_name.name = 'Distinguished name'
		        join t_req_info req_info on req_info.request = req.id
		      ]);

  while (my $row = $q->fetchrow_hashref()) {
      $$req_info{$$row{REQ_ID}} = $row;
  }

  my $req_dest = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id, node.name dest_name
		        from t_req_request req
		        join t_req_info_dest req_dest on req_dest.request = req.id
		        join t_adm_node node on node.id = req_dest.destination
		      ]);

  while (my ($rid, $node) = $q->fetchrow()) {
      if (!exists $$req_dest{$rid}) {
	  $$req_dest{$rid} = [];
      }
      push @{$$req_dest{$rid}}, $node;
  }

  my $req_datasets = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id,
		             req_ds.dbs req_dbs, req_ds.dataset, req_ds.dbs_isknown, req_ds.dps_isknown
		        from t_req_request req
		        join t_req_info_dataset req_ds on req_ds.request = req.id
		      ]);

  while (my ($rid, $dbs, $dataset, $dbs_isknown, $dps_isknown) = $q->fetchrow()) {
      $$req_datasets{$rid}{$dataset} = { DBS => $dbs,
					 DBS_ISKNOWN => $dbs_isknown,
					 DPS_ISKNOWN => $dps_isknown };
  }

  my $req_blocks = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id,
		             req_b.dbs req_dbs, req_b.block, req_b.dbs_isknown, req_b.dps_isknown
		        from t_req_request req
		        join t_req_info_block req_b on req_b.request = req.id
		      ]);

  while (my ($rid, $dbs, $block, $dbs_isknown, $dps_isknown) = $q->fetchrow()) {
      $$req_blocks{$rid}{$block} = { DBS => $dbs,
				     DBS_ISKNOWN => $dbs_isknown,
				     DPS_ISKNOWN => $dps_isknown };
  }

  my $table = new Web25::TableSpool;
  $table->set_filehandle( $$self{ CONTENT } );

  $table->set_querycols( [('Request #', 'col', 'REQUEST', 1)],
			 [('DBS', 'col', 'DBS', 1)],
			 [('Data Item', 'col', 'DATA_ITEM', 1)],
			 [('Destinations', 'col', 'DESTINATIONS', 1)],
			 [('Requestor', 'col', 'REQUESTOR', 1)],
			 [('Updated', 'col', 'UPDATED', 1)],
			 [('Known to DBS?', 'col', 'DBS_ISKNOWN', 1)],
			 [('Known to PhEDEx?', 'col', 'DPS_ISKNOWN', 1)]
			 );

  $table->set_tablehead({ REQUEST => 'Request #',
			      DBS => 'DBS',
			      DATA_ITEM => 'Data Item',
			      DESTINATIONS => 'Destinations',
			      REQUESTOR => 'Requestor',
			      UPDATED => 'Request Updated',
			      DBS_ISKNOWN => 'Known to DBS?',
			      DPS_ISKNOWN => 'Known to PhEDEx?' });


  $table->set_tableclass('data');
  $table->set_stripeclass('stripe');

  $table->set_dataformats({ REQUESTOR => \&dn_to_human_name,
			    UPDATED   => sub { &formatTime($_[0], 'stamp') },
			    DBS_ISKNOWN => \&yesno,
			    DPS_ISKNOWN => \&yesno
			});

  $table->set_cellformats({DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			   DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});

  $table->start();
  $table->head();

  foreach my $rid (reverse sort keys %{$req_info}) {
      next if ($request && $request != $rid); # XXX improve later...
      my $dests = join ', ', @{$$req_dest{$rid}};
      my $row = { REQUEST => $rid, DESTINATIONS => $dests };
      $$row{$_} = $$req_info{$rid}{$_} foreach (qw(REQUESTOR UPDATED));
      
      foreach my $dataset (sort keys %{$$req_datasets{$rid}}) {
	  $$row{DATA_ITEM} = $dataset;
	  $$row{$_} = $$req_datasets{$rid}{$dataset}{$_} foreach(qw(DBS DBS_ISKNOWN DPS_ISKNOWN));
	  $table->row($row);
      }

      foreach my $block (sort keys %{$$req_blocks{$rid}}) {
	  $$row{DATA_ITEM} = $block;
	  $$row{$_} = $$req_blocks{$rid}{$block}{$_} foreach(qw(DBS DBS_ISKNOWN DPS_ISKNOWN));
	  $table->row($row);
      }
  }

  $table->finish();

  #  Options form
  my $optspane = new Web25::OptsPane;
  $optspane->add_hidden( hidden('request', $request) ) if $request;
  my $target = $self->myurl();
  $optspane->set_form_target($target);
  
  my $form = $table->columns_form();
  $optspane->add_tab('Columns', $form);
  
  print { $$self{OPTIONS} } $optspane->output();

}



1;

######################################################################
package Web25::Request::CreateTools;
use strict; use warnings;
use base "Exporter";
import Web25::Common;
use CGI qw(:standard);
use Text::Glob 'glob_to_regex';
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} 
	|| "./"; $__scriptdir =~ s,[^/]+$,,;
	unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;

our @EXPORT = qw(get_request_nodes
		 create_check_access
		 create_check_identity
		 create_check_email
		 create_check_comment
		 create_check_dbs
		 create_check_data
		 create_check_dest
		 create_check_options
		 create_check_bad
		 resolve_data
);

sub get_request_nodes
{
    my ($self) = shift @_;
    my %nodes = $self->fetch_nodes(with_ids=>1);
    foreach my $node (keys %nodes) {
	delete $nodes{$node} if ($node =~ /(.*)_(Buffer|Stage)$/ && exists $nodes{"$1_MSS"});
    }
    return sort keys %nodes;
}

sub create_check_access
{
  my ($self, $bad) = @_;
  return if $$bad;

  if (request_method() ne 'POST')
  {
    alert($self, "This form can only be accessed with 'POST' method.");
    $$bad = 1;
  }
}

sub create_check_identity
{
  my ($self, $bad) = @_;
  return if $$bad;

  # Make sure this page can be used
  if (! $self->alert_auth('need' => 'anycert', 'power' => 'create a transfer request'))
  {
    $$bad = 1;
    return;
  }

  if (! $$self{SSL_VERIFIED})
  {
    warning($self,
	    "Your identity has not been verified.  The certificate",
	    " presented by your web browser is not a recognised grid",
	    " certificate.  For now you are still allowed to create",
	    " a transfer request.");
  }
}

sub create_check_email
{
  my ($self, $bad, $email) = @_;
  return undef if $$bad;

  if (! $email)
  {
    alert($self, "No requestor e-mail, please supply one.");
    $$bad = 1;
    return undef;
  }

  my ($nrvalidmails, @emails) = validlist ($email);
  if ($email ne '' && ! $nrvalidmails)
  {
    alert($self, "Requestor e-mail &ldquo;@{[&escapeHTML($email)]}&rdquo; is",
	  " not a valid RFC822 e-mail address or address list.");
    $$bad = 1;
  }

    return $$bad ? undef : $email;
}

sub create_check_comment
{
  my ($self, $bad, $comment) = @_;
  return undef if $$bad;
  return $comment;
}

sub create_check_dbs
{
  my ($self, $bad, $dbs) = @_;
  return undef if $$bad;
  if (! $dbs)
  {
    alert($self, "No DBS selected, please choose a value.");
    $$bad = 1;
    return undef;
  }

  if ($dbs !~ m|^[-=+_:/?&;.a-zA-Z0-9]+$|)
  {
    alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	  " contains unsafe characters.");
    $$bad = 1;
  }

  my $SAFE_HOST = "[-A-Za-z0-9_+.]+";
  my $SAFE_PATH = "[-A-Za-z0-9_+.:/&%;]*";
  if ($dbs !~ m,^https?://($SAFE_HOST)(:\d+)?/($SAFE_PATH)\?.*instance=$SAFE_PATH$,)
  {
      my %dbses = $self->get_dbses();
      if (! grep($_ eq $dbs, keys %dbses))
    {
      alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " is not a URL for a DBS service.  Please use a URL of",
	    " the form http://server/path?instance=name.");
      $$bad = 1;
    }
  }
  else
  {
    my $hostname = $1;
    my ($name,$aliases,$addrtype,$length,@addrs)
      = CORE::gethostbyname($hostname);
    if (! $name)
    {
      alert($self, "The host name of the DBS service, &ldquo;",
	    &escapeHTML($hostname), "&rdquo;, did not resolve.",
	    " Please make sure the host is accessible.");
      $$bad = 1;
    }

    my $info = qx(wget -qO- '$dbs;api=listPrimaryDatasets;pattern=/zilch');
    if (! $info || $info !~ /<dbs>/s)
    {
      alert($self, "The DBS contact, &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " does not respond to aliveness check.  Please make sure",
	    " the contact URL points to a correct service.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : $dbs;
}



sub create_check_data
{
  my ($self, $bad, $data) = @_;
  return undef if $$bad;

  my @data = split(/\s+/, $data);
  if (! @data)
  {
    alert($self, "No data specified.");
    $$bad = 1;
  }

  foreach my $data (@data)
  {
    if ($data !~ m<^/[^/]+/[^/]+(/[^/]+|\#[^\#]+)$>)
    {
      alert($self, "The data pattern is &ldquo;@{[&escapeHTML($data)]}&rdquo;",
	      " does not match pattern of type /PRIMARY/TIER/DATASET or /PRIMARY/DATASET#BLOCK.");
      $$bad = 1;
    }

  }

  return $$bad ? undef : @data;
}

sub create_check_dest
{
  my ($self, $bad, @dests) = @_;
  return undef if $$bad;

  if (! @dests)
  {
    alert($self, "No destination selected, please select some.");
    $$bad = 1;
    return undef;
  }

  my @nodes = $self->get_request_nodes();

  foreach my $node (@dests)
  {
    if (! grep ($_ eq $node, @nodes))
    {
      alert($self, "Node name &ldquo;@{[&escapeHTML($node)]}&rdquo;",
	    " is not known to PhEDEx.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : sort @dests;
}

sub create_check_options
{
  my ($self, $bad) = @_;
  return undef if $$bad;

  my $opts = {};

  foreach ('is_move', 'is_transient') {
      if (!param($_) && param($_) !~ /^[yn]$/) {
	  $self->alert("Option '$_' missing or illegal value");
	  $$bad = 0;
	  return undef;
      }
  }
  
  if (!param('priority') && param('priority') !~ /^[012]$/) {
      $self->alert("Option 'priority' missing or illegal value");
      $$bad = 0;
      return undef;
  }
  return (param('is_move'), param('is_transient'), param('priority'));
}

sub create_check_bad
{
  my ($self, $bad) = @_;
  print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n" if $bad;
  return $bad;
}

sub dbs_lookup
{
    my ($dbs, $pattern) = @_;

    ### Security:  Strict list of characters allowed to go to shell
    my $reg = qr/[^\w\.\*\-\#\/\?=:\+\&]/;
    foreach (@_) {
	if (/$reg/) {
	    die "Invalid string '$_' given to dbs_lookup()";
	}
    }
        
    my $dbscmd = "wget -qO- '$dbs;api=listDatasets;pattern=$pattern'";
    my $dbsresults = `$dbscmd`;
    if ($dbsresults) { 
	my @paths = ($dbsresults =~ /path='([^'\'']*)'/g);
	return @paths;
    }
}


# Resolve user datasets;  Search DPS and DBS for glob patterns
# Fill data object with results:
# $$resolved{$userglob} = [ { params }, ... ]
# Where { params } contains:
#   DBS = dbs the data was found in PhEDEx, not necessarily the one the user specified
#   LEVEL = 'BLOCK' or  'DATASET'
#   DATASET = Dataset name
#   BLOCK = Block name.  undef if LEVEL = DATASET
#   ID = The dps unique id for item
#   DPS_ISKNOWN = 'y' or 'n'
#   DBS_ISKNOWN = 'y' or 'n'
sub resolve_data
{
    my ($dbh, $userdbs, @userdata) = @_;

    my $resolved = {};
    my $userdupes = {};
    my $dbsdupes = {};
    my $all = {};

    foreach my $level (qw(DATASET BLOCK)) {
	$$all{$level} = [];
    }

    foreach my $userglob (@userdata) {
	$$resolved{$userglob} = [];
	my $level = ($userglob =~ m|/.+\#\d+$| ? 'BLOCK' : 'DATASET');

	# Search the DPS for the user's glob
	my $sql;
	if ($level eq 'DATASET') {
	    $sql = qq{select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset
		        from t_dps_dataset ds
			join t_dps_dbs dbs on dbs.id = ds.dbs
		       order by ds.id };
	} else {
	    $sql = qq{select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset, b.id block_id, b.name block
			from t_dps_block b
			join t_dps_dataset ds on b.dataset = ds.id
			join t_dps_dbs dbs on ds.dbs = dbs.id
		       order by b.id};
	}

	my $q = &dbexec($dbh, $sql);

	my $pattern = glob_to_regex($userglob);
	my $lastid = -1;
	while (my $row = $q->fetchrow_hashref()) {
	    my $name = $$row{$level};
	    my $id = $$row{$level.'_ID'};
	    next unless $name =~ /$pattern/;

	    # Redundancy checking
	    if ($id == $lastid) {
		$$dbsdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	    push @{$$all{$level}}, $id;

	    push @{$$resolved{$userglob}},  { DBS => $$row{DBS},
					      LEVEL => $level,
					      DATASET => $$row{DATASET},
					      BLOCK   => $$row{BLOCK},
					      DPS_ISKNOWN => 'y',
					      DBS_ISKNOWN => 'y', # XXX This is assuming DPS and DBS are in sync
					      ID => $id };
	}
	
	# User's glob not found in DPS, check their DBS
	if (! @{$$resolved{$userglob}}) {
	    my @dbsdata = dbs_lookup($userdbs, $userglob);
	    foreach my $name (@dbsdata) {
		push @{$$resolved{$userglob}}, { DBS => $userdbs,
						 LEVEL => $level,
						 DATASET => ($level eq 'DATASET' ? $name : undef),
						 BLOCK   => ($level eq 'BLOCK' ? $name : undef),
						 DPS_ISKNOWN => 'n',
						 DBS_ISKNOWN => 'y',
						 ID => undef };
	    }
	}
    }

    my $lastid = -1;
    foreach my $level (qw(DATASET BLOCK)) {
	foreach my $id (sort @{$$all{$level}}) {
	    if ($id == $lastid) {
		$$userdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	}
    }

    if (wantarray) {
	return ($resolved, $userdupes, $dbsdupes);
    } else {
	return $resolved;
    }
}


1;

######################################################################
package Web25::Request::Create;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Create Request",
	       LINK_TITLE => "Create a new transfer request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  return if $bad;

  my $email_contact = $self->create_default_email();
  
  my @dbsnames = sort $self->fetch_dbses();
  my $defaultdbs = 'http://cmsdbs.cern.ch/cms/prod/comp/DBS/CGIServer/prodquery?instance=MCGlobal/Writer';
  my @nodes = $self->get_request_nodes();

  my @dbs_selection = &striplabels(radio_group(-name=>'dbschoice', -values=>['known', 'user'], -default=>'known', 
					       -nolabels=>1, -class=>'labeled'));

  $dbs_selection[0] .= "<label style='width:5em'>Known</label>".
      popup_menu(-name=>'dbs', -values=>[ map { &escapeHTML($_) } @dbsnames ], -default=>&escapeHTML($defaultdbs) ).
      "<br/>\n";

  $dbs_selection[1] .= "<label style='width:5em'>Other</label>".
      textfield(-name=>'userdbs', -default=>'http://path?instance=value', -size=>50).
      "<br/>\n";

  print { $$self{CONTENT} }
  "<form class='nice' method='post' action='@{[$self->myurl('page' => 'Request::CreateCheck')]}'>\n",
  "<label>E-mail:</label>", textfield(-name=>'email', -default=>$email_contact, -class=>'labeled', -style=>'width:450px'), "<br/>\n",

  "<label>DBS:</label>",  "<div class='labeled'>",@dbs_selection, "</div><br/>",

  "<label>Data Items:<br/><br/>",
  "<span class='note'>/Primary/Tier/Dataset<br/>or<br/>",
  "/Primary/Dataset#Block<br/>(Use * as wildcard)</span><br/>",
  &help("More Help", "Data Item List", 
	"A whitespace separated list of the datasets or blocks you are ",
	"requesting.  Glob-style wildcards may be used, but the data ",
	"tier separators are required.  E.g. to subscribe to all ",
	"datasets you would have to write '/*/*/*', not '*'."), 
  "</label>\n",
  textarea(-name=>'data', -value=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), 
  "<br/>",

  "<label>Destinations</label>",
  "<div class='labeled'  style='font-size:8pt;width:450px;height:150px;overflow:scroll;border:thin solid black;' >",
  "<table><tr valign='top'>",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   sort grep (/^T1_|T0_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   grep (/^T2_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   grep (! /^T[012]_/, @nodes)),
  "  </td>\n",
  " </tr></table></div><br/>\n",
  "<label>Transfer Type:</label>", popup_menu(-name=>'is_move', 
					      -values=>['y', 'n'],
					      -default=>'n',
					      -labels=>{'n' => 'Replica', 'y' => 'Move'},
					      -class=>'labeled'),
  &help("What's this?", "Transfer Type", "A <b>replica</b> replicates ",
	"data from the source to the destination, while a <b>move</b> ",
	"replicates the data then deletes the data at the source.  Note that ",
	"moves are only used for moving data from T2s to T1s."),
  "<br/>",
  "<label>Subscription Type:</label>", popup_menu(-name=>'is_transient', 
					       -values=>['y', 'n'],
					       -default=>'n',
					       -labels=>{'n' => 'Open', 'y' => 'Closed' },
					       -class=>'labeled'), 
  &help("What's this?", "Subscription Type", 
	"An <b>open</b> subscription downloads blocks/files added to open ",
	"datasets/blocks as they become available, until the dataset/block is ",
	"closed.  A <b>closed</b> subscription will only transfer the blocks/files ",
	"available at the time the subscription is made.  In a sense an open ",
	"subscription is a true \"subscription\" and a closed subscription is a snapshot."),
  "<br/>",
  "<label>Priority:</label>", popup_menu(-name=>'priority', 
					 -values=>[0, 1, 2], 
					 -default=>1,
					 -labels=>{ 0 => 'High',
						    1 => 'Normal',
						    2 => 'Low' },
					 -class=>'labeled'),
  &help("What's this?", "Priority",
	"Priority is used to determine which data items get priority when resources are limited."),
  "<br/>",
  "<label>Comment:</label>", textarea(-name=>'comment', -default=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), "<br/>\n",

  "<label>&nbsp;</label>", submit(-name=>'submit', -value=>'Submit Request', -class=>'labeled'),
  "</form>";
}

1;



######################################################################
package Web25::Request::CreateCheck;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Submit Request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $bad = 0;
  &create_check_identity($self, \$bad);
  &create_check_access($self, \$bad);
  my $email = &create_check_email($self, \$bad, param('email'));
  my $comment = &create_check_comment($self, \$bad, param('comment'));
  my $dbs;
  if (param('dbschoice') eq 'known') { $dbs = param('dbs') }
  elsif (param('dbschoice') eq 'user') { $dbs = param('userdbs') } 
  else { $self->alert("Missing or unknown DBS parameters"); return; }
  $dbs = &create_check_dbs($self, \$bad, $dbs);
  my @data = &create_check_data($self, \$bad, param('data'));
  my @dest = &create_check_dest($self, \$bad, param('dest'));
  my ($is_move, $is_transient, $priority) = &create_check_options($self, \$bad);
  if ($bad)
  {
    print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n";
    return;
  }

  my $confirmok = 1;
        
  if ($is_move eq 'y' && param('move_confirm') ne 'y') {
      $confirmok = 0;
  }

  if ($confirmok && param('go_ahead') eq 'y') {
      $self->write_request('email' => $email,
			   'comment' => $comment,
			   'dbs' => $dbs,
			   'data' => [@data],
			   'destinations' => [@dest],
			   'is_move' => $is_move,
			   'is_transient' => $is_transient,
			   'priority' => $priority);
      return;
  }

  my $subscription_type = &subscription_type($priority, $is_transient, $is_move);

  print { $$self{CONTENT} } 
  "<form method='POST' action='@{[$self->myurl()]}'>\n",
  "<p>Please review these request details and confirm below.  If you would like to ",
  "change your request, use the back button in your browser.</p>",
  "<h1>Request Information</h1>",
  "<div class='nice'>",
  "<label>Requestor:</label><span class='labeled'>$$self{SSL_IDENTITY}</span><br/>",
  "<label>email:</label><span class='labeled'>$email</span><br/>",
  "<label>DBS:</label><span class='labeled'>$dbs</span><br/>",
  "<label>Data:</label><span class='labeled'>", join('<br/>', @data), "</span><br/>",
  "<label>Destination:</label><span class='labeled'>", join('<br/>', @dest), "</span><br/>",
  "<label>Subscription Type:</label><span class='labeled'>$subscription_type</span><br/>",
  "</div>";

  # Warnings
  if ($is_move eq 'y' && grep($_ !~ /^T1_\w*_MSS$/, @dest)) {
      $self->alert("You have requested a move to an unsupported destination (e.g. not a Mass Storage System ",
		   "at a T1 centre).  Please change the destination, or choose to trigger a replication ",
		   "instead of a move");
      return;
  } elsif ($is_move eq 'y' && grep(/^T1_\w*_MSS$/, @dest)) {
      $self->note("You have chosen to move data to ", join(', ', @dest), ". Once the transfer is complete this will ",
		  "remove the data at the source site.  Please confirm that this is what you want to do by checking ",
		  "the box.<br/><br/>",
		  ( param('go_ahead') ? "<p class='alarm'><b>You must confirm!</b></p>" : ''),
		  checkbox(-name=>'move_confirm', -value=>'y', -label=>'Yes, I understand'));
  }

  if ($is_transient eq 'n') {
      $self->note("You are requesting an open subscription.  The nodes selected will continue to ",
		  "receive files from open blocks if they are made available.  Please carefully monitor ",
		  "your disks, as the size of this subscription could grow significantly.");
  }
  

  print { $$self{CONTENT} } "<h1>Data Item Lookup</h1>",
  "<p>The following table summarizes an attempt to look for your requested data items in PhEDEx.  ",
  "Items in red may be problematic and require extra consideration by the PhEDEx admins.</p>";
  
  # Pull all subscriptions into a hash organized by node for subscription duplication checking
  my $subscriptions = {};
  my $q = &dbexec($$self{DBH}, qq{ select NVL2(s.block, 'BLOCK', 'DATASET') lvl,
				          NVL2(s.block, s.block, s.dataset) id,
				          n.name node
                                   from t_dps_subscription s
                                   join t_adm_node n on s.destination = n.id });
  
  while (my ($level, $id, $node) = $q->fetchrow_array()) {
      $$subscriptions{$node}{$level}{$id} = 1;
  }

  my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, $dbs, @data);

  my $table = new Web25::TableSpool;
  $table->set_filehandle( $$self{CONTENT} );
  $table->set_tableclass('data');
  $table->set_stripeclass('stripe');
  $table->set_tablecols([qw(LEVEL ITEM DPS_ISKNOWN DBS_ISKNOWN COMMENT)]);
  $table->set_tablehead({LEVEL => 'Data Level', 
			 ITEM => 'Data Item', 
			 DPS_ISKNOWN => 'Known to PhEDEx', 
			 DBS_ISKNOWN => 'Known to DBS', 
			 COMMENT => 'Comment'});
  $table->set_cellformats({COMMENT     => sub { $_[1]->{WARN} ? 'alarm' : '' },
			   DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			   DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});

  $table->set_dataformats({DPS_ISKNOWN => \&yesno,
		           DBS_ISKNOWN => \&yesno});

  $table->start();
  $table->head();

  my $problems = 0;
  foreach my $userglob (sort @data) {
      if (! @{$$resolved{$userglob}} ) {
	  $table->row({LEVEL => 'User Search',
		       ITEM  => $userglob,
		       DPS_ISKNOWN => 'n',
		       DBS_ISKNOWN => 'n',
		       COMMENT => 'Data item not found anywhere',
		       WARN => 1});
	  $problems = 1;
      } else {
	  foreach my $res (@{$$resolved{$userglob}}) {
	      my @comments;
	      my $warn = 0;
	      
	      if ($$res{DBS} ne $dbs)  { push @comments, "Known to PhEDEx in another DBS ($$res{DBS})"; $warn = 1; $problems = 1; }
	      if ($$userdupes{$$res{LEVEL}}{$$res{ID}}) { push @comments, "User duplicated requests"; $warn = 1; }
	      if ($$dbsdupes{$$res{LEVEL}}{$$res{ID}})  { 
		  push @comments, "Data item known to PhEDEx in multiple DBSes";
		  $warn = 1; 
	      }
	      
	      foreach my $node (@dest) {
		  if ($$subscriptions{$node}{$$res{LEVEL}}{$$res{ID}}) {
		      push @comments, "Already subscribed to $node";
		      $warn = 1;
		  }
	      }

	      $$res{ITEM} = $$res{$$res{LEVEL}}; # Name of dataset or block, depending on which it is for
	      $$res{LEVEL} = ucfirst lc $$res{LEVEL}; # Just to make it pretty
	      $$res{COMMENT} = join('<br/>', @comments);
	      $$res{WARN} = $warn;
	      
	      if ($warn) { $problems = 1; }
	      if ($$res{DPS_ISKNOWN} eq 'n' || $$res{DBS_ISKNOWN} eq 'n') { $problems = 1; }
	      $table->row($res);
	  }
      }
  }

  $table->finish();

  # Save the previous state
  foreach (qw(email comment dbschoice dbs userdbs is_move is_transient priority data dest)) {
      print { $$self{CONTENT} } hidden($_);
  }

  unless ($problems) {
      print { $$self{CONTENT} }
      hidden(-name=>'go_ahead', -default=>'y'),
      "<p><center>", submit(-value=>'Confirm'), "</p>";
  } else {
      $self->alert("Sorry, due to the problems with your request (in red) it cannot be submitted.  ",
		   "Please go back and resolve the problems if you can, or ",
		   "<a href='mailto:cms-phedex-admins\@cern.ch'>mail the admins</a> if you have a question.");
  }
  print { $$self{CONTENT} } "</form>";
}
  


sub write_request
{
    my ($self, %params) = @_;

    foreach (qw(email comment dbs data destinations is_move is_transient priority)) {
	if (!exists $params{$_}) { die "write_request() insufficient parameters"; }
    }
    
    my $now = time();

    # Write information about the Client
    my $client = $self->logClientInfo();
    
    # Write the request
    my $rid = &makeObjWithAttrs
	($$self{DBH}, "req_request", undef,
	 { "creator" => $client, "state" => 0 });

    my $aid = &makeObjWithAttrs
	($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "Created",
	   "client" => $client,
	   "time_apply" => $now },
	 "Comment" => $params{comment},
	 "E-mail" => $params{email},
	 "DBSURL" => $params{dbs},
	 map( { ("Destination Node" => $_) } @{$params{destinations}}),
	 map( { ("Data" => $_) } @{$params{data}}),
	 "Priority" => $params{priority},
	 "Transient" => $params{is_transient},
	 "Move" => $params{is_move}
	 );
    
    # Get the list of Global admins
    my %admins = $self->fetch_users(global_admins => 1);
    if (!%admins) {
	alert("Sorry, the request cannot be created.",
	      "The database does not contain any global admins.",
	      "Please contact the PhEDEx group about this!"); 
	return;
    }

    # Write a task with this request for each of the global admins
    # While we're at it, build an array of admin emails
    my @adminmails;
    foreach my $admin (keys %admins) {
	&makeObjWithAttrs
	    ($$self{DBH}, "req_task", undef,
	     { "action" => $aid,
	       "person" => ${$admins{$admin}}{ID},
	       "time_create" => $now
	       }
	     );
	push @adminmails, ${$admins{$admin}}{EMAIL};
    }

    # Write the request details (resolved datasets/blocks) to the DB
    &dbexec($$self{DBH}, qq[ insert into t_req_info (request, time_update)
			     values ( :rid, :time_update ) ],
	    ':rid' => $rid,
	    ':time_update' => $now);

    my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, $params{dbs}, @{$params{data}});

    my @rv;
    foreach my $userglob (sort @{$params{data}}) {
	foreach my $res (@{$$resolved{$userglob}}) {
	    if ($$res{LEVEL} eq 'DATASET') {
		@rv = &dbexec($$self{DBH}, 
			      qq[ insert into t_req_info_dataset (request, dbs, dataset, dbs_isknown, dps_isknown,
								  is_move, is_transient, priority)
				  values ( :rid, :dbs, :dataset, :dbs_isknown, :dps_isknown,
					   :is_move, :is_transient, :priority) ],
			      ':rid'          => $rid,
			      ':dbs'          => $$res{DBS},
			      ':dataset'      => $$res{DATASET},
			      ':dbs_isknown'  => $$res{DBS_ISKNOWN},
			      ':dps_isknown'  => $$res{DPS_ISKNOWN},
			      ':is_move'      => $params{is_move},
			      ':is_transient' => $params{is_transient},
			      ':priority'     => $params{priority}
			      );
	    } elsif ($$res{LEVEL} eq 'BLOCK') {
		@rv = &dbexec($$self{DBH},
			      qq[ insert into t_req_info_block ( request, dbs, dataset, block,
								 dbs_isknown, dps_isknown,
								 is_move, is_transient, priority)
				  values ( :rid, :dbs, :dataset, :block, :dbs_isknown, :dps_isknown,
					   :is_move, :is_transient, :priority) ],
			      ':rid' => $rid,
			      ':dbs' => $$res{DBS},
			      ':dataset' => $$res{DATASET},
			      ':block' => $$res{BLOCK},
			      ':dbs_isknown' => $$res{DBS_ISKNOWN},
			      ':dps_isknown' => $$res{DPS_ISKNOWN},
			      ':is_move'      => $params{is_move},
			      ':is_transient' => $params{is_transient},
			      ':priority'     => $params{priority}
			      );
	    }
	    unless ($rv[1] > 0) {
		$$self{DBH}->rollback();
		&alert("Request creation failed");
	    }
	}
    }
    
    foreach my $node (@{$params{destinations}}) {
	&dbexec($$self{DBH},
		qq[ insert into t_req_info_dest (request, destination)
		    select :rid, id node_id from t_adm_node where name = :node ],
		':rid' => $rid, ':node' => $node);
    }

    $$self{DBH}->commit();

    # Send an email to each of the PhEDEx global admins
    # and each of the site admins
    my $instance = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE};
    my $subscription_type =  &subscription_type(@params{qw(priority is_transient is_move)});
    my @cc = ($params{email});
    my %siteadmins = $self->fetch_users(admin_of => $params{destinations});
    if (%siteadmins) {
	push @cc, $$_{EMAIL} foreach values %siteadmins;
    }

    # Here we build a hash of node => site
    my %node_sites;
    my %site_nodes = $self->fetch_sites(for_nodes => $params{destinations});
    foreach my $site (keys %site_nodes) {
	foreach my $node (@{$site_nodes{$site}}) {
	    $node_sites{$node} = $site 
	}
    }

    my $admin_url = $self->myurl('fullurl' => 1, 'secure' => 1, 'page' => 'Request::Admin', 'view' => 'my');

    my $message =<<ENDEMAIL;
Greetings PhEDEx Global Admins,

You may wish to take note of the following new transfer request:

* Requestor:
   Name:  $$self{USER_NAME}
   DN: $$self{SSL_IDENTITY}
   Host: $ENV{HTTP_X_FORWARDED_FOR}
   Agent: @{[user_agent()]}

* Request:
   Type:
     $subscription_type
   Database:
     $instance
   Contact:
     $params{email}
   DBS:
     $params{dbs}
   Data:
ENDEMAIL

    $message .= join('', map( { "     $_\n" } @{$params{data}})).
    "   Destination Nodes:\n".
    join('', map( { "     $_ (Site: $node_sites{$_})\n" } @{$params{destinations}}));

    $message .=<<ENDEMAIL;
   Comments:
     "$params{comment}"

This mail has also been sent to the requestor, and to the site admins of the sites affected.

Go to
  $admin_url
to handle this request.

Yours truly,
  PhEDEx Transfer Request Web Form
ENDEMAIL
    
send_email(subject => "PhEDEx Transfer Request ($instance instance)",
	   to => [ @adminmails ],
	   cc => [ @cc ],
	   from => "PhEDEx Request Form <cms-phedex-admins\@cern.ch>",
	   message => $message)
or $self->alert("Sending request email to admins failed, sorry");
    
    
    print { $$self{ CONTENT } }
    "<h1>Request Confirmed</h1>",
    "<p>Your request has been logged to the database and the admins have been notified.  ",
    "You will receive updates about this request via e-mail.</p>";
}

sub subscription_type
{
    my ($priority, $is_transient, $is_move) = @_;
    my $nice = 
    {
	is_move => { y => 'move', n => 'replication' },
	is_transient => { y => 'closed', n => 'open' },
	priority => { 0 => 'High', 1 => 'Normal', 2 => 'Low' }
    };

    return "$$nice{priority}{$priority} priority $$nice{is_transient}{$is_transient} $$nice{is_move}{$is_move}";
}

1;



######################################################################
package Web25::Components::Status;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Status",
	       LINK_TITLE => "View recently active PhEDEx components" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my %offline_thresholds = ( 'FileDownload' => 60*30,
			     'FileExport'   => 60*90,
			     'InfoFileSize' => 60*30,
			     'OTHER'        => 60*15 );
  
  
  my $now = time ();
  my $query = &dbexec($$self{DBH}, qq{
      select n.name, a.name, ast.time_update
	  from t_agent_status ast
	  join t_adm_node n on n.id = ast.node
	  join t_agent a on a.id = ast.agent});

  my (%agents, %status);
  while (my $row = $query->fetchrow_arrayref)
  {
      my ($node, $agent, $contact) = @$row;
      $status{$node}{$agent} = $contact;
      $agents{$agent} = 1;
  }

  my @standard = grep (!/^(Block|Info(?!Drop)|Perf|Table)/, sort keys %agents);
  my @admin = grep (/^Block/, sort keys %agents);
  my @support = grep (/^(?!File|Block|InfoDrop)/, sort keys %agents);

  foreach my $item ([ "Common", @standard ], [ "Administrative", @admin ], [ "Support", @support ])
  {
      my ($type, @agents) = @{$item};
      print { $$self{CONTENT} }
      "<p><table class='striped'>\n",
      "<tbody>\n",
      "<tr class='selected'>\n",
      " <td align='center' colspan='" . (scalar @agents + 1) . "'>$type Agents</td>\n",
      "</tr>\n",
      "<tr class='selected'>\n",
      " <th>Node</th>\n",
      (map { " <th>$_</th>\n" } @agents),
      "</tr>\n";

      foreach my $node (sort keys %status)
      {
	  next if ! grep (defined $status{$node}{$_}, @agents);

	  print { $$self{CONTENT} } "<tr>\n", " <td>$node</td>\n";
	  foreach my $agent (@agents)
	  {
	      my $offline = ( $offline_thresholds{$agent} || $offline_thresholds{OTHER} );
	      my $active = $offline / 3;
	      my $contact = $status{$node}{$agent};

	      if (! defined $contact)
	      {
		  print { $$self{CONTENT} } " <td>&nbsp;</td>\n";
		  next;
	      }
	      
	      my $ago = &age($now - $contact);
	      if (($now - $contact) < $active) {
		  print { $$self{CONTENT} } "<td align='center' bgcolor='$goodcolor'>UP</td>\n";
	      } elsif (($now - $contact) < $offline) {
		  print { $$self{CONTENT} } "<td align='center' bgcolor='$goodcolor'>UP ($ago ago)</td>\n";
	      } else {
		  print { $$self{CONTENT} } "<td align='center' bgcolor='$badcolor'>DOWN ($ago ago)</td>\n";
	      }
	  }
	  print { $$self{CONTENT} } "</tr>\n";
      }
      print { $$self{CONTENT} } "</tbody>\n", "</table>\n";
  }
}

1;

######################################################################
package Web25::Components::Agents;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Processes",
	       LINK_TITLE => "View details about PhEDEx processes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

    my $now = time();

    # Group by host, 
    my $sql = qq[ select s.time_update time_update,
                         n.name node_name, 
                         s.host_name,
                         s.directory_path,
                         a.name agent_name,
                         v.filename,
                         v.release,
                         v.revision,
                         v.tag,
                         s.label agent_label,
                         s.process_id pid,
                         s.worker_id, 
                         s.queue_pending q_pend,
                         s.queue_received q_recv,
                         s.queue_work q_work,
                         s.queue_completed q_comp,
                         s.queue_bad q_bad,
                         s.queue_outgoing q_out,
                         s.state state
 		    from t_agent_status s
                    join (select host_name, agent, label, min(node) node
			         from t_agent_status group by host_name, agent, label) s_sub
                      on s_sub.host_name = s.host_name and s_sub.agent = s.agent 
                     and s_sub.label = s.label and s_sub.node = s.node
		    join t_adm_node n on s.node = n.id
                    join t_agent a on s.agent = a.id
                    left join t_agent_version v on v.agent = a.id and v.node = n.id and v.filename = a.name
		   order by n.name, s.host_name, s.directory_path, s.label, s.worker_id ];
    my $q = &dbexec($$self{DBH}, $sql);

    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{ CONTENT });
    
    $dbtable->set_querycols( [('Age', 'pcolumn', 'TIME_UPDATE', 1)],
			     [('Node', 'pcolumn', 'NODE_NAME', 1)],
			     [('Host', 'pcolumn', 'HOST_NAME', 1)],
			     [('Path', 'pcolumn', 'DIRECTORY_PATH', 1)],
			     [('Agent Name', 'pcolumn', 'AGENT_NAME', 1)],
			     [('File and Version Columns', 'pcolumn', 'FILENAME:RELEASE:REVISION:TAG', 0)],
			     [('Agent Label', 'pcolumn', 'AGENT_LABEL', 1)],
			     [('Process', 'pcolumn', 'PID', 1)],
			     [('Worker', 'pcolumn', 'WORKER_ID', 1)],
			     [('Queue State Columns', 'pcolumn', 'Q_PEND:Q_RECV:Q_WORK:Q_BAD:Q_OUT', 1)] 
			     );
    $dbtable->set_tablehead({
	TIME_UPDATE => 'Age',
	NODE_NAME => 'Node',
	AGENT_NAME => 'Agent Name',
	AGENT_LABEL => 'Agent Label',
	PID => 'Process',
	HOST_NAME => 'Host',
	WORKER_ID => 'Worker',
	Q_PEND => 'Pending',
	Q_RECV => 'Received',
	Q_WORK => 'Work',
	Q_COMP => 'Completed',
	Q_BAD => 'Bad',
	Q_OUT => 'Outgoing',
	FILENAME => 'Filename',
	DIRECTORY_PATH => 'Path',
	RELEASE => 'Version Release',
	REVISION => 'Version Revision',
	TAG => 'Version Tag'
	});

    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');

    my $binsub = sub { $_[0] ? "1" : "0" };
    $dbtable->set_dataformats({
	TIME_UPDATE => sub { &age($now - $_[0]) },
	Q_PEND => $binsub,
	Q_RECV => $binsub,
	Q_WORK => $binsub,
	Q_COMP => $binsub,
	Q_BAD  => $binsub,
	Q_OUT  => $binsub
    });

    my $nullsub = sub { $_[0] ? 'alarm' : '' };
    $dbtable->set_cellformats({
	TIME_UPDATE => sub { $now - $_[0] <= (1.5)*3600 ? '' : 'alarm' },
	P_ID => sub { $_[1]->{STATE} ? '' : 'alarm' },
	Q_PEND => $nullsub,
	Q_RECV => $nullsub,
	Q_WORK => $nullsub,
	Q_COMP => $nullsub,
	Q_BAD => $nullsub,
	Q_OUT => $nullsub
    });

    my $nrows = $dbtable->output($q);
    if ($nrows == 0) {
	$self->alert("No process data available.");
    }

    #  Options form
    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = $dbtable->columns_form();
    $optspane->add_tab('Columns', $form);

    print { $$self{OPTIONS} } $optspane->output();
}


1;



######################################################################
package Web25::Activity::Rate;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Rate",
	       LINK_TITLE => "Show recent transfer rates in tabular form" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(span errors tofilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::Rate");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my %stats = ();
  my @spans = qw(h 2h d w m);
  my %spans = (h => [ 'Last hour', $now, 3600 ],
	       '2h' => [ 'Last 2 hours', $now, 3600*2 ],
	       d => [ 'Last day', $now, 86400 ],
	       w => [ 'Last 7 days', int($now/86400)*86400, 7*86400 ],
	       m => [ 'Last 30 days', int($now/86400)*86400, 30*86400 ]);
  my $span = param('span') || $spans[0];
  $span = $spans[0] if ! grep($span eq $_, @spans);
  my $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(sum(h.done_files),0) done_files,
      nvl(sum(h.done_bytes),0) done_bytes,
      nvl(sum(h.fail_files),0) fail_files,
      nvl(sum(h.expire_files),0) expire_files
    from t_history_link_events h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    $stats{$span}{N}{$key} = $row;
  }

  $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(avg(h.param_rate),0) param_rate,
      nvl(avg(h.param_latency),0) param_latency
    from t_history_link_stats h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    next if ! exists $stats{$span};
    $stats{$span}{N}{$key}{PARAM_RATE} = $$row{PARAM_RATE};
    $stats{$span}{N}{$key}{PARAM_LATENCY} = $$row{PARAM_LATENCY};
  }

  $stats{$span}{T}{1} = { DONE_FILES => 0, DONE_BYTES => 0, FAIL_FILES => 0, EXPIRE_FILES => 0 };
  my $errors = param('errors') ? "checked='checked'" : "";
  my $tofilter = param('tofilter') || "";
  my $fromfilter = param('fromfilter') || "";
  my $andor = param('andor') || 'or';
  print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<label for='span'>Time span</label>\n",
    "<select name='span' onchange='submit()'>",
    (map { (" <option", ($span eq $_ ? " selected='selected'" : ""),
	    "  value='$_'>$spans{$_}[0]</option>") } @spans),
    "</select>\n",
    "&nbsp;<input type='checkbox' name='errors' $errors>\n",
    "<label for='errors'>Include links with nothing but errors</label> ",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'><tbody>\n",

    "<tr class='selected'>\n",
    " <th colspan='10'>",
    "Last @{[&format_timespan($spans{$span}[2])]}",
    "</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>To</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From</th>\n",
    " <th rowspan='2'>Files</th>\n",
    " <th rowspan='2'>Total Size</th>\n",
    " <th rowspan='2'>Rate</th>\n",
    " <th rowspan='2'>Errors</th>\n",
    " <th rowspan='2'>Expired</th>\n",
    " <th rowspan='2'>Avg. Est. Rate</th>\n",
    " <th rowspan='2'>Avg. Est. Latency</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "<th>",
    "<select name='andor' onchange='submit()'>",
    " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
    "  value='and'>and</option>",
    " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
    "  value='or'>or</option>",
    "</select>",
    "</th>",
    " <th>",
    textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
		       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "</tr>\n";

  foreach my $kind (qw(N T))
  {
    foreach my $row (sort { $$b{DONE_BYTES} <=> $$a{DONE_BYTES}
			    || $$b{FAIL_FILES} <=> $$a{FAIL_FILES}
			    || $$b{EXPIRE_FILES} <=> $$a{EXPIRE_FILES}
			    || $$a{TO_NODE} cmp $$b{TO_NODE}
			    || $$a{FROM_NODE} cmp $$b{FROM_NODE} }
		     values %{$stats{$span}{$kind}})
    {
      next if ($kind eq 'N'
	       && ($fromfilter || $tofilter)
	       && ($andor eq 'or'
		   ? ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			|| ($tofilter && $$row{TO_NODE} =~ /$tofilter/))
		   : ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			&& ($tofilter && $$row{TO_NODE} =~ /$tofilter/))));
      next if $kind eq 'N' && ! $errors && ! $$row{DONE_FILES};
      next if $kind eq 'N' && ! $$row{DONE_FILES} && ! $$row{FAIL_FILES} && ! $$row{EXPIRE_FILES};
      my $bps = $$row{DONE_BYTES} / $spans{$span}[2];
      print { $$self{CONTENT} }
	"<tr>",
	($$row{FROM_NODE}
	 ? "<td>$$row{TO_NODE}</td><td>&nbsp;</td><td>$$row{FROM_NODE}</td>"
	 : "<td colspan='3'>Total</td>"),
	"<td align='right'>@{[&format_num($$row{DONE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{DONE_BYTES})]}</td>",
	"<td align='right'>", ($bps >= 0 ? &format_size($bps) . '/s' : &format_num(0)), "</td>",
	"<td align='right'>@{[&format_num($$row{FAIL_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_num($$row{EXPIRE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{PARAM_RATE} || 0)]}/s</td>",
	"<td align='right'>@{[&age($$row{PARAM_LATENCY} || 0)]}</td>",
	"</tr>\n";

      if ($kind eq 'N')
      {
	$stats{$span}{T}{1}{DONE_FILES} += $$row{DONE_FILES};
	$stats{$span}{T}{1}{DONE_BYTES} += $$row{DONE_BYTES};
	$stats{$span}{T}{1}{FAIL_FILES} += $$row{FAIL_FILES};
	$stats{$span}{T}{1}{EXPIRE_FILES} += $$row{EXPIRE_FILES};
      }
    }
  }
  print { $$self{CONTENT} } "</tbody></table></p></form>\n";
}

1;

######################################################################
package Web25::Activity::PlotPage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use File::Temp ':mktemp';

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{PLOT_ORDER} = [ qw(l24h l48h l72h l96h l132h l7d l14d l30d l45d l90d l120d
			    l6w l26w l52w ad aw am) ];
  $$self{PLOTS} = { "l24h" => [ "24:hour", "Last 24 Hours" ],
		    "l48h" => [ "48:hour", "Last 48 Hours" ],
	            "l72h" => [ "72:hour", "Last 72 Hours" ],
	            "l96h" => [ "96:hour", "Last 96 Hours" ],
	            "l132h" => [ "132:hour", "Last 132 Hours" ],
	            "l7d" => [ "7:day", "Last 7 Days" ],
	            "l14d" => [ "14:day", "Last 14 Days" ],
	            "l30d" => [ "30:day", "Last 30 Days" ],
	            "l45d" => [ "45:day", "Last 45 Days" ],
	            "l90d" => [ "90:day", "Last 90 Days" ],
	            "l120d" => [ "120:day", "Last 120 Days" ],
	            "l6w" => [ "6:week", "Last 6 Weeks" ],
	            "l26w" => [ "26:week", "Last 26 Weeks" ],
	            "l52w" => [ "52:week", "Last 52 Weeks" ],
	            "ad" => [ "0:day", "Daily Since Start" ],
	            "aw" => [ "0:week", "Weekly Since Start" ],
	            "am" => [ "0:month", "Monthly Since Start" ] };
  $$self{DEFAULT_PLOT} = 'l96h';
  $$self{DEFAULT_GRAPH} = undef;
  $$self{GRAPH_ORDER} = [];
  $$self{GRAPHS} = {};
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(plot graph entity filter upto);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Activity::RatePlots"
        && $args{"page"} ne "Activity::QueuePlots"
        && $args{"page"} ne "Activity::QualityPlots");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $page = param("page");
  my $plot = param("plot");
  my $graph = param("graph");
  my $entity = param("entity");
  my $filter = param("filter") || '';
  my $upto = param("upto") || '';
  $plot = $$self{DEFAULT_PLOT} if (! $plot || ! exists $$self{PLOTS}{$plot});
  $graph = $$self{DEFAULT_GRAPH} if (! $graph || ! exists $$self{GRAPHS}{$graph});
  $entity = 'dest' if (! $entity || ! grep($_ eq $entity, qw(dest src link)));

  print { $$self{CONTENT} } "<p><form method='get' action='@{[$self->myurl()]}'>\n",
    "<label for='graph'>Graph</label>\n",
    "<select name='graph' onchange='submit()'>\n",
    (map { (" <option", ($graph eq $_ ? " selected='selected'" : ""),
	    " value='$_'>$$self{GRAPHS}{$_}</option>\n") }
     @{$$self{GRAPH_ORDER}}),
    "</select>\n",
    "<label for='plot'>Period</label>\n",
    "<select name='plot' onchange='submit()'>\n",
    (map { (" <option", ($plot eq $_ ? " selected='selected'" : ""),
            " value='$_'>$$self{PLOTS}{$_}[1]</option>\n") }
     @{$$self{PLOT_ORDER}}),
    "</select>\n",
    "<label for='entity'>By</label> ",
    "<select name='entity' onchange='submit()'>",
    " <option ", ($entity eq 'dest' ? "selected='selected'" : ''),
    "  value='dest'>Destination</option>",
    " <option ", ($entity eq 'src' ? "selected='selected'" : ''),
    "  value='src'>Source</option>",
    " <option ", ($entity eq 'link' ? "selected='selected'" : ''),
    "  value='link'>Link</option>",
    "</select>\n",
    "<label for='filter'>Filter</label> ",
    textfield(-name=>'filter', -default=>$filter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")), "\n",
    "<label for='upto'>Up to</label> ",
    textfield(-name=>'upto', -default=>$upto, -size=>15,
	      -title=>("Time up to and including which results will be shown. "
		       ."Specify the time in format matching the selected plot type:\n"
		       ."YYYYMMDDZHHMM for hourly plots;\n"
		       ."YYYYMMDD for daily plots;\n"
		       ."YYYYMM for monthly plots;\n"
		       ."YYYYWW for weekly plots.")), "\n",
    "<input type='submit' value='Update'></form></p>\n";

  my ($last, $unit) = $$self{PLOTS}{$plot}[0] =~ /([^:]+)/g;
  my %span = ("hour" => 3600, "day" => 86400, "week" => 7*86400, "month" => 86400);
  my %round = (%span, 'week' => 86400);
  my $now = time();
  my $end = (int($now/$round{$unit})+1)*$round{$unit};
  if ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)Z(\d\d)\d\d$/)
  {
    $end = timegm(0, 0, $4, $3, $2-1, $1-1900) + 3600;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, $3, $2-1, $1-1900) + 86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/ && $unit eq 'week')
  {
    # January 4th is always in (ISO) week one, so find out what
    # day of week that is, then go back to Monday of that week,
    # and advance specified number of weeks plus one.
    my $jan4 = timegm(0, 0, 0, 4, 0, $1-1900);
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($jan4);
    $end = $jan4 + (-$diff{$wday} + 7*$2)*86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, 1, $2, $1-1900);
  }

  my $start = ($last ? $end - $last*$span{$unit} : 0);
  # The new plot package really does set range to time 0.
  # Need to provide a more reasonable range.  PhEDEx started taking data in 2004.
  $start = timegm(0, 0, 0, 1, 1, 2004-1900) if $start == 0;  

  my $conn = $$self{DBID};

  my %args = ('conn' => $conn, 'unit' => $unit, 'span' => $span{$unit}, 'by' => $entity, 'last' => $last,
              'filter' => $filter, 'upto' => $upto, 'starttime' => $start, 'endtime' => $end);


#  use Data::Dumper;  print { $$self{CONTENT} } "<pre>", Dumper({%args}), "</pre>";
  $self->output_plot($graph, %args);

}

1;

######################################################################
package Web25::Activity::RatePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Rate Plots",
	       LINK_TITLE => "Show recent transfer rate as plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'quantity_rates';
  $$self{GRAPH_ORDER} = [ 'quantity_rates', 'quantity', 'quantity_cumulative' ];
  $$self{GRAPHS} = { 'quantity_rates' => "Rate", 
		     'quantity' => "Volume", 
		     'quantity_cumulative' => "Cumulative" };
  bless $self, $class;
  return $self;
}

sub output_plot
{
  my ($self, $graph, %args) = @_;

  my $home = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/"; #"http://cmsdoc.cern.ch/cms/aprom/phedex/cgi-bin/";

  my $to_node = '.*';
  my $from_node = '.*';
  if    ($args{by} eq 'dest' && $args{filter}) { $to_node = $args{filter}; }
  elsif ($args{by} eq 'src' && $args{filter}) { $from_node = $args{filter}; }
  elsif ($args{by} eq 'link' && $args{filter}) { $to_node = $from_node = $args{filter}; }

  my %graphargs = ('graph' => $graph,
		   'from_node' => $from_node,
		   'to_node' => $to_node,
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = "${home}phedex-cgi.sh?". &urlencode(%graphargs);

#  XXX No way to tell if the plot has errors.  Iframe doesn't work so well...
#  print { $$self{CONTENT} } "<p><iframe width='100%' height='100%' frameborder='1' src='$imgsrc' /></iframe></p>";
  print { $$self{CONTENT} } "<p><img src='$imgsrc' /></p>";
}

1;

######################################################################
package Web25::Activity::QueuePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Queue Plots",
	       LINK_TITLE => "Show pending transfer queue plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'destined';
  $$self{GRAPH_ORDER} = [ 'destined', 'resident', 'pending', 'cooloff', 'request', 'idle' ];
  $$self{GRAPHS} = { 'destined' => "Allocated volume",
		     'resident' => "Resident volume",
		     'pending' => "Transferable volume",
		     'cooloff' => 'Transfer cool-off',
		     'request' => "Currently routed",
		     'idle' => "Routing cool-off" };
  bless $self, $class;
  return $self;
}

sub output_plot
{
  my ($self, $graph, %args) = @_;

  my $home = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/"; #"http://cmsdoc.cern.ch/cms/aprom/phedex/cgi-bin/";

  my $node = '.*';
  if    ($args{filter}) { $node = $args{filter}; }

  my %graphargs = ('graph' => $graph,
		   'node' => $node,
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = "${home}phedex-cgi.sh?". &urlencode(%graphargs);

  print { $$self{CONTENT} } "<p><img src='$imgsrc' /></p>";

}

1;

######################################################################
package Web25::Activity::QualityPlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Quality Plots",
	       LINK_TITLE => "Show transfer quality plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{GRAPH_ORDER} = [ 'quality_all', 'quality_try', 'quality_done', 'quality_fail' ];
  $$self{GRAPHS} = { 'quality_all' => "Quality map",
		     'quality_try' => "Attempts",
		     'quality_done' => "Successes",
		     'quality_fail' => "Failures" };
  bless $self, $class;
  return $self;
}

sub output_plot
{
  my ($self, $graph, %args) = @_;

  my $home = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/"; #"http://cmsdoc.cern.ch/cms/aprom/phedex/cgi-bin/";

  my $to_node = '.*';
  my $from_node = '.*';
  if    ($args{by} eq 'dest' && $args{filter}) { $to_node = $args{filter}; }
  elsif ($args{by} eq 'src' && $args{filter}) { $from_node = $args{filter}; }
  elsif ($args{by} eq 'link' && $args{filter}) { $to_node = $from_node = $args{filter}; }

  my %graphargs = ('graph' => $graph,
		   'to_node' => $to_node,
		   'from_node' => $from_node,
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = "${home}phedex-cgi.sh?". &urlencode(%graphargs);

  print { $$self{CONTENT} } "<p><img src='$imgsrc' /></p>";
}

1;

######################################################################
package Web25::Activity::TransferState;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Transfer State",
	       LINK_TITLE => "Show overview of the transfer situation" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $rows = 0;
  my $now = time();
  my $query = &dbexec($$self{DBH}, qq{
    select
      n.name, max(br.time_update),
      sum(br.dest_files), sum(br.dest_bytes),
      sum(br.node_files), sum(br.node_bytes),
      sum(br.xfer_files), sum(br.xfer_bytes)
     from t_dps_block_replica br join t_adm_node n on n.id = br.node
     group by n.name order by n.name});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Last<br>Change</th>\n",
    " <th rowspan='2'>Node</th>\n",
    " <th colspan='2'>Destined</th>\n",
    " <th colspan='2'>On Site</th>\n",
    " <th colspan='2'>In Transfer</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    "</tr>\n";

 my ($tdest_files, $tdest_size,
     $tnode_files, $tnode_size,
     $txfer_files, $txfer_size) = (0) x 6;

  while (my $row = $query->fetchrow_arrayref)
  {
    my ($n, $stamp,
	$dest_files, $dest_size,
	$node_files, $node_size,
	$xfer_files, $xfer_size) = @$row;

    $tdest_files += $dest_files; $tdest_size += $dest_size;
    $tnode_files += $node_files; $tnode_size += $node_size;
    $txfer_files += $xfer_files; $txfer_size += $xfer_size;

    my $node_color = (($dest_files && $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : $xfer_files ? " bgcolor='$pendcolor'" : "");
    my $xfer_color = (($xfer_files) ? " bgcolor='$goodcolor'"
		      : ($xfer_files + $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : "");

    print { $$self{CONTENT} }
      "<tr>\n",
      " <td>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$n</td>\n",
      " <td align='right'>@{[&format_num($dest_files)]}</td>\n",
      " <td align='right'>@{[&format_size($dest_size)]}</td>\n",
      " <td align='right'$node_color>@{[&format_num($node_files)]}</td>\n",
      " <td align='right'$node_color>@{[&format_size($node_size)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_num($xfer_files)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_size($xfer_size)]}</td>\n",
      "</tr>\n";
  }
  my $node_color = (($tdest_files && $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : ($txfer_files) ? " bgcolor='$pendcolor'" : "");
  my $xfer_color = (($txfer_files) ? " bgcolor='$goodcolor'"
		    : ($txfer_files + $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : "");

  print { $$self{CONTENT} }
    "<tr>\n",
    " <th>&nbsp;</th>\n",
    " <th align='left'>Total</th>\n",
    " <th align='right'>@{[&format_num($tdest_files)]}</th>\n",
    " <th align='right'>@{[&format_size($tdest_size)]}</th>\n",
    " <th align='right'$node_color>@{[&format_num($tnode_files)]}</th>\n",
    " <th align='right'$node_color>@{[&format_size($tnode_size)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_num($txfer_files)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_size($txfer_size)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n";
}

1;

######################################################################
package Web25::Activity::TransferDetails;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Transfer Details",
	       LINK_TITLE => "Browse transfer state details" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::TransferDetails");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
    my ($self) = @_;
    my $rows = 0;
    my $now = time();
    my %total = ();
    my $tofilter = param('tofilter') || "";
    my $fromfilter = param('fromfilter') || "";
    my $andor = param('andor') || 'or';
    my $query = &dbexec($$self{DBH}, qq{
    select
      time_update,
      nd.name, ns.name,
      state,
      files, bytes
    from t_status_task xs
      join t_adm_node ns on ns.id = xs.from_node
      join t_adm_node nd on nd.id = xs.to_node
    order by nd.name, ns.name, state});

    print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='8' align='center'>Transfer State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th rowspan='2'>Age</th>\n",
    " <th>To Node</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From Node</th>\n",
    " <th rowspan='2'>State</th>\n",
    " <th rowspan='2'>N Files</th>\n",
    " <th rowspan='2'>Size</th>\n",
    " <th rowspan='2'>Detail</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th>\n",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")
	      ),
     "</th>",
     "<th>",
     "<select name='andor' onchange='submit()'>",
     " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
     "  value='and'>and</option>",
     " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
     "  value='or'>or</option>",
     "</select>",
     "</th>",
     "<th>",
     textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	       -title=>("Regular expression to match against node or link names. "
			."Only those matching the expression will be shown.")),
     "</th>",
     "</tr>\n";
    
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($stamp,
	    $to_node, $from_node,
	    $state,
	    $files, $bytes) = @$row;

	next if (($fromfilter || $tofilter)
		 && ($andor eq 'or'
		     ? ! (($fromfilter && $from_node =~ /$fromfilter/)
			  || ($tofilter && $to_node =~ /$tofilter/))
		     : ! (($fromfilter && $from_node =~ /$fromfilter/)
			  && ($tofilter && $to_node =~ /$tofilter/))));
	$total{$state} ||= { FILES => 0, BYTES => 0 };
	$total{$state}{FILES} += $files;
	$total{$state}{BYTES} += $bytes;
	my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	my $url = $self->myurl("page" => "Activity::FileInfo",
			       "to_node" => $to_node,
			       "from_node" => $from_node,
			       "state" => $state_name
			       );
	print { $$self{CONTENT} }
	"<tr>\n",
	" <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
	" <td>$to_node</td>\n",
	" <td align='right'>&nbsp;</td>\n",
	" <td>$from_node</td>\n",
	" <td align='left'>$state_name</td>\n", # ($from_state_name)
	" <td align='right'>@{[&format_num($files)]}</td>\n",
	" <td align='right'>@{[&format_size($bytes)]}</td>\n",
	" <td align='center'><a href='$url'>(Files)</a></td>\n",
	"</tr>\n";
    }
    
    my $first_total = 1;
    my ($tfiles, $tbytes) = (0, 0);
    foreach my $state (sort keys %total)
    {
	$tfiles += $total{$state}{FILES};
	$tbytes += $total{$state}{BYTES};
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	
	print { $$self{CONTENT} }
        "<tr>\n",
        " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
        " <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>$state_name</td>\n",
	" <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
	" <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
	" <th align='right'>&nbsp;</th>\n",
	"</tr>\n";
	$first_total = 0;
    }

    print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    " <th align='right'>&nbsp;</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n";


  $query = &dbexec($$self{DBH}, qq{
    select xr.time_update, n.name, xr.state, xr.files, xr.bytes
    from t_status_replica xr join t_adm_node n on n.id = xr.node
    order by n.name, state});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='5' align='center'>Replica State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Age</th>",
    " <th rowspan='2'>Node</th>",
    " <th rowspan='2'>State</th>",
    " <th colspan='2'>Files</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>N</th>\n",
    " <th>Size</th>\n",
    "</tr>\n";

  %total = ();
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($stamp, $node, $state, $files, $bytes) = @$row;
    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $node =~ /$fromfilter/)
		   || ($tofilter && $node =~ /$tofilter/)));
    $total{$state} ||= { FILES => 0, BYTES => 0 };
    $total{$state}{FILES} += $files;
    $total{$state}{BYTES} += $bytes;
    my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    my $color = (($state == 1) ? " bgcolor='$goodcolor'" : "");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$node</td>\n",
      " <td$color align='right'>$state_name</td>\n",
      " <td$color align='right'>@{[&format_num($files)]}</td>\n",
      " <td$color align='right'>@{[&format_size($bytes)]}</td>\n",
      "</tr>\n";
  }

  $first_total = 1;
  ($tfiles, $tbytes) = (0, 0);
  foreach my $state (sort keys %total)
  {
    $tfiles += $total{$state}{FILES};
    $tbytes += $total{$state}{BYTES};
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
      " <th align='right'>$state_name</td>\n",
      " <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
      " <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
      "</tr>\n";
    $first_total = 0;
  }
  print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n",
    "</form>\n";
}

1;

######################################################################
package Web25::Activity::FileInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "File Info" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(to_node from_node state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::FileInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $to_node = param('to_node');
  my $from_node = param('from_node');
  my $state = param('state');
  if (! defined $to_node || $to_node eq ''
      || ! defined $from_node || $from_node eq ''
      || ! defined $state || $state eq ''
      )
  {
    print { $$self{CONTENT} }
    $self->alert('Missing Arguments');
    return;
  }

  my $state_join = '';
  my $state_where = '';
  if    ($state eq 'exported')     { 
      $state_join = 'join t_xfer_task_export ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_inxfer )';
  } elsif ($state eq 'transferring') { 
      $state_join = 'join t_xfer_task_inxfer ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_done )';
  } elsif ($state eq 'transferred')  { 
      $state_join = 'join t_xfer_task_done ts on ts.task = xt.id'; }
  elsif ($state eq 'assigned') {
      $state_where = 'and xt.id not in ( select task from t_xfer_task_export )';
  } else {
      $self->alert('Invalid state');
  }
     
  my $sql = qq{
    select f.id, f.logical_name, f.filesize, xt.from_pfn, xt.to_pfn,
	   xt.time_assign, err.cnt num_errors
      from t_xfer_task xt
      $state_join
      join t_xfer_file f on f.id = xt.fileid
      join t_adm_node ns on ns.id = xt.from_node
      join t_adm_node nd on nd.id = xt.to_node
      left join (select xe.fileid, xe.from_node, xe.to_node, count(*) cnt 
                   from t_xfer_error xe
                  group by xe.fileid, xe.from_node, xe.to_node
                 ) err 
           on     err.fileid = xt.fileid 
              and err.from_node= xt.from_node 
              and err.to_node = xt.to_node
    where ns.name = :from_node
      and nd.name = :to_node
      $state_where
      order by xt.time_assign, f.logical_name};

  my $query = &dbexec($$self{DBH}, $sql, 
		      ':from_node' => $from_node,
		      ':to_node' => $to_node);
  print { $$self{CONTENT} }
    "<h1>Files $state from $from_node to $to_node.</h1>\n",
    "<ol align='left'>\n";
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($fileid, $lfn, $size, $from_pfn, $to_pfn, $assigned, $nerrors) = @$row;
    my $errorurl = $self->myurl('page' => 'Activity::ErrorInfo',
				'to_node' => $to_node,
				'from_node' => $from_node,
				'fileid' => $fileid);
    print { $$self{CONTENT} }
    "<li><b>lfn</b>=@{[&escapeHTML($lfn)]}<br />",
    "<b>size</b>=$size<br />",
    ($from_pfn ? "<b>from_pfn</b>=@{[&escapeHTML($from_pfn)]}<br />" : ""),
    ($to_pfn ? "<b>to_pfn</b>=@{[&escapeHTML($to_pfn)]}<br />" : ""),
    ($nerrors ? "<span class='alarm'><b>errors</b>=$nerrors</span> <a href='$errorurl'>(View)</a><br />"  : ""),
    ($assigned ? "<b>time_assign</b>=@{[strftime('%Y-%m-%d %H:%M:%S', gmtime($assigned))]} UTC<br />" : ""),
    "<br /></li>\n";
  }
  print { $$self{CONTENT} } "</ol></p>\n";
}

1;



######################################################################
package Web25::Activity::ErrorInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Error Info" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub output
{
    my ($self) = @_;

    my $to_node = param('to_node');
    my $from_node = param('from_node');
    my $fileid = param('fileid');
    if (! defined $to_node || $to_node eq ''
	|| ! defined $from_node || $from_node eq ''
	|| ! defined $fileid || $fileid eq ''
	)
    {
	print { $$self{CONTENT} }
	$self->alert('Missing Arguments');
	return;
    }


    my $sql = qq{ select time_assign, time_expire, time_export, time_inxfer, time_xfer, time_done,
		         report_code, xfer_code, from_pfn, to_pfn,
		         log_xfer, log_detail, log_validate
		    from t_xfer_error xe
                    join t_adm_node nd on nd.id = xe.to_node
		    join t_adm_node ns on ns.id = xe.from_node
                   where nd.name = :to_node
                     and ns.name = :from_node
                     and xe.fileid = :fileid
		order by time_assign
		  };

    my $max_log_length = 100_000;
    $$self{DBH}->{LongReadLen} = $max_log_length;
    $$self{DBH}->{LongTruncOk} = 1;
    my $q = &dbexec($$self{DBH}, $sql, 
		    ':to_node' => $to_node,
		    ':from_node' => $from_node,
		    ':fileid' => $fileid);

    my $n = 0;
    my $time_labels = { TIME_ASSIGN => "Time Assigned",
			TIME_EXPORT => "Time Exported",
			TIME_INXFER => "Time Pumped",
			TIME_XFER   => "Time Transfer Start",
			TIME_DONE   => "Time Transfer Done",
			TIME_EXPIRE => "Time Transfer Expires" };

    my $log_labels = { LOG_XFER => "Transfer Log",
		       LOG_DETAIL => "Detail Log",
		       LOG_VALIDATE => "Validate Log" };

    my $now = time();
    while (my $error = $q->fetchrow_hashref()) {
	$n++;
	print { $$self{CONTENT} }
	"<div class='nice errorinfo'>",
	"<h1>Error $n</h1>";

	my $time_assign = $$error{TIME_ASSIGN};
	my $tn = 0;
	foreach my $time (qw(TIME_ASSIGN TIME_XFER TIME_EXPORT TIME_DONE TIME_INXFER TIME_EXPIRE)) {
	    my $diff_assign = &age($$error{$time} - $time_assign, 'second');
	    my $diff_now    = &age($$error{$time} - $now, 'second');

	    print { $$self{CONTENT} }
	    "<label>$$time_labels{$time}:</label><span class='labeled halfwidefield'>", 
	    &formatTime($$error{$time}, 'stamp'), 
	    " <span class='diff_assigned'>($diff_assign since assigned)</span> ",
	    " <span class='diff_now'>($diff_now from now)</span>",
	    "</span>",
	    (++$tn % 2 == 0 ? "<br/>" : '');
	}

	print { $$self{CONTENT} }
	"<hr/>",
	"<label>Final Code:</label><span class='labeled halfwidefield'>$$error{REPORT_CODE}</span>",
	"<label>Transfer Report Code:</label><span class='labeled halfwidefield'>$$error{XFER_CODE}</span><br/>",
	"<hr/>",
	"<label>From PFN:</label><span class='labeled'>$$error{FROM_PFN}</span><br/>",
	"<label>To PFN:</label><span class='labeled'>$$error{TO_PFN}</span><br/>",
	"<hr/>";

	foreach my $log (qw(LOG_XFER LOG_DETAIL LOG_VALIDATE)) {
	    if (! defined $$error{$log} ) { $$error{$log} = ''; }
	    my $chars = length $$error{$log};
	    my $trunc = ($chars == $max_log_length ? "<br/><span class='alarm'>Truncated</span>" : '');
	    $$error{$log} =~ s/\s*$/\n/;
	    my $lines = ($$error{$log} =~ tr/\n/\n/);
	   
	    print { $$self{CONTENT} }
	    "<label>$$log_labels{$log}:<br/><span class='note'>($lines lines)<br/>($chars chars)$trunc</span></label>",
	    "<div class='labeled logbox'>$$error{$log}</div><br/>";	    
 	}
	print { $$self{CONTENT} } "</div>";
    }

}

1;


######################################################################
package Web25::Data::ExplorePage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use Sort::Key::Natural;
use Sort::Key::Maker sort_dbs =>
  sub { $$_{LABEL}, ($$_{BASE} || ''), $$_{ID} }, qw(nat nat int);
use Sort::Key::Maker sort_dataset_dbs =>
  sub { $$_{DBS}{LABEL}, ($$_{DBS}{BASE}||''), $$_{DBS}{ID}, $$_{NAME}, $$_{ID} },
  qw(nat nat int nat int);
use Sort::Key::Maker sort_name_id =>
  sub { $$_{NAME}, $$_{ID} }, qw(nat int);
use Sort::Key::Maker sort_name =>
  sub { $$_{NAME} }, qw(nat);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{SAVE_DB}   = [ qw(filter dcolumn rcolumn nvalue scolumn rows) ];
  $$self{SAVE_PAGE} = [ @{$$self{SAVE_DB}}, qw(dbs node dexp bexp) ];
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Data::Replicas"
        && $args{"page"} ne "Data::Subscriptions");

  # If we stay in the same database, keep all, otherwise strip off db-specific
  my @save = $args{"db"} && $args{"db"} ne $$self{DBID}
    ? @{$$self{SAVE_DB}} : @{$$self{SAVE_PAGE}};

  # Return a URL with saved parameters
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub saveform
{
  my ($self, @omit) = @_;
  my $result = "";
  foreach my $option ('view', @{$$self{SAVE_PAGE}})
  {
    next if grep($option eq $_, @omit) || !defined param($option);
    if ($option eq 'nvalue')
    {
      $result .= "<input type='hidden' name='$option' value='$$self{NVALUE}' />";
    }
    elsif (grep($option eq $_, qw(dcolumn rcolumn scolumn)))
    {
      $result .= "<input type='hidden' name='$option' value='$_' />"
	for grep($$self{uc($option)}{$_}, param($option));
    }
    elsif (grep($option eq $_, qw(dbs node dexp bexp)))
    {
      $result .= "<input type='hidden' name='$option'"
		 . " value='@{[&escapeHTML($_)]}' />"
	for param($option);
    }
    else
    {
      $result .= "<input type='hidden' name='$option'"
	  . " value='@{[&escapeHTML(param($option))]}' />";
    }
  }

  return $result;
}

sub dbs_list
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select id, name, dls from t_dps_dbs
    order by name asc});

  my (%bases, @result);
  while (my ($id, $name, $dls) = $q->fetchrow())
  {
    # Build DBS object
    my $dbs = { ID => $id, URL => $name, DLS => $dls,
		BASE => undef, LABEL => $name };
    if ($name =~ /^(http.*)\?instance=(.*)/)
    {
      $$dbs{BASE} = $1;
      $$dbs{LABEL} = $2;
      $$dbs{LABEL} =~ s,/Writer$,,;
    }

    # Add HTML-formatted data
    my $htmllabel = &escapeHTML($$dbs{LABEL});
    my $htmldls = &breakAtSlash(&escapeHTML($$dbs{DLS}));
    my $suplink = "";
    if ($$dbs{BASE})
    {
      $bases{$$dbs{BASE}} = scalar(keys %bases) + 1
	if ! exists $bases{$$dbs{BASE}};
  
      $$dbs{BASE_ID} = $bases{$$dbs{BASE}};
      $suplink = "<sup><small>$$dbs{BASE_ID}</small></sup>";
    }
    $$dbs{HTML_DBS} = "$htmllabel$suplink";
    $$dbs{HTML_DLS} = $htmldls || '&nbsp;';

    # Add to the result
    push(@result, $dbs);
  }

  $q->finish();
  return @result;
}

sub dataset_list
{
  my ($self, @dbses) = @_;
  my $q = &dbprep($$self{DBH}, qq{
    select ds.id, ds.name, ds.is_open, ds.is_transient,
           nvl(count(b.id),0), nvl(sum(b.files),0), nvl(sum(b.bytes),0)
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
    where dbs = :dbsid
    group by ds.id, ds.name, ds.is_open, ds.is_transient
    order by ds.name asc});

  my @result = ();
  foreach my $dbs (@dbses)
  {
    &dbbindexec($q, ":dbsid" => $$dbs{ID});
    while (my ($id, $name, $open, $transient, $nblocks, $nfiles, $nbytes) = $q->fetchrow())
    {
      push(@result, {
	DBS => $dbs,
	ID => $id,
	NAME => $name,
	IS_OPEN => $open,
	IS_TRANSIENT => $transient,
	BLOCKS => $nblocks,
	FILES => $nfiles,
	BYTES => $nbytes });
    }
    $q->finish();
  }

  return @result;
}

sub dataset_replicas
{
  my ($self, @datasets) = @_;
  my $list = join(" or ", map { "ds.id = $$_{ID}" } @datasets);
  my $q = &dbexec($$self{DBH}, qq{
    select ds.id dataset, n.id node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
      join t_dps_block_replica br on br.block = b.id
      join t_adm_node n on n.id = br.node
    where $list
    group by ds.id, n.id});

  my %byid = map { $$_{ID} => $_ } @datasets;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{DATASET}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_list
{
  my ($self, $dataset) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, b.name, b.is_open, b.files, b.bytes
    from t_dps_block b where b.dataset = :dsid},
    ":dsid" => $$dataset{ID});

  my @result = ();
  while (my ($id, $name, $open, $nfiles, $nbytes) = $q->fetchrow())
  {
    push(@result, {
      DATASET => $dataset,
      ID => $id,
      NAME => $name,
      IS_OPEN => $open,
      BLOCKS => 1,
      FILES => $nfiles,
      BYTES => $nbytes });
  }

  $q->finish();
  return @result;
}

sub file_list
{
  my ($self, $block) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select f.id, f.logical_name, f.filesize, n.name
    from t_dps_file f join t_adm_node n on n.id = f.node
    where inblock = :bid},
    ":bid" => $$block{ID});

  my @result = ();
  while (my ($id, $name, $size, $source) = $q->fetchrow())
  {
    push(@result, {
      BLOCK => $block,
      SOURCE => $source,
      ID => $id,
      NAME => $name,
      SIZE => $size });
  }

  $q->finish();
  return @result;
}

sub block_replicas
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, br.node node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
    from t_dps_block b
      join t_dps_block_replica br on br.block = b.id
    where $list
    group by b.id, br.node});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{BLOCK}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_sources
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, f.node, n.name
    from t_dps_block b
      join t_dps_file f on f.inblock = b.id
      join t_adm_node n on n.id = f.node
    where $list
    group by b.id, f.node, n.name});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $node, $name) = $q->fetchrow())
  {
    $byid{$block}{SOURCES}{$node} = $name;
    $byid{$block}{DATASET}{SOURCES}{$node} = $name;
  }

  $q->finish ();
}

sub file_replicas
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, f.id, xr.node
    from t_dps_block b
      join t_xfer_file f on f.inblock = b.id
      join t_xfer_replica xr on xr.fileid = f.id
    where $list});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $file, $node) = $q->fetchrow())
  {
    $byid{$block}{FILE_REPLICAS}{$file}{$node} = 1;
  }

  $q->finish ();
}

sub node_list
{
  my ($self) = @_;

  my @result = ();
  my %nodes = $self->fetch_nodes(with_ids=>1);
  while (my ($name, $id) = each %nodes) {
    push(@result, { ID => $id, NAME => $name });
  }

  return @result;
}

sub apply_options
{
  my ($self) = @_;

  # Determine which dataset options we are showing (in dataset mode)
  $$self{DCOLUMN_NAMES} = [ qw(DBS Name Blocks Files Bytes Open Transient Id) ];
  $$self{DCOLUMN} = { "DBS" => 0, "Name" => 1, "Blocks" => 0, "Files" => 1,
                      "Bytes" => 1, "Open" => 0, "Transient" => 0, "Id" => 0 };
  if (defined param('dcolumn'))
  {
    $$self{DCOLUMN}{$_} = 0 for keys %{$$self{DCOLUMN}};
    $$self{DCOLUMN}{$_} = 1 for grep(exists $$self{DCOLUMN}{$_}, param('dcolumn'));
  }

  # Determine which replica options we are showing (in replica mode)
  $$self{RCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{RCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
		    
  if (defined param('rcolumn'))
  {
    $$self{RCOLUMN}{$_} = 0 for keys %{$$self{RCOLUMN}};
    $$self{RCOLUMN}{$_} = 1 for grep(exists $$self{RCOLUMN}{$_}, param('rcolumn'));
  }

  # Determine which replica options we are showing (in subscription mode)
  $$self{SCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{SCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
  if (defined param('scolumn'))
  {
    $$self{SCOLUMN}{$_} = 0 for keys %{$$self{SCOLUMN}};
    $$self{SCOLUMN}{$_} = 1 for grep(exists $$self{SCOLUMN}{$_}, param('scolumn'));
  }

  # Determine which replica value we show (in replica mode)
  $$self{NVALUES} = [ "Node blocks", "Node files", "Node bytes",
		      "Destined blocks", "Destined files", "Destined bytes",
		      "Missing blocks", "Missing files", "Missing bytes" ];
  $$self{NVALUE} = param('nvalue') || "Node files";
  $$self{NVALUE} = "Node files" if !grep($$self{NVALUE} eq $_, @{$$self{NVALUES}});

  # Determine if we are showing all or interesting rows
  $$self{ROWS} = param('rows') || 'all';
  $$self{ROWS} = 'all' if !grep($$self{ROWS} eq $_, qw(all interesting));
}

sub fetch_data
{
  my ($self) = @_;

  # Obtain the list of DBSes, sort them and pick the ones we show.
  my %shown = map { $_ => 1 } param('dbs');
  $$self{DBS_LIST} = [ sort_dbs $self->dbs_list() ];

  if (keys %shown)
  {
    $$self{DBS_SHOWN} = [ grep(exists $shown{$$_{ID}}, @{$$self{DBS_LIST}}) ];
  }
  else
  {
    $$self{DBS_SHOWN} = $$self{DBS_LIST};
  }

  $$_{IS_SHOWN} = 1 for @{$$self{DBS_SHOWN}};

  # Now get a sorted list of the datasets we are interested in
  my $filter = param('filter');
  $filter = "." if ! defined $filter || $filter eq '';
  my @datasets = grep($$_{NAME} =~ /$filter/,
		      $self->dataset_list(@{$$self{DBS_SHOWN}}));
  if ($$self{DCOLUMN}{"DBS"})
  {
    $$self{DATASET_LIST} = [ sort_dataset_dbs @datasets ];
  }
  else
  {
    $$self{DATASET_LIST} = [ sort_name_id @datasets ];
  }

  # Fetch blocks and block replicas
  my %dexpand = map { $_ => 1 } param('dexp');
  my %bexpand = map { $_ => 1 } param('bexp');
  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    if (! $dexpand{$$ds{ID}})
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ $$ds{ID}, param('dexp') ]) .
        "#d$$ds{ID}'>&#187;</a>";
    }
    else
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ grep($_ != $$ds{ID}, param('dexp')) ]) .
        "#d$$ds{ID}'>&#171;&#171;</a>";
    }

    # Pass if not expanded
    next if ! $dexpand{$$ds{ID}};

    # Expanded, obtain block list
    $$ds{BLOCK_LIST} = [ sort_name $self->block_list($ds) ];
    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      if (! $bexpand{$$block{ID}})
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ $$block{ID}, param('bexp') ]) .
          "#b$$block{ID}'>&#187;</a>";
      }
      else
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ grep($_ != $$block{ID}, param('bexp')) ]) .
          "#b$$block{ID}'>&#171;&#171;</a>";
      }

      # Pass if not expanded
      next if ! $bexpand{$$block{ID}};

      # Expanded, obtain file list
      $$block{FILE_LIST} = [ sort_name $self->file_list($block) ];
    }
  }

  # Fetch per-node replicas for datasets, blocks and files in expanded view
  if (ref ($self) !~ /Datasets/)
  {
    $$self{NODE_LIST} = [ sort_name $self->node_list() ];
    my %nodesel = defined param('node')
      ? (map { $_ => 1 } param('node'))
      : (map { $$_{ID} => 1 } grep($$_{NAME} =~ /CERN_MSS/, @{$$self{NODE_LIST}}));
    $$self{NODE_SHOWN} = [ grep($nodesel{$$_{ID}}, @{$$self{NODE_LIST}}) ];
    $$_{IS_SHOWN} = 1 for @{$$self{NODE_SHOWN}};
      
    $self->dataset_replicas(@{$$self{DATASET_LIST}})
      if @{$$self{DATASET_LIST}};

    my @allblocks = map { @{$$_{BLOCK_LIST}} } grep($$_{BLOCK_LIST}, @{$$self{DATASET_LIST}});

    $self->block_replicas(@allblocks)
      if @allblocks;

    $self->block_sources(@allblocks)
      if (@allblocks
	  && ((ref ($self) =~ /::Replicas/ && $$self{RCOLUMN}{"Source"})
	      || (ref ($self) =~ /::Subs/ && $$self{SCOLUMN}{"Source"})));

    my @expblock = grep($bexpand{$$_{ID}}, @allblocks);
    $self->file_replicas(@expblock) if @expblock;
  }
}


sub dbs_form
{
    my ($self) = @_;

    my $form = "";
    $form .= "<div id='dbschoice'>\n";
    $form .= "  <div id='dbsmenu' style='width:100%;font-size:0.9em'>\n";
    $form .= "    <table>\n";
    $form .= "     <thead>\n";
    $form .= "      <tr>\n";
    $form .= "       <th width='4%' align='center'>Show</th>\n";
    $form .= "       <th width='20%' align='left'>DBS</th>\n";
    $form .= "       <th width='100%' align='left'>DLS contact</th>\n";
    $form .= "       <th width='4%' align='right'>Id</th>\n";
    $form .= "      </tr>\n";
    $form .= "     </thead>\n";
    $form .= "     <tbody>\n";

    my $n = 0;
    foreach my $dbs (@{$$self{DBS_LIST}})
    {
	my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
	$form .= "      <tr$rowcolor>\n";
	$form .= "       <td align='center'><input type='checkbox' name='dbs' value='$$dbs{ID}'";
	$form .= ($$dbs{IS_SHOWN} ? " checked='checked'" : '') . " /></td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DBS}</td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DLS}</td>\n";
	$form .= "       <td align='right' style='color:#666'>$$dbs{ID}</td>\n";
	$form .= "      </tr>\n";
    }
    $form .= "     </tbody>\n";
    $form .= "    </table>\n";
    $form .= "  </div>\n";
    $form .= "</div>\n";
    return $form;
}

sub node_form
{
  my ($self) = @_;

  my $form = "";

  $form .= "<div id='nodechoice'>\n";
  $form .= "<input type='submit' value='Select all' onclick=\"select_all('nodechoice', 'node', '1')\"/>\n",
  $form .= "<input type='submit' value='Select none' onclick=\"select_all('nodechoice', 'node', '0')\"/>\n",

  my (@all, @columns) = @{$$self{NODE_LIST}};
  my $percolumn = int(scalar(@all)/4 + 0.5);
  $percolumn = 4 if ! $percolumn;
  push (@columns, [ splice(@all, 0, $percolumn) ]) while @all;

  $form .= "  <div id='nodemenu' style='font-size:0.9em'>\n";
  $form .= "    <table style='white-space:  nowrap;'>\n";
  $form .= "     <tbody>\n";
  $form .= "      <tr>\n";

  foreach my $col (@columns)
  {
      $form .= "       <td>\n";
      $form .= join("\n", (map { "        <input type='checkbox' name='node' value='$$_{ID}'" .
				     ($$_{IS_SHOWN} ? " checked='checked'" : "") .
				     " />&nbsp;" . &escapeHTML($$_{NAME}) . "<br />" }
			   @$col));
      $form .= "       </td>\n";
  }
  
  $form .= "     </tr>\n";
  $form .= "    </tbody>\n";
  $form .= "   </table>\n";
  $form .= " </div>\n";
  $form .= "</div>\n";
  return $form;
}


sub columns_form
{
    my ($self, @display_columns) = @_;

    my $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Display Columns</i></p>\n";
    foreach my $pair (@display_columns)
    {
	my ($dataset, $column) = @{$pair};

	$form .= "   <input type='checkbox' name='$dataset' value='$column'" .
	    ($$self{uc($dataset)}{$column} ? " checked='checked'" : "") .
	    " />&nbsp;$column<br/>\n";
    }
    
    return $form;
}

sub output_filter
{
  my ($self) = @_;
  my $filter = param('filter');
  my $filterform = "" .
    "<form style='display:inline' method='get' action='@{[$self->myurl()]}'>" .
    $self->saveform('filter') .
    textfield(-name=>'filter', -default=>$filter, -size=>15,
	      -title=>("Regular expression to match against the name column. "
		       ."Only those matching the expression will be shown.")) .
    " <input type='submit' value='Filter' />" .
    "</form>";

  return ($filter, $filterform);
}

sub output
{
  my ($self) = @_;

  # Apply form options and fetch the data we show on this form
  $self->apply_options();
  $self->fetch_data();
  $self->output_page();
  $self->output_options_form();
}

1;


######################################################################
package Web25::Data::Replicas;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Replicas",
	       LINK_TITLE => "Explore replicas" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  my ($filter, $filterform) = $self->output_filter();

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $node_th = $$self{NVALUE};
  $node_th =~ s/Node\s+//;
  $node_th =~ s/ +/\&nbsp;/g;
  $node_th = ucfirst($node_th);

  print { $$self{CONTENT} }
    "<table id='dataset_tbl'>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{RCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{RCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{DCOLUMN}{"Blocks"}    ? "   <th width='4%' align='center'>Blocks</th>\n" : ()),
    ($$self{RCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{RCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{RCOLUMN}{"Source"}    ? "   <th width='6%' align='left'>Source</th>\n" : ()),
    ($$self{DCOLUMN}{"Open"}      ? "   <th width='4%' align='center'>Open</th>\n" : ()),
    ($$self{DCOLUMN}{"Transient"} ? "   <th width='4%' align='center'>Transient</th>\n" : ()),
    (map { "   <th width='4%' align='center'>@{[&escapeHTML($$_{NAME})]} $node_th</th>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody>\n";

  my $n = 0;
  my %total = (BLOCKS => 0, FILES => 0, BYTES => 0);
  $total{$$_{ID}} = { VALUE => 0, ATTR => "" } for @{$$self{NODE_SHOWN}};
  my ($quantity, $formatter) = ("", sub { return -1, 0 }, sub { return @_ });
  if ($$self{NVALUE} eq "Node blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = (($$obj{NODE_BLOCKS} || $$obj{DEST_BLOCKS}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = ($$obj{DEST_BLOCKS} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BLOCKS} || 0) - ($$obj{NODE_BLOCKS} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BLOCKS} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = (($$obj{NODE_FILES} || $$obj{DEST_FILES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = ($$obj{DEST_FILES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_FILES} || 0) - ($$obj{NODE_FILES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = (($$obj{NODE_BYTES} || $$obj{DEST_BYTES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = ($$obj{DEST_BYTES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BYTES} || 0) - ($$obj{NODE_BYTES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }

  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my %values = ();
    my $interesting = 0;
    foreach my $node (@{$$self{NODE_SHOWN}})
    {
      my ($value, $refvalue, $intr) = &$quantity($ds, $$ds{REPLICAS}{$$node{ID}});
      my $attr = $value == $refvalue ? "" : " style='color:#d00'";
      $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
      $interesting ||= $intr;
    }

    next if $$self{ROWS} eq 'interesting' && ! $interesting;

    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    my @sources = ($$ds{SOURCES} ? values %{$$ds{SOURCES}}
		   : "<span style='color:#666'>(Expand)</span>");
    my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		  ? "<span style='color:#666'>(Multiple)</span>"
		  : $sources[0]);
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{RCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>@{[&format_num($$ds{BLOCKS})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
      ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$ds{IS_OPEN}</td>\n" : ()),
      ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>$$ds{IS_TRANSIENT}</td>\n" : ()),
    (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
      "  </tr>\n";

    $total{BYTES} += $$ds{BYTES};
    $total{BLOCKS} += $$ds{BLOCKS};
    $total{FILES} += $$ds{FILES};
    for (@{$$self{NODE_SHOWN}})
    {
      $total{$$_{ID}}{VALUE} += $values{$$_{ID}}{VALUE};
      $total{$$_{ID}}{ATTR} ||= $values{$$_{ID}}{ATTR};
    }

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      %values = ();
      $interesting = 0;
      foreach my $node (@{$$self{NODE_SHOWN}})
      {
        my ($value, $refvalue, $intr) = &$quantity($block, $$block{REPLICAS}{$$node{ID}});
        my $attr = $value == $refvalue ? "" : " style='color:#d00'";
        $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
        $interesting ||= $intr;
      }

      next if $$self{ROWS} eq 'interesting' && ! $interesting;

      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      my @sources = ($$block{SOURCES} ? values %{$$block{SOURCES}}
		     : "<span style='color:#666'>(Expand)</span>");
      my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		    ? "<span style='color:#666'>(Multiple)</span>"
		    : &escapeHTML($sources[0]));
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>&nbsp;</td>\n" : ()),
        ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
        ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$block{IS_OPEN}</td>\n" : ()),
        ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
        (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
        "  </tr>\n";

      foreach my $file (@{$$block{FILE_LIST}})
      {
        my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
        my $span = 1; $span++ if $$self{RCOLUMN}{"Files"};
        my $have = "<span style='color:#666'>y</span>";
        my $havenot = "<span style='color:#d00'>N</span>";
        my $goal = ($$self{NVALUE} =~ /Missing/ ? $havenot : $have);
	my %nodeattr = map { $$_{ID} => ($$block{FILE_REPLICAS}{$$file{ID}}{$$_{ID}}
			                 ? $have : $havenot) }
		      @{$$self{NODE_SHOWN}};
	$interesting = scalar(grep($_ eq $goal, values %nodeattr));
	next if $$self{ROWS} eq 'interesting' && ! $interesting;

        print { $$self{CONTENT} }
          "  <tr$rowcolor>\n",
          "   <td>&nbsp;</td>\n",
          ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
          ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:3em' colspan='$span'>@{[&escapeHTML($$file{NAME})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$file{SIZE})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>@{[&escapeHTML($$file{SOURCE})]}</td>\n" : ()),
          ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
          (map { "   <td align='right'>$nodeattr{$$_{ID}}</td>\n" } @{$$self{NODE_SHOWN}}),
          "  </tr>\n";
      }
    }
  }

  print { $$self{CONTENT} }
  " </tbody>\n",
  " <tfoot>\n",
  "   <tr bgcolor='#f8f8f8'>\n",
  "    <th>&nbsp;</th>\n",
  ($$self{RCOLUMN}{"DBS"} && $$self{RCOLUMN}{"Name"}
   ? "   <th colspan='2' align='left'>Total</th>\n"
   : $$self{RCOLUMN}{"DBS"} || $$self{RCOLUMN}{"Name"}
   ? "   <th align='left'>Total</th>\n"
   : ()),
       ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>@{[&format_num($total{BLOCKS})]}</td>\n" : ()),
       ($$self{RCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Source"}    ? "   <th align='right'>&nbsp;</th>\n" : ()),
       ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
       ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
       (map { "   <td align='right'$total{$$_{ID}}{ATTR}>@{[&$formatter($total{$$_{ID}}{VALUE})]}</td>\n" } @{$$self{NODE_SHOWN}}),
       "   </tr>\n",
       " </tfoot>\n",
       "</table>\n";
  
  # Produce "footnotes" for the DBS URL base strings
  my %bases = map { $$_{BASE_ID} => $$_{BASE} } grep($$_{BASE}, @{$$self{DBS_LIST}});
  if (keys %bases)
  {
      print { $$self{CONTENT} }
      "<div style='font-size: 0.9em;margin-top:1em'>\n<hr>\n",
      (map { ("<sup><small>$_</small></sup>",
	      "&nbsp;", &breakAtSlash(&escapeHTML($bases{$_})), "<br />\n") }
       sort keys %bases),
      "</div>";
  }
}

# Produce content to the options panel
sub output_options_form
{
    my ($self) = @_;

    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = "";

    # Save everything except what this form controls
    $form = $self->saveform(qw(dcolumn rcolumn node nvalue dbs rows));
    $optspane->add_hidden($form);

   # Columns Tab
    my @display_columns;
    push @display_columns, 
    [('rcolumn', 'DBS')], 
    [('rcolumn', 'Name')], 
    [('dcolumn', 'Blocks')],
    [('rcolumn', 'Files')], 
    [('rcolumn', 'Bytes')], 
    [('rcolumn', 'Source')], 
    [('dcolumn', 'Open')], 
    [('dcolumn', 'Transient')];

    $form = $self->columns_form(@display_columns);
    $optspane->add_tab('Columns', $form);

    # DBS Source tab
    $form = $self->dbs_form();
    $optspane->add_tab('DBS Sources', $form);

    # Node Selection tab
    $form = $self->node_form();
    $optspane->add_tab('Nodes Shown', $form);
    
    # Node Values tab
    $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Node Values</i></p>\n";
    foreach my $opt (@{$$self{NVALUES}})
    {
	$form .= "  <input type='radio' name='nvalue' value='$opt'" .
	    ($$self{NVALUE} eq $opt ? " checked='checked'" : "") .
	    " />&nbsp;$opt<br/>\n";
    }

    $form .= "   <p style='margin-top:1ex'><i>Filter rows</i></p>\n" .
	"   <input type='radio' name='rows' value='all'" .
	($$self{ROWS} eq 'all' ? " checked='checked'" : "") .
	" />&nbsp;Show all rows<br/>\n" .
	"   <input type='radio' name='rows' value='interesting'" .
	($$self{ROWS} eq 'interesting' ? " checked='checked'" : "") .
	" />&nbsp;Show interesting rows<br/>\n";

    $optspane->add_tab('Node Values', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;

######################################################################
package Web25::Data::Subscriptions;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Subscriptions",
	       LINK_TITLE => "Explore subscriptions" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  my $adminok = $self->alert_auth(need => 'siteadmin', power => 'update suspensions and priorities');

  if (param('subsaction')) {
      $self->update_subscriptions();
  }

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $q =$self->data_subscriptions();
  
  my @cols = qw(SELECT ITEM_LEVEL ITEM_NAME NODE_NAME PRIORITY 
		IS_MOVE IS_TRANSIENT TIME_SUSPEND_UNTIL);
  my $th =
  { SELECT => 'Select',
    ITEM_LEVEL => 'Data Level',
    ITEM_NAME => 'Data Item',
    NODE_NAME => 'Node',
    PRIORITY => 'Priority',
    IS_MOVE => 'Replica/Move',
    IS_TRANSIENT => 'Open/Closed',
    TIME_SUSPEND_UNTIL => 'Active/Suspended' };
  
  # Special data fromats
  my $now = time();
  my $df = 
  { 
      PRIORITY => sub { if ($_[0] == 0) { return 'High'; }
			if ($_[0] == 1) { return 'Normal'; }
			if ($_[0] == 2) { return 'Low'; } },
      IS_MOVE => sub { return $_[0] eq 'y' ? 'Move' : 'Replica'; },
      TIME_SUSPEND_UNTIL => sub { 
	  my $susp_time = $_[0];
	  if (!defined $susp_time || $susp_time <= $now) { return 'Active'; }
	  elsif ($susp_time == 9_999_999_999)            { return 'Suspended Forever'; }
	  else { return 'Suspended Until  '.&formatTime($susp_time, 'stamp') }
      },
      IS_TRANSIENT => sub { return $_[0] eq 'y' ? 'Closed' : 'Open'; }
  };

  # Special cell formats
  my $cf = 
  { 
      TIME_SUSPEND_UNTIL => sub { return defined $_[0] && $_[0] >= $now ? 'alarm' : ''; }
  };

  # Pseudo columns
  my %pseudo =
      (
       'SELECT'  => sub { "<input type='checkbox' name='s_id' value='$_[1]->{ITEM_LEVEL}:$_[1]->{ITEM_ID}:$_[1]->{NODE_ID}'/>" }
       );
  
  if (!$adminok) {
      delete $pseudo{SELECT};
      delete $df->{SELECT};
      delete $th->{SELECT};
      @cols = grep !/SELECT/, @cols;
  }

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead($th);
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats($df);
  $dbtable->set_cellformats($cf);
  $dbtable->add_pseudocolumn($_, $pseudo{$_}) foreach (keys %pseudo);

  if ($adminok) {
      print { $$self{CONTENT} }
      "<p><label>Selections:</label>\n",
      "<input type='submit' value='Select all' onclick=\"select_all('subsform', 's_id', '1')\"/>\n",
      "<input type='submit' value='Select none' onclick=\"select_all('subsform', 's_id', '0')\"/>\n",
      "</p>\n";

      my $target = $self->myurl();
      print { $$self{CONTENT} } "<form id='subsform' method='post' action='$target'>",
      $self->saveform(),
      "<p>\n",
      "<label>Actions:</label>\n",
      "<select class='labeled' name='subsaction'>\n",
      "<option value='suspend'>Suspend subscriptions</option>\n",
      "<option value='unsuspend'>Unsuspend subscriptions</option>\n",
      "<option value='priorityhi'>Make high priority</option>\n",
      "<option value='prioritymd'>Make normal priority</option>\n",
      "<option value='prioritylo'>Make low priority</option>\n",
      "</select>\n",
      "<input type='submit' value='Update'/>\n",
      "</p>\n";

  }

  my $nrows = $dbtable->output($q);

  if ($adminok) {
      print { $$self{CONTENT} } "</form>\n";
  }

  if ($nrows == 0) {
      $self->alert("No data exists for your selected nodes.");
  }
}

sub update_subscriptions
{
    my ($self) = @_;
    my %auth_nodes = $self->fetch_nodes(with_ids => 1, user_auth => 1);
    my %all_nodes = reverse $self->fetch_nodes(with_ids => 1); # just a hash of id => name

    my $upd_suspend = qq[ update t_dps_subscription set time_suspend_until = :val
			  where _ITEM_ = :id and destination = :dest ];
    my $upd_priority = qq[ update t_dps_subscription set priority = :val
			   where _ITEM_ = :id and destination = :dest];

    my $action_list = 
    {
	suspend => { desc => ' suspended',
		     sql  => $upd_suspend,
		     val  => 9_999_999_999 },
    	unsuspend => { desc => ' unsuspended',
		       sql  => $upd_suspend,
		       val  => undef },
	priorityhi => { desc => ' set to high priority',
			sql => $upd_priority,
			val => 0 },
	prioritymd => { desc => ' set to medium priority',
			sql => $upd_priority,
			val => 1 },
	prioritylo => { desc => ' set to low priority',
			sql => $upd_priority,
			val => 2 }
    };

    # Execute the update
    my $action = $action_list->{param('subsaction')};

    my $n_changed = 0;
    my %warn_hash;  # to keep unique warnings

    foreach (param('s_id')) {
	my ($level, $id, $destination) = split /:/;
	if (grep $destination == $_, values %auth_nodes) { # Check permission
	    my $sql = $$action{sql};
	    $sql =~ s/_ITEM_/$level/;

	    my @rv = &dbexec($$self{DBH}, $sql, 
			     ':val' => $$action{val},
			     ':id'  => $id,
			     ':dest' => $destination);
	    $n_changed += $rv[1];
	} else {
	    my $warn = "<p class='alarm'>Sorry, you don't have permission to update ".
		"$all_nodes{$destination} subscriptions!</p>";
	    $warn_hash{$warn} = 1;
	}
    }

    $$self{DBH}->commit();

    # Print scoldings
    print { $$self{CONTENT} } keys %warn_hash;

    # Report the changes
    if ($n_changed) {
	print { $$self{CONTENT} } "<p class='note'>$n_changed data items $action->{desc}!</p>";
    } else {
	print { $$self{CONTENT} } "<p class='alarm'>Nothing was changed!<p>";
    }
}

# Produce content to the options panel
sub output_options_form
{
    my ($self) = @_;

    my $optspane = new Web25::OptsPane;

    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = "";

    # Save everything except what this form controls
    $form = $self->saveform(qw(node));
    $optspane->add_hidden($form);

    # Node Selection tab
    $form = $self->node_form();
    $optspane->add_tab('Nodes Shown', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

sub data_subscriptions
{
  my ($self) = @_;
  my @node_ids = map { $$_{IS_SHOWN} ? $$_{ID} : '' } @{$$self{NODE_LIST}};
  @node_ids = grep /\d+/, @node_ids;
  my ($where_list) = join(' or ', map { "n.id=$_"} @node_ids );

  my $q = &dbexec($$self{DBH}, qq{
    select NVL2(s.block, 'BLOCK', 'DATASET') item_level,
           NVL2(s.block, s.block, s.dataset) item_id,
           NVL2(s.block, b.name, ds.name) item_name,
           n.id node_id,
           n.name node_name,
           s.priority,
           s.is_move,
           s.is_transient,
           s.time_suspend_until
      from t_dps_subscription s
      join t_adm_node n on n.id = s.destination
      left join t_dps_dataset ds on ds.id = s.dataset
      left join t_dps_block b on b.id = s.block
     where $where_list
      order by n.name, ds.id, b.id
  });

  return $q;
}


1;

######################################################################
package Web25::Data::Delete;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 3, TITLE => "Deletions",
	       LINK_TITLE => "Delete datasets or blocks from PhEDEx database",
               SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $adminok = $self->alert_auth(need => 'siteadmin', power => 'delete datasets and blocks');

  print { $$self{CONTENT} }
  "<h1>Deletion Queue</h1>",
  "<p>This table contains the data items which are queued for deletion.</p>";
  

  my $sql = qq{ select ds.name dataset, b.name block, n.name node, del.time_request, del.time_complete
                  from t_dps_block_delete del
	 	  join t_dps_block b on b.id = del.block
		  join t_dps_dataset ds on ds.id = del.dataset
		  join t_adm_node n on n.id = del.node
 	      order by del.time_complete desc, del.time_request desc };

  my $q = &dbexec($$self{DBH}, $sql);

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->output($q);

  my $del_url = $self->myurl('page' => 'Data::DeleteConfirm');

  my @nodes = $self->fetch_nodes();

  print { $$self{CONTENT} }
  "<h1>Delete Data</h1>",
  "<p>Enter the datasets you would like to delete.  Deletions are ",
  "added to the queue and are actually deleted when the deletion agents ",
  "get around to it.</p>",

  "<form class='nice' method='post' target='$del_url'>",

  "<label>Node</label>",
  popup_menu(-name=>'node', -values=>[@nodes], -class=>'labeled'),
  "<br/>",

  "<label>Data Items:<br/><br/>",
  "<span class='note'>/Primary/Tier/Dataset<br/>or<br/>",
  "/Primary/Dataset#Block<br/>(Use * as wildcard)</span><br/>",
  &help("More Help", "Data Item List", 
	"A whitespace separated list of the datasets or blocks you are ",
	"deleting.  Glob-style wildcards may be used, but the data ",
	"tier separators are required.  E.g. to subscribe to all ",
	"datasets you would have to write '/*/*/*', not '*'."), 
  "</label>\n",
  textarea(-name=>'data', -value=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), 
  "<br/>",

  "<label>&nbsp;</label>", 
  submit(-class=>'labeled', -value=>'Go To Confirmation'),
  "</form>";

}

1;



######################################################################
package Web25::Reports::DailyReports;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Daily Reports",
	       LINK_TITLE => "Browse all daily reports" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my @reports = sort <$reportdir/$dbname-*.txt*>;
  print { $$self{CONTENT} }
    "<p><table class='striped'><tbody>\n",
    "<tr class='selected'><th colspan='32'>Available reports</th></tr>\n",
    "<tr class='selected'>\n",
    " <th>Month</td>\n",
    (map { sprintf " <th>%02d</th>\n", $_ } 1 .. 31),
    "</tr>\n";
  my $prev = "";
  my $prevday = 0;
  foreach my $file (@reports)
  {
    my $basename = $file; $basename =~ s|.*/||;
    my $cleanname = $basename; $cleanname =~ s|^$dbname-||;
    my $url = $self->myurl("page" => "Reports::DailyReport", "reportfile" => $cleanname);
    my ($year, $month, $day) = ($cleanname =~ /(\d\d\d\d)(\d\d)(\d\d)\..*/);
    if ("$year-$month" ne $prev)
    {
      if ($prev)
      {
        while (++$prevday <= 31) { print { $$self{CONTENT} } "<td></td>\n"; }
        print { $$self{CONTENT} } "</tr>\n";
      }

      print { $$self{CONTENT} } "<tr>\n <td>$year&#8209;$month</td>\n";
      $prev = "$year-$month";
      $prevday = 0;
    }
    while (++$prevday < $day) { print { $$self{CONTENT} } " <td></td>\n"; }
    print { $$self{CONTENT} } "<td align='center'><a href='$url'>R</a></td>\n";
    $prevday = $day;
  }

  print { $$self{CONTENT} } "</tbody></table></p>\n";
}

1;

######################################################################
package Web25::Reports::DailyReport;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Daily Report",
	       LINK_TITLE => "Show today's daily report" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(reportfile);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Reports::DailyReport");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my $report = param('reportfile') || (strftime('%Y%m%d', gmtime()) . ".txt");
  print { $$self{CONTENT} } "<pre class='wide' align='left'>\n";
  if ($report && $report =~ m|^[-A-Za-z0-9.]+$|)
  {
    my $reportfile = (<$reportdir/$dbname-$report>)[0];
    if (-f $reportfile)
    {
      local $/ = undef;
      open (REPORT, $reportfile =~ /.gz$/ ? "gzip -dc < $reportfile |" : "< $reportfile");
      my $report = <REPORT>;
      close (REPORT);
      $report =~ s/&/&amp;/gso;
      $report =~ s/</&lt;/gso;
      $report =~ s/>/&gt;/gso;
      $report =~ s/\"/&quot;/gso;
      print { $$self{CONTENT} } $report;
    }
  }
  print { $$self{CONTENT} } "</pre>\n";
}

1;

######################################################################
package Web25::Reports::Size;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "File Sizes",
	       LINK_TITLE => "Show file size distribution and other statistics" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my $overview = $$self{DBH}->selectrow_arrayref(qq{
    select time_update, n_files, sz_total, sz_min, sz_max, sz_mean, sz_median
    from t_status_file_size_overview});
  my $histo = $$self{DBH}->selectall_arrayref(qq{
    select time_update, bin_low, bin_width, n_total, sz_total
    from t_status_file_size_histogram order by bin_low asc});

  print { $$self{CONTENT} }
    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='6'>File size statistics ", &age($now - $overview->[0]), " ago</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    " <th>Min Size</th>\n",
    " <th>Max Size</th>\n",
    " <th>Mean Size</th>\n",
    " <th>Median Size</th>\n",
    "</tr>\n",
    "<tr>\n",
    " <td align='right'>@{[&format_num($overview->[1])]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[2], 0, 2, 'T')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[3], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[4], 0, 2, 'G')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[5], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[6], 0, 2, 'M')]}</td>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>",

    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='4'>File size breakdown</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th colspan='2'>Bin</th>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    "</tr>\n";

  foreach my $row (@$histo)
  {
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td align='right'>@{[&format_size($row->[1] * $row->[2],1,2,'G')]} ..</td>\n",
      " <td align='right'>@{[&format_size(($row->[1]+1) * $row->[2],1,2,'G')]}</td>\n",
      " <td align='right'>@{[&format_num($row->[3])]}</td>\n",
      " <td align='right'>@{[&format_size($row->[4],1,2,'T')]}</td>\n",
      "</tr>\n";
  }

  print { $$self{CONTENT} } "</tbody>\n</table>\n</p>\n";
}

1;

######################################################################
package Web25::Administration::SignUp;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Sign Up",
	       LINK_TITLE => "Sign up to be a transfer administrator",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  # Check if user has certificate loaded
  my $adminok = $self->alert_auth(need => 'gridcert', power => 'sign up to be a transfer administrator');
  unless ($adminok) { return; }

  # Display the apporpriate part of this page
  if (!param('signup')) {
      $self->signup_form();
  } else {
      $self->send_request();
  }
}


sub signup_form
{
    my ($self) = @_;
    
    my $name = $$self{USER_NAME};
    my $client_dn = $$self{SSL_IDENTITY};
    my $email = $self->create_default_email();
    
    my $actionurl = $self->myurl();
    print { $$self{CONTENT} } "<form class='nice' method='post' action='$actionurl'>";
    print { $$self{CONTENT} } "<h1>Admin Registration</h1>",
    "<p>Fill in the requested information and choose the sites ",
    "you would like to be authorized to administer.  Your request will be ",
    "emailed to existing site administrators and PhEDEx global admins for ",
    "approval.</p>";
    
    print { $$self{CONTENT} } 
    "<fieldset><legend>Certificate Parameters</legend>",
    "<label>Name:</label><span class='labeled'>$name</span><br/>",
    "<label>Distinguished Name:</label><span class='labeled'>$client_dn</span><br/>",
    "<label>Certificate email:</label><span class='labeled'>$email</span><br/>",
    "</fieldset>";
    
    print { $$self{CONTENT} } 
    "<fieldset><legend>Registration Information</legend>",
    "<label>Preferred email:</label>", textfield(-class=>'labeled',-name=>'pref_email', -value=>$email),"<br/>",
    "</fieldset>";
    
    print { $$self{CONTENT} } "<h2>Sites:</h2>";
    my $sql = qq[ select s.id, s.name, s.role_name, n.name
		  from t_adm_site s join t_adm_site_node sn on s.id = sn.site
		  join t_adm_node n on n.id = sn.node ];
    
    my $q = &dbexec($$self{DBH}, $sql);
    my $sites = {};
    while (my ($id, $site, $role, $node) = $q->fetchrow_array) {
	if (!exists $sites->{$site}) {
	    $sites->{$site} = {site => $site, id => $id, role => $role, nodes => $node };
	} else {
	    $sites->{$site}->{nodes} = join ', ', $sites->{$site}->{nodes}, $node;
	}
    }
    my $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tablecols([qw(select site role nodes)]);
    $table->set_tablehead({
	select => 'Select',
	site => 'Site Name',
	role => 'Database Role',
	nodes => 'Nodes'
	});
    $table->set_tableclass('data');
    $table->add_pseudocolumn('select', sub { &striplabels(checkbox(-name=>'sites', 
								   -value=>"$_[1]->{site}",
								   -label=>'')) });
    $table->start();
    $table->head();
    foreach(sort keys %{$sites}) {
	$table->row($sites->{$_});
    }
    $table->finish();
    
    print { $$self{CONTENT} } 
    "<br/><label>(Optional) Comment:</label>", 
    textarea(-name=>'comment',
	     -class=>'labeled',
	     -rows=>5,
	     -cols=>50),
    "<br/><br/>",
    submit(-name=>'signup', value=>'Submit'),
    "</form>";
}


sub send_request
{
    my ($self) = @_;

    # Get User Info
    my $name = $$self{USER_NAME};
    my $client_dn = $$self{SSL_IDENTITY};
    my $email = $self->create_default_email();
    my $pref_email = param('pref_email');
    my @sites = param('sites');
    my $comment = param('comment');

    # Check required params
    unless (@sites) {
	$self->alert("You need to choose a site from the list.  Please go back and choose a site.");
	return;
    }

    # Get a hash of sites => nodes
    my %site_nodes = $self->fetch_sites();

    # Get the list of Global admins
    my %global_admins = $self->fetch_users(global_admins=>1);
    if (!%global_admins) {
	alert("Sorry, the request cannot be created.",
	      "The database does not contain any global admins.",
	      "Please contact the PhEDEx developers  about this!"); 
	return;
    }
    my @global_admin_mails;
    push @global_admin_mails, $$_{EMAIL} foreach values %global_admins;
    
    # Get the list of existing site admins
    my %site_admins = $self->fetch_users(admin_of => \@sites);
    my @site_admin_mails;
    push @site_admin_mails, $$_{EMAIL} foreach values %site_admins;

    my $message =<<ENDEMAIL;
Greetings PhEDEx Global Admin,

There has been a request from $name to become a site administrator.  Here are the details of the request:

Name:               '$name'
Certificate DN:     '$client_dn'
Certificate Email:  '$email'
Preferred Email:    '$pref_email'
Sites ([Site Name]:  [Nodes])
ENDEMAIL

foreach my $site (@sites) {
    my $nodes = join(', ' , @{$site_nodes{$site}});
    $message .= "  $site:  $nodes\n";
}
    
    if ($comment) {
	$message .= "\n$name also had the following comment:\n\n\"$comment\"\n";
    }

    if (%site_admins) {
	$message .= "\nNote that the following sites already have a site admin:\n\n";
	foreach (keys %site_admins) {
	    my $name = &dn_to_human_name($_);
	    my @admin_sites = @{$site_admins{$_}->{SITES}};
	    $message .= "  @admin_sites:  $name\n";
	}
	$message .= "\nAnd they have been CCed in this mail.\n";
    }

    $message .=<<ENDEMAIL;

Yours Truly,
   The PhEDEx Web SignUp Form
ENDEMAIL

      send_email(subject => "PhEDEx Administration Request",
 		to => [ @global_admin_mails ],
 		cc => [ @site_admin_mails ],
 		from => "PhEDEx SignUp Form <cms-phedex-admins\@cern.ch>",
 		message => $message );

    print { $$self{CONTENT} } 
    "<h1>Request Sent</h1>",
    "<p>Your request has been emailed to the PhEDEx global admins and ",
	"the existing site admins for their consideration.</p>";
}

1;

######################################################################
package Web25::Administration::Identities;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
import Web25::Request::CreateTools;

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Identities",
	       LINK_TITLE => "View registered users" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $name = $$self{USER_NAME};
  my $identity = $$self{DB_IDENTITY_ID};
  my $client_dn = $$self{SSL_IDENTITY};
  my $email = $self->create_default_email();
  my %globals = $self->fetch_users(global_admins => 1);
  my $signupurl = $self->myurl(page=>'Administration::SignUp');

  print { $$self{CONTENT} } "<h1>Your Identity</h1>";
  
  if ($$self{SSL_VERIFIED} && $identity)
  {
      my @sites;
      
      if (grep $$_{ID} == $identity, values %globals) {
	  push @sites, '<b>Global PhEDEx</b>';
      } else {
	  my %auth_sites = $self->fetch_sites(user_auth=>1);
	  push @sites, sort keys %auth_sites;
      }

      if (!@sites) { push @sites, "Nothing"; }
      
      print { $$self{CONTENT} }
      "<p>Hello $name, the PhEDEx website recognizes you!</p>",
      "<div class='nice'>",
      "<label>Your Certificate DN:</label><span class='labeled'>$client_dn</span><br/>",
      "<label>Your Email:</label><span class='labeled'>$email</span><br/>",
      "<label>Your Identity#:</label><span class='labeled'>$identity</span><br/>",
      "<label>You Administer:</label><span class='labeled'>", join(', ', @sites),"</span><br/>",
      "</div>",
      "<p>You will be able to access privileged operations.</p>";
  }
  elsif ($$self{SSL_VERIFIED} && !$identity) 
  {
      print { $$self{CONTENT} }
      "<p>Hello $name, the PhEDEx website <i>partially</i> recognizes you!</p>",
      "<div class='nice'>",
      "<label>Your Certificate DN:</label><span class='labeled'>$client_dn</span><br/>",
      "<label>Your Email:</label><span class='labeled'>$email</span><br/>",
      "</div>",
      "<p>However, you are <b>not a registered user</b>.  You will only be able to access some privileged operations.  ",
      "Please <a href='$signupurl'>sign up</a> if you require privileges!</p>";
  }
  elsif (($ENV{HTTPS} || "nope") eq 'on')
  {
      print { $$self{CONTENT} }
      "<p>You are accessing this web site securely, but your identity",
      "   could not be verified. To authenticate please <a",
      "   href='http://lcg.web.cern.ch/LCG/users/registration/load-cert.html'",
      "   >load your grid certificate into your browser</a> and authorise",
      "  this web site to authenticate using the certificate.</p>",
      " <p>You will be able to access only <i>unprivileged operations.</i></p>";
  }
  else
  {
      print { $$self{CONTENT} }
      " <p>You are accessing this web site insecurely and unauthenticated.</p>",
      " <p>You will be able to access only <i>unprivileged operations.</i></p>";
  }
  
  print { $$self{CONTENT} } "<h1>Registered Users</h1>";

  my $q = &dbexec($$self{DBH}, qq{
    select dn.identity, dn.value dn, email.value email
    from t_adm_identity_attr dn
      left join t_adm_identity_attr email
        on email.identity = dn.identity
        and email.name = 'E-mail'
    where dn.name = 'Distinguished name'
    order by dn.identity});

  my $table = new Web25::TableSpool;
  $table->set_filehandle( $$self{CONTENT} );
  $table->set_tableclass('data');
  $table->set_stripeclass('stripe');
  $table->set_tablecols([qw(NAME DN EMAIL SITE_ADMIN IDENTITY)]);
  $table->set_tablehead({ NAME => 'Name',
			  DN   => 'Distinguished name',
			  EMAIL => 'E-mail',
			  SITE_ADMIN => 'Admin of',
			  IDENTITY => 'ID'
			  });
  
  $table->add_pseudocolumn('NAME', sub { &dn_to_human_name($_[1]->{DN}); });

  $table->start();
  $table->head();
  while (my $row = $q->fetchrow_hashref()) {
      my @sites;
      
      if (grep $$_{ID} == $$row{IDENTITY}, values %globals) {
	  push @sites, '<b>Global PhEDEx</b>';
      } else {
	  my %auth_sites = $self->fetch_sites(identity_auth=>$$row{IDENTITY});
	  @sites = sort keys %auth_sites;
      }

      $$row{SITE_ADMIN} = join ', ', @sites;
      $table->row($row);
  }

  $table->finish();

}

1;

######################################################################
package Web25::Administration::Admins;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Administrators",
	       LINK_TITLE => "Manage administrator privileges" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web25::Administration::Sites;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Sites",
	       LINK_TITLE => "Manage sites" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web25::Administration::Nodes;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Nodes",
	       LINK_TITLE => "Administer nodes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web25::Administration::Links;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Links",
	       LINK_TITLE => "Administer links between nodes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;



######################################################################
package Web25::Test::Test;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Test Functions",
	       LINK_TITLE => "Testing Page" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  
  my %sites = $self->fetch_sites(user_auth=>1);
  &dump_var($$self{CONTENT}, 'sites', {%sites});

  my @nodes = $self->fetch_nodes(user_auth=>1);
  &dump_var($$self{CONTENT}, 'nodes', [@nodes]);

  my %dbses = $self->fetch_dbses(with_ids => 1);
  &dump_var($$self{CONTENT}, 'dbses', {%dbses});

  my %users = $self->fetch_users(global_admins => 1 );
  &dump_var($$self{CONTENT}, 'users', {%users});
}

1;

######################################################################
package main;
BEGIN { use strict; use warnings; $^W=1; }
use CGI qw(:standard);

# Run the script main routine.  Determine which page we are looking
# at, instantiate it, then ask the page to generate itself.
sub runme
{
  # Read PhEDEx web server configuration
  my $config = &read_config();
  #eval "use CGI::Carp qw(fatalsToBrowser)";

  # Interpret the trailing path suffix: /DB/PAGE?QUERY
  my $path = path_info() || "/prod";
  my ($db, $cgipage) = ("prod", "Info::Main");
  $db = $1 if ($path =~ m!\G/([^/]+)!g);
  $cgipage = $1 if ($path =~ m!\G/([^/]+)!g);

  # Grab the database name from the path info
  $db = "prod" if ! $db || ! exists $$config{INSTANCES}{$db};
  
  # Get the scope object for the page.
  no strict "refs";
  my $type = "Web25::Info::Main";
  $type = "Web25::$cgipage"
    if ($cgipage =~ /^[A-Za-z0-9]+(::[A-Za-z0-9]+)*/
	&& exists ${"Web25::$cgipage\::"}{INDEX}
	&& exists ${"Web25::$cgipage\::"}{new});

  # Instantiate the page object and remember it as a CGI parameter
  # so we can use it in generating links to other pages.
  my $page = &{"$type\::new"}($type);
  $type =~ s!^Web25::!!;
  param('page', $type);
  
  # Generate the page
  $page->generate($config, $db);
}

sub read_config
{
  my $config_file = $ENV{PHEDEX_SERVER_CONFIG}
    || die "No server configuration.\n";

  $config_file =~ s/DEVNAME/$ENV{PHEDEX_DEV}/;
  open (CONFIG, "< $config_file")
    || die "$config_file: cannot read server configuration: $!\n";

  my $config = {};
  my $instance_rank = 0;
  while (1)
  {
    my $line = &parse_line($config_file);
    if (! defined $line)
    {
      last;
    }
    elsif ($line =~ /^$/)
    {
      next;
    }
    elsif ($line =~ /^server-root:\s+(\S+)$/)
    {
      $$config{SERVER_ROOT} = $1;
    }
    elsif ($line =~ /^ssl-server-root:\s+(\S+)$/)
    {
      $$config{SSL_SERVER_ROOT} = $1;
    }
    elsif ($line =~ /^service-path:\s+(\S+)$/)
    {
      $$config{SERVICE_PATH} = $1;
    }
    elsif ($line =~ /^instance:\s+([\S\s]+)$/)
    {
      my $rest = $1;
      my $info = {};
      while ($rest =~ /\G([-a-z]+)\s*=\s*(\S+)\s*/g)
      {
        my $name = uc($1);
        my $value = $2;
        $name =~ s/-/_/g;
        $$info{$name} = $value;
      }

      my @required = qw(ID TITLE DATABASE_NAME USER_NAME PASSWORD);
      my @missing = map { s/_/-/g; lc; } grep(! exists $$info{$_}, @required);
      die "$config_file: instance is missing parameters '@missing'\n" if @missing;
  
      $$info{RANK} = $instance_rank++;
      $$config{INSTANCES}{$$info{ID}} = $info;
    }
    else
    {
      die "$config_file: unexpected parameters '$line'\n";
    }
  }

  close (CONFIG);
  return $config;
}

sub input_line
{
  my $line = <CONFIG>;
  return undef if ! defined $line;

  chomp($line);
  $line =~ s/#.*//;
  $line =~ s/^\s+//;
  $line =~ s/\s+$//;
  $line =~ s/\s+/ /;
  return $line;
}

sub parse_line
{
  my ($file) = @_;
  my $line = &input_line();
  return undef if ! defined $line;

  while (substr($line,-1,1) eq '\\')
  {
    chop($line);
    my $next = &input_line();
    die "$file: file ends in '\\', expected continued line\n"
      if ! defined $next;
    $line .= " ";
    $line .= $next;
  }

  return $line;
}

&runme();
exit(0);
