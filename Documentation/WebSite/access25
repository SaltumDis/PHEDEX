#!/usr/bin/env perl

our $TESTING = 1;

use CMSWebTools::SecurityModule::Oracle;

######################################################################
package Web25::Common; use strict; use warnings; use base "Exporter";
use CGI qw(:standard unescape);
use Net::hostent;
require Socket;
use POSIX qw(strftime mktime);
use Text::Glob 'glob_to_regex';
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} || "./"; $__scriptdir =~ s,[^/]+$,,; unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;


our @EXPORT = qw(urlencode dblink toclink pagelink
		 alert warning breakAtSlash note help
		 age format_num format_size format_timespan
		 badcolor warncolor pendcolor goodcolor altcolor
		 dbexec dbprep dbbindexec dbinlist makeObjWithAttrs
		 timeSeries formatTime timegm sizeValue
		 auth_help fetch_nodes fetch_dbses fetch_identity
                 send_email dn_to_human_name
		 yesno striplabels
		 dump_params dump_var
		 parse_userdata dbs_lookup resolve_data
);

# Various useful colours
our $badcolor = '#ff9e9e';
our $warncolor = '#ffd89e';
our $pendcolor = '#ccccff'; # ececff
our $goodcolor = '#ccffcc';
our $altcolor = '#f0f0f0';

# Encode arguments into a URL query string.
sub urlencode
{
  eval "use CGI '-oldstyle_urls'";
  my %args = @_; return new CGI (\%args)->query_string();
}

# Generate a HTML <a> link for a database instance.
sub dblink
{
  my ($self, $dbname, $db) = @_;
  return "<a href='" . $self->myurl('db' => $$db{ID})
    . "' title='$$db{TITLE} database instance'>$$db{TITLE}</a>";
}

# Generate a HTML <a> link for a category.  For now this is just a
# link to the first page of the category.
sub toclink
{
  my ($self, $category) = @_;

  # Scan pages for this category
  no strict "refs";
  my @pages = ();
  my $scope = \%{*{$category}{PACKAGE} . "::"};
  foreach (keys %$scope)
  {
    next if ! /::$/;
    next if ! exists ${$$scope{$_}}{INDEX};
    push(@pages, ${$$scope{$_}}{INDEX});
  }

  @pages = sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @pages;
  return &pagelink($self, $pages[0], ${$$category}{TITLE});
}

# Generate a HTML <a> link for a page.
sub pagelink
{
  my ($self, $page, $label) = @_;
  my $title = "";
  my $url = ${$$page}{LINK};
  my $name = *{$page}{PACKAGE}; $name =~ s/Web25:://;
  $label = ${$$page}{TITLE} if ! defined $label;

  # If the page has a title, stuff into a link attribute.
  if (${$$page}{LINK_TITLE})
  {
    $title = " title='@{[&escapeHTML(${$$page}{LINK_TITLE})]}'";
  }

  # If the page has a URL, convert relative one; otherwise generate a URL.
  if ($url && $url !~ /^[a-z]+:/ && substr($url,0,1) ne '/') 
  {
    $url = "$$self{CONFIG}{SERVICE_PATH}/$url";
  }
  elsif (! $url)
  {
    $url = $self->myurl("page" => $name);
  }

  # Return final link.
  return "<a href='$url'$title>" .  &escapeHTML($label) . "</a>";
}

# Convert a time difference into human-friendly short age string.
sub age
{
  my ($diff, $precision) = @_;
  $precision = 'minute' if !defined $precision;
  if (! grep ($precision eq $_, qw(second minute)) ) {
      die "Bad args to age()\n";
  }

  my $str = "";
  my $full = 0;

  if ($precision ne 'minute' &&  abs($diff) <= 3600) {
      $str .= sprintf("%dm", $diff / 60);
      $diff %= 60;
      $str .=  sprintf("%02d", $diff);
      return $str;
  }

  if (abs($diff) >= 86400)
  {
    $str .= sprintf("%dd", $diff / 86400);
    $diff %= 86400;
    $full = 1;
  }
  $str .= sprintf("%dh", $diff / 3600);
  $diff %= 3600;
  $str .= sprintf("%02d", $diff / 60);
  return $str;
}

# Convert a time span into human-friendly long string.
sub format_timespan
{
  my $span = shift;
  if ($span >= 86400)
  {
    $span /= 86400;
    return $span == 1 ? "day" : "$span days";
  }
  elsif ($span >= 3600)
  {
    $span /= 3600;
    return $span == 1 ? "hour" : "$span hours";
  } elsif ($span >= 60) {
    $span /= 60;
    return $span == 1 ? "minute" : "$span minutes";
  } else {
    return $span == 1 ? "second" : "$span seconds";
  }
}

sub breakAtSlash
{
  my ($val) = @_;
  return unless $val;
  my $agent = $ENV{HTTP_USER_AGENT} || "";
  $val =~ s,/,/&\#8203;,g if ($agent =~ /Mozilla/ && $agent !~ /MSIE/);
  return $val;
}

# Generate an alert into the output.
sub alert
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='alert'>",
    "<p><b>Error:</b> ", @_, "</p></div></center>\n";
}

# Generate a warning into the output.
sub warning
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='warning'>",
    "<p><b>Warning:</b> ", @_, "</p></div></center>\n";
}

# Generate a note into the output.
sub note
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='note'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate hide/show help
sub help
{
    my ($linktext, $helpsubject, @help) = @_;
    my $id = 'help'.rand();
    return 
	"<a class='help' href='#' onclick='return hideshow(this,\"$id\",0)'>$linktext</a>",
	"<div id='$id' style='display:none' class='help'>",
	"<a href='#' class='closelink' onclick='return hideshow(this, \"$id\", 0)'>[close]</a>",
	"<p class='title'>$helpsubject</p>",
	"<p class='body'>",
	@help,
	"</p>",
	"</div>";
}


# Format a number as a string.  Zero is converted into a dash.
sub format_num
{
  my ($n) = @_;
  return $n ? "$n" : '&#8211;';
}

# Format a file size as a string.  The value is automatically
# abbreviated with a k/M/G/T/P/E suffix, either the first that
# applies or a minimum scale requested by the caller.  The default
# precision is one decimal point, but the caller can change this.
sub format_size {
  my ($bytes, $nodash, $precision, $minscale) = @_;
  my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		[ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
  my ($val, $unit, $minus) = ($bytes, '', $bytes < 0 ? "-" : "");
  do { $val = -$val; $bytes = -$bytes; } if $minus;
  while (@bounds && ($bytes >= $bounds [0][0] || defined $minscale))
  {
    $val = $bytes / $bounds[0][0];
    $unit = $bounds[0][1];
    undef $minscale if (defined $minscale && $minscale eq $unit);
    shift (@bounds);
  }

  $precision = "1" if ! defined $precision;
  return $bytes || $nodash
    ? sprintf("%s%.${precision}f&nbsp;%sB", $minus, $val, $unit)
    : '&#8211;';
}

# Tidy up SQL statement
sub dbsql
{
  my ($sql) = @_;
  $sql =~ s/--.*//mg;
  $sql =~ s/^\s+//mg;
  $sql =~ s/\s+$//mg;
  $sql =~ s/\n/ /g;
  return $sql;
}

# Simple utility to prepare a SQL statement
sub dbprep
{
  my ($dbh, $sql) = @_;
  return $dbh->prepare (&dbsql ($sql));
}

# Simple utility to prepare, bind and execute a SQL statement.
sub dbexec
{
  my ($dbh, $sql, %params) = @_;
  my $stmt = &dbprep ($dbh, $sql);
  my $rv = &dbbindexec ($stmt, %params);
  return wantarray ? ($stmt, $rv) : $stmt;
}

# Simple bind and execute a SQL statement.
sub dbbindexec
{
  my ($stmt, %params) = @_;
  my $isarray = 0;
  while (my ($param, $val) = each %params)
  {
    if (ref $val eq 'ARRAY')
    {
      $stmt->bind_param_array ($param, $val);
      $isarray++;
    }
    elsif (ref $val)
    {
      $stmt->bind_param_inout ($param, $val, 4096);
    }
    else
    {
      $stmt->bind_param ($param, $val);
    }
  }

  return $isarray
    ? $stmt->execute_array({ ArrayTupleResult => [] })
    : $stmt->execute();
}

# Retrun an sql fragment and a bind hash for an SQL "IN" list
sub dbinlist
{
    my ($prefix, @binds) = @_;
    my $in_list = join(', ', map { ":${prefix}_".($_+1) } (0..$#binds));                                                            
    my %in_binds = map { (":${prefix}_".($_+1) => $binds[$_]) } (0..$#binds); 
    return $in_list, %in_binds;
}


# Convenience wrapper for automatically constructing an object
# with requested set of attributes.
sub makeObjWithAttrs
{
  my ($dbh, $kind, $link, $obj, @attrs) = @_;
  my ($tname, $sname) = ("t_$kind", "seq_$kind");
  my @objfields = keys %$obj;
  my %objattrs = map { (":attr_$_" => $$obj{$_}) } @objfields;

  my $objsql =
    "insert into $tname ("
    . join(", ", "id", @objfields)
    . ")\n values ("
    . join(", ", "$sname.nextval", map { ":attr_$_" } @objfields)
    . ")\n returning id into :id";
  my $id = undef;
  &dbexec($dbh, $objsql, ":id" => \$id, %objattrs);

  $tname .= "_attr"; $sname .= "_attr";
  while (@attrs)
  {
    my ($name, $value) = splice(@attrs, 0, 2);
    &dbexec($dbh, qq{
      insert into $tname (id, $link, name, value)
      values ($sname.nextval, :Id, :name, :value)},
      ":id" => $id, ":name" => $name, ":value" => $value);
  }

  return $id;
}

# Print a help message about authentication requirements
# Takes a hash of $power => [@requirements]
# The first entry of @requirements should be the authentication level,
# the rest are the required roles for $power
sub auth_help 
{
    my ($self, %powers) = @_;

    my $login_url = $self->myurl("secure" => 1);
    my $sitedb_url = $$self{CONFIG}{SITEDB_URL} || 'blank';
    my $gridcert_help_url = $$self{CONFIG}{GRIDCERT_HELP_URL} || 'blank';
    my $contact_mail = "mailto:$$self{CONFIG}{FEEDBACK_MAIL}";

    my %auth_words = ( 'cert' => 'grid certificate authentication',
		       'passwd' => 'password authentication',
		       'anyauth' => 'to log in');
    my $msg = '';
    my %help;
    sub or_list {
	my $last = pop @_;
	return join(', ', @_)." or $last";
    }

    foreach my $power (keys %powers) {
	my @requirements = @{$powers{$power}};
	my $auth_level = shift @requirements;
	$help{$auth_level} = 1;
	$msg .= "You need <b>$auth_words{$auth_level}</b>";
	if (@requirements) {
	    @requirements = map { "<b>'$_'</b>" } @requirements;
	    $help{'sitedb'} = 1;
	    $msg .= ' and to be a '.&or_list(@requirements);
	}
	$msg .= " in order to $power.<br/>  ";
    }
    $msg .= "<br/>";

    if (exists $help{'cert'}) {
	$msg .= "You can go <a href='$gridcert_help_url'>here</a> to find help on obtaining a grid certificate.  ";
    }

    if (exists $help{'passwd'} || exists $help{'anyauth'}) {
	$msg .= "Passwords are managed via <a href='$sitedb_url'>SiteDB</a> ".
	    "and are synced with the CMS hypernews passwords.  ";
    }

    if (exists $help{'sitedb'}) {
	$msg .= "Authorization roles are handled by <a href='$sitedb_url'>SiteDB.</a> ";
    }

    $msg .= "If you think you have the necessary rights in SiteDB ".
	"and are <a href='$login_url'>logged in</a> but you are still ".
	"having problems with this page you may <a href='$contact_mail'>contact the PhEDEx developers</a>.  ";

    print {$$self{CONTENT}} &help('Privilaged Activities Help', 'Privilaged Activities', $msg), "<br/>";
}



# Returns a list of nodes.
# If argument 'with_ids' is true, returns a hash of node_name => node_id
# else it returns an array of nodes
#
# If web_user_auth is set with the name of some role (e.g. 'Data
# Manager'), we check the security module to find out if the user has
# that role, find out for which sites they have that role, and return
# a list of nodes associated with those sites.
#
# web_user_auth can be set with multiple roles separated by '||', for
# which all authorized nodes among those roles will be returned.
# (e.g. web_user_auth => 'Data Manager||Site Admin')
#
# The role 'Global Admin' need not be specified in web_user_auth.  If
# the user is a Global Admin then all nodes are always returned.
#
# Otherwise it returns from t_adm_node table, which contains all nodes.
# The default behavior is to return an array of all nodes from t_adm_node.
sub fetch_nodes
{
    my ($self, %args) = @_;

    my @auth_nodes;
    if (exists $args{web_user_auth} && $args{web_user_auth}) {
	my $roles = $$self{SECMOD}->getRoles();
	my @to_check = split /\|\|/, $args{web_user_auth};
	my $roles_ok = 0;
	foreach my $role (@to_check) {
	    if (grep $role eq $_, keys %{$roles}) {
		$roles_ok = 1;
	    }
	}

	my $global_admin = (exists $$roles{'Global Admin'} &&
			    grep $_ = 'phedex', @{$$roles{'Global Admin'}}) || 0;

	return unless ($roles && ($roles_ok || $global_admin));
	
	# If the user is not a global admin, make a list of sites and
	# nodes they are authorized for.  If they are a global admin
	# we continue below where all nodes will be returned.
	if (!$global_admin) {
	    my %node_map = $$self{SECMOD}->getPhedexNodeToSiteMap();
	    my %auth_sites;
	    foreach my $role (@to_check) {
		if (exists $$roles{$role}) {
		    foreach my $site (@{$$roles{$role}}) {
			$auth_sites{$site} = 1;
		    }
		}
	    }
	    foreach my $node (keys %node_map) {
		foreach my $site (keys %auth_sites) {
		    push @auth_nodes, $node if $node_map{$node} eq $site;
		}
	    }
	}
    }

    my $sql = qq{select name, id from t_adm_node};
    my $q = &dbexec($$self{DBH}, $sql);
    
    my %nodes;
    while (my ($node, $node_id) = $q->fetchrow()) {
	# Filter by auth_nodes if there are any
	if (!@auth_nodes || grep $node eq $_, @auth_nodes) {
	    $nodes{$node} = $node_id;
	}
    }
    if (exists $args{with_ids} && $args{with_ids}) {
	return %nodes;
    } else {
	return keys %nodes;
    }
}



# Returns a list of DBSes.
# If argument 'with_ids' is true, then return a hash of name => id
# else return an array of DBS names
sub fetch_dbses
{
    my ($self, %args) = @_;

    my %dbses;
    my $q = &dbexec($$self{DBH}, qq{select name, id from t_dps_dbs});
    while (my ($dbs, $dbs_id) = $q->fetchrow()) {
	$dbses{$dbs} = $dbs_id;
    }
    
    if (exists $args{with_ids} && $args{with_ids}) {
	return %dbses;
    } else {
	return keys %dbses;
    }
}


# Tries to resolve the user's identity and returns it.  Also logs the
# identity to the t_adm_identity table, if it is not already there.
# Note:  does not commit this logging activity, this is left to the function caller
sub fetch_identity
{
    my ($self, $secmodUser) = @_;

    my $id = {};
    my @to_sync;

    if (! $secmodUser ) {
	if (! $$self{SECMOD}->isAuthenticated() ) { return; }

	$$id{SECMOD_ID} = $$self{SECMOD}->getID();
	$$id{NAME} = $$self{SECMOD}->getForename() .' '. $$self{SECMOD}->getSurname();
	$$id{EMAIL} = $$self{SECMOD}->getEmail();

	if ($$self{SECMOD}->isCertAuthenticated()) {
	    @to_sync = qw(SECMOD_ID NAME EMAIL DN CERTIFICATE);
	    $$id{DN} = $$self{SECMOD}->getDN();
	    $$id{CERTIFICATE} = $$self{SECMOD}->getCert();
	} elsif ($$self{SECMOD}->isPasswdAuthenticated()) {
	    @to_sync = qw(SECMOD_ID NAME EMAIL USERNAME);
	    $$id{USERNAME} = $$self{SECMOD}->getUsername();
	}
    } else {
	$$id{SECMOD_ID} = $$secmodUser{ID};
	$$id{NAME} = $$secmodUser{FORENAME} .' '. $$secmodUser{SURNAME};
	$$id{EMAIL} = $$secmodUser{EMAIL};
	$$id{DN} = $$secmodUser{DN};
	$$id{USERNAME} = $$secmodUser{USERNAME};
	@to_sync = qw(SECMOD_ID NAME EMAIL DN USERNAME);
    }
    my $now = time();

    # Look up a logged identity by either the SecurityModule ID or the DN
    my $q = &dbexec($$self{DBH},
		    qq{ select id, secmod_id, name, email, dn, certificate, username
			    from t_adm_identity where secmod_id = :secmod_id or dn = :dn
			    order by time_update desc },
		    ':secmod_id' => $$id{SECMOD_ID},
		    ':dn' => ($$id{DN} || 'dummy')
		    );

    my $logged_id = $q->fetchrow_hashref();

    my $synced = ($logged_id ? 1 : 0);
    foreach my $param (@to_sync) {
	last if !$synced;
	no warnings;  # we need to compare undef values too
	$synced &&= $$logged_id{$param} eq $$id{$param};
    }

    if ($logged_id && $synced) {
	# If everything is logged and up-to-date, return the identity information
	return $logged_id;
    } elsif ($logged_id && !$synced) {
	# If it is logged, but out of date, update it then return the information by recursing
	my $sql = qq{ update t_adm_identity set };
	my @params = map { "$_ = :$_" } (@to_sync, "TIME_UPDATE");
	$sql .= join(', ', @params);
	$sql .= qq{ where id = :id };
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;
	$binds{':ID'} = $$logged_id{ID};

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    } else {
	# If it is not logged, log it then recurse
	my $sql = qq{ insert into t_adm_identity };
	$sql .= '('.join(', ', "ID", @to_sync, "TIME_UPDATE").') ';
	$sql .= 'values ('.join(', ', "seq_adm_identity.nextval", map { ":$_" } (@to_sync,'TIME_UPDATE')).')';
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    }
}

sub send_email
{
    my (%args) = @_;

    # Required arguments
    foreach (qw(subject from to message)) {
	return 0 unless exists $args{$_};
    }

    # Make to and cc arrays unique
    foreach (qw(to cc)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    my %unique;
	    $unique{$_} = 1 foreach @{$args{$_}};
	    $args{$_} = [keys %unique];
	}
    }

    # Ensure names are not duplicated from to to cc
    if (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	&& ref $args{to} eq 'ARRAY') {
	my @uniquecc;
	foreach my $mail (@{$args{cc}}) {
	    push @uniquecc, $mail unless grep $_ eq $mail, @{$args{to}};	    
	}
	$args{cc} = [ @uniquecc ];
    } elsif (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	     && ref $args{to} ne 'ARRAY') {
	$args{cc} = [ grep $_ ne $args{to}, @{$args{cc}} ];
    } elsif (exists $args{cc}
	     && ref $args{to} eq 'ARRAY') {
	delete $args{cc} if grep $_ eq $args{cc}, @{$args{to}};
    } elsif (exists $args{cc}) {
	delete $args{cc} if $args{cc} eq $args{to};
    }
    
    foreach (qw(from to cc replyto)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    $args{$_} = join(', ', @{$args{$_}});
	} elsif ( exists $args{$_} && ! $args{$_} ) {
	    $args{$_} = '';
	}
    }
    
    foreach (qw(from to cc replyto)) {
	next unless exists $args{$_};
	return 0 unless &validlist($args{$_});
    }

    # For debugging without bothering people
    if ($TESTING) {
	$args{subject} = "TESTING:  $args{subject}";
	$args{message} .= "\n\nTO:  $args{to}\n\n"; $args{to} = 'Ricky.Egeland@cern.ch';
	if ($args{cc}) {$args{message} .= "\n\nCC:  $args{cc}\n\n"; delete $args{cc};}
    }

    (open (MAIL, "| /usr/sbin/sendmail -t")
     && (print MAIL
 	 "Subject: $args{subject}\n",
 	 "From: $args{from}\n",
 	 (exists $args{replyto} ? "Reply-To:  $args{replyto}\n" : ''),
 	 "To: $args{to}\n",
 	 (exists $args{cc} ? "Cc: $args{cc}\n" : ''),
 	 "\n",
 	 $args{message},
 	 "\n" )
     && close(MAIL))
 	or do { return 0; };
    
    return %args;
}



sub dn_to_human_name
{
    my $dn = shift @_;
    return undef unless $dn;
    my @names = ($dn =~ m:/CN=([^/]+?)[\s\d]*(/|$):g);
    my $name = $names[0];
    foreach (@names) {
      $name = $_ if length $_ > length $name;
    }
    $name =~ s/\b(\w)/\U$1/g;
    return $name;
}


    
sub yesno 
{ 
    $_ = shift @_;
    return undef unless $_;
    s/^y$/Yes/; s/^n$/No/; 
    return $_; 
}



sub striplabels 
{ 
    my @stripped =  map { s:<[/]*label>::g; $_; } @_; 
    return wantarray ? @stripped : shift @stripped;
}



sub dump_params
{
    my $fh = shift @_;
    use Data::Dumper;
    print { $fh } "<pre>$_:\n", Dumper(param($_)), "</pre>" foreach param();

}


sub dump_var
{
    my ($fh, $name, $var) = @_;
    use Data::Dumper;
    print { $fh } "<pre>$name:\n", Dumper($var), "</pre>";
}


# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
  my ($first, $range, $now) = @_;
  $now ||= time();
  my @series = ();
  $first = int($first);

  if ($range eq 'hour') {
    # Convert first time to UTC hour in units of half a day.  Then
    # make a time series of hours until end of current 4 hours.
    my $low = int($first / 3600);
    my $high = int($now / 3600) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
    }
  } elsif ($range eq 'day') {
    # Convert first time to UTC day at 00:00.  Then make a
    # time series of days until end of today.
    my $low = int($first / 86400);
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
    }
  } elsif ($range eq 'week') {
    # Convert first time to previous Monday.  Then make a
    # time series of weeks until we pass today.
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $low = int($first/86400) - $diff{$wday};
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; $low += 7) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
    }
  } elsif ($range eq 'month') {
    # Convert first time to first of the month.  Then convert
    # into a time-series of months.  This is a bit dodgy, we
    # go by day so we don't need to worry about month dates.
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $start = int(($first - ($mday-1)*86400)/86400);
    my $limit = int($now / 86400) + 1;
    while ($start < $limit)
    {
      my $low = $start;
      my ($prevyear, $prevmon) = ($year, $mon);
      while ($year == $prevyear && $mon == $prevmon)
      {
	($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
	  = gmtime ((++$start) * 86400);
      }
      push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
    }
  }

  return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
  my ($time, $range) = @_;
  return undef unless ($time && $range);
  return undef if ($time <= 0);
  if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
  elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
  elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
  elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
  elsif ($range eq 'stamp') { return strftime ('%Y-%m-%d %H:%M:%S UTC', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
  my @args = @_;
  my $t1 = mktime (@args);
  my @gmt = gmtime ($t1);
  my $t2 = mktime (@gmt);
  return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
  my ($value) = @_;
  if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
  {
    my %scale = ('k' => 2**10, 'M' => 2**20, 'G' => 2**30,
		 'T' => 2**40, 'P' => 2**50, 'E' => 2**60);
    $value = $1 * $scale{$2};
  }
  return $value * 1.0;
}

# Takes an array of user data clobs and parses out single dataset and block globs
# Returns a hash of key:  glob pattern value: item type (DATASET or BLOCK)
sub parse_userdata
{
    my ($self, @userdata) = @_;
    my %parsed;
    foreach my $string (@userdata) {
	$string =~ s/^\s+//;  $string =~ s/\s+$//;
	my @data = split(/\s+/, $string);
	foreach my $item (@data) {
	    if ($item =~ m<^/[^/]+/[^/]+(/[^/]+|\#[^\#]+)$>) {
		$parsed{$item} = ($1 =~ /\#/ ? 'BLOCK' : 'DATASET');
	    } else {
		$parsed{$item} = undef;
	    }
	}
    }
    return %parsed;
}

sub dbs_lookup
{
    my ($dbs, $pattern) = @_;

    ### Security:  Strict list of characters allowed to go to shell
    my $reg = qr/[^\w\.\*\-\#\/\?=:\+\&]/;
    foreach (@_) {
	if (/$reg/) {
	    die "Invalid string '$_' given to dbs_lookup()";
	}
    }
        
    # TODO:  set this up in the apache config
    if ($dbs =~ /^https/) {
	# remove secure connection
	$dbs =~ s/^https/http/;
	$dbs =~ s|:\d+/|/|;
	$dbs =~ s/_writer//;
    }

    my $dbscmdsetup = 
	"source /opt/aptinstaller/slc3_ia32_gcc323/cms/dbs-client/DBS_1_0_0/etc/profile.d/init.sh; ".
	"source /opt/aptinstaller/slc3_ia32_gcc323/external/python/2.4.2/etc/profile.d/init.sh;";
    my $dbscmd = "$dbscmdsetup ../../Toolkit/DBS/DBSLookup -u '$dbs' -d '$pattern'";
    my $dbsresults = `$dbscmd`;
    my @paths;
    if ($dbsresults) {
	foreach (split "\n", $dbsresults) {
	    push @paths, $_ if /^\//;
	}
    }
    return @paths;
}



# Resolve user datasets;  Search DPS and DBS for glob patterns
# Fill data object with results:
# $$resolved{$userglob} = [ { params }, ... ]
# Where { params } contains:
#   DBS = dbs the data was found in PhEDEx, not necessarily the one the user specified
#   LEVEL = 'BLOCK' or  'DATASET'
#   DATASET = Dataset name
#   BLOCK = Block name.  undef if LEVEL = DATASET
#   ID = The dps unique id for item
#   DPS_ISKNOWN = 'y' or 'n'
#   DBS_ISKNOWN = 'y' or 'n'
sub resolve_data
{
    my ($dbh, $userdbs, @userdata) = @_;

    my $resolved = {};
    my $userdupes = {};
    my $dbsdupes = {};
    my $all = {};

    foreach my $level (qw(DATASET BLOCK)) {
	$$all{$level} = [];
    }
    foreach my $userglob (@userdata) {
	$$resolved{$userglob} = [];
	my $level = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');

	# Search the DPS for the user's glob
	my $sql;
	if ($level eq 'DATASET') {
	    $sql = qq{select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset
		        from t_dps_dataset ds
			join t_dps_dbs dbs on dbs.id = ds.dbs
		       order by ds.id };
	} else {
	    $sql = qq{select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset, b.id block_id, b.name block
			from t_dps_block b
			join t_dps_dataset ds on b.dataset = ds.id
			join t_dps_dbs dbs on ds.dbs = dbs.id
		       order by b.id};
	}

	my $q = &dbexec($dbh, $sql);

	my $pattern = glob_to_regex($userglob);
	my $lastid = -1;
	while (my $row = $q->fetchrow_hashref()) {
	    my $name = $$row{$level};
	    my $id = $$row{$level.'_ID'};
	    next unless $name =~ $pattern;

	    # Redundancy checking
	    if ($id == $lastid) {
		$$dbsdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	    push @{$$all{$level}}, $id;

	    push @{$$resolved{$userglob}},  { DBS => $$row{DBS},
					      LEVEL => $level,
					      DATASET => $$row{DATASET},
					      BLOCK   => $$row{BLOCK},
					      DPS_ISKNOWN => 'y',
					      DBS_ISKNOWN => 'y', # XXX This is assuming DPS and DBS are in sync
					      ID => $id };
	}
	
	# User's glob not found in DPS, check their DBS
	if ($userdbs && ! @{$$resolved{$userglob}}) {
	    my @dbsdata = dbs_lookup($userdbs, $userglob);
	    foreach my $name (@dbsdata) {
		push @{$$resolved{$userglob}}, { DBS => $userdbs,
						 LEVEL => $level,
						 DATASET => ($level eq 'DATASET' ? $name : undef),
						 BLOCK   => ($level eq 'BLOCK' ? $name : undef),
						 DPS_ISKNOWN => 'n',
						 DBS_ISKNOWN => 'y',
						 ID => undef };
	    }
	}
    }

    my $lastid = -1;
    foreach my $level (qw(DATASET BLOCK)) {
	foreach my $id (sort @{$$all{$level}}) {
	    if ($id == $lastid) {
		$$userdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	}
    }

    if (wantarray) {
	return ($resolved, $userdupes, $dbsdupes);
    } else {
	return $resolved;
    }
}



1;


######################################################################
# A tool to create paged results given an SQL query
package Web25::QueryPager;
use strict; use warnings;
use CGI qw(param);
use POSIX qw(ceil);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{RESULTS_PER_PAGE} = 10;

  bless $self, $class;
  return $self;
}

# Initialize with the database handle, query to page, a hashref of its
# binds, and the number of results per page
sub init
{
    my ($self, $webself, $select, $binds, $results_per_page, $rank_col) = @_;
    $$self{WEB} = $webself;
    $$self{DBH} = $$webself{DBH};
    $$self{SELECT} = $select;
    $$self{BINDS} = $binds;
    $$self{RESULTS_PER_PAGE} = $results_per_page if $results_per_page;
    $$self{RANK_COL} = $rank_col;
    $$self{TOTAL_RESULTS} = &count_results($$self{DBH}, $select, $binds, $rank_col);
    $$self{TOTAL_PAGES} = &total_pages($$self{TOTAL_RESULTS}, $$self{RESULTS_PER_PAGE});
    $$self{CURRENT_PAGE} = param('page_num') || 1;
    if ($$self{CURRENT_PAGE} <= 0 
	|| $$self{CURRENT_PAGE} > $$self{TOTAL_PAGES}) {
	$$self{CURRENT_PAGE} = 1;
    }
}

sub get_total_results
{
    my ($self) = @_;
    return $$self{TOTAL_RESULTS};
}

# Returns the pager widget
sub pager
{
    my ($self) = @_;

    my $current_page = $$self{CURRENT_PAGE};
    my $total_pages = $$self{TOTAL_PAGES};

    return if $total_pages == 1;

    my @pager_html;

    push @pager_html, "<div class='pager'>Page $current_page of $total_pages:  ";
   
    if ($current_page > 1) {
	push @pager_html, $self->page_link(1, '[First]'), " \n";
	push @pager_html, $self->page_link(($current_page-1), '[Prev]'), " \n";
    }

    for (my $i = ($current_page-5); $i <= $current_page+5; $i++) {
	next if ($i < 1 || $i > $total_pages);

	if ($i != $current_page) {
	    push @pager_html, $self->page_link($i, $i), " \n";
	} else {
	    push @pager_html, $self->page_link($i, "<strong><big>$i</big></strong>"), " \n";
	}
    }

    if ($current_page < $total_pages) {
	push @pager_html, $self->page_link(($current_page+1), '[Next]'), " \n";
	push @pager_html, $self->page_link($total_pages, '[Last]'), " \n";
    }

    push @pager_html, "</div>";
    return @pager_html;
}

# Returns a query handle with 1 page's worth of results
sub paged_result
{
    my ($self) = @_;
    my $start_result = &page_to_result($$self{CURRENT_PAGE}, $$self{RESULTS_PER_PAGE});
    my $end_result = $start_result + $$self{RESULTS_PER_PAGE} - 1;
    my $sql;
    if (!$$self{RANK_COL}) {
	$sql = qq[select * from ( select r.*, rownum as result_number
				  from ($$self{SELECT}) r 
				  where rownum <= :end_result ) 
		  where :start_result <= result_number ];
    } else {
	$sql = qq[select * from 
                    (select results.*, dense_rank() over (order by results.$$self{RANK_COL}) result_number
		     from ($$self{SELECT}) results )
                     where result_number >= :start_result and result_number <= :end_result];
    }
    my %binds = %{$$self{BINDS}};
    $binds{':start_result'} = $start_result;
    $binds{':end_result'} = $end_result;
    my $q = &dbexec($$self{DBH}, $sql, %binds);

    return $q;
}

### Private functions ###

# Return a link to a page
sub page_link
{
    my ($self, $page_num, $linktext) = @_;
# Using this method screws up when using https which seems like a CGI bug
# unfortunately this binds us to using the myurl() function...
#     my @ignore = qw(page);
#     my $cgi = new CGI;
#     $cgi->delete(@ignore);
#     $cgi->param('page_num', $page_num);
#     my $url = $cgi->self_url(-secure=>1);
    my $url = $$self{WEB}->myurl('page_num' => $page_num);
    return "<a href='$url'>$linktext</a>";
}

sub total_pages
{
    my ($total_results, $results_per_page) = @_;
    if ($total_results < 1) { $total_results = 1; }
    return POSIX::ceil($total_results/$results_per_page);
}

sub page_to_result
{
    my ($current_page, $results_per_page) = @_;
    return ( ($current_page - 1 ) * $results_per_page + 1 );
}

sub count_results
{
    my ($dbh, $select, $binds, $rank_col) = @_;
    my $sql;
    if (!$rank_col) {
	$sql = qq[select count(*) as num_results from ($select)];
    } else {
	$sql = qq[select max(rank) from 
                    (select results.*, dense_rank() over (order by results.$rank_col) rank from ($select) results)];
    }
    my $q = &dbexec($dbh, $sql, %{$binds});
    my ($num_results) = $q->fetchrow();
    return $num_results || 0;
}

1;



######################################################################
# A tool to print an html table
# many options for formatting cell data, row style and cell style
# based on given subrefs

# TODO Make TableSpool able to filter rows given a subref
# TODO Make TableSpool able to compute and display sums of columns

package Web25::TableSpool;
use strict; use warnings;
use CGI qw(param);



sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{FH} = *STDOUT;
  $$self{STRIPE} = undef;
  $$self{ROWCNT} = 0;
  $$self{COLCNT} = 0;
  $$self{TABLECOLS}   = undef;
  $$self{TABLEHEAD}   = undef;
  $$self{TABLECLASS}  = undef;
  $$self{STRIPECLASS} = undef;
  $$self{DATAFORMATS} = undef;
  $$self{ROWFORMATS}  = undef;
  $$self{CELLFORMATS} = undef;
  $$self{PSEUDOCOLS}  = undef;
  $$self{QUERYCOLS}   = undef;

  bless $self, $class;
  return $self;
}

# Set filehandle to print to 
sub set_filehandle
{
    my ($self, $fh) = @_;
    $$self{FH} = $fh;
}

# $cols: array ref of DB_column_names to output (others are ignored)
sub set_tablecols
{
    my ($self, $cols) = @_;
    $$self{TABLECOLS} = $cols;
}

# Sets columns to display based on CGI query parameters
# takes a list of column descriptions of the form
# (label, querykey, columnkeys, is_default)
# If no specified query variables are found, the 'is_default' columns are shown
sub set_querycols
{
    my ($self, @column_descriptions) = @_;
    $$self{QUERYCOLS} = [@column_descriptions];
    my %checked_querykeys;
    my @foundcols;
    my @defaultcols;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	unless (exists $checked_querykeys{$querykey}) {
	    foreach my $param_columnkeys (param($querykey)) {
		push @foundcols, split( /:/, $param_columnkeys);
	    }
	}
	$checked_querykeys{$querykey} = 1;
	push @defaultcols, split( /:/, $columnkeys ) if $is_default;
    }

    if (@foundcols) { $self->set_tablecols([ @foundcols ]); }
    else { $self->set_tablecols([ @defaultcols ]); }
}


# $th : hash of DB_column_name=>Pretty_column_name for table headers
sub set_tablehead
{
    my ($self, $th) = @_;
    $$self{TABLEHEAD} = $th;
}

# $class :  CSS class for the HTML table
sub set_tableclass
{
    my ($self, $class) = @_;
    $$self{TABLECLASS} = $class;
}

# $stripe :  CSS class for striped rows
sub set_stripeclass
{
    my ($self, $class) = @_;
    $$self{STRIPECLASS} = $class;
}
# $dataformats : hash of DB_column_name=>formatting_subroutine($data, $rowref) for formatting data
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_dataformats
{
    my ($self, $df) = @_;
    $$self{DATAFORMATS} = $df;
}

# $cellformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the cell (<td>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_cellformats
{
    my ($self, $cf) = @_;
    $$self{CELLFORMATS} = $cf;
}

# $rowformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the row (<tr>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_rowformats
{
    my ($self, $rf) = @_;
    $$self{ROWFORMATS} = $rf;
}

# $pseudocols : hash with key 'name' (column name) and value 'generator' (sub ref)
# for generating a pseudocolumn in the table.  Requires 'name' to be in TABLEHEAD for output.
# 'generator' is passed the hash of the current row data, before any processing
sub add_pseudocolumn
{
    my ($self, $name, $generator) = @_;
    $$self{PSEUDOCOLS} = {} unless $$self{PSEUDOCOLS};
    $$self{PSEUDOCOLS}->{$name} = $generator;
}



# Print the beginning of the table
sub start
{
    my ($self) = @_;
    print { $$self{FH} }
    "<table ", $$self{TABLECLASS} ? "class='$$self{TABLECLASS}'" : '', ">\n";
}

# Print the title columns
sub head
{
    my ($self, @headers) = @_;

    if (@headers) {
	# Do nothing
    } elsif ($$self{TABLECOLS} && $$self{TABLEHEAD}) {
	@headers = @{$$self{TABLEHEAD}}{@{$$self{TABLECOLS}}};
    } elsif ($$self{TABLECOLS}) {
	@headers = @{$$self{TABLECOLS}};
    }

    if (!@headers) {
	die "TableSpool::head called without any column information\n";
    }

    print { $$self{FH} } "<thead>\n";
    print { $$self{FH} } "<tr>";
    print { $$self{FH} } "<th>$_</th>" foreach (@headers);
    print { $$self{FH} } "</tr>\n";
    print { $$self{FH} } "</thead>\n";

    $$self{COLCNT} = scalar @headers;
}

# Prints a row, taking either an array of data
# or a hashref of labled data (name=>val)
sub row
{
    my ($self, @row) = @_;

    if ($$self{ROWCNT} == 0) { 
	print { $$self{FH} } "<tbody>\n"; 
    }

    if (ref $row[0] eq 'HASH') {
	$self->hash_row($row[0]);
    } else {
	if (ref $row[0] eq 'ARRAY') {
	    @row = @{$row[0]};
	}

	my $rowclass = '';
	if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	    $rowclass = " class='$$self{STRIPECLASS}'";
	}
	
	print { $$self{FH} } "<tr$rowclass>";
	print { $$self{FH} } "<td>$_</td>" foreach (@row);
	print { $$self{FH} } "</tr>";
    }
    $$self{ROWCNT}++;
    return $$self{ROWCNT};
}

sub rows
{
    my ($self, $row_ary) = @_;
    foreach my $row (@{$row_ary}) {
	$self->row($row);
    }
}

# Print a row from a hash applying all features
sub hash_row
{
    my ($self, $row, $rowclass) = @_;
    $rowclass = '' if !defined $rowclass;

    # Copy the row
    my $myrow = {%{$row}};

    # Add the pseudocolumns to the row
    if ($$self{PSEUDOCOLS}) {
	foreach my $name (keys %{$$self{PSEUDOCOLS}}) {
	    $myrow->{$name} = &{$$self{PSEUDOCOLS}->{$name}}(undef, $myrow);
	}
    }

    # Format data row if format sub provided   
    if ($$self{ROWFORMATS}) {
	my $rowclass_ary = [];
	foreach my $name (keys %{$$self{ROWFORMATS}}) {
	    push @{$rowclass_ary}, &{$$self{ROWFORMATS}->{$name}}($row->{$name}, $myrow);
	}
	$rowclass = join(' ', $rowclass, @{$rowclass_ary});
    }

    # Format data cell if format sub provided
    my $cellclass_hash = {};
    if ($$self{CELLFORMATS}) {
	foreach my $name (keys %{$$self{CELLFORMATS}}) {
	    $cellclass_hash->{$name} = &{$$self{CELLFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Format data columns if format sub provided
    if ($$self{DATAFORMATS}) {
	foreach my $name (keys %{$$self{DATAFORMATS}}) {
	    $myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Print out the row with the appropriate classes
    if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	$rowclass .= ' '.$$self{STRIPECLASS};
    }

    if ($rowclass) { $rowclass = " class='$rowclass'"; }
  
    print { $$self{FH} } "<tr$rowclass>";

    foreach my $name (@{$$self{TABLECOLS}}) {
	my $cellclass = '';
	if (exists $cellclass_hash->{$name}) {
	    $cellclass = " class='".$cellclass_hash->{$name}."'";
	}
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td$cellclass>$val</td>";
    }
    print { $$self{FH} } "</tr>\n";
}

# Finish, returns number of rows printed
sub finish
{
    my ($self) = @_;
    print { $$self{FH} } "</tbody>\n";
    print { $$self{FH} } "</table>\n";
    return $$self{ROWCNT};
}

# Returns form inputs for column selection
# requires set_querycols
sub columns_form
{
    my ($self) = @_;

    my @checked;
    my @defaults;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	foreach my $param_columnkeys (param($querykey)) {
	    push @checked, $label if ($param_columnkeys eq $columnkeys);
	}
	push @defaults, $label if ($is_default);
    }

    unless (@checked) {
	@checked = @defaults;
    }


    my $form = "";
    $form .= "<p><i>Display Columns</i></p>\n";
    foreach my $desc (@{$$self{QUERYCOLS}})
    {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	$form .= "<input type='checkbox' name='$querykey' value='$columnkeys'";
	$form .= (grep $_ eq $label, @checked) ? " checked='checked'" : "";
	$form .= " />&nbsp;$label<br/>\n";
    }
    
    return $form;
}


1;



######################################################################
# A simple class to print an HTML table of a DB query
package Web25::DBTable;
use strict; use warnings;
use base "Web25::TableSpool";

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  bless $self, $class;
  return $self;
}



# Output a table given a statement handle $sth,
# $sth : database handle to iterate on
sub output
{
    my ($self, $sth) = @_;

    if (! $$self{TABLECOLS}) {
	$self->set_tablecols($sth->{NAME});
    }

    if (! $$self{TABLEHEAD}) {
	my $th = {};
	$th->{$_} = $_ foreach (@{$sth->{NAME}});
	$self->set_tablehead($th);
    }

    $self->start();    
    $self->head();
    while (my $row = $sth->fetchrow_hashref()) {
	$self->row($row);
    }
    return $self->finish();
}

1;



######################################################################
package Web25::OptsPane;
use strict; use warnings;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{TABS} = [];
  $$self{HIDDEN} = [];
  $$self{TARGET} = "#";

  bless $self, $class;
  return $self;
}

sub set_form_target
{
    my ($self, $target) = @_;
    $$self{TARGET} = $target;
}

sub add_tab
{
    my ($self, $name, $form) = @_;
    my $id = scalar @{$$self{TABS}};
    push @{$$self{TABS}}, { id => $id, name => $name, form => $form };
}

sub add_hidden
{
    my ($self, $form) = @_;
    push @{$$self{HIDDEN}}, $form;
}

sub output
{
    my ($self) = @_;

    my $html = "";

    $html .= "<form method='get' action='$$self{TARGET}'>\n";

    $html .= "<div id='optsnav'>\n";
    foreach my $tab (@{$$self{TABS}}) {
	my $class = $tab->{id} == 0 ? 'raised' : 'lowered';
	$html .= "<div class='$class' onclick='return showtab($tab->{id})' id='optstab$tab->{id}'><a href='#'>$tab->{name}</a></div>\n";
    }
    $html .= "</div>\n";


    foreach my $tab (@{$$self{TABS}}) {
	my $display = $tab->{id} == 0 ? '' : 'style=\'display:none;\'';
	$html .= "<div class='optscontent' $display id='optspane$tab->{id}'>\n";
	$html .= $tab->{form};
	$html .= "</div>\n";
    }
    foreach my $hidden (@{$$self{HIDDEN}}) {
	$html .= $hidden;
    }

    $html .= "<div id='optsfoot'>\n";
    $html .= "<input type='submit' value='Cancel' onclick='return hideshow(this,\"opts\",0)'/>&nbsp;\n";
    $html .= "<input type='submit' value='Apply' />\n";
    $html .= "</div>\n";

    $html .= "</form>\n";


    return $html;
}

sub link
{
    my ($self, $linkname) = @_;
    "<a href='#' onclick='return hideshow(this,\"opts\",0)'>$linkname</a><br/>\n";
}



1;


######################################################################
package Web25::Page;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

our $TEMPLATE_DEFAULT = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style25.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }

    function showtab(tab) {
	var i=0;
	var tabobj;
	var paneobj;
	for (i=0;i<10;i++) {
	    tabobj = document.getElementById('optstab'+i);
	    paneobj = document.getElementById('optspane'+i);
	    if (tab == i) {
		tabobj.className = 'raised';
		paneobj.style.display = '';
	    } else {
		tabobj.className = 'lowered';
		paneobj.style.display = 'none';
	    }
        }
	return false;
    }

function select_all(form_id, name, value) {
    var formblock= document.getElementById(form_id);
    var forminputs = formblock.getElementsByTagName('input');
    for (i = 0; i < forminputs.length; i++) {
	if (forminputs[i].getAttribute('name') == name) {
	    if (value == '1') {
		forminputs[i].checked = true;
	    } else {
		forminputs[i].checked = false;
	    }
	}
    }
}

--></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
'>
<div id="page">
<div id="header">
 <!-- Logo and page title -->
 <div id="logo">
  <a href="@HOMEPAGE@" title="PhEDEx Home Page"
    ><img src="@ROOTURL@phedex-logo-small.gif" alt="PhEDEx" height="80" /></a>
 </div> <!-- /logo -->

 <div id="heading">
  <h1 class="title">@PAGEHEADING@</h1>
  <div class="pagenav">
   @TOCSELECTOR@
   @PAGESELECTOR@
  </div> <!-- /pagenav -->
 </div> <!-- /heading -->
</div> <!-- /header -->

<!-- main content -->
<div id="content">
@THIS_IS_A_TEST@
@CONTENT@
</div>
</div> <!-- /page -->

<!-- side navigation panel -->
<div class="viewnav">
@DBSELECTOR@
@IDENTITY@
@MYPAGE@
</div>

<!-- options panel -->
<div id="opts" style="display:none;">
@OPTIONS@
</div>


</body>
</html>
END_OF_TEMPLATE

our $TEMPLATE_BARE = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }
   --></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
' style='background: none; margin: .5em'>

<!-- main content -->
<div id="content" style='border: none'>
@CONTENT@
</div>
</body>
</html>
END_OF_TEMPLATE

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};
  bless $self, $class;
  return $self;
}

sub initSecurityModule
{
    my ($self, $secmod_config) = @_;
    $$self{SECMOD} = new CMSWebTools::SecurityModule::Oracle({CONFIG => $secmod_config});
}

sub toc
{
  my ($self) = @_;
  my @result = ();
  foreach (keys %{Web25::})
  {
    next if ! /::$/;
    next if ! exists ${$Web25::{$_}}{TOC};
    push (@result, ${$Web25::{$_}}{TOC});
  }
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

sub index
{
  my ($self) = @_;
  my @result = ();

  # Get the type of dynamic type of this page and navigate to
  # the namespace scope just above it (e.g. Web25::Request::).
  no strict "refs";
  my $scope = ref $self;
  $scope =~ s/[^:]+$//;

  # Search the scope for sub-types with $INDEX.  These are
  # web pages we'll offer to make visible.
  foreach (keys %$scope)
  {
    push (@result, ${$$scope{$_}}{INDEX})
      if /::$/ && exists ${$$scope{$_}}{INDEX};
  }

  # Sort the pages by order tag.
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

# Return a hash of existing valid parameters
sub urlparams
{
  my ($self, @names) = @_;
  my %known = map { $_ => 1 } param();
  my %result = ();

  foreach my $name (@names)
  {
    $result{$name} = [ param($name) ]
      if exists $known{$name};
  }
  return %result;
}

# Return a URL to this page, i.e. a URL which would come back to this
# page, plus additional query parameters.  The page can be changed
# with "page" parametre and database instance with "db" parametre;
# these are automatically converted into script path components such
# that the final URL is "/path/to/script[/DB[/PAGE]][?QUERY]".
sub myurl
{
  my $self = shift(@_);

  my $curpage = param('page');
  my $curview = param('view');
  my $curlayout = param('layout');
  my $currefresh = param('refresh');
  my $cursecure = $$self{SECMOD}->isSecure();
  my $curquery = query_string();
  my %args = ('db' => $$self{DBID},
	      ($cursecure ? ('secure' => 1) : ()),
	      ($curview ? ('view' => $curview) : ()),
	      ($curpage ? ('page' => $curpage) : ()),
	      ($curlayout ? ('layout' => $curlayout) : ()),
	      ($currefresh ? ('refresh' => $currefresh) : ()),
	      @_);
  my $page = $args{'page'}; delete $args{'page'};
  my $db = $args{'db'}; delete $args{'db'};
  my $secure = $args{'secure'}; delete $args{'secure'};
  my $fullurl = $args{'fullurl'}; delete $args{'fullurl'};

  my $newcgi = new CGI ("");
  $newcgi->param ($_, ref $args{$_} ? @{$args{$_}} : $args{$_}) for keys %args;
  my $url = $$self{CONFIG}{SERVICE_PATH};
  my $q = $newcgi->query_string();

  if (($cursecure || 0) != ($secure || 0) 
      || $fullurl) {
      $url = $$self{CONFIG}{$secure ? "SSL_SERVER_ROOT" : "SERVER_ROOT"} . $url;
  }

  $url .= "/$db";
  $url .= "/$page" if $page;
  $url .= "?$q" if $q;
  
  return $url;
}



sub generate
{
  my ($self, $config, $db) = @_;
  $$self{CONFIG} = $config;
  $$self{DBID} = $db;

  # Fire up the security module
  $$self{SECMOD}->setPwdHandler($self->myurl('fullurl' => 1, 'secure' => 1, 'page'=>'Security::Password'));
  $$self{SECMOD}->setSignupHandler($self->myurl('fullurl' => 1, 'secure' => 0, 'page'=>'Security::SignUp'));
  $$self{SECMOD}->setReqCertFailHandler($self->myurl('fullurl' => 1, 'secure' => 0, 'page'=>'Security::SignUp'));
  $$self{SECMOD}->setCallerURL($self->myurl('fullurl' => 1));
  $$self{SECMOD}->init();

  # Find the class scope index of this page instance.
  my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

  # Force redirect to https if using http
  if ($$index{SECURE} && !$$self{SECMOD}->isSecure() && param('page') !~ /^Security/) {
      print redirect(-uri => $self->myurl("fullurl" => 1, "secure" => 1, "view" => "my"));
      return;
  }
  
  # Check if the client's identity was verified
  if ($$self{SECMOD}->isAuthenticated())
  {
    $$self{USER_NAME} = $$self{SECMOD}->getForename()." ".$$self{SECMOD}->getSurname();
    $$self{LOGIN_MESSAGE} =
	"<p>". &escapeHTML($$self{USER_NAME}) .
	" | <a href='" . $self->myurl("secure" => 1, "fullurl" => 1, "SecModLogout" => 1, page=>"Info::Main") . "'>Sign out</a></p>";
    if ($TESTING) {
	use Data::Dumper;
	my $roles = Dumper($$self{SECMOD}->getRoles());
	$$self{LOGIN_MESSAGE} .= "<p>$roles</p>", 
    }
  }
  else
  {
      $$self{LOGIN_MESSAGE} = 
	  "<p>Sign in ".
	  "<a href='" . $self->myurl("secure" => 1, "view" => "my") . "'>via Cert</a> or ".
	  "<a href='" . $self->myurl("secure" => 1, "view" => "my", "SecModPwd" => 1) . "'>via Password</a>".
	  "</p>";
  }
  my $login_state = $$self{SECMOD}->getAuthnState();
  if ($login_state eq 'cert') { $login_state = 'Logged in via Certificate'; }
  elsif ($login_state eq 'passwd') { $login_state = 'Logged in via Password'; }
  elsif ($login_state eq 'failed') { $login_state = 'Not logged in'; }
  $$self{LOGIN_MESSAGE} .= "<p>$login_state</p>";
  
  # Check whether we are looking at our vs. global view
  if (! $$self{SECMOD}->isAuthenticated() )
  {
      $$self{MY_VIEW} = 0;
      param('view', 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>global</strong></p>";
  }
    elsif (!param('view') || param('view') eq 'my')
  {
      $$self{MY_VIEW} = 1;
      my $otherurl = $self->myurl('view' => 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>my</strong> | <a href='$otherurl'>global</a></p>";
  }
  else
  {
      $$self{MY_VIEW} = 0;
      my $otherurl = $self->myurl('view' => 'my');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><a href='$otherurl'>my</a> | <strong>global</strong></p>";
  }

  # Select page we are visiting
  my %pagemap;
  my @pages = grep(${$$_}{LIST}, $self->index());
  foreach (@pages)
  {
    my ($name) = (*{$_}{PACKAGE} =~ /Web25::(.*)/);
    $pagemap{$_} = $name;
  }

  my $page = param('page');
  my @toc = $self->toc();
  my $cat = do {
    no strict "refs";
    my $scope = ref $self;
    $scope =~ s/[^:]+$//;
    exists $$scope{TOC} ? ${"${scope}TOC"} : undef
  };

  # Check if this is running against a test location and obnoxiously warn if so
  my $testwarn = "";
  my $pageheading = 'PhEDEx &#8211; CMS Data Transfers';
  if ($ENV{PHEDEX_DEV}) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $prod =~ s!/dev/$ENV{PHEDEX_DEV}/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a development server for <b>$ENV{PHEDEX_DEV}</b>. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>($ENV{PHEDEX_DEV}'s Development)</blink>";
  } elsif ($ENV{SCRIPT_NAME} =~ m!/test/!) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a test server for the developers. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>(TEST)</blink>";
  }

  # Initialise page template
  my $ndb = 0;
  my $replacements = {
    'THIS_IS_A_TEST' => $testwarn,
    'CONTENT' => '',
    'PAGETITLE' =>
      ($cat ? $$cat{TITLE} . " &#8211; " . $$index{TITLE} : $$index{TITLE}),
    'PAGEHEADING' => $pageheading,
    'HOMEPAGE' => $self->myurl('page'=>'Info::Main'),
    'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
    'DBTITLE' => $$config{INSTANCES}{$db}{TITLE},
    'ROOTURL' => "$$self{CONFIG}{SERVICE_PATH}/",
    'REFRESH' => (param('refresh') ? "<meta http-equiv='refresh' content='600'>" : ""),
    'DBSELECTOR' =>
      ("<div class='dbopt'>\n" .
       "<label>DB Instance:</label><strong>$$config{INSTANCES}{$db}{TITLE}</strong>&nbsp;" .
       "<a href='@{[$self->myurl('page'=>'DB')]}'" .
       " onclick='return hideshow(this,\"dbopts\",0)'>&#187;&#187;</a>\n" .
       "  <div id='dbopts' style='display:none'>\n" .
       "   <a class='closelink' href='#' onclick='return hideshow(this,\"dbopts\",0)'>[close]</a>\n" .
       join ("",
             map { &dblink ($self, $db, $_) . "<br />\n" }
	     sort { $$a{RANK} <=> $$b{RANK} }
	     grep($$_{ID} ne $db, values %{$$config{INSTANCES}})) .
       "  </div>\n" .
       " </div>"),
    'TOCSELECTOR' =>
      (@toc ?
       "<div class='catopt'>\n" .
       " <ul>\n" .
       join("", map { "  <li"
		      . ($cat && $$_ == $cat
			 ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
			 : (">" . &toclink($self, $_)))
		      . "</li>\n" } @toc) .
       " </ul>\n" .
       "</div>" : ""),
    'PAGESELECTOR' =>
      (@pages ?
       "<div class='menuopt'>\n" .
       " <ul>\n" .
       join("",
	    map { "  <li" .
		  ("Web25::$page" eq *{$_}{PACKAGE}
		   ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
		   : (">" . &pagelink($self, $_)))
		  . "</li>\n" }
	    @pages) .
       " </ul>\n" .
       "</div>" : ""),
    'IDENTITY' =>
      (" <div>\n" .
       "$$self{LOGIN_MESSAGE}\n" .
       " </div>"),
    'MYPAGE' => "<div>$$self{VIEW_MESSAGE}</div>",
  };

  # Hide these things on the password page
  if (param('page') eq 'Security::Password') { 
      $$replacements{MYPAGE} = '';
      $$replacements{IDENTITY} = '';
      $$replacements{DBSELECTOR} = '';
      $$replacements{PAGESELECTOR} = '';
      $$replacements{TOCSELECTOR} = '';
      $$replacements{THIS_IS_A_TEST} = '';
  }


  # Execute the desired page.  We save old STDOUT to print to it
  # later, then redirect the page routine's output to CONTENT.
  my ($output, $options) = ("", "");
  open ($$self{CONTENT}, ">", \$output);
  open ($$self{OPTIONS}, ">", \$options);
  eval
  {
    # Connect to the database, do the page, the disconnect
    if (! $$index{NOLOGIN})
    {
      eval
      {
	my $dbtns = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBNAME};
        my $dbuser = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBUSER};
        my $dbpass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBPASS};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;

	if (exists $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE}) {
	    my $role_name = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE};
	    my $role_pass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}

      };
      if ($@)
      {
	my $msg = $@;
	my $feedbackurl =
	  "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
	  . "PhEDEx%20web%20is%20inaccessible";

	print { $$self{CONTENT} }
	  "<center><div class='alert'>\n",
	  " <p>This PhEDEx instance is not available at this time.",
	  " Please try again at another time, or if the problem",
	  " persists and this is an instance you should be using,",
	  " please <a href='$feedbackurl'>notify the administrators</a>.",
	  "</p>",
          # "<p>The database error was: <i>", &escapeHTML($@), "</i></p>",
          "</div></center>\n";

	print STDERR "$0: Internal error: $msg\n";
	return;
      }
    }
    $self->output();
    if ($$self{DBH})
    {
      $$self{DBH}->disconnect() if $$self{DBH};
      delete $$self{DBH};
    }
  };
  if ($@)
  {
    my $message = $@;
    $message = &escapeHTML($message);

    my $feedbackurl =
      "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
      . "PhEDEx%20web%20server%20trouble";

    if ($message =~ /ORA-00942/) # table or view doesn't exist
    {
      print { $$self{CONTENT} }
        "<center><div class='warning'>\n",
        " <p>This PhEDEx instance is not capable of providing",
        " this feature.  Perhaps you meant to select another PhEDEx",
        " instance in the instance menu above?</p></div></center>\n";
    }
    else
    {
      print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Apologies, looks like we have an internal server error,",
        " details of which below.  If the problem persists, please",
        " <a href='$feedbackurl'>notify the administrators</a>.</p>\n",
        " <p><i>$message</i></p>\n",
        "</div></center>\n";
    }
  }
  close($$self{CONTENT});
  close($$self{OPTIONS});
  $$replacements{CONTENT} = join("\n", $output);
  $$replacements{OPTIONS} = join("\n", $options);

  # Instantiate the desired template and spit it out
  my $template = param('layout');
  $template = 'default'
    if (! $template || ! grep($template eq $_, qw(default bare)));

  my $result = ($template eq 'bare' ? $TEMPLATE_BARE : $TEMPLATE_DEFAULT);
  while (my ($key, $value) = each %$replacements)
  {
    $result =~ s/\@$key\@/$value/g;
  }

  # We need to set a cookie, if the security module orders us too
  if(( my $cookie = $$self{SECMOD}->getCookie() )) {
      print header(-type => 'text/html',-cookie => $cookie), $result;
  } else {
      print header(-type => 'text/html'), $result;
  }
}


1;

######################################################################
package Web25::Security::Password;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 0, NOLOGIN => 1, TITLE => "Password Sign-In" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $caller_url = param('caller_url');
    $caller_url =~ s,^http://[^/]+,$$self{CONFIG}{SSL_SERVER_ROOT},;
    my $msg = param('msg');

    print {$$self{CONTENT}} 
    "<h1>Password Sign-In</h1><br/>",
    "<p>Sign in with your CMS SiteDB/Hypernews password</p>",
    ($msg ? "<p style='color:red'>$msg</p>" : ''),
    "<form class='nice' method='post' action='$caller_url'>",
    "<label>Username</label>",textfield(-name=>'SecModLogin', -class=>'labeled'),"<br/>",
    "<label>Password</label>",password_field(-name=>'SecModPwd', -class=>'labeled'),"<br/>",
    "<label>&nbsp;</label>", submit(-name=>'Submit', -value=>'submit'),
    "</form>";
}

1;



######################################################################
package Web25::Security::SignUp;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 0, NOLOGIN => 1, TITLE => "Password Sign-In" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $caller_url = param('caller_url');

    my $sitedb = "<a href='$$self{CONFIG}{SITEDB_URL}'>SiteDB</a>";

    print {$$self{CONTENT}} 
    "<h1>Have You Signed Up?</h1><br/>",
    "<p class='blocktext'>You need to sign up with CMS Web Services in order to log in ",
    "and use privileged features.  Signing up can be done via ",
    "$sitedb.</p>",
    "<p class='blocktext'>If you have already signed up with SiteDB, it ",
    "is possible that your certificate or password information is out ",
    "of date there.  In that case go back to $sitedb and update your ",
    "information.</p>";
    

}

1;


######################################################################
package Web25::Info::Main;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 1, ORDER => 0, NOLOGIN => 1, TITLE => "Overview" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  no strict "refs";
  foreach my $toc ($self->toc())
  {
    next if ! ${$$toc}{LIST};
    my $type = *{$toc}{PACKAGE};
    print { $$self{CONTENT} }
      (${$$toc}{ORDER} % 3 ? "" : "<p style='clear: left'></p>\n"),
      "<div class='toc'>\n",
      " <h2>", &escapeHTML(${$$toc}{TITLE}), "</h2>\n",
      " <ul>\n";

    my @pages = ();
    my $scope = "${type}::";
    foreach (keys %$scope)
    {
      next if ! /::$/;
      next if ! exists ${$$scope{$_}}{INDEX};
      push(@pages, ${$$scope{$_}}{INDEX});
    }

    print { $$self{CONTENT} }
      map { "  <li>" . &pagelink($self, $_) . "</li>\n" }
      sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} }
      grep (${$$_}{LIST}, @pages);

    print { $$self{CONTENT} } " </ul>\n</div>";
  }
}

1;



######################################################################
package Web25::Info; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 0, TITLE => "Info" }; 1;

package Web25::Activity; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 1, TITLE => "Activity" }; 1;

package Web25::Data; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 2, TITLE => "Data" }; 1;

package Web25::Request; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 3, TITLE => "Requests" }; 1;

package Web25::Components; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 4, TITLE => "Components" }; 1;

package Web25::Reports; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 5, TITLE => "Reports" }; 1;


######################################################################
package Web25::Info::About; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "About",
	       LINK => "about.html",
	       LINK_TITLE => "General Information" };
1;

package Web25::Info::Documentation; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Documentation",
	       LINK => "documents.html",
	       LINK_TITLE => "READMEs and Other Documentation" };
1;

package Web25::Info::Presentations; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Presentations",
	       LINK => "presentations.html",
	       LINK_TITLE => "PhEDEx Presentations" };
1;

package Web25::Info::HyperNews; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "HyperNews Forum",
	       LINK => "https://hypernews.cern.ch/HyperNews/CMS/get/phedex.html",
	       LINK_TITLE => "Mailing List and HyperNews Forum" };
1;

package Web25::Info::Developers; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Developers",
	       LINK => "developers.html",
	       LINK_TITLE => "Developer info" };
1;

######################################################################
package Web25::Request::Page;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

our @reqstates = (
  { STATE => 0, RANK => 0, LABEL => "Pending approval" },
  { STATE => 2, RANK => 3, LABEL => "Partially disapproved" },
  { STATE => 3, RANK => 4, LABEL => "Partially approved" },
  { STATE => 4, RANK => 9, LABEL => "Disapproved" },
  { STATE => 5, RANK => 5, LABEL => "Approved" }
);
our %reqstatenames  = map { ($$_{STATE} => $$_{LABEL}) } @reqstates;
our %reqstatevalues = map { ($$_{LABEL} => $$_{STATE}) } @reqstates;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub logClientInfo
{
    my ($self) = @_;

    # Is there a case for logging anonymous access?
    # If so we will want to change this function...
    if (!$$self{SECMOD}->isAuthenticated()) { return undef; }

    my $identity = $self->fetch_identity();

    my $cid = &makeObjWithAttrs
	($$self{DBH}, "adm_contact", "contact", {},
	 "Remote host" => $ENV{HTTP_X_FORWARDED_FOR},
	 "User agent" => user_agent());
    
    my $client = &makeObjWithAttrs
	($$self{DBH}, "adm_client", undef,
	 { "identity" => $$identity{ID}, "contact" => $cid });
    
    return $client;
}


sub getClientData 
{
    my ($self, $clientid) = @_;
    my $contactsql = qq{ select name, value 
                             from t_adm_contact_attr con_attr 
                             join t_adm_contact con on con.id = con_attr.contact
                             join t_adm_client cli on cli.contact = con.id
			     where cli.id = :id order by con_attr.id};
    my $identsql  = qq{ select ident.name, ident.email, ident.dn, ident.certificate
                            from t_adm_identity ident
                            join t_adm_client cli on cli.identity = ident.id
			    where cli.id = :id order by ident.id};
    
    
    my %types = ('CONTACT_ATTR'  => $contactsql, 
		 'IDENTITY' => $identsql);
    
    my $result = {};
    
    while (my ($type, $sql) = each %types) {
	my $q = &dbexec($$self{DBH}, $sql, ':id' => $clientid);
	if ($type eq 'CONTACT_ATTR') {
	    $result->{$type} = {};
	    while (my ($name, $value) = $q->fetchrow_array()) {
		$result->{$type}->{$name} = $value;
	    }
	} elsif ($type eq 'IDENTITY') {
	    $result->{$type} = $q->fetchrow_hashref();
	}
    }
    return $result;
}

sub formatClientData
{
    my ($self, $data) = @_;
    my @html;
    
    my %nice_names = ('NAME' => 'Name',
		      'DN' => 'Distinguished name',
		      'EMAIL' => 'E-mail');
    foreach my $name (sort keys %{$data->{IDENTITY}}) {
	if ($name ne 'CERTIFICATE') {
	    push @html, "<label>$nice_names{$name}:</label><span class='labeled'>", 
	    ($data->{IDENTITY}->{$name} or 'Unknown'), "</span><br/>";
	} else {
	    push @html, "<label>Certificate:</label>";
	    if ($data->{IDENTITY}->{$name}) {
		push @html, 
		"<div class='labeled' style='height:100px;overflow:scroll;'><pre>", 
		$data->{IDENTITY}->{$name},
		"</pre></div><br/>";
	    } else { push @html, "<div class='labeled'>Unavailable</div><br/>"; }
	}
    }
    
    foreach my $name (sort keys %{$data->{CONTACT_ATTR}}) {
	push @html, "<label>$name:</label><span class='labeled'>", 
	($data->{CONTACT_ATTR}->{$name} or 'Unknown'), "</span><br/>";
    }
    
    return @html;
}


sub formatAction
{
    my ($self, $aid, $action, $tid) = @_;
    my @html;

    my $actionid = "action$aid";
    my $actionclientid = "actionclient$aid";
    if ($tid) {
	$actionid = "task$tid".$actionid;
	$actionclientid = "task$tid".$actionclientid;
    }

    push @html,
    "<h1><a href='#' onclick='return hideshow(this,\"$actionid\",0)'>",
    $$action{ACTION_NAME}, "</a></h1>",
    "<div id='$actionid' style='display:none;'>",
    "<label>Time:</label>", "<span class='labeled'>", &formatTime($$action{ACTION_TIME}, 'stamp'), "</span><br/>",
    "<label>Client:</label>", "<span class='labeled'>",
    "<a href='#' onclick='return hideshow(this, \"$actionclientid\", 0)'>",
    ($$action{ACTION_CREATOR}{IDENTITY}{NAME} or 'Unknown'), "</a></span><br/>",
    "<div id='$actionclientid' class='hideaway' style='display:none;'>",
    $self->formatClientData($$action{ACTION_CREATOR}),
    "</div>";
    
    sub formatAttr
    {
	my $attr = shift;
	if ($$attr{NAME} eq 'Priority') {
	    my $fmt = { 0 => 'High', 1 => 'Normal', 2 => 'Low' };
	    return $$fmt{$$attr{VALUE}};
	} elsif ($$attr{NAME} eq 'Transient' or 'Move') {
	    return &yesno($$attr{VALUE});
	}
	return $$attr{VALUE};
    }

    foreach my $attr (@{ $$action{ATTR} } ) {
	next unless $$attr{VALUE};
	my $commentclass = (grep $$attr{NAME} eq $_,  qw(Comment Message)) ? ' comment' : '';
	push @html, "<label>$$attr{NAME}:</label><span class='labeled$commentclass'>", &formatAttr($attr),"</span><br/>";
    }
    
    push @html, "</div>";

    return @html;
}

1;

######################################################################
package Web25::Request::Main;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 0, TITLE => "Overview",
	       LINK_TITLE => "Quick overview of transfer requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my ($qtask, $qreq);
  if ($$self{MY_VIEW}) {
      my $identity = $self->fetch_identity();
      
      $qtask = &dbexec($$self{DBH},
		     qq{ select count(t.id)
			     from t_req_task t
			     where t.person = :identity },
		     ":identity" => $$identity{ID});

    $qreq = &dbexec($$self{DBH}, qq{
	select req.state, count(req.id)
	    from t_adm_client c
	    join t_req_request req on req.creator = c.id
	    where c.identity = :identity
	    group by req.state},
		    ":identity" => $$identity{ID});
  } else {
    $qtask = &dbexec($$self{DBH}, qq{
      select count(t.id) from t_req_task t});

    $qreq = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      group by req.state});
  }

  my ($tasks) = $qtask->fetchrow();
  my $your = $$self{MY_VIEW} ? "Your" : "All";
  print { $$self{CONTENT} }
    "<div align='left'>",
    "<p><a href='@{[$self->myurl('page' => 'Request::Admin')]}'>$your pending tasks</a></p>\n",
    "<ul>\n",
    " <li> ", ($tasks ? "$tasks Tasks" : "None"), "</li>\n",
    "</ul>\n",
    "<p><a href='@{[$self->myurl('page' => 'Request::Requests')]}'>$your transfer requests</a></p>\n",
    "<ul>\n";

  my $n = 0;
  my %status = ();
  while (my ($state, $count) = $qreq->fetchrow())
  {
    $status{$state} = $count;
  }

  foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
  {
    my $s = $$state{STATE};
    next if ! $status{$s};
    print { $$self{CONTENT} } " <li> $status{$s} $$state{LABEL}</li>\n";
    $n += $status{$s};
  }

  print { $$self{CONTENT} } "</div>\n";
}

1;

######################################################################
package Web25::Request::Admin;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Administer Requests",
	       LINK_TITLE => "Browse and carry out pending tasks",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $task = param('task');

  my @where;  my %binds;
  my $identity = $self->fetch_identity()->{ID};

  if ($$self{MY_VIEW}) {
      push @where, qq{ t.person = :identity };
      $binds{':identity'} = $identity;
  }

  if ($task) {
      push @where, 't.id = :task';
      $binds{':task'} = $task;
  }

  my $where_bit = @where ? 'where '.join(' and ', @where) : '';

  my $sql = qq{
      select t.id tid, a.id aid, r.id rid, i.name assigned_to, i.id assigned_to_id, t.time_create, r.state, r.creator,
             a.action, a.time_apply, a.client, a_attr.name, a_attr.value
      from t_req_task t
      join t_adm_identity i on t.person = i.id
      join t_req_action a on a.id = t.action
      join t_req_request r on r.id = a.request
      left join t_req_action_attr a_attr on a_attr.action = a.id
      $where_bit
      order by t.id desc, a.time_apply, a_attr.id};

  my $pager = new Web25::QueryPager;
  $pager->init($self, $sql, {%binds}, 10, 'tid desc');
  my $n_tasks = $pager->get_total_results();
  
  if (! $n_tasks) {
      print { $$self{CONTENT} } "<p>No tasks to show.</p>";
      return;
  }

  print {$$self{CONTENT}} $pager->pager();
  my $qtask = $pager->paged_result();

  my $n = 0;
  my $oldtid = -1;
  my $oldaid = -1;
  my %task;
  while (my ($tid, $aid, $rid, $tassigned, $tassigned_id, $tcreate, $rstate, $rcreator,
	     $action, $atime, $aclient, $name, $value) = $qtask->fetchrow()) {
      if ($oldtid != $tid) {
	  $task{$tid}{TASK_ASSIGNED} = $tassigned;
	  $task{$tid}{TASK_ASSIGNED_ID} = $tassigned_id;
	  $task{$tid}{TASK_CREATED}  = $tcreate;
	  $task{$tid}{REQUEST_ID} = $rid;
	  $task{$tid}{REQUEST_STATE} = $rstate;
	  $task{$tid}{REQUEST_CREATOR} = $self->getClientData($rcreator);
      }
      if ($oldtid != $tid || $oldaid != $aid) {
	  $task{$tid}{ACTIONS}{$aid}{ACTION_NAME} = $action;
	  $task{$tid}{ACTIONS}{$aid}{ACTION_TIME} = $atime;
	  $task{$tid}{ACTIONS}{$aid}{ACTION_CREATOR} = $self->getClientData($aclient);
	  $task{$tid}{ACTIONS}{$aid}{ATTR} = [];
      }
      push @{$task{$tid}{ACTIONS}{$aid}{ATTR}}, {NAME=> $name, VALUE=> $value};
      $oldtid = $tid;
      $oldaid = $aid;
      ++$n;
  }

  if (! $n) {
      print { $$self{CONTENT} } "<p>No pending tasks to show.</p>";
      return;
  }

  foreach my $tid (reverse sort { $a <=> $b } keys %task) {
      my $details_url = $self->myurl(page => 'Request::Detail', 'request' => $task{$tid}{REQUEST_ID});

      print { $$self{CONTENT} } 
      "<div class='nice paramblock lev1'>",
      "<h1>Task $tid</h1>",
      "<label>Task Assigned to:</label>", "<span class='labeled'>", $task{$tid}{TASK_ASSIGNED}, "</span><br/>",
      "<label>Task Created:</label>", "<span class='labeled'>", &formatTime($task{$tid}{TASK_CREATED}, 'stamp' ), "</span><br/>",
      "<label>Request #:</label><span class='labeled'>", $task{$tid}{REQUEST_ID}, "<a href='$details_url'>(details)</a></span><br/>",
      "<label>Requestor:</label>", "<span class='labeled'>",
      "<a href='#' onclick='return hideshow(this, \"creator$tid\", 0)'>",
      ($task{$tid}{REQUEST_CREATOR}{IDENTITY}{NAME} or 'Unknown'), "</a></span><br/>",
      "<div id='creator$tid' class='hideaway' style='display:none;'>",
      $self->formatClientData($task{$tid}{REQUEST_CREATOR}),
      "</div>",
      "<label>Request State:</label>", "<span class='labeled'>", $reqstatenames{$task{$tid}{REQUEST_STATE}}, "</span><br/>";

      foreach my $aid (sort { $task{$tid}{ACTIONS}{$a}{ACTION_TIME} <=>
			      $task{$tid}{ACTIONS}{$b}{ACTION_TIME} } keys %{$task{$tid}{ACTIONS}}) {
	  print { $$self{CONTENT} }
	  "<div class='paramblock lev2'>",
	  $self->formatAction($aid, $task{$tid}{ACTIONS}{$aid}, $tid),
	  "</div>";

	  if ($task{$tid}{TASK_ASSIGNED_ID} == $identity
	      && $task{$tid}{ACTIONS}{$aid}{ACTION_NAME} eq 'Created') {
	      my @destinations;
	      foreach my $attr (@{$task{$tid}{ACTIONS}{$aid}{ATTR}}) {
		  if ($$attr{NAME} eq 'Destination Node') {
		      push @destinations, $$attr{VALUE};
		  }
	      }

	      my @auth_nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');

	      my @auth_dests;
	      foreach my $dest (@destinations) {
		  push @auth_dests, $dest if grep $dest eq $_, @auth_nodes;
	      }

	      my $formurl = $self->myurl(page=>'Request::NewAction');
	      print { $$self{CONTENT} }
	      "<form method='post' action='$formurl'>",
	      hidden(-name=>'request', -value=>$task{$tid}{REQUEST_ID}),
	      hidden(-name=>'task', -value=>$tid),
	      hidden(-name=>'action', -value=>$aid),
	      "<label>Next Action:</label>",
	      popup_menu(-name=>'newaction', 
			 -values=>['subscribe', 'disapprove'],
			 -labels=>{'subscribe' => 'Subscribe',
				   'disapprove' => 'Disapprove'},
			 -class=>'labeled'
			 ),
			     "<br/><label>For Nodes:</label>", checkbox_group(-name=>'nodes',
									      -values=>[@auth_dests],
									      -default=>[@auth_dests],
									      -class=>'labeled',
									      -columns=>3
									      ),
	      "<label>Comment:<br/><span class='note'>(Optional)</span></label>",
	      textarea(-name=>'comment', -rows=>10, -cols=>60, -class=>'labeled'), "<br/>",
			     "<label>&nbsp;</label>",
			     submit(-value=>'Submit', -class=>'labeled'), "<br/>",
	      "</form>";
	  }
      }
      print { $$self{CONTENT} } "</div>"; # close task
  }
  print {$$self{CONTENT}} $pager->pager();
}



1;

######################################################################
package Web25::Request::NewAction;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 0, ORDER => 100, TITLE => "New Action",
	       LINK_TITLE => "Create a new action on a task",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    
    my $newaction = param('newaction');
    my $oldaction = param('action');
    my $request = param('request');
    my $person = $self->fetch_identity()->{ID};
    my $task = param('task');
    my @nodes = param('nodes');
    my $comment = param('comment');

    if (!$newaction || !$request || !$task || !$person) {
	alert('Missing parameters');
	return;
    }

    # Check that the user is authorized to approve/deny requests
    unless ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Global Admin', 'phedex') || $$self{SECMOD}->hasRole('Data Manager'))) {
	$self->auth_help('approve requests' => ['cert', 'Data Manager', 'Global Admin']);
	return;
    }

    # Check that some nodes have been selected
    unless (@nodes) {
	$self->alert("No nodes selected for this action.  Please go back and select some nodes");
	return;
    }

    # Check that the user is authorized to act on these nodes
    my @auth_nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');
    foreach my $node (@nodes) {
	if (! grep $node eq $_, @auth_nodes) {
	    $self->alert("You are not authorized to approve requests for the node '$node'");
	    return;
	}
    }

    my @action_attr;
    my $newactionname;
    my $now = time();
    
    foreach my $node (@nodes) {
	push @action_attr, ('For Node' => $node);
    }

    if ($comment) {
	push @action_attr, ('Comment' => $comment);
    }
    
    if ($newaction eq 'subscribe') {
	$newactionname = 'Subscribed';
	my $n_subs = &subscribe_request($$self{DBH}, $request, [@nodes], $now);
	if ($n_subs == 0) {
	    my $msg = 'Warning:  Request approval did not create any new subscriptions.  Possible reasons are:  '.
		'1. All data items requested were already subscribed via another request or '.
		'2. The data items are no longer known to phedex.';
	    $self->note($msg);
	    push @action_attr, ('Message', $msg);
	}
    } elsif ($newaction eq 'disapprove') {
	unless (&disapprove_request($$self{DBH}, $request, [@nodes], $now)) {
	    $self->alert("Disapproval failed.  Please notify the developers.");
	    return;
	}
	$newactionname = 'Disapproved';
    } else { &alert("Unknown action type '$newaction'"); return; }
    
    my $client = $self->logClientInfo();

    my $aid = &makeObjWithAttrs
	($$self{DBH}, "req_action", "action",
	 { "request" => $request,
	   "action" => $newactionname,
	   "client" => $client,
	   "time_apply" => $now },
	 @action_attr
	 );

    my $newstate = &get_request_state($$self{DBH}, $request);

    # If the request has been handled for all nodes, we delete all
    # tasks associated with this request.  Otherwise, we only delete
    # the task for the current user.
    if ($newstate !~ /^Partially/) {
	&dbexec($$self{DBH}, qq{delete from t_req_task where action = :aid},
		':aid' => $oldaction);
    } else {
	&dbexec($$self{DBH}, qq{delete from t_req_task where action = :aid and person = :person},
		':aid' => $oldaction, ':person' => $person);
    }

    # Update the state
    &dbexec($$self{DBH}, qq{update t_req_request set state = :newstate where id = :request},
	    ':newstate' => $reqstatevalues{$newstate}, ':request' => $request);

    $$self{DBH}->commit();
    
    print { $$self{CONTENT} }
    "<h1>Task Completed</h1>",
    "<p>You have $newactionname request \#$request for ",
    join(", ", @nodes),".</p>";
    
    my $q = &dbexec($$self{DBH}, 
		    qq{ select creator from t_req_request where id = :id },
		    ':id' => $request);

    my ($creator_id) = $q->fetchrow();
    my $creator_data = $self->getClientData($creator_id);
    my $creator_name = $$creator_data{IDENTITY}{NAME};
    my $creator_email = $$creator_data{IDENTITY}{EMAIL};
    my $detail_url = $self->myurl(page => 'Request::Requests', request => $request, fullurl => 1);
    my $admin_email = $$self{SECMOD}->getEmail();
    my $msg_comment = ($comment ? "\nThe person who handled this had the following comment:\n\n\"$comment\"\n" : '');
    my $nodes_str = join(', ', @nodes);

    my $message=<<ENDEMAIL;
Dear $creator_name,

Your request \#$request has been $newactionname by $$self{USER_NAME} for $nodes_str.
$msg_comment
This request is now $newstate.

To review details of the request, please go to:

$detail_url

To inquire further about this request, you may reply to this email.

Yours truly,
  PhEDEx transfer request webpage

ENDEMAIL

    send_email(subject => "PhEDEx Request $newactionname (request \#$request)",
	       to => [ $creator_email ],
	       from => "PhEDEx Web Requests <$$self{CONFIG}{FEEDBACK_MAIL}>",
	       replyto => [ $admin_email ],
	       message => $message
	      );
}


sub subscribe_request
{
    my ($dbh, $request, $nodes, $now) = @_;

    my ($node_list, %node_binds) = &dbinlist('node', @{$nodes});

    my ($sth, $rv) = &dbexec($dbh,
	    qq[ insert into t_dps_subscription 
		  (dataset, block, destination, priority, is_move, is_transient, time_create)
		select dataset, block, destination, priority, is_move, is_transient, time_create
                 from (
		select ds.id dataset, NULL block, dest.destination, priority, is_move, is_transient, :now time_create
		  from t_req_info_dest dest
		  join t_req_info_dataset req_ds on dest.request = req_ds.request
		  join t_dps_dataset ds on req_ds.dataset = ds.name
                  join t_dps_dbs dbs on ds.dbs = dbs.id
		 where dest.request = :rid and dbs.name = req_ds.dbs
                   and req_ds.dps_isknown = 'y' and req_ds.dbs_isknown = 'y'
                union
                select NULL dataset, b.id block, dest.destination, priority, is_move, is_transient, :now time_create
                  from t_req_info_dest dest
		  join t_req_info_block req_b on dest.request = req_b.request
                  join t_dps_block b on req_b.block = b.name
		  join t_dps_dataset ds on b.dataset = ds.id
                  join t_dps_dbs dbs on ds.dbs = dbs.id
		 where dest.request = :rid and dbs.name = req_b.dbs
                   and req_b.dps_isknown = 'y' and req_b.dbs_isknown = 'y' 
		) requests
                join t_adm_node n on n.id = requests.destination
                where n.name in ($node_list)
                and not exists (select 1 from t_dps_subscription s 
                                 where s.dataset = requests.dataset
                                       and (s.block = requests.block
                                            or s.destination = requests.destination)) ],
	    ':now' => $now,
	    ':rid' => $request,
	    ':now' => $now,
	    ':rid' => $request,
	     %node_binds);

    return (!$rv || $rv == 0) ? 0 : $rv;
}


sub disapprove_request
{
    return 1;
}

sub get_request_state
{
    my ($dbh, $request) = @_;

    my $sql = qq{
      select create_attr.value dest, subs_attr.value subscribed, dis_attr.value disapproved
       from t_req_action create_act join t_req_action_attr create_attr
              on create_attr.action = create_act.id 
                 and create_act.action = 'Created' and create_attr.name = 'Destination Node'
            left join (
              t_req_action subs_act join t_req_action_attr subs_attr
              on subs_attr.action = subs_act.id
                 and subs_act.action = 'Subscribed' and subs_attr.name = 'For Node'
            ) on subs_act.request = create_act.request and subs_attr.value = create_attr.value
            left join (
              t_req_action dis_act join t_req_action_attr dis_attr
              on dis_attr.action = dis_act.id
                 and dis_act.action = 'Disapproved' and dis_attr.name = 'For Node'
            ) on dis_act.request = create_act.request and dis_attr.value = create_attr.value
      where create_act.request = :request
  };

    my $q = &dbexec($dbh, $sql, ':request' => $request);
    
    my $res = {};
    my ($n_dest, $n_subs, $n_dis) = (0) x 3;
    while (my ($dest, $subs, $dis) = $q->fetchrow()) {
	$$res{$dest} = { 'SUBSCRIBED' => $subs, 'DISAPPROVED' => $dis };
	$n_dest++;
	$n_subs++ if $subs;
	$n_dis++ if $dis;
    }

    my $state;
    if    ($n_dest == $n_subs)          { $state = 'Approved'; }
    elsif ($n_dest == $n_dis)           { $state = 'Disapproved'; }
    elsif ($n_subs == 0 && $n_dis == 0) { $state = 'Pending approval'; }
    elsif ($n_subs !=0)                 { $state = 'Partially approved'; }
    elsif ($n_dis !=0)                  { $state = 'Partially disapproved'; }

    return wantarray ? ($state, $res) : $state;
}

1;



######################################################################
package Web25::Request::Requests;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "View Requests",
	       LINK_TITLE => "Browse requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $request = param('request');

    my @where; my %binds;
    if ($$self{MY_VIEW}) {
	push @where, 'ident.id = :identity';
	$binds{':identity'} = $self->fetch_identity()->{ID};
    }

    if ($request) {
	push @where, 'r.id = :request';
	$binds{':request'} = $request;
    }

    my $where_bit = @where ? 'where '.join(' and ', @where) : '';

    my $sql = qq{
      select r.id rid, r.state, r.creator, a.id aid, a.action, a.time_apply, a.client, a_attr.name, a_attr.value
      from t_req_request r
      join t_req_action a on a.request = r.id
      join t_adm_client client on client.id = r.creator
      join t_adm_identity ident on ident.id = client.identity
      left join t_req_action_attr a_attr on a_attr.action = a.id
      $where_bit
      order by r.id desc, a.time_apply, a_attr.id};

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, {%binds}, 10, 'rid desc');
    my $n_requests = $pager->get_total_results();

    if (! $n_requests) {
	print { $$self{CONTENT} } "<p>No requests to show.</p>";
	return;
    }

    print {$$self{CONTENT}} $pager->pager();
    my $qreq = $pager->paged_result();

    my $n = 0;
    my $oldrid = -1;
    my $oldaid = -1;
    my %req;
    while (my ($rid, $rstate, $rcreator, $aid, $action, $atime, $aclient, $name, $value) = $qreq->fetchrow()) {
	if ($oldrid != $rid) {
	    $req{$rid}{REQUEST_STATE} = $rstate;
	    $req{$rid}{REQUEST_CREATOR} = $self->getClientData($rcreator);
	}
	if ($oldaid != $aid) {
	    $req{$rid}{ACTIONS}{$aid}{ACTION_NAME} = $action;
	    $req{$rid}{ACTIONS}{$aid}{ACTION_TIME} = $atime;
	    $req{$rid}{ACTIONS}{$aid}{ACTION_CREATOR} = $self->getClientData($aclient);
	    $req{$rid}{ACTIONS}{$aid}{ATTR} = [];
	}
	push @{$req{$rid}{ACTIONS}{$aid}{ATTR}}, {NAME=> $name, VALUE=> $value} if ($name);
	$oldrid = $rid;
	$oldaid = $aid;
	++$n;
    }

  foreach my $rid (reverse sort { $a <=> $b } keys %req) {
      my $details_url = $self->myurl(page => 'Request::Detail', 'request' => $rid);
      print { $$self{CONTENT} } 
      "<div class='nice paramblock lev1'>",
      "<h1>Request $rid <a href='$details_url'>(details)</a></h1>",
      "<label>Requestor:</label>", "<span class='labeled'>",
      "<a href='#' onclick='return hideshow(this, \"creator$rid\", 0)'>",
      ($req{$rid}{REQUEST_CREATOR}{IDENTITY}{NAME} or 'Unknown'), "</a></span><br/>",
      "<div id='creator$rid' class='hideaway' style='display:none;'>",
      $self->formatClientData($req{$rid}{REQUEST_CREATOR}),
      "</div>",
      "<label>Request State:</label>", "<span class='labeled'>", $reqstatenames{$req{$rid}{REQUEST_STATE}}, "</span><br/>";

      foreach my $aid (sort { $req{$rid}{ACTIONS}{$a}{ACTION_TIME} <=>
			      $req{$rid}{ACTIONS}{$b}{ACTION_TIME} } keys %{$req{$rid}{ACTIONS}}) {
 	  print { $$self{CONTENT} }
 	  "<div class='paramblock lev2'>",
	  $self->formatAction($aid, $req{$rid}{ACTIONS}{$aid}),
 	  "</div>";
      }

      print { $$self{CONTENT} } "</div>";
  }
    print {$$self{CONTENT}} $pager->pager();
}


1;

######################################################################
package Web25::Request::Detail;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Request Details",
	       LINK_TITLE => "Explore request details",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $request = param('request');
  my $where_bit = $request ? 'where req.id = :request' : '';
  my %binds = $request ? (':request' => $request) : ();

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $req_info = {};
  my $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id, req.creator creator_id, req.state req_state,
                             ident.dn requestor,
		             req_info.time_update updated
		        from t_req_request req
                        join t_adm_client client on client.id = req.creator
                        join t_adm_identity ident on ident.id = client.identity
		        join t_req_info req_info on req_info.request = req.id
		        $where_bit ], %binds);

  while (my $row = $q->fetchrow_hashref()) {
      $$req_info{$$row{REQ_ID}} = $row;
  }

  my $req_dest = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id, node.name dest_name
		        from t_req_request req
		        join t_req_info_dest req_dest on req_dest.request = req.id
		        join t_adm_node node on node.id = req_dest.destination
		      $where_bit ], %binds);

  while (my ($rid, $node) = $q->fetchrow()) {
      if (!exists $$req_dest{$rid}) {
	  $$req_dest{$rid} = [];
      }
      push @{$$req_dest{$rid}}, $node;
  }

  my $req_datasets = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id,
		             req_ds.dbs req_dbs, req_ds.dataset, req_ds.dbs_isknown, req_ds.dps_isknown
		        from t_req_request req
		        join t_req_info_dataset req_ds on req_ds.request = req.id
		      $where_bit ], %binds);

  while (my ($rid, $dbs, $dataset, $dbs_isknown, $dps_isknown) = $q->fetchrow()) {
      $$req_datasets{$rid}{$dataset} = { DBS => $dbs,
					 DBS_ISKNOWN => $dbs_isknown,
					 DPS_ISKNOWN => $dps_isknown };
  }

  my $req_blocks = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id,
		             req_b.dbs req_dbs, req_b.block, req_b.dbs_isknown, req_b.dps_isknown
		        from t_req_request req
		        join t_req_info_block req_b on req_b.request = req.id
		      ]);

  while (my ($rid, $dbs, $block, $dbs_isknown, $dps_isknown) = $q->fetchrow()) {
      $$req_blocks{$rid}{$block} = { DBS => $dbs,
				     DBS_ISKNOWN => $dbs_isknown,
				     DPS_ISKNOWN => $dps_isknown };
  }

  my $table = new Web25::TableSpool;
  $table->set_filehandle( $$self{ CONTENT } );

  $table->set_querycols( [('Request #', 'col', 'REQUEST', 1)],
			 [('DBS', 'col', 'DBS', 1)],
			 [('Data Item', 'col', 'DATA_ITEM', 1)],
			 [('Destinations', 'col', 'DESTINATIONS', 1)],
			 [('Requestor', 'col', 'REQUESTOR', 1)],
			 [('Updated', 'col', 'UPDATED', 1)],
			 [('Known to DBS?', 'col', 'DBS_ISKNOWN', 1)],
			 [('Known to PhEDEx?', 'col', 'DPS_ISKNOWN', 1)]
			 );

  $table->set_tablehead({ REQUEST => 'Request #',
			      DBS => 'DBS',
			      DATA_ITEM => 'Data Item',
			      DESTINATIONS => 'Destinations',
			      REQUESTOR => 'Requestor',
			      UPDATED => 'Request Updated',
			      DBS_ISKNOWN => 'Known to DBS?',
			      DPS_ISKNOWN => 'Known to PhEDEx?' });


  $table->set_tableclass('data');
  $table->set_stripeclass('stripe');

  $table->set_dataformats({ REQUESTOR => \&dn_to_human_name,
			    UPDATED   => sub { &formatTime($_[0], 'stamp') },
			    DBS_ISKNOWN => \&yesno,
			    DPS_ISKNOWN => \&yesno
			});

  $table->set_cellformats({DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			   DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});

  $table->start();
  $table->head();

  foreach my $rid (reverse sort { $a <=> $b } keys %{$req_info}) {
      my $dests = join ', ', @{$$req_dest{$rid}};
      my $row = { REQUEST => $rid, DESTINATIONS => $dests };
      $$row{$_} = $$req_info{$rid}{$_} foreach (qw(REQUESTOR UPDATED));
      
      foreach my $dataset (sort keys %{$$req_datasets{$rid}}) {
	  $$row{DATA_ITEM} = $dataset;
	  $$row{$_} = $$req_datasets{$rid}{$dataset}{$_} foreach(qw(DBS DBS_ISKNOWN DPS_ISKNOWN));
	  $table->row($row);
      }

      foreach my $block (sort keys %{$$req_blocks{$rid}}) {
	  $$row{DATA_ITEM} = $block;
	  $$row{$_} = $$req_blocks{$rid}{$block}{$_} foreach(qw(DBS DBS_ISKNOWN DPS_ISKNOWN));
	  $table->row($row);
      }
  }

  $table->finish();

  #  Options form
  my $optspane = new Web25::OptsPane;
  $optspane->add_hidden( hidden('request', $request) ) if $request;
  my $target = $self->myurl();
  $optspane->set_form_target($target);
  
  my $form = $table->columns_form();
  $optspane->add_tab('Columns', $form);
  
  print { $$self{OPTIONS} } $optspane->output();

}



1;

######################################################################
package Web25::Request::CreateTools;
use strict; use warnings;
use base "Exporter";
import Web25::Common;
use CGI qw(:standard);
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} 
	|| "./"; $__scriptdir =~ s,[^/]+$,,;
	unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;

our @EXPORT = qw(get_request_nodes
		 create_check_access
		 create_check_identity
		 create_check_email
		 create_check_comment
		 create_check_dbs
		 create_check_data
		 create_check_dest
		 create_check_options
		 create_check_bad
);

sub get_request_nodes
{
    my ($self) = shift @_;
    my %nodes = $self->fetch_nodes(with_ids=>1);
    foreach my $node (keys %nodes) {
	delete $nodes{$node} if ($node =~ /(.*)_(Buffer|Stage)$/ && exists $nodes{"$1_MSS"});
    }
    return sort keys %nodes;
}

sub create_check_access
{
  my ($self, $bad) = @_;
  return if $$bad;

  if (request_method() ne 'POST')
  {
    alert($self, "This form can only be accessed with 'POST' method.");
    $$bad = 1;
  }
}

sub create_check_identity
{
  my ($self, $bad) = @_;
  return if $$bad;

  # Make sure this page can be used
  if (! $$self{SECMOD}->isAuthenticated() ) {
      $self->auth_help('create a transfer request' => ['anyauth']);
      $$bad = 1;
      return;
  }
}

sub create_check_email
{
  my ($self, $bad, $email) = @_;
  return undef if $$bad;

  if (! $email)
  {
    alert($self, "No requestor e-mail, please supply one.");
    $$bad = 1;
    return undef;
  }

  my ($nrvalidmails, @emails) = validlist ($email);
  if ($email ne '' && ! $nrvalidmails)
  {
    alert($self, "Requestor e-mail &ldquo;@{[&escapeHTML($email)]}&rdquo; is",
	  " not a valid RFC822 e-mail address or address list.");
    $$bad = 1;
  }

    return $$bad ? undef : $email;
}

sub create_check_comment
{
  my ($self, $bad, $comment) = @_;
  return undef if $$bad;
  return $comment;
}

sub create_check_dbs
{
  my ($self, $bad, $dbs) = @_;
  return undef if $$bad;
  if (! $dbs)
  {
    alert($self, "No DBS selected, please choose a value.");
    $$bad = 1;
    return undef;
  }

  if ($dbs !~ m|^[-=+_:/?&;.a-zA-Z0-9]+$|)
  {
    alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	  " contains unsafe characters.");
    $$bad = 1;
  }

  my $SAFE_HOST = "[-A-Za-z0-9_+.]+";
  my $SAFE_PATH = "[-A-Za-z0-9_+.:/&%;]*";
  if ($dbs !~ m,^https?://($SAFE_HOST)(:\d+)?/($SAFE_PATH)\?.*instance=$SAFE_PATH$,)
  {
      my @dbses = $self->fetch_dbses();
      if (! grep($_ eq $dbs, @dbses))
    {
      alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " is not a URL for a DBS service.  Please use a URL of",
	    " the form http://server/path?instance=name.");
      $$bad = 1;
    }
  }
  else
  {
    my $hostname = $1;
    my ($name,$aliases,$addrtype,$length,@addrs)
      = CORE::gethostbyname($hostname);
    if (! $name)
    {
      alert($self, "The host name of the DBS service, &ldquo;",
	    &escapeHTML($hostname), "&rdquo;, did not resolve.",
	    " Please make sure the host is accessible.");
      $$bad = 1;
    }

    my $info = qx(wget -qO- '$dbs;api=listPrimaryDatasets;pattern=/zilch');
    if (! $info || $info !~ /<dbs>/s)
    {
      alert($self, "The DBS contact, &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " does not respond to aliveness check.  Please make sure",
	    " the contact URL points to a correct service.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : $dbs;
}



sub create_check_data
{
  my ($self, $bad, $data) = @_;
  return undef if $$bad;

  my %userdata = $self->parse_userdata($data);
  if (! %userdata) {
    alert($self, "No data specified.");
    $$bad = 1;
  }

  foreach my $data (keys %userdata) {
      if (! $userdata{$data} ) {
	  $self->alert("The data pattern is &ldquo;@{[&escapeHTML($data)]}&rdquo;",
		       " does not match pattern of type /PRIMARY/TIER/DATASET or /PRIMARY/DATASET#BLOCK.");
	  $$bad = 1;
      }
  }

  return $$bad ? undef : keys %userdata;
}

sub create_check_dest
{
  my ($self, $bad, @dests) = @_;
  return undef if $$bad;

  if (! @dests)
  {
    alert($self, "No destination selected, please select some.");
    $$bad = 1;
    return undef;
  }

  my @nodes = $self->get_request_nodes();

  foreach my $node (@dests)
  {
    if (! grep ($_ eq $node, @nodes))
    {
      alert($self, "Node name &ldquo;@{[&escapeHTML($node)]}&rdquo;",
	    " is not known to PhEDEx.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : sort @dests;
}

sub create_check_options
{
  my ($self, $bad) = @_;
  return undef if $$bad;

  my $opts = {};

  foreach ('is_move', 'is_transient') {
      if (!param($_) && param($_) !~ /^[yn]$/) {
	  $self->alert("Option '$_' missing or illegal value");
	  $$bad = 0;
	  return undef;
      }
  }
  
  if (!param('priority') && param('priority') !~ /^[012]$/) {
      $self->alert("Option 'priority' missing or illegal value");
      $$bad = 0;
      return undef;
  }
  return (param('is_move'), param('is_transient'), param('priority'));
}

sub create_check_bad
{
  my ($self, $bad) = @_;
  print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n" if $bad;
  return $bad;
}

1;

######################################################################
package Web25::Request::Create;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Create Request",
	       LINK_TITLE => "Create a new transfer request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  return if $bad;

  my $email_contact = $$self{SECMOD}->getEmail();
  
  my @dbsnames = $self->fetch_dbses();
  my $defaultdbs = $$self{CONFIG}{DEFAULT_DBS} || 'blank';
  my @nodes = $self->get_request_nodes();

  my $dbs_selection =  popup_menu(-name=>'dbs', 
				  -values=>[ map { &escapeHTML($_) } @dbsnames ],
				  -default=>&escapeHTML($defaultdbs) );

  print { $$self{CONTENT} }
  "<form class='nice' method='post' action='@{[$self->myurl('page' => 'Request::CreateCheck')]}'>\n",
  "<label>E-mail:</label>", textfield(-name=>'email', -default=>$email_contact, -class=>'labeled', -style=>'width:450px'), "<br/>\n",

  &hidden(-name=>'dbschoice', 'value'=>'known'),
  "<label>DBS:</label>",  "<div class='labeled'>",$dbs_selection, "</div><br/>",

  "<label>Data Items:<br/><br/>",
  "<span class='note'>/Primary/Processed/Tier<br/>or<br/>",
  "/Primary/Processed/Tier#Block<br/>(Use * as wildcard)</span><br/>",
  &help("More Help", "Data Item List", 
	"A whitespace separated list of the datasets or blocks you are ",
	"requesting.  Glob-style wildcards may be used, but the dataset ",
	"path separators are required.  E.g. to subscribe to all ",
	"datasets you would have to write '/*/*/*', not '*'."), 
  "</label>\n",
  textarea(-name=>'data', -value=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), 
  "<br/>",

  "<label>Destinations</label>",
  "<div class='labeled'  style='font-size:8pt;width:450px;height:150px;overflow:scroll;border:thin solid black;' >",
  "<table><tr valign='top'>",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   sort grep (/^T1_|T0_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   grep (/^T2_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   grep (! /^T[012]_/, @nodes)),
  "  </td>\n",
  " </tr></table></div><br/>\n",
  "<label>Transfer Type:</label>", popup_menu(-name=>'is_move', 
					      -values=>['y', 'n'],
					      -default=>'n',
					      -labels=>{'n' => 'Replica', 'y' => 'Move'},
					      -class=>'labeled'),
  &help("What's this?", "Transfer Type", "A <b>replica</b> replicates ",
	"data from the source to the destination, while a <b>move</b> ",
	"replicates the data then deletes the data at the source.  Note that ",
	"moves are only used for moving data from T2s to T1s."),
  "<br/>",
  "<label>Subscription Type:</label>", popup_menu(-name=>'is_transient', 
					       -values=>['y', 'n'],
					       -default=>'n',
					       -labels=>{'n' => 'Open', 'y' => 'Closed' },
					       -class=>'labeled'), 
  &help("What's this?", "Subscription Type", 
	"An <b>open</b> subscription downloads blocks/files added to open ",
	"datasets/blocks as they become available, until the dataset/block is ",
	"closed.  A <b>closed</b> subscription will only transfer the blocks/files ",
	"available at the time the subscription is made.  In a sense an open ",
	"subscription is a true \"subscription\" and a closed subscription is a snapshot."),
  "<br/>",
  "<label>Priority:</label>", popup_menu(-name=>'priority', 
					 -values=>[0, 1, 2], 
					 -default=>1,
					 -labels=>{ 0 => 'High',
						    1 => 'Normal',
						    2 => 'Low' },
					 -class=>'labeled'),
  &help("What's this?", "Priority",
	"Priority is used to determine which data items get priority when resources are limited."),
  "<br/>",
  "<label>Comment:</label>", textarea(-name=>'comment', -default=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), "<br/>\n",

  "<label>&nbsp;</label>", submit(-name=>'submit', -value=>'Submit Request', -class=>'labeled'),
  "</form>";
}

1;



######################################################################
package Web25::Request::CreateCheck;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Submit Request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $bad = 0;
  &create_check_identity($self, \$bad);
  &create_check_access($self, \$bad);
  my $email = &create_check_email($self, \$bad, param('email'));
  my $comment = &create_check_comment($self, \$bad, param('comment'));
  my $dbs;
  if (param('dbschoice') eq 'known') { $dbs = param('dbs') }
  elsif (param('dbschoice') eq 'user') { $dbs = param('userdbs') } 
  else { $self->alert("Missing or unknown DBS parameters"); return; }
  $dbs = &create_check_dbs($self, \$bad, $dbs);
  my @data = &create_check_data($self, \$bad, param('data'));
  my @dest = &create_check_dest($self, \$bad, param('dest'));
  my ($is_move, $is_transient, $priority) = &create_check_options($self, \$bad);
  if ($bad)
  {
    print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n";
    return;
  }

  my $confirmok = 1;
        
  if ($is_move eq 'y' && param('move_confirm') && param('move_confirm') ne 'y') {
      $confirmok = 0;
  }

  if ($confirmok && param('go_ahead') && param('go_ahead') eq 'y') {
      $self->write_request('email' => $email,
			   'comment' => $comment,
			   'dbs' => $dbs,
			   'data' => [@data],
			   'destinations' => [@dest],
			   'is_move' => $is_move,
			   'is_transient' => $is_transient,
			   'priority' => $priority);
      return;
  }

  my $subscription_type = &subscription_type($priority, $is_transient, $is_move);

  print { $$self{CONTENT} } 
  "<form method='post' action='@{[$self->myurl()]}'>\n",
  "<p>Please review these request details and confirm below.  If you would like to ",
  "change your request, use the back button in your browser.</p>",
  "<h1>Request Information</h1>",
  "<div class='nice'>",
  "<label>Requestor:</label><span class='labeled'>$$self{USER_NAME}</span><br/>",
  "<label>email:</label><span class='labeled'>$email</span><br/>",
  "<label>DBS:</label><span class='labeled'>$dbs</span><br/>",
  "<label>Data:</label><span class='labeled'>", join('<br/>', @data), "</span><br/>",
  "<label>Destination:</label><span class='labeled'>", join('<br/>', @dest), "</span><br/>",
  "<label>Subscription Type:</label><span class='labeled'>$subscription_type</span><br/>",
  "</div>";

  # Warnings
  if ($is_move eq 'y' && grep($_ !~ /^T1_\w*_MSS$/, @dest)) {
      $self->alert("You have requested a move to an unsupported destination (e.g. not a Mass Storage System ",
		   "at a T1 centre).  Please change the destination, or choose to trigger a replication ",
		   "instead of a move");
      return;
  } elsif ($is_move eq 'y' && grep(/^T1_\w*_MSS$/, @dest)) {
      $self->note("You have chosen to move data to ", join(', ', @dest), ". Once the transfer is complete this will ",
		  "remove the data at the source sites.  Furthermore, only Global Admins may approve move requests.  ",
		  "Please confirm that this is what you want to do by checking ",
		  "the box.<br/><br/>",
		  ( param('go_ahead') ? "<p class='alarm'><b>You must confirm!</b></p>" : ''),
		  checkbox(-name=>'move_confirm', -value=>'y', -label=>'Yes, I understand'));
  }

  if ($is_transient eq 'n') {
      $self->note("You are requesting an open subscription.  The nodes selected will continue to ",
		  "receive files from open blocks if they are made available.  Please carefully monitor ",
		  "your disks, as the size of this subscription could grow significantly.");
  }
  

  print { $$self{CONTENT} } "<h1>Data Item Lookup</h1>",
  "<p>The following table summarizes an attempt to look for your requested data items in PhEDEx.  ",
  "Items in red may be problematic and require extra consideration by the PhEDEx admins.</p>";
  
  # Pull all subscriptions into a hash organized by node for subscription duplication checking
  my $subscriptions = {};
  my $q = &dbexec($$self{DBH}, qq{ select NVL2(s.block, 'BLOCK', 'DATASET') lvl,
				          NVL2(s.block, s.block, s.dataset) id,
				          n.name node
                                   from t_dps_subscription s
                                   join t_adm_node n on s.destination = n.id });
  
  while (my ($level, $id, $node) = $q->fetchrow_array()) {
      $$subscriptions{$node}{$level}{$id} = 1;
  }

  my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, $dbs, @data);

  my $table = new Web25::TableSpool;
  $table->set_filehandle( $$self{CONTENT} );
  $table->set_tableclass('data');
  $table->set_stripeclass('stripe');
  $table->set_tablecols([qw(LEVEL ITEM DPS_ISKNOWN DBS_ISKNOWN COMMENT)]);
  $table->set_tablehead({LEVEL => 'Data Level', 
			 ITEM => 'Data Item', 
			 DPS_ISKNOWN => 'Known to PhEDEx', 
			 DBS_ISKNOWN => 'Known to DBS', 
			 COMMENT => 'Comment'});
  $table->set_cellformats({COMMENT     => sub { $_[1]->{WARN} ? 'alarm' : '' },
			   DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			   DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});

  $table->set_dataformats({DPS_ISKNOWN => \&yesno,
		           DBS_ISKNOWN => \&yesno});

  $table->start();
  $table->head();

  my $problems = 0;
  foreach my $userglob (sort @data) {
      if (! @{$$resolved{$userglob}} ) {
	  $table->row({LEVEL => 'User Search',
		       ITEM  => $userglob,
		       DPS_ISKNOWN => 'n',
		       DBS_ISKNOWN => 'n',
		       COMMENT => 'Data item not found anywhere',
		       WARN => 1});
	  $problems = 1;
      } else {
	  foreach my $res (@{$$resolved{$userglob}}) {
	      my @comments;
	      my $warn = 0;
	      
	      if ($$res{DBS} ne $dbs)  { push @comments, "Known to PhEDEx in another DBS ($$res{DBS})"; $warn = 1; $problems = 1; }
	      if ($$userdupes{$$res{LEVEL}}{$$res{ID}}) { push @comments, "User duplicated requests"; $warn = 1; }
	      if ($$dbsdupes{$$res{LEVEL}}{$$res{ID}})  { 
		  push @comments, "Data item known to PhEDEx in multiple DBSes";
		  $warn = 1; 
	      }
	      
	      foreach my $node (@dest) {
		  if ($$subscriptions{$node}{$$res{LEVEL}}{$$res{ID}}) {
		      push @comments, "Already subscribed to $node";
		      $warn = 1;
		  }
	      }

	      $$res{ITEM} = $$res{$$res{LEVEL}}; # Name of dataset or block, depending on which it is for
	      $$res{LEVEL} = ucfirst lc $$res{LEVEL}; # Just to make it pretty
	      $$res{COMMENT} = join('<br/>', @comments);
	      $$res{WARN} = $warn;
	      
	      if ($warn) { $problems = 1; }
	      if ($$res{DPS_ISKNOWN} eq 'n' || $$res{DBS_ISKNOWN} eq 'n') { $problems = 1; }
	      $table->row($res);
	  }
      }
  }

  $table->finish();

  # Save the previous state
  foreach (qw(email comment dbschoice dbs userdbs is_move is_transient priority data dest)) {
      print { $$self{CONTENT} } hidden($_);
  }

  unless ($problems) {
      print { $$self{CONTENT} }
      hidden(-name=>'go_ahead', -value=>'y'),
      "<p><center>", submit(-value=>'Confirm'), "</p>";
  } else {
      $self->alert("Sorry, due to the problems with your request (in red) it cannot be submitted.  ",
		   "Please go back and resolve the problems if you can, or ",
		   "<a href='mailto:$$self{CONFIG}{FEEDBACK_MAIL}'>mail the admins</a> if you have a question.");
  }
  print { $$self{CONTENT} } "</form>";
}
  


sub write_request
{
    my ($self, %params) = @_;

    foreach (qw(email comment dbs data destinations is_move is_transient priority)) {
	if (!exists $params{$_}) { die "write_request() insufficient parameters"; }
    }
    
    my $now = time();

    # Write information about the Client
    my $client = $self->logClientInfo();
    
    # Write the request
    my $rid = &makeObjWithAttrs
	($$self{DBH}, "req_request", undef,
	 { "creator" => $client, "state" => 0 });

    my $aid = &makeObjWithAttrs
	($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "Created",
	   "client" => $client,
	   "time_apply" => $now },
	 "Comment" => $params{comment},
	 "E-mail" => $params{email},
	 "DBSURL" => $params{dbs},
	 map( { ("Destination Node" => $_) } @{$params{destinations}}),
	 map( { ("Data" => $_) } @{$params{data}}),
	 "Priority" => $params{priority},
	 "Transient" => $params{is_transient},
	 "Move" => $params{is_move}
	 );
    
    # Get a list of the sites involved in this request
    my %node_sites = $$self{SECMOD}->getPhedexNodeToSiteMap();
    my %sites;  # for unique list
    foreach my $dest (@{$params{destinations}}) {
	$sites{ $node_sites{$dest} } = 1;
    }
    
    # Get the list of Global admins
    my @global_admins = $$self{SECMOD}->getUsersWithRoleForGroup('Global Admin', 'phedex');
    if (!@global_admins) {
	alert("Sorry, the request cannot be created.",
	      "The database does not contain any global admins.",
	      "Please contact the PhEDEx group about this!"); 
	return;
    }

    # Get the list of Data Managers affected by this request
    my @data_managers;
    foreach my $site (keys %sites) {
	push @data_managers, $$self{SECMOD}->getUsersWithRoleForSite('Data Manager', $site);
    }

    # Get the list of Site Admins affected by this request
    my @site_admins;
    foreach my $site (keys %sites) {
	push @site_admins, $$self{SECMOD}->getUsersWithRoleForSite('Site Admin', $site);
    }

    # Write a task with this request for each of the global admins and
    # data managers authorized to approve this
    my %task_people;  # use a hash to ensure no duplicates
    my @auth_admins;
    if ($params{'is_move'} eq 'y') {
	@auth_admins = @global_admins;
    } else {
	@auth_admins = (@global_admins, @data_managers);
    }

    foreach my $admin (@auth_admins) {
	my $ident = $self->fetch_identity($admin);
	$task_people{$$ident{ID}} = 1;
    }
    foreach my $person (keys %task_people) {
	&makeObjWithAttrs
	    ($$self{DBH}, "req_task", undef,
	     { "action" => $aid,
	       "person" => $person,
	       "time_create" => $now
	       }
	     );
    }

    # Write the request details (resolved datasets/blocks) to the DB
    &dbexec($$self{DBH}, qq[ insert into t_req_info (request, time_update)
			     values ( :rid, :time_update ) ],
	    ':rid' => $rid,
	    ':time_update' => $now);

    my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, $params{dbs}, @{$params{data}});

    my @rv;
    foreach my $userglob (sort @{$params{data}}) {
	foreach my $res (@{$$resolved{$userglob}}) {
	    if ($$res{LEVEL} eq 'DATASET') {
		@rv = &dbexec($$self{DBH}, 
			      qq[ insert into t_req_info_dataset (request, dbs, dataset, dbs_isknown, dps_isknown,
								  is_move, is_transient, priority)
				  values ( :rid, :dbs, :dataset, :dbs_isknown, :dps_isknown,
					   :is_move, :is_transient, :priority) ],
			      ':rid'          => $rid,
			      ':dbs'          => $$res{DBS},
			      ':dataset'      => $$res{DATASET},
			      ':dbs_isknown'  => $$res{DBS_ISKNOWN},
			      ':dps_isknown'  => $$res{DPS_ISKNOWN},
			      ':is_move'      => $params{is_move},
			      ':is_transient' => $params{is_transient},
			      ':priority'     => $params{priority}
			      );
	    } elsif ($$res{LEVEL} eq 'BLOCK') {
		@rv = &dbexec($$self{DBH},
			      qq[ insert into t_req_info_block ( request, dbs, dataset, block,
								 dbs_isknown, dps_isknown,
								 is_move, is_transient, priority)
				  values ( :rid, :dbs, :dataset, :block, :dbs_isknown, :dps_isknown,
					   :is_move, :is_transient, :priority) ],
			      ':rid' => $rid,
			      ':dbs' => $$res{DBS},
			      ':dataset' => $$res{DATASET},
			      ':block' => $$res{BLOCK},
			      ':dbs_isknown' => $$res{DBS_ISKNOWN},
			      ':dps_isknown' => $$res{DPS_ISKNOWN},
			      ':is_move'      => $params{is_move},
			      ':is_transient' => $params{is_transient},
			      ':priority'     => $params{priority}
			      );
	    }
	    unless ($rv[1] > 0) {
		$$self{DBH}->rollback();
		&alert("Request creation failed");
	    }
	}
    }
    
    foreach my $node (@{$params{destinations}}) {
	&dbexec($$self{DBH},
		qq[ insert into t_req_info_dest (request, destination)
		    select :rid, id node_id from t_adm_node where name = :node ],
		':rid' => $rid, ':node' => $node);
    }

    $$self{DBH}->commit();

    # Send an email to the requestor, the global admins, the data managers, and the site admins
    my $instance = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE};
    my $subscription_type =  &subscription_type(@params{qw(priority is_transient is_move)});
    my @to;
    push @to, $$_{EMAIL} foreach (@global_admins, @data_managers);
    my @cc = ($params{email});
    push @cc, $$_{EMAIL} foreach @site_admins;
    
    my $admin_url = $self->myurl('fullurl' => 1, 'secure' => 1, 'page' => 'Request::Admin', 'view' => 'my');
    my $name = $$self{USER_NAME};
    my $dn = $$self{SECMOD}->getDN();
    my $auth = "";
    if ($$self{SECMOD}->isCertAuthenticated()) {
	$auth = "DN:  ".$$self{SECMOD}->getDN();
    } elsif ($$self{SECMOD}->isPasswdAuthenticated()) {
	$auth = "Username:  ".$$self{SECMOD}->getUsername();
    }
    my $move_msg = '';
    if ($params{'is_move'} eq 'y') {
	$move_msg = 'Note:  This is a request for a data MOVE '.
	    'and can only be approved by the Global Admins.';
    }


    my $message =<<ENDEMAIL;
Greetings PhEDEx Data Managers,

You may wish to take note of the following new transfer request:

* Requestor:
   Name:  $name
   Authentication $auth
   Host: $ENV{HTTP_X_FORWARDED_FOR}
   Agent: @{[user_agent()]}

* Request:
   Type:
     $subscription_type
   Database:
     $instance
   Contact:
     $params{email}
   DBS:
     $params{dbs}
   Data:
ENDEMAIL

    $message .= join('', map( { "     $_\n" } @{$params{data}})).
    "   Destination Nodes:\n".
    join('', map( { "     $_ (Site: $node_sites{$_})\n" } @{$params{destinations}}));

    $message .=<<ENDEMAIL;
   Comments:
     "$params{comment}"

$move_msg
 
This mail has also been sent to the requestor, the PhEDEx global
admins, and the site admins of the relevant sites.

Go to
  $admin_url
to handle this request.

Yours truly,
  PhEDEx Transfer Request Web Form
ENDEMAIL
    
send_email(subject => "PhEDEx Transfer Request ($instance instance)",
	   to => [ @to ],
	   cc => [ @cc ],
	   from => "PhEDEx Request Form <$$self{CONFIG}{FEEDBACK_MAIL}>",
	   message => $message)
or $self->alert("Sending request email to admins failed, sorry");
    
    
    print { $$self{ CONTENT } }
    "<h1>Request Confirmed</h1>",
    "<p>Your request has been logged to the database and the admins have been notified.  ",
    "You will receive updates about this request via e-mail.</p>";
}

sub subscription_type
{
    my ($priority, $is_transient, $is_move) = @_;
    my $nice = 
    {
	is_move => { y => 'move', n => 'replication' },
	is_transient => { y => 'closed', n => 'open' },
	priority => { 0 => 'High', 1 => 'Normal', 2 => 'Low' }
    };

    return "$$nice{priority}{$priority} priority $$nice{is_transient}{$is_transient} $$nice{is_move}{$is_move}";
}

1;



######################################################################
package Web25::Components::Status;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Status",
	       LINK_TITLE => "View recently active PhEDEx components" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my %offline_thresholds = ( 'FileDownload' => 60*30,
			     'FileExport'   => 60*90,
			     'InfoFileSize' => 60*30,
			     'OTHER'        => 60*15 );
  
  
  my $now = time ();
  my $query = &dbexec($$self{DBH}, qq{
      select n.name, a.name, ast.time_update
	  from t_agent_status ast
	  join t_adm_node n on n.id = ast.node
	  join t_agent a on a.id = ast.agent});

  my (%agents, %status);
  while (my $row = $query->fetchrow_arrayref)
  {
      my ($node, $agent, $contact) = @$row;
      $status{$node}{$agent} = $contact;
      $agents{$agent} = 1;
  }

  my @standard = grep (!/^(Block|Info(?!Drop)|Perf|Table)/, sort keys %agents);
  my @admin = grep (/^Block/, sort keys %agents);
  my @support = grep (/^(?!File|Block|InfoDrop)/, sort keys %agents);

  foreach my $item ([ "Common", @standard ], [ "Administrative", @admin ], [ "Support", @support ])
  {
      my ($type, @agents) = @{$item};
      print { $$self{CONTENT} }
      "<p><table class='striped'>\n",
      "<tbody>\n",
      "<tr class='selected'>\n",
      " <td align='center' colspan='" . (scalar @agents + 1) . "'>$type Agents</td>\n",
      "</tr>\n",
      "<tr class='selected'>\n",
      " <th>Node</th>\n",
      (map { " <th>$_</th>\n" } @agents),
      "</tr>\n";

      foreach my $node (sort keys %status)
      {
	  next if ! grep (defined $status{$node}{$_}, @agents);

	  print { $$self{CONTENT} } "<tr>\n", " <td>$node</td>\n";
	  foreach my $agent (@agents)
	  {
	      my $offline = ( $offline_thresholds{$agent} || $offline_thresholds{OTHER} );
	      my $active = $offline / 3;
	      my $contact = $status{$node}{$agent};

	      if (! defined $contact)
	      {
		  print { $$self{CONTENT} } " <td>&nbsp;</td>\n";
		  next;
	      }
	      
	      my $ago = &age($now - $contact);
	      if (($now - $contact) < $active) {
		  print { $$self{CONTENT} } "<td align='center' bgcolor='$goodcolor'>UP</td>\n";
	      } elsif (($now - $contact) < $offline) {
		  print { $$self{CONTENT} } "<td align='center' bgcolor='$goodcolor'>UP ($ago ago)</td>\n";
	      } else {
		  print { $$self{CONTENT} } "<td align='center' bgcolor='$badcolor'>DOWN ($ago ago)</td>\n";
	      }
	  }
	  print { $$self{CONTENT} } "</tr>\n";
      }
      print { $$self{CONTENT} } "</tbody>\n", "</table>\n";
  }
}

1;

######################################################################
package Web25::Components::Agents;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Processes",
	       LINK_TITLE => "View details about PhEDEx processes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

    my $now = time();

    # Group by host, 
    my $sql = qq[ select s.time_update time_update,
                         n.name node_name, 
                         s.host_name,
                         s.directory_path,
                         a.name agent_name,
                         v.filename,
                         v.release,
                         v.revision,
                         v.tag,
                         s.label agent_label,
                         s.process_id pid,
                         s.worker_id, 
                         s.queue_pending q_pend,
                         s.queue_received q_recv,
                         s.queue_work q_work,
                         s.queue_completed q_comp,
                         s.queue_bad q_bad,
                         s.queue_outgoing q_out,
                         s.state state
 		    from t_agent_status s
                    join (select host_name, agent, label, min(node) node
			         from t_agent_status group by host_name, agent, label) s_sub
                      on s_sub.host_name = s.host_name and s_sub.agent = s.agent 
                     and s_sub.label = s.label and s_sub.node = s.node
		    join t_adm_node n on s.node = n.id
                    join t_agent a on s.agent = a.id
                    left join t_agent_version v on v.agent = a.id and v.node = n.id and v.filename = a.name
		   order by n.name, s.host_name, s.directory_path, s.label, s.worker_id ];
    my $q = &dbexec($$self{DBH}, $sql);

    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{ CONTENT });
    
    $dbtable->set_querycols( [('Age', 'pcolumn', 'TIME_UPDATE', 1)],
			     [('Node', 'pcolumn', 'NODE_NAME', 1)],
			     [('Host', 'pcolumn', 'HOST_NAME', 1)],
			     [('Path', 'pcolumn', 'DIRECTORY_PATH', 1)],
			     [('Agent Name', 'pcolumn', 'AGENT_NAME', 1)],
			     [('File and Version Columns', 'pcolumn', 'FILENAME:RELEASE:REVISION:TAG', 0)],
			     [('Agent Label', 'pcolumn', 'AGENT_LABEL', 1)],
			     [('Process', 'pcolumn', 'PID', 1)],
			     [('Worker', 'pcolumn', 'WORKER_ID', 1)],
			     [('Queue State Columns', 'pcolumn', 'Q_PEND:Q_RECV:Q_WORK:Q_BAD:Q_OUT', 1)] 
			     );
    $dbtable->set_tablehead({
	TIME_UPDATE => 'Age',
	NODE_NAME => 'Node',
	AGENT_NAME => 'Agent Name',
	AGENT_LABEL => 'Agent Label',
	PID => 'Process',
	HOST_NAME => 'Host',
	WORKER_ID => 'Worker',
	Q_PEND => 'Pending',
	Q_RECV => 'Received',
	Q_WORK => 'Work',
	Q_COMP => 'Completed',
	Q_BAD => 'Bad',
	Q_OUT => 'Outgoing',
	FILENAME => 'Filename',
	DIRECTORY_PATH => 'Path',
	RELEASE => 'Version Release',
	REVISION => 'Version Revision',
	TAG => 'Version Tag'
	});

    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');

    my $binsub = sub { $_[0] ? "1" : "0" };
    $dbtable->set_dataformats({
	TIME_UPDATE => sub { &age($now - $_[0]) },
	Q_PEND => $binsub,
	Q_RECV => $binsub,
	Q_WORK => $binsub,
	Q_COMP => $binsub,
	Q_BAD  => $binsub,
	Q_OUT  => $binsub
    });

    my $nullsub = sub { $_[0] ? 'alarm' : '' };
    $dbtable->set_cellformats({
	TIME_UPDATE => sub { $now - $_[0] <= (1.5)*3600 ? '' : 'alarm' },
	P_ID => sub { $_[1]->{STATE} ? '' : 'alarm' },
	Q_PEND => $nullsub,
	Q_RECV => $nullsub,
	Q_WORK => $nullsub,
	Q_COMP => $nullsub,
	Q_BAD => $nullsub,
	Q_OUT => $nullsub
    });

    my $nrows = $dbtable->output($q);
    if ($nrows == 0) {
	$self->alert("No process data available.");
    }

    #  Options form
    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = $dbtable->columns_form();
    $optspane->add_tab('Columns', $form);

    print { $$self{OPTIONS} } $optspane->output();
}


1;



######################################################################
package Web25::Activity::Rate;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Rate",
	       LINK_TITLE => "Show recent transfer rates in tabular form" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(span errors tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::TransferRate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  @save = qw(andor tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::TransferDetails");
  @save = qw(tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::ErrorInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my %stats = ();
  my @spans = qw(h 2h d w m);
  my %spans = (h => [ 'Last hour', $now, 3600 ],
	       '2h' => [ 'Last 2 hours', $now, 3600*2 ],
	       d => [ 'Last day', $now, 86400 ],
	       w => [ 'Last 7 days', int($now/86400)*86400, 7*86400 ],
	       m => [ 'Last 30 days', int($now/86400)*86400, 30*86400 ]);
  my $span = param('span') || $spans[0];
  $span = $spans[0] if ! grep($span eq $_, @spans);
  my $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(sum(h.done_files),0) done_files,
      nvl(sum(h.done_bytes),0) done_bytes,
      nvl(sum(h.fail_files),0) fail_files,
      nvl(sum(h.expire_files),0) expire_files
    from t_history_link_events h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    $stats{$span}{N}{$key} = $row;
  }

  $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(avg(h.param_rate),0) param_rate,
      nvl(avg(h.param_latency),0) param_latency
    from t_history_link_stats h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    next if ! exists $stats{$span};
    $stats{$span}{N}{$key}{PARAM_RATE} = $$row{PARAM_RATE};
    $stats{$span}{N}{$key}{PARAM_LATENCY} = $$row{PARAM_LATENCY};
  }

  $stats{$span}{T}{1} = { DONE_FILES => 0, DONE_BYTES => 0, FAIL_FILES => 0, EXPIRE_FILES => 0 };
  my $errors = param('errors') ? "checked='checked'" : "";
  my $tofilter = param('tofilter') || "";
  my $fromfilter = param('fromfilter') || "";
  my $andor = param('andor') || 'or';
  print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<label for='span'>Time span</label>\n",
    "<select name='span' onchange='submit()'>",
    (map { (" <option", ($span eq $_ ? " selected='selected'" : ""),
	    "  value='$_'>$spans{$_}[0]</option>") } @spans),
    "</select>\n",
    "&nbsp;<input type='checkbox' name='errors' $errors>\n",
    "<label for='errors'>Include links with nothing but errors</label> ",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'><tbody>\n",

    "<tr class='selected'>\n",
    " <th colspan='10'>",
    "Last @{[&format_timespan($spans{$span}[2])]}",
    "</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>To</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From</th>\n",
    " <th rowspan='2'>Files</th>\n",
    " <th rowspan='2'>Total Size</th>\n",
    " <th rowspan='2'>Rate</th>\n",
    " <th rowspan='2'>Errors</th>\n",
    " <th rowspan='2'>Expired</th>\n",
    " <th rowspan='2'>Avg. Est. Rate</th>\n",
    " <th rowspan='2'>Avg. Est. Latency</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "<th>",
    "<select name='andor' onchange='submit()'>",
    " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
    "  value='and'>and</option>",
    " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
    "  value='or'>or</option>",
    "</select>",
    "</th>",
    " <th>",
    textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
		       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "</tr>\n";

  foreach my $kind (qw(N T))
  {
    foreach my $row (sort { $$b{DONE_BYTES} <=> $$a{DONE_BYTES}
			    || $$b{FAIL_FILES} <=> $$a{FAIL_FILES}
			    || $$b{EXPIRE_FILES} <=> $$a{EXPIRE_FILES}
			    || $$a{TO_NODE} cmp $$b{TO_NODE}
			    || $$a{FROM_NODE} cmp $$b{FROM_NODE} }
		     values %{$stats{$span}{$kind}})
    {
      next if ($kind eq 'N'
	       && ($fromfilter || $tofilter)
	       && ($andor eq 'or'
		   ? ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			|| ($tofilter && $$row{TO_NODE} =~ /$tofilter/))
		   : ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			&& ($tofilter && $$row{TO_NODE} =~ /$tofilter/))));
      next if $kind eq 'N' && ! $errors && ! $$row{DONE_FILES};
      next if $kind eq 'N' && ! $$row{DONE_FILES} && ! $$row{FAIL_FILES} && ! $$row{EXPIRE_FILES};
      my $bps = $$row{DONE_BYTES} / $spans{$span}[2];

      my $errorcolumn = &format_num($$row{FAIL_FILES});
      if ($$row{FAIL_FILES} && $$row{FROM_NODE} && $$row{TO_NODE}) {
	  my $errorurl = $self->myurl(page => 'Activity::ErrorInfo',
				      fromfilter => $$row{FROM_NODE},
				      tofilter => $$row{TO_NODE});
	  $errorcolumn = "<a href='$errorurl'>$errorcolumn</a>";
      }

      print { $$self{CONTENT} }
	"<tr>",
	($$row{FROM_NODE}
	 ? "<td>$$row{TO_NODE}</td><td>&nbsp;</td><td>$$row{FROM_NODE}</td>"
	 : "<td colspan='3'>Total</td>"),
	"<td align='right'>@{[&format_num($$row{DONE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{DONE_BYTES})]}</td>",
	"<td align='right'>", ($bps >= 0 ? &format_size($bps) . '/s' : &format_num(0)), "</td>",
	"<td align='right'>$errorcolumn</a></td>",
	"<td align='right'>@{[&format_num($$row{EXPIRE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{PARAM_RATE} || 0)]}/s</td>",
	"<td align='right'>@{[&age($$row{PARAM_LATENCY} || 0)]}</td>",
	"</tr>\n";

      if ($kind eq 'N')
      {
	$stats{$span}{T}{1}{DONE_FILES} += $$row{DONE_FILES};
	$stats{$span}{T}{1}{DONE_BYTES} += $$row{DONE_BYTES};
	$stats{$span}{T}{1}{FAIL_FILES} += $$row{FAIL_FILES};
	$stats{$span}{T}{1}{EXPIRE_FILES} += $$row{EXPIRE_FILES};
      }
    }
  }
  print { $$self{CONTENT} } "</tbody></table></p></form>\n";
}

1;

######################################################################
package Web25::Activity::PlotPage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use File::Temp ':mktemp';

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  $$self{PERIOD_ORDER} = [ qw(l24h l48h l72h l96h l132h l7d l14d l30d l45d l90d l120d
			    l6w l26w l52w ad aw am) ];
  $$self{PERIODS} = { "l24h" => [ "24:hour", "Last 24 Hours" ],
		    "l48h" => [ "48:hour", "Last 48 Hours" ],
	            "l72h" => [ "72:hour", "Last 72 Hours" ],
	            "l96h" => [ "96:hour", "Last 96 Hours" ],
	            "l132h" => [ "132:hour", "Last 132 Hours" ],
	            "l7d" => [ "7:day", "Last 7 Days" ],
	            "l14d" => [ "14:day", "Last 14 Days" ],
	            "l30d" => [ "30:day", "Last 30 Days" ],
	            "l45d" => [ "45:day", "Last 45 Days" ],
	            "l90d" => [ "90:day", "Last 90 Days" ],
	            "l120d" => [ "120:day", "Last 120 Days" ],
	            "l6w" => [ "6:week", "Last 6 Weeks" ],
	            "l26w" => [ "26:week", "Last 26 Weeks" ],
	            "l52w" => [ "52:week", "Last 52 Weeks" ],
	            "ad" => [ "0:day", "Daily Since Start" ],
	            "aw" => [ "0:week", "Weekly Since Start" ],
	            "am" => [ "0:month", "Monthly Since Start" ] };
  $$self{DEFAULT_PERIOD} = 'l96h';
  $$self{DEFAULT_GRAPH} = undef;
  $$self{GRAPH_ORDER} = [];
  $$self{GRAPHS} = {};
  $$self{ENTITY_ORDER} = [qw(dest src link)];
  $$self{ENTITIES} = {dest => 'Destination', src => 'Source', link => 'Link'};
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(period graph entity src_filter dest_filter no_mss upto);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Activity::RatePlots"
        && $args{"page"} ne "Activity::QueuePlots"
        && $args{"page"} ne "Activity::QualityPlots");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  $$self{PLOT_SCRIPT} = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/phedex-cgi.sh";

  my $page = param("page");
  my $period = param("period");
  my $graph = param("graph");
  my $entity = param("entity");
  my $src_filter = param("src_filter") || '';
  my $dest_filter = param("dest_filter") || '';
  my $no_mss = param("no_mss");
  if (!defined $no_mss) { $no_mss = 'true'; } # Filter MSS by default
  my $upto = param("upto") || '';
  $period = $$self{DEFAULT_PERIOD} if (! $period || ! exists $$self{PERIODS}{$period});
  $graph = $$self{DEFAULT_GRAPH} if (! $graph || ! exists $$self{GRAPHS}{$graph});
  $entity = 'dest' if (! $entity || ! grep($_ eq $entity, @{$$self{ENTITY_ORDER}} ));
  

  my $dest_filter_name = 'destination';
  if (exists $$self{DEST_ONLY_GRAPHS}
      && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      $$self{ENTITY_ORDER} = ['dest'];
      $$self{ENTITIES} = { dest => 'Node' };
      $dest_filter_name = 'node';
  }

  my $formurl = $self->myurl();

  print { $$self{CONTENT} } 
  "<form method='get' action='$formurl' class='nice'>\n",
  "<label for='graph' class='inline'>Graph</label>\n",
  popup_menu(-name=>'graph', -onchange=>'submit()',
	     -values=>$$self{GRAPH_ORDER},
	     -labels=>$$self{GRAPHS},
	     -class=>'labeled'),
  "<label for='entity' class='inline'>by</label> ",
  popup_menu(-name=>'entity', -onchange=>'submit()', 
	     -values=>$$self{ENTITY_ORDER},
	     -labels=>$$self{ENTITIES},
	     -class=>'labeled'),
  "<label class='inline'>filter</label>";

  unless (exists $$self{DEST_ONLY_GRAPHS} && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      print { $$self{CONTENT} }
      "<label class='inline' for='src_filter'>source</label>",
      textfield(-name=>'src_filter', -size=>15,
		-title=>("Regular expression to match against node names. "
			 ."Only those matching the expression will be shown."),
		-class=>'labeled');
  } else { print {$$self{CONTENT}} hidden('src_filter'); }

  print { $$self{CONTENT} }
  "<label class='inline' for='dest_filter'>$dest_filter_name</label>",
  textfield(-name=>'dest_filter', -size=>15,
	    -title=>("Regular expression to match against node names. "
		     ."Only those matching the expression will be shown."),
	    -class=>'labeled'),
  popup_menu(-name=>'no_mss', -values=>['true', 'false'], -labels=>{'true' => 'hide MSS nodes', 'false' => 'show MSS nodes'},
	     -default=>$no_mss, -onchange=>'submit()', -class=>'labeled'),
  "<br/>";
  
  print { $$self{CONTENT} }
  "<label for='period' class='inline'>Period</label>\n",
  popup_menu(-name=>'period', -onchange=>'submit()',
	     -values=>$$self{PERIOD_ORDER},
	     -labels=>{ map { $_ => $$self{PERIODS}{$_}[1] } @{$$self{PERIOD_ORDER}} },
	     -default=>$period,
	     -class=>'labeled'),
  "<label for='upto' class='inline'>up to</label>",
  textfield(-name=>'upto', -size=>15,
	    -title=>("Time up to and including which results will be shown. "
		     ."Specify the time in format matching the selected period:\n"
		     ."YYYYMMDDZHHMM for hourly periods;\n"
		     ."YYYYMMDD for daily periods;\n"
		     ."YYYYMM for monthly periods;\n"
		     ."YYYYWW for weekly periods."),
	    -class=>'labeled'),
		     submit(-label=>'Update', -class=>'labeled'), "<br/>",
		     "</form>";

  my ($last, $unit) = $$self{PERIODS}{$period}[0] =~ /([^:]+)/g;
  my %span = ("hour" => 3600, "day" => 86400, "week" => 7*86400, "month" => 86400);
  my %round = (%span, 'week' => 86400);
  my $now = time();
  my $end = (int($now/$round{$unit})+1)*$round{$unit};
  if ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)Z(\d\d)\d\d$/)
  {
    $end = timegm(0, 0, $4, $3, $2-1, $1-1900) + 3600;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, $3, $2-1, $1-1900) + 86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/ && $unit eq 'week')
  {
    # January 4th is always in (ISO) week one, so find out what
    # day of week that is, then go back to Monday of that week,
    # and advance specified number of weeks plus one.
    my $jan4 = timegm(0, 0, 0, 4, 0, $1-1900);
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($jan4);
    $end = $jan4 + (-$diff{$wday} + 7*$2)*86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, 1, $2, $1-1900);
  }

  my $start = ($last ? $end - $last*$span{$unit} : 0);
  # The new plot package really does set range to time 0.
  # Need to provide a more reasonable range.  PhEDEx started taking data in Sep 2004.
  $start = timegm(0, 0, 0, 1, 9, 2004-1900) if $start == 0;  

  my $conn = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{CONNECTION};

  my %args = ('conn' => $conn, 'unit' => $unit, 'span' => $span{$unit}, 'by' => $entity, 'last' => $last,
              'src_filter' => $src_filter, 'dest_filter' => $dest_filter, 'no_mss' => $no_mss,
	      'upto' => $upto, 'starttime' => $start, 'endtime' => $end);
  
  my $imgsrc = $self->imgsrc($graph, %args);
  print {$$self{CONTENT}} "<p><img src='$imgsrc' /></p>";

#   &dump_var($$self{CONTENT}, 'tns_admin', $ENV{TNS_ADMIN});
#   print {$$self{CONTENT}} "<pre>";
#   print {$$self{CONTENT}}<<STOP;
#       no_mss:  $no_mss
#  dest_filter:  $dest_filter
#   src_filter:  $src_filter
#      formurl:  $formurl
#       imgsrc:  $imgsrc
# STOP
# print {$$self{CONTENT}} "</pre>";
#   &dump_var($$self{CONTENT}, 'args', {%args});
#   &dump_params($$self{CONTENT});

}

1;

######################################################################
package Web25::Activity::RatePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Rate Plots",
	       LINK_TITLE => "Show recent transfer rate as plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'quantity_rates';
  $$self{GRAPH_ORDER} = [ 'quantity_rates', 'quantity', 'quantity_cumulative' ];
  $$self{GRAPHS} = { 'quantity_rates' => "Transfer Rate", 
		     'quantity' => "Transfer Volume", 
		     'quantity_cumulative' => "Cumulative Rate" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('graph' => $graph,
		   'from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{PLOT_SCRIPT}.'?'. &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::QueuePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Queue Plots",
	       LINK_TITLE => "Show pending transfer queue plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'destined';
  $$self{GRAPH_ORDER} = [ 'destined', 'resident', 'pending', 'request', 'idle', 'cooloff' ];
  $$self{GRAPHS} = { 'destined' => "Volume Routed",    # by dest only
		     'resident' => "Volume Resident",     # by dest only
		     'pending'  => "Volume Queued", # any
		     'request'  => "Volume Requested",    # by dest only
		     'idle'     => "Volume Idle",  # by dest only
		     'cooloff'  => 'Volume Cool-off' };   # any

  $$self{DEST_ONLY_GRAPHS} = [ qw( destined resident request idle ) ];

  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('graph' => $graph,
		   'from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $dest_only = (grep($graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) ? 1 : 0);
  if ($dest_only && $args{by} ne 'dest') {
      $self->alert("The \"$$self{GRAPHS}{$graph}\" graph can only show data by destination");
      return;
  } elsif ($dest_only) {
      $graphargs{node} = $to_node;
      delete $graphargs{from_node};
      delete $graphargs{to_node};
  }

  my $imgsrc = $$self{PLOT_SCRIPT}.'?'. &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::QualityPlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Quality Plots",
	       LINK_TITLE => "Show transfer quality plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = [ 'quality_all' ];
  $$self{GRAPH_ORDER} = [ 'quality_all', 'quality_try', 'quality_done', 'quality_fail' ];
  $$self{GRAPHS} = { 'quality_all' => "Quality Map",
		     'quality_try' => "Attempts",
		     'quality_done' => "Successes",
		     'quality_fail' => "Failures" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('graph' => $graph,
		   'to_node' => $to_node,
		   'from_node' => $from_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{PLOT_SCRIPT}.'?'. &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::TransferState;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Transfer State",
	       LINK_TITLE => "Show overview of the transfer situation" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $rows = 0;
  my $now = time();
  my $query = &dbexec($$self{DBH}, qq{
    select
      n.name, max(br.time_update),
      sum(br.dest_files), sum(br.dest_bytes),
      sum(br.node_files), sum(br.node_bytes),
      sum(br.xfer_files), sum(br.xfer_bytes)
     from t_dps_block_replica br join t_adm_node n on n.id = br.node
     group by n.name order by n.name});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Last<br>Change</th>\n",
    " <th rowspan='2'>Node</th>\n",
    " <th colspan='2'>Destined</th>\n",
    " <th colspan='2'>On Site</th>\n",
    " <th colspan='2'>In Transfer</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    "</tr>\n";

 my ($tdest_files, $tdest_size,
     $tnode_files, $tnode_size,
     $txfer_files, $txfer_size) = (0) x 6;

  while (my $row = $query->fetchrow_arrayref)
  {
    my ($n, $stamp,
	$dest_files, $dest_size,
	$node_files, $node_size,
	$xfer_files, $xfer_size) = @$row;

    $tdest_files += $dest_files; $tdest_size += $dest_size;
    $tnode_files += $node_files; $tnode_size += $node_size;
    $txfer_files += $xfer_files; $txfer_size += $xfer_size;

    my $node_color = (($dest_files && $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : $xfer_files ? " bgcolor='$pendcolor'" : "");
    my $xfer_color = (($xfer_files) ? " bgcolor='$goodcolor'"
		      : ($xfer_files + $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : "");

    print { $$self{CONTENT} }
      "<tr>\n",
      " <td>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$n</td>\n",
      " <td align='right'>@{[&format_num($dest_files)]}</td>\n",
      " <td align='right'>@{[&format_size($dest_size)]}</td>\n",
      " <td align='right'$node_color>@{[&format_num($node_files)]}</td>\n",
      " <td align='right'$node_color>@{[&format_size($node_size)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_num($xfer_files)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_size($xfer_size)]}</td>\n",
      "</tr>\n";
  }
  my $node_color = (($tdest_files && $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : ($txfer_files) ? " bgcolor='$pendcolor'" : "");
  my $xfer_color = (($txfer_files) ? " bgcolor='$goodcolor'"
		    : ($txfer_files + $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : "");

  print { $$self{CONTENT} }
    "<tr>\n",
    " <th>&nbsp;</th>\n",
    " <th align='left'>Total</th>\n",
    " <th align='right'>@{[&format_num($tdest_files)]}</th>\n",
    " <th align='right'>@{[&format_size($tdest_size)]}</th>\n",
    " <th align='right'$node_color>@{[&format_num($tnode_files)]}</th>\n",
    " <th align='right'$node_color>@{[&format_size($tnode_size)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_num($txfer_files)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_size($txfer_size)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n";
}

1;

######################################################################
package Web25::Activity::TransferDetails;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Transfer Details",
	       LINK_TITLE => "Browse transfer state details" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
    my ($self) = @_;
    my $rows = 0;
    my $now = time();
    my %total = ();
    my $tofilter = param('tofilter') || "";
    my $fromfilter = param('fromfilter') || "";
    my $andor = param('andor') || 'or';
    my $query = &dbexec($$self{DBH}, qq{
    select
      time_update,
      nd.name, ns.name,
      state, priority,
      files, bytes
    from t_status_task xs
      join t_adm_node ns on ns.id = xs.from_node
      join t_adm_node nd on nd.id = xs.to_node
    order by nd.name, ns.name, state});

    print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='10' align='center'>Transfer State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th rowspan='2'>Age</th>\n",
    " <th>To Node</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From Node</th>\n",
    " <th rowspan='2'>State</th>\n",
    " <th rowspan='2'>Transfer</th>\n",
    " <th rowspan='2'>Priority</th>\n",
    " <th rowspan='2'>N Files</th>\n",
    " <th rowspan='2'>Size</th>\n",
    " <th rowspan='2'>Detail</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th>\n",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")
	      ),
     "</th>",
     "<th>",
     "<select name='andor' onchange='submit()'>",
     " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
     "  value='and'>and</option>",
     " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
     "  value='or'>or</option>",
     "</select>",
     "</th>",
     "<th>",
     textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	       -title=>("Regular expression to match against node or link names. "
			."Only those matching the expression will be shown.")),
     "</th>",
     "</tr>\n";
    
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($stamp,
	    $to_node, $from_node,
	    $state, $priority,
	    $files, $bytes) = @$row;

	next if (($fromfilter || $tofilter)
		 && ($andor eq 'or'
		     ? ! (($fromfilter && $from_node =~ /$fromfilter/)
			  || ($tofilter && $to_node =~ /$tofilter/))
		     : ! (($fromfilter && $from_node =~ /$fromfilter/)
			  && ($tofilter && $to_node =~ /$tofilter/))));
	$total{$state} ||= { FILES => 0, BYTES => 0 };
	$total{$state}{FILES} += $files;
	$total{$state}{BYTES} += $bytes;
	my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
	my $transfer_name = ($priority % 2 == 0 ? 'local' : 'remote'); # Local even, remote odd
	my $priority_name = ($priority == 0 || $priority == 1 ? 'high'
			     : $priority == 2 || $priority == 3 ? 'normal'
			     : $priority == 4 || $priority == 5 ? 'low'
			     : 'unknown');
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	my $url = $self->myurl("page" => "Activity::FileInfo",
			       "to_node" => $to_node,
			       "from_node" => $from_node,
			       "state" => $state_name,
			       "priority" => $priority
			       );
	print { $$self{CONTENT} }
	"<tr>\n",
	" <td$stampcolor>", ($now - $stamp < 5*60 ? 'current' : &age($now - $stamp)), "</td>\n",
	" <td>$to_node</td>\n",
	" <td align='right'>&nbsp;</td>\n",
	" <td>$from_node</td>\n",
	" <td align='left'>$state_name</td>\n",
	" <td align='left'>$transfer_name</td>\n",
	" <td align='left'>$priority_name</td>\n",
	" <td align='right'>@{[&format_num($files)]}</td>\n",
	" <td align='right'>@{[&format_size($bytes)]}</td>\n",
	" <td align='center'><a href='$url'>(Files)</a></td>\n",
	"</tr>\n";
    }
    
    my $first_total = 1;
    my ($tfiles, $tbytes) = (0, 0);
    foreach my $state (sort keys %total)
    {
	$tfiles += $total{$state}{FILES};
	$tbytes += $total{$state}{BYTES};
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	
	print { $$self{CONTENT} }
        "<tr>\n",
        " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
        " <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>$state_name</td>\n",
	" <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
	" <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
	" <th align='right'>&nbsp;</th>\n",
	"</tr>\n";
	$first_total = 0;
    }

    print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    " <th align='right'>&nbsp;</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n";


  $query = &dbexec($$self{DBH}, qq{
    select xr.time_update, n.name, xr.state, xr.files, xr.bytes
    from t_status_replica xr join t_adm_node n on n.id = xr.node
    order by n.name, state});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='5' align='center'>Replica State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Age</th>",
    " <th rowspan='2'>Node</th>",
    " <th rowspan='2'>State</th>",
    " <th colspan='2'>Files</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>N</th>\n",
    " <th>Size</th>\n",
    "</tr>\n";

  %total = ();
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($stamp, $node, $state, $files, $bytes) = @$row;
    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $node =~ /$fromfilter/)
		   || ($tofilter && $node =~ /$tofilter/)));
    $total{$state} ||= { FILES => 0, BYTES => 0 };
    $total{$state}{FILES} += $files;
    $total{$state}{BYTES} += $bytes;
    my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    my $color = (($state == 1) ? " bgcolor='$goodcolor'" : "");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$node</td>\n",
      " <td$color align='right'>$state_name</td>\n",
      " <td$color align='right'>@{[&format_num($files)]}</td>\n",
      " <td$color align='right'>@{[&format_size($bytes)]}</td>\n",
      "</tr>\n";
  }

  $first_total = 1;
  ($tfiles, $tbytes) = (0, 0);
  foreach my $state (sort keys %total)
  {
    $tfiles += $total{$state}{FILES};
    $tbytes += $total{$state}{BYTES};
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
      " <th align='right'>$state_name</td>\n",
      " <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
      " <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
      "</tr>\n";
    $first_total = 0;
  }
  print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n",
    "</form>\n";
}

1;

######################################################################
package Web25::Activity::FileInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "File Info" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(to_node from_node state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::FileInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $to_node = param('to_node');
  my $from_node = param('from_node');
  my $state = param('state');
  my $priority = param('priority');
  if (! defined $to_node || $to_node eq ''
      || ! defined $from_node || $from_node eq ''
      || ! defined $state || $state eq ''
      || ! defined $priority || $priority eq ''
      )
  {
    print { $$self{CONTENT} }
    $self->alert('Missing Arguments');
    return;
  }

  my $state_join = '';
  my $state_where = '';
  if    ($state eq 'exported')     { 
      $state_join = 'join t_xfer_task_export ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_inxfer )';
  } elsif ($state eq 'transferring') { 
      $state_join = 'join t_xfer_task_inxfer ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_done )';
  } elsif ($state eq 'transferred')  { 
      $state_join = 'join t_xfer_task_done ts on ts.task = xt.id'; }
  elsif ($state eq 'assigned') {
      $state_where = 'and xt.id not in ( select task from t_xfer_task_export )';
  } else {
      $self->alert('Invalid state');
  }
     
  my $sql = qq{
    select f.id, f.logical_name, f.filesize, xt.from_pfn, xt.to_pfn,
	   xt.time_assign, err.cnt num_errors
      from t_xfer_task xt
      $state_join
      join t_xfer_file f on f.id = xt.fileid
      join t_adm_node ns on ns.id = xt.from_node
      join t_adm_node nd on nd.id = xt.to_node
      left join (select xe.fileid, xe.from_node, xe.to_node, count(*) cnt 
                   from t_xfer_error xe
                  group by xe.fileid, xe.from_node, xe.to_node
                 ) err 
           on     err.fileid = xt.fileid 
              and err.from_node= xt.from_node 
              and err.to_node = xt.to_node
    where ns.name = :from_node
      and nd.name = :to_node
      and xt.priority = :priority
      $state_where
      order by xt.time_assign, f.logical_name};

  my $query = &dbexec($$self{DBH}, $sql, 
		      ':from_node' => $from_node,
		      ':to_node' => $to_node,
		      ':priority' => $priority);
  print { $$self{CONTENT} }
    "<h1>Files $state from $from_node to $to_node.</h1>\n",
    "<ol align='left'>\n";
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($fileid, $lfn, $size, $from_pfn, $to_pfn, $assigned, $nerrors) = @$row;
    my $errorurl = $self->myurl('page' => 'Activity::ErrorInfo',
				'to_node' => $to_node,
				'from_node' => $from_node,
				'fileid' => $fileid);
    print { $$self{CONTENT} }
    "<li><b>lfn</b>=@{[&escapeHTML($lfn)]}<br />",
    "<b>size</b>=$size<br />",
    ($from_pfn ? "<b>from_pfn</b>=@{[&escapeHTML($from_pfn)]}<br />" : ""),
    ($to_pfn ? "<b>to_pfn</b>=@{[&escapeHTML($to_pfn)]}<br />" : ""),
    ($nerrors ? "<span class='alarm'><b>errors</b>=$nerrors</span> <a href='$errorurl'>(View)</a><br />"  : ""),
    ($assigned ? "<b>time_assign</b>=@{[strftime('%Y-%m-%d %H:%M:%S', gmtime($assigned))]} UTC<br />" : ""),
    "<br /></li>\n";
  }
  print { $$self{CONTENT} } "</ol></p>\n";
}

1;



######################################################################
package Web25::Activity::ErrorInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 7, TITLE => "Recent Errors" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}



sub output
{
    my ($self) = @_;

    my $tofilter = param('tofilter') || '.*';
    my $fromfilter = param('fromfilter') || '.*';
    my $fileid = param('fileid');
    my @nodes = sort $self->fetch_nodes();

    my @where;
    my %args;
    
    if ($fileid) {
	push @where, qq[xe.fileid = :fileid];
	$args{':fileid'} = $fileid;
    } else {
	print {$$self{CONTENT}}
	"<form method='get' action='#' class='nice'/>",
	"<label class='inline'>Show errors on links to </label>",
	textfield(-name=>'tofilter', -value=>$tofilter, -class=>'labeled'),
	"<label class='inline'>from</label>",
	textfield(-name=>'fromfilter', -value=>$fromfilter, -class=>'labeled'),
	submit(-name=>'Update', -class=>'labeled'), "<br/>",
	"</form>";
    }

    my @from = grep /$fromfilter/, @nodes;
    my @to = grep /$tofilter/, @nodes;
    my ($from_list, %from_binds) = &dbinlist('from', @from);
    my ($to_list, %to_binds) = &dbinlist('to', @to);
    push @where, "(ns.name in ($from_list) and nd.name in ($to_list))";
    my $where = join ' and ', @where;
    $args{$_} = $from_binds{$_} foreach (keys %from_binds);
    $args{$_} = $to_binds{$_} foreach (keys %to_binds);

    my $sql = qq{ select ns.name from_node, nd.name to_node,
		         time_assign, time_expire, time_export, time_inxfer, time_xfer, time_done,
		         report_code, xfer_code, from_pfn, to_pfn,
		         log_xfer, log_detail, log_validate
		    from t_xfer_error xe
                    join t_adm_node nd on nd.id = xe.to_node
		    join t_adm_node ns on ns.id = xe.from_node
                   where $where
		order by time_done desc
	    };

    my $max_log_length = 100_000;
    $$self{DBH}->{LongReadLen} = $max_log_length;
    $$self{DBH}->{LongTruncOk} = 1;

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, {%args}, 10);
    my $n_errors = $pager->get_total_results();

    if ($fileid) {
	my $alllink = $self->myurl('fromfilter' => $fromfilter, 'tofilter' => $tofilter);
	print {$$self{CONTENT}}
	"<p><a href='$alllink'>Show all errors for this link</a></p>";
    } else {
	print {$$self{CONTENT}} 
	"<h1>$n_errors recent errors on links to ", &escapeHTML($tofilter), 
	" from ", &escapeHTML($fromfilter), "</h1>";
    }

    if ($n_errors >= 100) {
	print {$$self{CONTENT}} 
	"<p>Please note that PhEDEx only stores the last 100 link errors to the database ",
	"for a limited period of time. More errors may have occurred that are not visible here.</p>"
    }

    print {$$self{CONTENT}} $pager->pager();

    my $q = $pager->paged_result();

    my $time_labels = { TIME_ASSIGN => "Time Assigned",
			TIME_EXPORT => "Time Exported",
			TIME_INXFER => "Time Pumped",
			TIME_XFER   => "Time Transfer Start",
			TIME_DONE   => "Time Transfer Done",
			TIME_EXPIRE => "Time Transfer Expires" };

    my $log_labels = { LOG_XFER => "Transfer Log",
		       LOG_DETAIL => "Detail Log",
		       LOG_VALIDATE => "Validate Log" };

    my $now = time();
    while (my $error = $q->fetchrow_hashref()) {
	print { $$self{CONTENT} }
	"<div class='nice errorinfo'>",
	"<h1>Error $$error{ROW_NUMBER}</h1>";

	print { $$self{CONTENT} }
	"<label>To Node:</label><span class='labeled halfwidefield'>$$error{TO_NODE}</span>",
	"<label>From Node:</label><span class='labeled halfwidefield'>$$error{FROM_NODE}</span><br/>";

	my $time_assign = $$error{TIME_ASSIGN};
	my $tn = 0;
	foreach my $time (qw(TIME_ASSIGN TIME_XFER TIME_EXPORT TIME_DONE TIME_INXFER TIME_EXPIRE)) {
	    my $timestamp   = &formatTime($$error{$time}, 'stamp');
	    my $diff_assign = &age($$error{$time} - $time_assign, 'second');
	    my $diff_now    = &age($$error{$time} - $now, 'second');

	    print { $$self{CONTENT} }
	    "<label>$$time_labels{$time}:</label><span class='labeled halfwidefield'>", 
	    ($timestamp ? ($timestamp,
			   " <span class='diff_assigned'>($diff_assign since assigned)</span> ",
			   " <span class='diff_now'>($diff_now from now)</span>") :
	     $$error{$time} ),
	     "</span>",
	     (++$tn % 2 == 0 ? "<br/>" : '');
	}

	print { $$self{CONTENT} }
	"<hr/>",
	"<label>Final Code:</label><span class='labeled halfwidefield'>$$error{REPORT_CODE}</span>",
	"<label>Transfer Report Code:</label><span class='labeled halfwidefield'>$$error{XFER_CODE}</span><br/>",
	"<hr/>",
	"<label>From PFN:</label><span class='labeled'>$$error{FROM_PFN}</span><br/>",
	"<label>To PFN:</label><span class='labeled'>$$error{TO_PFN}</span><br/>",
	"<hr/>";

	foreach my $log (qw(LOG_XFER LOG_DETAIL LOG_VALIDATE)) {
	    if (! defined $$error{$log} ) { $$error{$log} = ''; }
	    my $chars = length $$error{$log};
	    my $trunc = ($chars == $max_log_length ? "<br/><span class='alarm'>Truncated</span>" : '');
	    $$error{$log} =~ s/\s*$/\n/;
	    my $lines = ($$error{$log} =~ tr/\n/\n/);
	    $lines = 0 if $chars == 0;
	   
	    print { $$self{CONTENT} }
	    "<label>$$log_labels{$log}:<br/><span class='note'>($lines lines)<br/>($chars chars)$trunc</span></label>",
	    "<div class='labeled logbox'>$$error{$log}</div><br/>";	    
 	}
	print { $$self{CONTENT} } "</div>";
    }
    print {$$self{CONTENT}} $pager->pager();
}

1;


######################################################################
package Web25::Data::ExplorePage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use Sort::Key::Natural;
use Sort::Key::Maker sort_dbs =>
  sub { $$_{LABEL}, ($$_{BASE} || ''), $$_{ID} }, qw(nat nat int);
use Sort::Key::Maker sort_dataset_dbs =>
  sub { $$_{DBS}{LABEL}, ($$_{DBS}{BASE}||''), $$_{DBS}{ID}, $$_{NAME}, $$_{ID} },
  qw(nat nat int nat int);
use Sort::Key::Maker sort_name_id =>
  sub { $$_{NAME}, $$_{ID} }, qw(nat int);
use Sort::Key::Maker sort_name =>
  sub { $$_{NAME} }, qw(nat);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{SAVE_DB}   = [ qw(filter dcolumn rcolumn nvalue scolumn rows) ];
  $$self{SAVE_PAGE} = [ @{$$self{SAVE_DB}}, qw(dbs node dexp bexp) ];
  bless $self, $class;
  return $self;
}

sub init
{
    my $self = shift @_;
    $$self{NODE_LIST} = [ sort_name $self->node_list() ];
    my %nodesel = defined param('node')
	? (map { $_ => 1 } param('node'))
	: (map { $$_{ID} => 1 } grep($$_{NAME} =~ /CERN_MSS/, @{$$self{NODE_LIST}}));
    $$self{NODE_SHOWN} = [ grep($nodesel{$$_{ID}}, @{$$self{NODE_LIST}}) ];
    $$_{IS_SHOWN} = 1 for @{$$self{NODE_SHOWN}};
}

sub myurl
{
  my ($self, %args) = @_;

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Data::Replicas"
        && $args{"page"} ne "Data::Subscriptions");

  # If we stay in the same database, keep all, otherwise strip off db-specific
  my @save = $args{"db"} && $args{"db"} ne $$self{DBID}
    ? @{$$self{SAVE_DB}} : @{$$self{SAVE_PAGE}};

  # Return a URL with saved parameters
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub saveform
{
  my ($self, @omit) = @_;
  my $result = "";
  foreach my $option ('view', @{$$self{SAVE_PAGE}})
  {
    next if grep($option eq $_, @omit) || !defined param($option);
    if ($option eq 'nvalue')
    {
      $result .= "<input type='hidden' name='$option' value='$$self{NVALUE}' />";
    }
    elsif (grep($option eq $_, qw(dcolumn rcolumn scolumn)))
    {
      $result .= "<input type='hidden' name='$option' value='$_' />"
	for grep($$self{uc($option)}{$_}, param($option));
    }
    elsif (grep($option eq $_, qw(dbs node dexp bexp)))
    {
      $result .= "<input type='hidden' name='$option'"
		 . " value='@{[&escapeHTML($_)]}' />"
	for param($option);
    }
    else
    {
      $result .= "<input type='hidden' name='$option'"
	  . " value='@{[&escapeHTML(param($option))]}' />";
    }
  }

  return $result;
}

sub dbs_list
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select id, name, dls from t_dps_dbs
    order by name asc});

  my (%bases, @result);
  while (my ($id, $name, $dls) = $q->fetchrow())
  {
    # Build DBS object
    my $dbs = { ID => $id, URL => $name, DLS => $dls,
		BASE => undef, LABEL => $name };
    if ($name =~ /^(http.*)\?instance=(.*)/)
    {
      $$dbs{BASE} = $1;
      $$dbs{LABEL} = $2;
      $$dbs{LABEL} =~ s,/Writer$,,;
    }

    # Add HTML-formatted data
    my $htmllabel = &escapeHTML($$dbs{LABEL});
    my $htmldls = &breakAtSlash(&escapeHTML($$dbs{DLS}));
    my $suplink = "";
    if ($$dbs{BASE})
    {
      $bases{$$dbs{BASE}} = scalar(keys %bases) + 1
	if ! exists $bases{$$dbs{BASE}};
  
      $$dbs{BASE_ID} = $bases{$$dbs{BASE}};
      $suplink = "<sup><small>$$dbs{BASE_ID}</small></sup>";
    }
    $$dbs{HTML_DBS} = "$htmllabel$suplink";
    $$dbs{HTML_DLS} = $htmldls || '&nbsp;';

    # Add to the result
    push(@result, $dbs);
  }

  $q->finish();
  return @result;
}

sub dataset_list
{
  my ($self, @dbses) = @_;
  my $q = &dbprep($$self{DBH}, qq{
    select ds.id, ds.name, ds.is_open, ds.is_transient,
           nvl(count(b.id),0), nvl(sum(b.files),0), nvl(sum(b.bytes),0)
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
    where dbs = :dbsid
    group by ds.id, ds.name, ds.is_open, ds.is_transient
    order by ds.name asc});

  my @result = ();
  foreach my $dbs (@dbses)
  {
    &dbbindexec($q, ":dbsid" => $$dbs{ID});
    while (my ($id, $name, $open, $transient, $nblocks, $nfiles, $nbytes) = $q->fetchrow())
    {
      push(@result, {
	DBS => $dbs,
	ID => $id,
	NAME => $name,
	IS_OPEN => $open,
	IS_TRANSIENT => $transient,
	BLOCKS => $nblocks,
	FILES => $nfiles,
	BYTES => $nbytes });
    }
    $q->finish();
  }

  return @result;
}

sub dataset_replicas
{
  my ($self, @datasets) = @_;
  my $list = join(" or ", map { "ds.id = $$_{ID}" } @datasets);
  my $q = &dbexec($$self{DBH}, qq{
    select ds.id dataset, n.id node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
      join t_dps_block_replica br on br.block = b.id
      join t_adm_node n on n.id = br.node
    where $list
    group by ds.id, n.id});

  my %byid = map { $$_{ID} => $_ } @datasets;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{DATASET}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_list
{
  my ($self, $dataset) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, b.name, b.is_open, b.files, b.bytes
    from t_dps_block b where b.dataset = :dsid},
    ":dsid" => $$dataset{ID});

  my @result = ();
  while (my ($id, $name, $open, $nfiles, $nbytes) = $q->fetchrow())
  {
    push(@result, {
      DATASET => $dataset,
      ID => $id,
      NAME => $name,
      IS_OPEN => $open,
      BLOCKS => 1,
      FILES => $nfiles,
      BYTES => $nbytes });
  }

  $q->finish();
  return @result;
}

sub file_list
{
  my ($self, $block) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select f.id, f.logical_name, f.filesize, n.name
    from t_dps_file f join t_adm_node n on n.id = f.node
    where inblock = :bid},
    ":bid" => $$block{ID});

  my @result = ();
  while (my ($id, $name, $size, $source) = $q->fetchrow())
  {
    push(@result, {
      BLOCK => $block,
      SOURCE => $source,
      ID => $id,
      NAME => $name,
      SIZE => $size });
  }

  $q->finish();
  return @result;
}

sub block_replicas
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, br.node node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
    from t_dps_block b
      join t_dps_block_replica br on br.block = b.id
    where $list
    group by b.id, br.node});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{BLOCK}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_sources
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, f.node, n.name
    from t_dps_block b
      join t_dps_file f on f.inblock = b.id
      join t_adm_node n on n.id = f.node
    where $list
    group by b.id, f.node, n.name});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $node, $name) = $q->fetchrow())
  {
    $byid{$block}{SOURCES}{$node} = $name;
    $byid{$block}{DATASET}{SOURCES}{$node} = $name;
  }

  $q->finish ();
}

sub file_replicas
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, f.id, xr.node
    from t_dps_block b
      join t_xfer_file f on f.inblock = b.id
      join t_xfer_replica xr on xr.fileid = f.id
    where $list});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $file, $node) = $q->fetchrow())
  {
    $byid{$block}{FILE_REPLICAS}{$file}{$node} = 1;
  }

  $q->finish ();
}

sub node_list
{
  my ($self) = @_;

  my @result = ();
  my %nodes = $self->fetch_nodes(with_ids=>1);
  while (my ($name, $id) = each %nodes) {
    push(@result, { ID => $id, NAME => $name });
  }

  return @result;
}

sub apply_options
{
  my ($self) = @_;

  # Determine which dataset options we are showing (in dataset mode)
  $$self{DCOLUMN_NAMES} = [ qw(DBS Name Blocks Files Bytes Open Transient Id) ];
  $$self{DCOLUMN} = { "DBS" => 0, "Name" => 1, "Blocks" => 0, "Files" => 1,
                      "Bytes" => 1, "Open" => 0, "Transient" => 0, "Id" => 0 };
  if (defined param('dcolumn'))
  {
    $$self{DCOLUMN}{$_} = 0 for keys %{$$self{DCOLUMN}};
    $$self{DCOLUMN}{$_} = 1 for grep(exists $$self{DCOLUMN}{$_}, param('dcolumn'));
  }

  # Determine which replica options we are showing (in replica mode)
  $$self{RCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{RCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
		    
  if (defined param('rcolumn'))
  {
    $$self{RCOLUMN}{$_} = 0 for keys %{$$self{RCOLUMN}};
    $$self{RCOLUMN}{$_} = 1 for grep(exists $$self{RCOLUMN}{$_}, param('rcolumn'));
  }

  # Determine which replica options we are showing (in subscription mode)
  $$self{SCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{SCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
  if (defined param('scolumn'))
  {
    $$self{SCOLUMN}{$_} = 0 for keys %{$$self{SCOLUMN}};
    $$self{SCOLUMN}{$_} = 1 for grep(exists $$self{SCOLUMN}{$_}, param('scolumn'));
  }

  # Determine which replica value we show (in replica mode)
  $$self{NVALUES} = [ "Node blocks", "Node files", "Node bytes",
		      "Destined blocks", "Destined files", "Destined bytes",
		      "Missing blocks", "Missing files", "Missing bytes" ];
  $$self{NVALUE} = param('nvalue') || "Node files";
  $$self{NVALUE} = "Node files" if !grep($$self{NVALUE} eq $_, @{$$self{NVALUES}});

  # Determine if we are showing all or interesting rows
  $$self{ROWS} = param('rows') || 'all';
  $$self{ROWS} = 'all' if !grep($$self{ROWS} eq $_, qw(all interesting));
}

sub fetch_data
{
  my ($self) = @_;

  # Obtain the list of DBSes, sort them and pick the ones we show.
  my %shown = map { $_ => 1 } param('dbs');
  $$self{DBS_LIST} = [ sort_dbs $self->dbs_list() ];

  if (keys %shown)
  {
    $$self{DBS_SHOWN} = [ grep(exists $shown{$$_{ID}}, @{$$self{DBS_LIST}}) ];
  }
  else
  {
    $$self{DBS_SHOWN} = $$self{DBS_LIST};
  }

  $$_{IS_SHOWN} = 1 for @{$$self{DBS_SHOWN}};

  # Now get a sorted list of the datasets we are interested in
  my $filter = param('filter');
  $filter = "." if ! defined $filter || $filter eq '';
  my @datasets = grep($$_{NAME} =~ /$filter/,
		      $self->dataset_list(@{$$self{DBS_SHOWN}}));
  if ($$self{DCOLUMN}{"DBS"})
  {
    $$self{DATASET_LIST} = [ sort_dataset_dbs @datasets ];
  }
  else
  {
    $$self{DATASET_LIST} = [ sort_name_id @datasets ];
  }

  # Fetch blocks and block replicas
  my %dexpand = map { $_ => 1 } param('dexp');
  my %bexpand = map { $_ => 1 } param('bexp');
  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    if (! $dexpand{$$ds{ID}})
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ $$ds{ID}, param('dexp') ]) .
        "#d$$ds{ID}'>&#187;</a>";
    }
    else
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ grep($_ != $$ds{ID}, param('dexp')) ]) .
        "#d$$ds{ID}'>&#171;&#171;</a>";
    }

    # Pass if not expanded
    next if ! $dexpand{$$ds{ID}};

    # Expanded, obtain block list
    $$ds{BLOCK_LIST} = [ sort_name $self->block_list($ds) ];
    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      if (! $bexpand{$$block{ID}})
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ $$block{ID}, param('bexp') ]) .
          "#b$$block{ID}'>&#187;</a>";
      }
      else
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ grep($_ != $$block{ID}, param('bexp')) ]) .
          "#b$$block{ID}'>&#171;&#171;</a>";
      }

      # Pass if not expanded
      next if ! $bexpand{$$block{ID}};

      # Expanded, obtain file list
      $$block{FILE_LIST} = [ sort_name $self->file_list($block) ];
    }
  }

  # Fetch per-node replicas for datasets, blocks and files in expanded view
  if (ref ($self) !~ /Datasets/)
  {
    $self->dataset_replicas(@{$$self{DATASET_LIST}})
      if @{$$self{DATASET_LIST}};

    my @allblocks = map { @{$$_{BLOCK_LIST}} } grep($$_{BLOCK_LIST}, @{$$self{DATASET_LIST}});

    $self->block_replicas(@allblocks)
      if @allblocks;

    $self->block_sources(@allblocks)
      if (@allblocks
	  && ((ref ($self) =~ /::Replicas/ && $$self{RCOLUMN}{"Source"})
	      || (ref ($self) =~ /::Subs/ && $$self{SCOLUMN}{"Source"})));

    my @expblock = grep($bexpand{$$_{ID}}, @allblocks);
    $self->file_replicas(@expblock) if @expblock;
  }
}


sub dbs_form
{
    my ($self) = @_;

    my $form = "";
    $form .= "<div id='dbschoice'>\n";
    $form .= "  <div id='dbsmenu' style='width:100%;font-size:0.9em'>\n";
    $form .= "    <table>\n";
    $form .= "     <thead>\n";
    $form .= "      <tr>\n";
    $form .= "       <th width='4%' align='center'>Show</th>\n";
    $form .= "       <th width='20%' align='left'>DBS</th>\n";
    $form .= "       <th width='100%' align='left'>DLS contact</th>\n";
    $form .= "       <th width='4%' align='right'>Id</th>\n";
    $form .= "      </tr>\n";
    $form .= "     </thead>\n";
    $form .= "     <tbody>\n";

    my $n = 0;
    foreach my $dbs (@{$$self{DBS_LIST}})
    {
	my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
	$form .= "      <tr$rowcolor>\n";
	$form .= "       <td align='center'><input type='checkbox' name='dbs' value='$$dbs{ID}'";
	$form .= ($$dbs{IS_SHOWN} ? " checked='checked'" : '') . " /></td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DBS}</td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DLS}</td>\n";
	$form .= "       <td align='right' style='color:#666'>$$dbs{ID}</td>\n";
	$form .= "      </tr>\n";
    }
    $form .= "     </tbody>\n";
    $form .= "    </table>\n";
    $form .= "  </div>\n";
    $form .= "</div>\n";
    return $form;
}

sub node_form
{
  my ($self) = @_;

  my $form = "";

  $form .= "<div id='nodechoice'>\n";
  $form .= "<input type='button' value='Select all' onclick=\"select_all('nodechoice', 'node', '1')\"/>\n",
  $form .= "<input type='button' value='Select none' onclick=\"select_all('nodechoice', 'node', '0')\"/>\n",

  my (@all, @columns) = @{$$self{NODE_LIST}};
  my $percolumn = int(scalar(@all)/4 + 0.5);
  $percolumn = 4 if ! $percolumn;
  push (@columns, [ splice(@all, 0, $percolumn) ]) while @all;

  $form .= "  <div id='nodemenu' style='font-size:0.9em'>\n";
  $form .= "    <table style='white-space:  nowrap;'>\n";
  $form .= "     <tbody>\n";
  $form .= "      <tr>\n";

  foreach my $col (@columns)
  {
      $form .= "       <td>\n";
      $form .= join("\n", (map { "        <input type='checkbox' name='node' value='$$_{ID}'" .
				     ($$_{IS_SHOWN} ? " checked='checked'" : "") .
				     " />&nbsp;" . &escapeHTML($$_{NAME}) . "<br />" }
			   @$col));
      $form .= "       </td>\n";
  }
  
  $form .= "     </tr>\n";
  $form .= "    </tbody>\n";
  $form .= "   </table>\n";
  $form .= " </div>\n";
  $form .= "</div>\n";
  return $form;
}


sub columns_form
{
    my ($self, @display_columns) = @_;

    my $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Display Columns</i></p>\n";
    foreach my $pair (@display_columns)
    {
	my ($dataset, $column) = @{$pair};

	$form .= "   <input type='checkbox' name='$dataset' value='$column'" .
	    ($$self{uc($dataset)}{$column} ? " checked='checked'" : "") .
	    " />&nbsp;$column<br/>\n";
    }
    
    return $form;
}

sub output_filter
{
  my ($self) = @_;
  my $filter = param('filter');
  my $filterform = "" .
    "<form style='display:inline' method='get' action='@{[$self->myurl()]}'>" .
    $self->saveform('filter') .
    textfield(-name=>'filter', -default=>$filter, -size=>15,
	      -title=>("Regular expression to match against the name column. "
		       ."Only those matching the expression will be shown.")) .
    " <input type='submit' value='Filter' />" .
    "</form>";

  return ($filter, $filterform);
}

sub output
{
  my ($self) = @_;

  # Apply form options and fetch the data we show on this form
  $self->apply_options();
  $self->init();
  $self->output_page();
  $self->output_options_form();
}

1;


######################################################################
package Web25::Data::Replicas;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Replicas",
	       LINK_TITLE => "Explore replicas" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  $self->fetch_data(); # puts all data into $self

  my ($filter, $filterform) = $self->output_filter();

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $node_th = $$self{NVALUE};
  $node_th =~ s/Node\s+//;
  $node_th =~ s/ +/\&nbsp;/g;
  $node_th = ucfirst($node_th);

  print { $$self{CONTENT} }
    "<table id='dataset_tbl'>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{RCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{RCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{DCOLUMN}{"Blocks"}    ? "   <th width='4%' align='center'>Blocks</th>\n" : ()),
    ($$self{RCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{RCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{RCOLUMN}{"Source"}    ? "   <th width='6%' align='left'>Source</th>\n" : ()),
    ($$self{DCOLUMN}{"Open"}      ? "   <th width='4%' align='center'>Open</th>\n" : ()),
    ($$self{DCOLUMN}{"Transient"} ? "   <th width='4%' align='center'>Transient</th>\n" : ()),
    (map { "   <th width='4%' align='center'>@{[&escapeHTML($$_{NAME})]} $node_th</th>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody>\n";

  my $n = 0;
  my %total = (BLOCKS => 0, FILES => 0, BYTES => 0);
  $total{$$_{ID}} = { VALUE => 0, ATTR => "" } for @{$$self{NODE_SHOWN}};
  my ($quantity, $formatter) = ("", sub { return -1, 0 }, sub { return @_ });
  if ($$self{NVALUE} eq "Node blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = (($$obj{NODE_BLOCKS} || $$obj{DEST_BLOCKS}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = ($$obj{DEST_BLOCKS} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BLOCKS} || 0) - ($$obj{NODE_BLOCKS} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BLOCKS} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = (($$obj{NODE_FILES} || $$obj{DEST_FILES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = ($$obj{DEST_FILES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_FILES} || 0) - ($$obj{NODE_FILES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = (($$obj{NODE_BYTES} || $$obj{DEST_BYTES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = ($$obj{DEST_BYTES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BYTES} || 0) - ($$obj{NODE_BYTES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }

  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my %values = ();
    my $interesting = 0;
    foreach my $node (@{$$self{NODE_SHOWN}})
    {
      my ($value, $refvalue, $intr) = &$quantity($ds, $$ds{REPLICAS}{$$node{ID}});
      my $attr = $value == $refvalue ? "" : " style='color:#d00'";
      $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
      $interesting ||= $intr;
    }

    next if $$self{ROWS} eq 'interesting' && ! $interesting;

    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    my @sources = ($$ds{SOURCES} ? values %{$$ds{SOURCES}}
		   : "<span style='color:#666'>(Expand)</span>");
    my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		  ? "<span style='color:#666'>(Multiple)</span>"
		  : $sources[0]);
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{RCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>@{[&format_num($$ds{BLOCKS})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
      ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$ds{IS_OPEN}</td>\n" : ()),
      ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>$$ds{IS_TRANSIENT}</td>\n" : ()),
    (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
      "  </tr>\n";

    $total{BYTES} += $$ds{BYTES};
    $total{BLOCKS} += $$ds{BLOCKS};
    $total{FILES} += $$ds{FILES};
    for (@{$$self{NODE_SHOWN}})
    {
      $total{$$_{ID}}{VALUE} += $values{$$_{ID}}{VALUE};
      $total{$$_{ID}}{ATTR} ||= $values{$$_{ID}}{ATTR};
    }

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      %values = ();
      $interesting = 0;
      foreach my $node (@{$$self{NODE_SHOWN}})
      {
        my ($value, $refvalue, $intr) = &$quantity($block, $$block{REPLICAS}{$$node{ID}});
        my $attr = $value == $refvalue ? "" : " style='color:#d00'";
        $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
        $interesting ||= $intr;
      }

      next if $$self{ROWS} eq 'interesting' && ! $interesting;

      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      my @sources = ($$block{SOURCES} ? values %{$$block{SOURCES}}
		     : "<span style='color:#666'>(Expand)</span>");
      my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		    ? "<span style='color:#666'>(Multiple)</span>"
		    : &escapeHTML($sources[0]));
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>&nbsp;</td>\n" : ()),
        ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
        ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$block{IS_OPEN}</td>\n" : ()),
        ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
        (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
        "  </tr>\n";

      foreach my $file (@{$$block{FILE_LIST}})
      {
        my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
        my $span = 1; $span++ if $$self{RCOLUMN}{"Files"};
        my $have = "<span style='color:#666'>y</span>";
        my $havenot = "<span style='color:#d00'>N</span>";
        my $goal = ($$self{NVALUE} =~ /Missing/ ? $havenot : $have);
	my %nodeattr = map { $$_{ID} => ($$block{FILE_REPLICAS}{$$file{ID}}{$$_{ID}}
			                 ? $have : $havenot) }
		      @{$$self{NODE_SHOWN}};
	$interesting = scalar(grep($_ eq $goal, values %nodeattr));
	next if $$self{ROWS} eq 'interesting' && ! $interesting;

        print { $$self{CONTENT} }
          "  <tr$rowcolor>\n",
          "   <td>&nbsp;</td>\n",
          ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
          ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:3em' colspan='$span'>@{[&escapeHTML($$file{NAME})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$file{SIZE})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>@{[&escapeHTML($$file{SOURCE})]}</td>\n" : ()),
          ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
          (map { "   <td align='right'>$nodeattr{$$_{ID}}</td>\n" } @{$$self{NODE_SHOWN}}),
          "  </tr>\n";
      }
    }
  }

  print { $$self{CONTENT} }
  " </tbody>\n",
  " <tfoot>\n",
  "   <tr bgcolor='#f8f8f8'>\n",
  "    <th>&nbsp;</th>\n",
  ($$self{RCOLUMN}{"DBS"} && $$self{RCOLUMN}{"Name"}
   ? "   <th colspan='2' align='left'>Total</th>\n"
   : $$self{RCOLUMN}{"DBS"} || $$self{RCOLUMN}{"Name"}
   ? "   <th align='left'>Total</th>\n"
   : ()),
       ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>@{[&format_num($total{BLOCKS})]}</td>\n" : ()),
       ($$self{RCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Source"}    ? "   <th align='right'>&nbsp;</th>\n" : ()),
       ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
       ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
       (map { "   <td align='right'$total{$$_{ID}}{ATTR}>@{[&$formatter($total{$$_{ID}}{VALUE})]}</td>\n" } @{$$self{NODE_SHOWN}}),
       "   </tr>\n",
       " </tfoot>\n",
       "</table>\n";
  
  # Produce "footnotes" for the DBS URL base strings
  my %bases = map { $$_{BASE_ID} => $$_{BASE} } grep($$_{BASE}, @{$$self{DBS_LIST}});
  if (keys %bases)
  {
      print { $$self{CONTENT} }
      "<div style='font-size: 0.9em;margin-top:1em'>\n<hr>\n",
      (map { ("<sup><small>$_</small></sup>",
	      "&nbsp;", &breakAtSlash(&escapeHTML($bases{$_})), "<br />\n") }
       sort keys %bases),
      "</div>";
  }
}

# Produce content to the options panel
sub output_options_form
{
    my ($self) = @_;

    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = "";

    # Save everything except what this form controls
    $form = $self->saveform(qw(dcolumn rcolumn node nvalue dbs rows));
    $optspane->add_hidden($form);

   # Columns Tab
    my @display_columns;
    push @display_columns, 
    [('rcolumn', 'DBS')], 
    [('rcolumn', 'Name')], 
    [('dcolumn', 'Blocks')],
    [('rcolumn', 'Files')], 
    [('rcolumn', 'Bytes')], 
    [('rcolumn', 'Source')], 
    [('dcolumn', 'Open')], 
    [('dcolumn', 'Transient')];

    $form = $self->columns_form(@display_columns);
    $optspane->add_tab('Columns', $form);

    # DBS Source tab
    $form = $self->dbs_form();
    $optspane->add_tab('DBS Sources', $form);

    # Node Selection tab
    $form = $self->node_form();
    $optspane->add_tab('Nodes Shown', $form);
    
    # Node Values tab
    $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Node Values</i></p>\n";
    foreach my $opt (@{$$self{NVALUES}})
    {
	$form .= "  <input type='radio' name='nvalue' value='$opt'" .
	    ($$self{NVALUE} eq $opt ? " checked='checked'" : "") .
	    " />&nbsp;$opt<br/>\n";
    }

    $form .= "   <p style='margin-top:1ex'><i>Filter rows</i></p>\n" .
	"   <input type='radio' name='rows' value='all'" .
	($$self{ROWS} eq 'all' ? " checked='checked'" : "") .
	" />&nbsp;Show all rows<br/>\n" .
	"   <input type='radio' name='rows' value='interesting'" .
	($$self{ROWS} eq 'interesting' ? " checked='checked'" : "") .
	" />&nbsp;Show interesting rows<br/>\n";

    $optspane->add_tab('Node Values', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;

######################################################################
package Web25::Data::Subscriptions;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Subscriptions",
	       LINK_TITLE => "Explore subscriptions" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  if (!$$self{SECMOD}->isAuthenticated() &&
      !($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
	$$self{SECMOD}->hasRole('Data Manager') ||
	$$self{SECMOD}->hasRole('Site Admin'))) {
      $self->auth_help('suspend/unsuspend subscriptions'
		       => ['anyauth', 'Data Manager', 'Site Admin', 'Global Admin'],
		       'change priorities of subscriptions'
		       => ['cert', 'Data Manager', 'Global Admin']);
      }

  my %admin_opts = ('suspend' => 'Suspend subscriptions',
		    'unsuspend' => 'Unsuspend subscriptions',
		    'priorityhi' => 'Make high priority',
		    'prioritymd' => 'Make normal priority',
		    'prioritylo' => 'Make low priority');
  my %admin_grps = ('suspend' => ['suspend', 'unsuspend'],
		    'priority' => ['priorityhi', 'prioritymd', 'prioritylo']);
  my @admin_auth;
  if ($$self{SECMOD}->isAuthenticated() &&
      ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
      $$self{SECMOD}->hasRole('Data Manager') ||
      $$self{SECMOD}->hasRole('Site Admin'))) {
      push @admin_auth, 'suspend';
  }

  if ($$self{SECMOD}->isCertAuthenticated() &&
      ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
      $$self{SECMOD}->hasRole('Data Manager'))) {
      push @admin_auth, 'priority';
  }

  if (param('subsaction')) {
      $self->update_subscriptions();
  }

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $q =$self->data_subscriptions();
  
  my @cols = qw(SELECT ITEM_LEVEL ITEM_NAME NODE_NAME PRIORITY 
		IS_MOVE IS_TRANSIENT TIME_SUSPEND_UNTIL);
  my $th =
  { SELECT => 'Select',
    ITEM_LEVEL => 'Data Level',
    ITEM_NAME => 'Data Item',
    NODE_NAME => 'Node',
    PRIORITY => 'Priority',
    IS_MOVE => 'Replica/Move',
    IS_TRANSIENT => 'Open/Closed',
    TIME_SUSPEND_UNTIL => 'Active/Suspended' };
  
  # Special data fromats
  my $now = time();
  my $df = 
  { 
      PRIORITY => sub { if ($_[0] == 0) { return 'High'; }
			if ($_[0] == 1) { return 'Normal'; }
			if ($_[0] == 2) { return 'Low'; } },
      IS_MOVE => sub { return $_[0] eq 'y' ? 'Move' : 'Replica'; },
      TIME_SUSPEND_UNTIL => sub { 
	  my $susp_time = $_[0];
	  if (!defined $susp_time || $susp_time <= $now) { return 'Active'; }
	  elsif ($susp_time == 9_999_999_999)            { return 'Suspended Forever'; }
	  else { return 'Suspended Until  '.&formatTime($susp_time, 'stamp') }
      },
      IS_TRANSIENT => sub { return $_[0] eq 'y' ? 'Closed' : 'Open'; }
  };

  # Special cell formats
  my $cf = 
  { 
      TIME_SUSPEND_UNTIL => sub { return defined $_[0] && $_[0] >= $now ? 'alarm' : ''; }
  };

  # Pseudo columns
  my %pseudo =
      (
       'SELECT'  => sub { "<input type='checkbox' name='s_id' value='$_[1]->{ITEM_LEVEL}:$_[1]->{ITEM_ID}:$_[1]->{NODE_ID}'/>" }
       );
  
  if (!@admin_auth) {
      delete $pseudo{SELECT};
      delete $df->{SELECT};
      delete $th->{SELECT};
      @cols = grep !/SELECT/, @cols;
  }

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead($th);
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats($df);
  $dbtable->set_cellformats($cf);
  $dbtable->add_pseudocolumn($_, $pseudo{$_}) foreach (keys %pseudo);

  if (@admin_auth) {
      print { $$self{CONTENT} }
      "<p><label>Selections:</label>\n",
      "<input type='button' value='Select all' onclick=\"select_all('subsform', 's_id', '1')\"/>\n",
      "<input type='button' value='Select none' onclick=\"select_all('subsform', 's_id', '0')\"/>\n",
      "</p>\n";

      my $target = $self->myurl();
      print { $$self{CONTENT} }
      "<form id='subsform' method='post' action='$target'>",
      $self->saveform(),
      "<p>\n",
      "<label>Actions:</label>\n",
      "<select class='labeled' name='subsaction'>\n";
      foreach my $auth (@admin_auth) {
	  foreach my $opt (@{$admin_grps{$auth}}) {
	      print { $$self{CONTENT} } 
	      "<option value='$opt'>$admin_opts{$opt}</option>\n";
	  }
      }
      print { $$self{CONTENT} }
      "</select>\n",
      "<input type='submit' value='Update'/>\n",
      "</p>\n";

  }

  my $nrows = $dbtable->output($q);

  if (@admin_auth) {
      print { $$self{CONTENT} } "</form>\n";
  }

  if ($nrows == 0) {
      $self->alert("No data exists for your selected nodes.");
  }
}

sub update_subscriptions
{
    my ($self) = @_;

    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager||Site Admin', with_ids => 1);
    
    my %all_nodes = reverse $self->fetch_nodes(with_ids => 1); # just a hash of id => name

    my $upd_suspend = qq[ update t_dps_subscription set time_suspend_until = :val
			  where _ITEM_ = :id and destination = :dest ];
    my $upd_priority = qq[ update t_dps_subscription set priority = :val
			   where _ITEM_ = :id and destination = :dest];

    my $action_list = 
    {
	suspend => { desc => ' suspended',
		     sql  => $upd_suspend,
		     val  => 9_999_999_999 },
    	unsuspend => { desc => ' unsuspended',
		       sql  => $upd_suspend,
		       val  => undef },
	priorityhi => { desc => ' set to high priority',
			sql => $upd_priority,
			val => 0 },
	prioritymd => { desc => ' set to medium priority',
			sql => $upd_priority,
			val => 1 },
	prioritylo => { desc => ' set to low priority',
			sql => $upd_priority,
			val => 2 }
    };

    # Execute the update
    my $action = $action_list->{param('subsaction')};

    my $n_changed = 0;
    my %warn_hash;  # to keep unique warnings

    foreach (param('s_id')) {
	my ($level, $id, $destination) = split /:/;
	if (grep $destination == $_, values %auth_nodes) { # Check permission
	    my $sql = $$action{sql};
	    $sql =~ s/_ITEM_/$level/;

	    my @rv = &dbexec($$self{DBH}, $sql, 
			     ':val' => $$action{val},
			     ':id'  => $id,
			     ':dest' => $destination);
	    $n_changed += $rv[1];
	} else {
	    my $warn = "<p class='alarm'>Sorry, you don't have permission to update ".
		"$all_nodes{$destination} subscriptions!</p>";
	    $warn_hash{$warn} = 1;
	}
    }

    $$self{DBH}->commit();

    # Print scoldings
    print { $$self{CONTENT} } keys %warn_hash;

    # Report the changes
    if ($n_changed) {
	print { $$self{CONTENT} } "<p class='note'>$n_changed data items $action->{desc}!</p>";
    } else {
	print { $$self{CONTENT} } "<p class='alarm'>Nothing was changed!<p>";
    }
}

# Produce content to the options panel
sub output_options_form
{
    my ($self) = @_;

    my $optspane = new Web25::OptsPane;

    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = "";

    # Save everything except what this form controls
    $form = $self->saveform(qw(node));
    $optspane->add_hidden($form);

    # Node Selection tab
    $form = $self->node_form();
    $optspane->add_tab('Nodes Shown', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

sub data_subscriptions
{
  my ($self) = @_;
  $self->fetch_nodes();
  my @node_ids = map { $$_{IS_SHOWN} ? $$_{ID} : '' } @{$$self{NODE_LIST}};
  @node_ids = grep /\d+/, @node_ids;
  my ($where_list) = join(' or ', map { "n.id=$_"} @node_ids );

  my $q = &dbexec($$self{DBH}, qq{
    select NVL2(s.block, 'BLOCK', 'DATASET') item_level,
           NVL2(s.block, s.block, s.dataset) item_id,
           NVL2(s.block, b.name, ds.name) item_name,
           n.id node_id,
           n.name node_name,
           s.priority,
           s.is_move,
           s.is_transient,
           s.time_suspend_until
      from t_dps_subscription s
      join t_adm_node n on n.id = s.destination
      left join t_dps_dataset ds on ds.id = s.dataset
      left join t_dps_block b on b.id = s.block
     where $where_list
     order by n.name, ds.id, b.id
  });

  return $q;
}


1;

######################################################################
package Web25::Data::Delete;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Delete",
	       LINK_TITLE => "Delete datasets or blocks from PhEDEx database",
               SECURE => 0 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  if ($$self{SECMOD}->isCertAuthenticated() &&
      ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
       $$self{SECMOD}->hasRole('Data Manager'))) {
      $self->deletion_form();
  } else {
      $self->auth_help('delete datasets and blocks' => ['cert', 'Data Manager', 'Global Admin']);
  }
  $self->deletion_queue();
}

sub deletion_form
{
    my $self = shift @_;

    my $del_url = $self->myurl('page' => 'Data::DeleteConfirm');
    my @nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');
    
    print { $$self{CONTENT} }
    "<h1>Delete Data</h1>",
    "<p>Enter the data items you would like to delete.  Deletions are ",
    "added to the queue and are actually deleted when the deletion agents ",
    "get around to it.</p>",
    
    "<form class='nice' method='post' action='$del_url'>";

    if ($$self{SECMOD}->hasRole('Global Admin', 'phedex')) {
	print {$$self{CONTENT}}
	"<label>Nodes:</label>",
	"<div class='labeled'  style='font-size:8pt;width:450px;height:150px;overflow:scroll;border:thin solid black;' >",
	"<table><tr valign='top'>",
	"  <td>\n",
	(map { &striplabels(checkbox(-name=>'node', -label=>'', -value=>$_)."$_<br/>") }
	 sort grep (/^T1_|T0_/, @nodes)),
	"  </td>\n",
	"  <td>\n",
	(map { &striplabels(checkbox(-name=>'node', -label=>'', -value=>$_)."$_<br/>") }
	 grep (/^T2_/, @nodes)),
	"  </td>\n",
	"  <td>\n",
	(map { &striplabels(checkbox(-name=>'node', -label=>'', -value=>$_)."$_<br/>") }
	 grep (! /^T[012]_/, @nodes)),
	"  </td>\n",
	" </tr></table></div><br/>\n";
    } else {
	print {$$self{CONTENT}}
	"<label>Node:</label>",
	popup_menu(-name=>'node', -values=>[@nodes], -class=>'labeled'),
	"<br/>";
    }
    
    print {$$self{CONTENT}}
    "<label>Data Items:<br/><br/>",
    "<span class='note'>/Primary/Processed/Dataset<br/>or<br/>",
    "/Primary/Processed/Tier#Block<br/>(Use * as wildcard)</span><br/>",
    &help("More Help", "Data Item List", 
	  "A whitespace separated list of the datasets or blocks you are ",
	  "deleting.  Glob-style wildcards may be used, but the dataset ",
	  "path separators are required.  E.g. to delete all ",
	  "datasets you would have to write '/*/*/*', not '*'."), 
    "</label>\n",
    textarea(-name=>'data', -value=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), 
    "<br/>",

    "<label>Remove Subscriptions?:</label>",
    popup_menu(-name=>'rm_subscriptions', -values=>[qw(y n)], -labels=>{y => 'Yes', n => 'No'}, -class=>'labeled'),
    &help("[what's this?]", "Remove Subscriptions",
	  "If you choose not to remove the subscription when deleting data PhEDEx will ",
	  "retransfer the data to your node after the deletion is complete."),
    "<br/>",

    "<label>&nbsp;</label>", 
    submit(-class=>'labeled', -value=>'Go to Confirmation'), "<br/>",
    "</form>";
}

sub deletion_queue
{
    my $self = shift @_;

    print { $$self{CONTENT} }
    "<h1>Deletion Queue</h1>",
    "<p>This table contains the blocks which are queued for deletion.</p>";
    
    my $sql = qq{ select n.name node, ds.name dataset, b.name block, del.time_request, del.time_complete
		      from t_dps_block_delete del
		      join t_dps_block b on b.id = del.block
		      join t_dps_dataset ds on ds.id = del.dataset
		      join t_adm_node n on n.id = del.node
		      order by del.time_complete desc, del.time_request desc };
    
    my $q = &dbexec($$self{DBH}, $sql);
    
    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{CONTENT});
    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');
    $dbtable->set_tablehead({ DATASET => 'Dataset',
			      BLOCK => 'Block',
			      NODE => 'Node',
			      TIME_REQUEST => 'Requested',
			      TIME_COMPLETE => 'Completed' });
    $dbtable->set_dataformats({ TIME_REQUEST  => sub { &formatTime($_[0], 'stamp') },
				TIME_COMPLETE => sub { $_[0] ? &formatTime($_[0], 'stamp') : 'Pending' } });
    
    $dbtable->output($q);
}

1;

######################################################################
package Web25::Data::DeleteConfirm;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use Text::Glob 'glob_to_regex';
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Delete Confirmation",
	       LINK_TITLE => "Delete datasets or blocks from PhEDEx database",
               SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    if (request_method() ne 'POST') {
    	alert($self, "This form can only be accessed with 'POST' method.");
	return;
    }

    unless ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
	     $$self{SECMOD}->hasRole('Data Manager'))) {
	$self->auth_help('delete datasets and blocks' => ['cert', 'Data Manager', 'Global Admin']);
	return;
    }

    my $bad = 0;
    unless (param('node') || param('data') || param('rm_subscriptions')) {
	$self->alert("Insufficient parameters");
	$bad = 1;
    }

    my $data = param('data');
    unless ($data) { $self->alert("No data items given"); $bad = 1; }
    my @nodes = param('node');
    unless (@nodes) { $self->alert("No nodes given"); $bad = 1; }

    my $rm_subscriptions = (param('rm_subscriptions') eq 'y' ? 1 : 0);

    my @auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager');
    foreach my $node (@nodes) {
	if (! grep $node eq $_, @auth_nodes) {
	    $self->alert("You don't have permission to delete data from $node.");
	    $bad = 1;
	}
    }
    
    # Parse users data field
    my %userdata = $self->parse_userdata($data);
    foreach (keys %userdata) {
	if (! $userdata{$_} ) {
	    $self->alert("The data pattern is &ldquo;@{[&escapeHTML($_)]}&rdquo;",
			 " does not match pattern of type /PRIMARY/TIER/DATASET or /PRIMARY/DATASET#BLOCK.");
	    $bad = 1;
	}
    }

    return if $bad;

#    &dump_var($$self{CONTENT}, 'userdata', {%userdata});

    # Find matches in replicas tables for the given nodes
    my ($node_list, %node_binds) = &dbinlist('node', @nodes);
    my $sql = qq{select n.id node_id, n.name node,
		        ds.id dataset_id, ds.name dataset,
		        b.id block_id, b.name block, b.bytes,
		        NVL2(dataset_subs.destination, 'y', 'n') dataset_subscribed,
		        NVL2(block_subs.destination, 'y', 'n') block_subscribed,
                        bd.block block_queued
   	           from t_dps_dataset ds
		   join t_dps_block b on b.dataset = ds.id
                   join t_dps_block_replica br on br.block = b.id
                   join t_adm_node n on n.id = br.node
              left join t_dps_subscription block_subs on block_subs.destination = n.id and block_subs.block = b.id
              left join t_dps_subscription dataset_subs on dataset_subs.destination = n.id and dataset_subs.dataset = ds.id
              left join t_dps_block_delete bd on bd.block = b.id and bd.node = n.id
		  where n.name in ($node_list)
	          order by n.name, ds.name };

    my $q = &dbexec($$self{DBH}, $sql, %node_binds);
    my @matches;
    my @dupes;
    my %usermatch = map { $_ => 0 } keys %userdata;
    my $blockwarnings = 0;
    ITEM: while (my $row = $q->fetchrow_hashref()) {
	foreach (keys %userdata) {
	    my $kind = $userdata{$_}; # DATASET or BLOCK
	    my $pattern = glob_to_regex($_);
	    if ($$row{$kind} =~ $pattern) {
		if ($rm_subscriptions && $kind eq 'BLOCK' && $$row{DATASET_SUBSCRIBED} eq 'y') {
		    $$row{BLOCKWARN} = 1;
		    $blockwarnings++;
		}
		if ($$row{BLOCK_QUEUED}) {
		    push @dupes, $row;
		} else {
		    push @matches, $row;
		}
		$usermatch{$_}++;
		next ITEM;
	    }
	}
    }
    my @nomatch = grep $usermatch{$_} == 0, keys %usermatch;

 #   &dump_var($$self{CONTENT}, 'matches', [@matches]);

    if (!param('execute')) {
	if (@matches) {
	    print {$$self{CONTENT}}
	    "<h1>Confirm Deletion</h1>",
	    "<h2>Blocks To Be Deleted</h2>",
	    "<p>The following blocks matched your selection and will be deleted upon your confirmation.</p>",
	    ($rm_subscriptions ? "<p>Subscriptions, where they exist,  will also be deleted.</p>" :
	     "<p>Subscriptions will <b>not</b> be removed, so you can expect a retransfer to be initiated</p>");
	    
	    # List matches for user confirmation
	    my $table = new Web25::TableSpool;
	    $table->set_filehandle($$self{CONTENT});
	    $table->set_tableclass('data');
	    $table->set_stripeclass('stripe');
	    $table->set_tablecols([qw(NODE DATASET BLOCK SUBSCRIBED BYTES)]);
	    $table->set_tablehead({NODE => 'Node',
				   DATASET => 'Dataset',
				   BLOCK => 'Block',
				   SUBSCRIBED => 'Block Subscribed?',
				   BYTES => 'Bytes' });
	    $table->add_pseudocolumn( SUBSCRIBED => sub { my ($ds, $b) = ($_[1]->{DATASET_SUBSCRIBED}, 
									  $_[1]->{BLOCK_SUBSCRIBED});
							  if ($ds eq 'y') { return 'Yes, via dataset'; }
							  elsif ($b eq 'y') { return 'Yes' }
							  else { return 'No' } });
	    $table->set_dataformats({ BYTES => sub { &format_size($_[0]) } });
	    $table->set_rowformats({ BLOCKWARN => sub { return $_[0] ? 'alarm' : '' } });
	    $table->start();
	    $table->head();
	    $table->row($_) foreach @matches;
	    $table->finish();
	}

	if (@dupes) {
	    print {$$self{CONTENT}}
	    "<h2>Blocks Already Queued</h2>",
	    "<p>Patience!  The following blocks you selected are already queued for deletion!  ",
	    "They will not be queued again.</p>";
	    my $table = new Web25::TableSpool;
	    $table->set_filehandle($$self{CONTENT});
	    $table->set_tableclass('data');
	    $table->set_stripeclass('stripe');
	    $table->set_tablecols([qw(NODE DATASET BLOCK)]);
	    $table->set_tablehead({NODE => 'Node',
				   DATASET => 'Dataset',
				   BLOCK => 'Block'});
	    $table->start();
	    $table->head();
	    $table->row($_) foreach @dupes;
	    $table->finish();
	}
	
	if (@nomatch) {
	    print {$$self{CONTENT}}
	    "<h2>Not Matched</h2>",
	    "<p>These selections did not match any known replicas that PhEDEx can delete.</p>";
	    my $table = new Web25::TableSpool;
	    $table->set_filehandle($$self{CONTENT});
	    $table->set_tableclass('data');
	    $table->set_stripeclass('stripe');
	    $table->start();
	    $table->head('Selection');
	    $table->row($_) foreach @nomatch;
	    $table->finish();
	}
	
	if (!@matches) {
	    $self->alert("None of your selections matched replicas PhEDEx can delete.");
	    return;
	}

	if ($blockwarnings) {
	    $self->alert("You are trying to delete a <b>specific block and its subscription</b> for which a ",
			 "<b>dataset subscription</b> exists (offending block shown in red).  This is not ",
			 "allowed by the system.  You must go back and choose:",
			 "<ol style='text-align:  left'><li>Not to delete subscriptions (block will be retransferred), or</li>",
			 "    <li>Not to delete the block in question, or</li>",
			 "    <li>To delete the dataset the block belongs to, instead of only the block</li></ul>");
	    return;
	}

	my $delete_url = $self->myurl();
	my @save = map { hidden($_, param($_)) } param();
 	print {$$self{CONTENT}}
	"<form method='post' action='$delete_url'>",
	hidden(-name=>'execute', -value=>1),
	@save,
	"<p>", submit(-value=>'Yes, I really want to delete all this data'), "</p>",
	"</form>";
    } else {
	my $data_delete_sql = qq{ insert into t_dps_block_delete (time_request, node, dataset, block)
				  values (:time, :node, :dataset, :block) };
	my $subs_delete_sql = qq{ delete from t_dps_subscription where destination = :dest and THING = :id };

	my $subs_update_sql = qq{ update t_dps_subscription set time_complete = NULL
				   where destination = :dest and THING = :id };

	my $now = time();

	my ($n_delete, $n_rm_subs) = (0, 0);
	my ($sth, $rv);
	MATCH: foreach (@matches) {
	    ($sth, $rv) = &dbexec($$self{DBH}, $data_delete_sql,
				     ':time' => $now,
				     ':node' => $$_{NODE_ID},
				     ':dataset' => $$_{DATASET_ID},
				     ':block' => $$_{BLOCK_ID});
	    $n_delete += $rv;

	    # Delete subscriptions if the user requested it, otherwise
	    # leave the subscription in place but set time_complete to
	    # be null
	    my ($item, $id);
	    if ($$_{DATASET_SUBSCRIBED} eq 'y') {
		$item = 'dataset';
		$id = $$_{DATASET_ID};
	    } elsif ($$_{BLOCK_SUBSCRIBED} eq 'y') {
		$item = 'block';
		$id = $$_{BLOCK_ID};
	    } else {
		next MATCH;
	    }
	    my $subs_sql = $rm_subscriptions ? $subs_delete_sql : $subs_update_sql;;
	    $subs_sql =~ s/THING/$item/;
	    ($sth, $rv) = &dbexec($$self{DBH}, $subs_sql,
				  ':dest' => $$_{NODE_ID},
				  ':id' => $id);
	    $n_rm_subs += $rv if $rm_subscriptions;
	    
	}
	$$self{DBH}->commit();

	print {$$self{CONTENT}}
	"<h1>Delete Confirmed</h1>",
	"<p>$n_delete blocks queued for deletion.</p>",
	( $rm_subscriptions ? "<p>$n_rm_subs subscriptions removed</p>" : '');
    }
}

1;



######################################################################
package Web25::Reports::DailyReports;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Daily Reports",
	       LINK_TITLE => "Browse all daily reports" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my @reports = sort <$reportdir/$dbname-*.txt*>;
  print { $$self{CONTENT} }
    "<p><table class='striped'><tbody>\n",
    "<tr class='selected'><th colspan='32'>Available reports</th></tr>\n",
    "<tr class='selected'>\n",
    " <th>Month</td>\n",
    (map { sprintf " <th>%02d</th>\n", $_ } 1 .. 31),
    "</tr>\n";
  my $prev = "";
  my $prevday = 0;
  foreach my $file (@reports)
  {
    my $basename = $file; $basename =~ s|.*/||;
    my $cleanname = $basename; $cleanname =~ s|^$dbname-||;
    my $url = $self->myurl("page" => "Reports::DailyReport", "reportfile" => $cleanname);
    my ($year, $month, $day) = ($cleanname =~ /(\d\d\d\d)(\d\d)(\d\d)\..*/);
    if ("$year-$month" ne $prev)
    {
      if ($prev)
      {
        while (++$prevday <= 31) { print { $$self{CONTENT} } "<td></td>\n"; }
        print { $$self{CONTENT} } "</tr>\n";
      }

      print { $$self{CONTENT} } "<tr>\n <td>$year&#8209;$month</td>\n";
      $prev = "$year-$month";
      $prevday = 0;
    }
    while (++$prevday < $day) { print { $$self{CONTENT} } " <td></td>\n"; }
    print { $$self{CONTENT} } "<td align='center'><a href='$url'>R</a></td>\n";
    $prevday = $day;
  }

  print { $$self{CONTENT} } "</tbody></table></p>\n";
}

1;

######################################################################
package Web25::Reports::DailyReport;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Daily Report",
	       LINK_TITLE => "Show today's daily report" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(reportfile);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Reports::DailyReport");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my $report = param('reportfile') || (strftime('%Y%m%d', gmtime()) . ".txt");
  print { $$self{CONTENT} } "<pre class='wide' align='left'>\n";
  if ($report && $report =~ m|^[-A-Za-z0-9.]+$|)
  {
    my $reportfile = (<$reportdir/$dbname-$report>)[0];
    if (-f $reportfile)
    {
      local $/ = undef;
      open (REPORT, $reportfile =~ /.gz$/ ? "gzip -dc < $reportfile |" : "< $reportfile");
      my $report = <REPORT>;
      close (REPORT);
      $report =~ s/&/&amp;/gso;
      $report =~ s/</&lt;/gso;
      $report =~ s/>/&gt;/gso;
      $report =~ s/\"/&quot;/gso;
      print { $$self{CONTENT} } $report;
    }
  }
  print { $$self{CONTENT} } "</pre>\n";
}

1;

######################################################################
package Web25::Reports::Size;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "File Sizes",
	       LINK_TITLE => "Show file size distribution and other statistics" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my $overview = $$self{DBH}->selectrow_arrayref(qq{
    select time_update, n_files, sz_total, sz_min, sz_max, sz_mean, sz_median
    from t_status_file_size_overview});
  my $histo = $$self{DBH}->selectall_arrayref(qq{
    select time_update, bin_low, bin_width, n_total, sz_total
    from t_status_file_size_histogram order by bin_low asc});

  print { $$self{CONTENT} }
    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='6'>File size statistics ", &age($now - $overview->[0]), " ago</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    " <th>Min Size</th>\n",
    " <th>Max Size</th>\n",
    " <th>Mean Size</th>\n",
    " <th>Median Size</th>\n",
    "</tr>\n",
    "<tr>\n",
    " <td align='right'>@{[&format_num($overview->[1])]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[2], 0, 2, 'T')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[3], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[4], 0, 2, 'G')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[5], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[6], 0, 2, 'M')]}</td>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>",

    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='4'>File size breakdown</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th colspan='2'>Bin</th>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    "</tr>\n";

  foreach my $row (@$histo)
  {
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td align='right'>@{[&format_size($row->[1] * $row->[2],1,2,'G')]} ..</td>\n",
      " <td align='right'>@{[&format_size(($row->[1]+1) * $row->[2],1,2,'G')]}</td>\n",
      " <td align='right'>@{[&format_num($row->[3])]}</td>\n",
      " <td align='right'>@{[&format_size($row->[4],1,2,'T')]}</td>\n",
      "</tr>\n";
  }

  print { $$self{CONTENT} } "</tbody>\n</table>\n</p>\n";
}

1;

######################################################################
package Web25::Test::Test;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Test Functions",
	       LINK_TITLE => "Testing Page" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  return if (!$TESTING);  # For security
  #&dump_var($$self{CONTENT}, 'Config', $$self{CONFIG});
  #&dump_var($$self{CONTENT}, 'Env', {%ENV});
  print {$$self{CONTENT}} 
  "<p>Full URL current  ",     $self->myurl('fullurl'=>1),"</p>",
  "<p>Full URL security on  ", $self->myurl('fullurl'=>1, 'secure'=>1),"</p>",
  "<p>Full URL security off  ",$self->myurl('fullurl'=>1, 'secure'=>0),"</p>",
  "<p>Normal URL current ", $self->myurl(),"</p>",
  "<p>Normal URL security on  ", $self->myurl('secure'=>1),"</p>",
  "<p>Normal URL security off ", $self->myurl('secure'=>0),"</p>";
  
  &dump_var($$self{CONTENT}, 'ENV{HTTPS}', $ENV{HTTPS});
  &dump_var($$self{CONTENT}, 'ENV{HTTP_HTTPS}', $ENV{HTTP_HTTPS});
#   &dump_var($$self{CONTENT}, 'SecMod CertAuth', $$self{SECMOD}->isCertAuthenticated());
#   &dump_var($$self{CONTENT}, 'SecMod PassAuth', $$self{SECMOD}->isPasswdAuthenticated());
#   &dump_var($$self{CONTENT}, 'SecMod Forename', $$self{SECMOD}->getForename());
#   &dump_var($$self{CONTENT}, 'SecMod Surname', $$self{SECMOD}->getSurname());
#   &dump_var($$self{CONTENT}, 'SecMod Username', $$self{SECMOD}->getUsername());
#   &dump_var($$self{CONTENT}, 'SecMod DN', $$self{SECMOD}->getDN());
#   &dump_var($$self{CONTENT}, 'SecMod CERT', $$self{SECMOD}->getCert());

#   &dump_var($$self{CONTENT}, 'SecMod Roles', $$self{SECMOD}->getRoles());

#   &dump_var($$self{CONTENT}, 'authorized nodes', [ $self->fetch_nodes(web_user_auth=>'Site Admin||Data Manager') ]);

#   &dump_var($$self{CONTENT}, 'SecMod Node Map', {$$self{SECMOD}->getPhedexNodeToSiteMap()});
  
#   &dump_var($$self{CONTENT}, 'SecMod CERN Site Admins', [$$self{SECMOD}->getUsersWithRoleForSite('Site Admin', 'CERN')]);

#   &dump_var($$self{CONTENT}, 'SecMod Global Admins', [$$self{SECMOD}->getUsersWithRoleForGroup('Global Admin', 'phedex')]);


}

1;

######################################################################
package main;
BEGIN { use strict; use warnings; $^W=1; }
use CGI qw(:standard);

# Run the script main routine.  Determine which page we are looking
# at, instantiate it, then ask the page to generate itself.
sub runme
{
  # Read PhEDEx web server configuration
  my $config = &read_config();
  #eval "use CGI::Carp qw(fatalsToBrowser)";
  my $secmod_config = $$config{SECMOD_CONFIG};
  if (!$secmod_config) {
      die "ERROR:  SecurityModule config file not set";
  }
  
  # Interpret the trailing path suffix: /DB/PAGE?QUERY
  my $path = path_info() || "/prod";
  my ($db, $cgipage) = ("prod", "Info::Main");
  $db = $1 if ($path =~ m!\G/([^/]+)!g);
  $cgipage = $1 if ($path =~ m!\G/([^/]+)!g);

  # Grab the database name from the path info
  $db = "prod" if ! $db || ! exists $$config{INSTANCES}{$db};
  
  # Get the scope object for the page.
  no strict "refs";
  my $type = "Web25::Info::Main";
  $type = "Web25::$cgipage"
    if ($cgipage =~ /^[A-Za-z0-9]+(::[A-Za-z0-9]+)*/
	&& exists ${"Web25::$cgipage\::"}{INDEX}
	&& exists ${"Web25::$cgipage\::"}{new});

  # Instantiate the page object and remember it as a CGI parameter
  # so we can use it in generating links to other pages.
  my $page = &{"$type\::new"}($type);
  $type =~ s!^Web25::!!;
  param('page', $type);
  
  # Initialize the SecurityModule
  $page->initSecurityModule($secmod_config);

  # Generate the page
  $page->generate($config, $db);
}

# Parses DBParam file, returns a configuration object
# TODO:  Should just use Toolkit/Common/UtilsDB
sub parseDatabaseInfo
{
    my ($file, $section) = @_;
    my $self = {};
    $$self{DBCONFIG} = $file.':'.$section;

    $$self{DBH_LIFE} = 86400;
    $$self{DBH_AGE} = 0;
    if ($$self{DBCONFIG} =~ /(.*):(.*)/)
    {
	$$self{DBCONFIG} = $1;
	$$self{DBSECTION} = $2;
    }

    my $insection = $$self{DBSECTION} ? 0 : 1;
    open (DBCONF, "< $$self{DBCONFIG}")
	or die "$$self{DBCONFIG}: $!\n";

    while (<DBCONF>)
    {
	chomp; s/#.*//; s/^\s+//; s/\s+$//; s/\s+/ /g; next if /^$/;
	if (/^Section (\S+)$/) {
	    $insection = ($1 eq $$self{DBSECTION});
	} elsif (/^Interface (\S+)$/) {
	    $$self{DBH_DBITYPE} = $1 if $insection;
	} elsif (/^Database (\S+)$/) {
	    $$self{DBH_DBNAME} = $1 if $insection;
	} elsif (/^AuthDBUsername (\S+)$/) {
	    $$self{DBH_DBUSER} = $1 if $insection;
	} elsif (/^AuthDBPassword (\S+)$/) {
	    $$self{DBH_DBPASS} = $1 if $insection;
	} elsif (/^AuthRole (\S+)$/) {
	    $$self{DBH_DBROLE} = $1 if $insection;
	} elsif (/^AuthRolePassword (\S+)$/) {
	    $$self{DBH_DBROLE_PASS} = $1 if $insection;
	} elsif (/^ConnectionLife (\d+)$/) {
	    $$self{DBH_LIFE} = $1 if $insection;
	    $$self{DBH_CACHE} = 0 if $insection && $1 == 0;
	} elsif (/^LogConnection (on|off)$/) {
	    $$self{DBH_LOGGING} = ($1 eq 'on') if $insection;
	} elsif (/^LogSQL (on|off)$/) {
	    $ENV{PHEDEX_LOG_SQL} = ($1 eq 'on') if $insection;
	} elsif (/^SessionSQL (.*)$/) {
	    push(@{$$self{DBH_SESSION_SQL}}, $1);
	} else {
	    die "$$self{DBCONFIG}: $.: Unrecognised line\n";
	}
    }
    close (DBCONF);

    die "$$self{DBCONFIG}: database parameters not found\n"
	if (! $$self{DBH_DBITYPE} || ! $$self{DBH_DBNAME}
	    || ! $$self{DBH_DBUSER} || ! $$self{DBH_DBPASS});

    die "$$self{DBCONFIG}: role specified without username or password\n"
	if ($$self{DBH_DBROLE} && ! $$self{DBH_DBROLE_PASS});
    return $self;
}

sub read_config
{
  my $config_file = $ENV{PHEDEX_SERVER_CONFIG}
    || die "No server configuration.\n";

  $config_file =~ s/DEVNAME/$ENV{PHEDEX_DEV}/;
  open (CONFIG, "< $config_file")
    || die "$config_file: cannot read server configuration: $!\n";

  my $config = {};
  my $instance_rank = 0;
  while (1)
  {
    my $line = &parse_line($config_file);
    if (! defined $line)
    {
      last;
    }
    elsif ($line =~ /^$/)
    {
      next;
    }
    elsif ($line =~ /^([-a-zA-Z0-9]+):\s+(\S+)$/)
    {
	my $name = uc $1;
	my $value = $2;
	$name =~ s/-/_/g;
	
	$$config{$name} = $value;
    }
    elsif ($line =~ /^instance:\s+([\S\s]+)$/)
    {
      my $rest = $1;
      my $info = {};
      while ($rest =~ /\G([-a-z]+)\s*=\s*(\S+)\s*/g)
      {
        my $name = uc($1);
        my $value = $2;
        $name =~ s/-/_/g;
        $$info{$name} = $value;
      }

      my @required = qw(ID TITLE CONNECTION);
      my @missing = map { s/_/-/g; lc; } grep(! exists $$info{$_}, @required);
      die "$config_file: instance is missing parameters '@missing'\n" if @missing;
      my $dbparam_config = &parseDatabaseInfo($$config{DBPARAM}, $$info{CONNECTION});
      $$info{DBPARAM} = $dbparam_config;
      $$info{RANK} = $instance_rank++;
      $$config{INSTANCES}{$$info{ID}} = $info;
    }
    else
    {
      die "$config_file: unexpected parameters '$line'\n";
    }
  }

  close (CONFIG);
  return $config;
}

sub input_line
{
  my $line = <CONFIG>;
  return undef if ! defined $line;

  chomp($line);
  $line =~ s/#.*//;
  $line =~ s/^\s+//;
  $line =~ s/\s+$//;
  $line =~ s/\s+/ /;
  return $line;
}

sub parse_line
{
  my ($file) = @_;
  my $line = &input_line();
  return undef if ! defined $line;

  while (substr($line,-1,1) eq '\\')
  {
    chop($line);
    my $next = &input_line();
    die "$file: file ends in '\\', expected continued line\n"
      if ! defined $next;
    $line .= " ";
    $line .= $next;
  }

  return $line;
}

&runme();
exit(0);
