#!/usr/bin/env perl

our $TESTING = 0;
our $TESTING_MAIL = undef;

use CMSWebTools::SecurityModule::Oracle;

######################################################################
package Web25::Common; use strict; use warnings; use base "Exporter";
use CGI qw(:standard unescape);
use Net::hostent;
require Socket;
use POSIX qw(strftime mktime);
use Text::Glob 'glob_to_regex';
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} || "./"; $__scriptdir =~ s,[^/]+$,,; unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;


our @EXPORT = qw(urlencode dblink toclink pagelink
		 alert warning breakAtSlash note help
		 age format_num format_percent format_size format_timespan shorten
		 badcolor warncolor pendcolor goodcolor altcolor
		 dbexec dbprep dbbindexec dbinlist makeObjWithAttrs
		 timeSeries formatTime timegm sizeValue
		 auth_help_msg auth_help_warning auth_help_popup fetch_nodes fetch_dbses fetch_identity
                 send_email dn_to_human_name
		 yesno striplabels
		 dump_params dump_var
		 parse_userdata dbs_lookup resolve_data
);

# Various useful colours
our $badcolor = '#ff9e9e';
our $warncolor = '#ffd89e';
our $pendcolor = '#ccccff'; # ececff
our $goodcolor = '#ccffcc';
our $altcolor = '#f0f0f0';

# Encode arguments into a URL query string.
sub urlencode
{
  eval "use CGI '-oldstyle_urls'";
  my %args = @_; return new CGI (\%args)->query_string();
}

# Generate a HTML <a> link for a database instance.
sub dblink
{
  my ($self, $dbname, $db) = @_;
  return "<a href='" . $self->myurl('db' => $$db{ID})
    . "' title='$$db{TITLE} database instance'>$$db{TITLE}</a>";
}

# Generate a HTML <a> link for a category.  For now this is just a
# link to the first page of the category.
sub toclink
{
  my ($self, $category) = @_;

  # Scan pages for this category
  no strict "refs";
  my @pages = ();
  my $scope = \%{*{$category}{PACKAGE} . "::"};
  foreach (keys %$scope)
  {
    next if ! /::$/;
    next if ! exists ${$$scope{$_}}{INDEX};
    push(@pages, ${$$scope{$_}}{INDEX});
  }

  @pages = sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @pages;
  return &pagelink($self, $pages[0], ${$$category}{TITLE});
}

# Generate a HTML <a> link for a page.
sub pagelink
{
  my ($self, $page, $label) = @_;
  my $title = "";
  my $url = ${$$page}{LINK};
  my $name = *{$page}{PACKAGE}; $name =~ s/Web25:://;
  $label = ${$$page}{TITLE} if ! defined $label;

  # If the page has a title, stuff into a link attribute.
  if (${$$page}{LINK_TITLE})
  {
    $title = " title='@{[&escapeHTML(${$$page}{LINK_TITLE})]}'";
  }

  # If the page has a URL, convert relative one; otherwise generate a URL.
  if ($url && $url !~ /^[a-z]+:/ && substr($url,0,1) ne '/') 
  {
    $url = "$$self{CONFIG}{SERVICE_PATH}/$url";
  }
  elsif (! $url)
  {
    $url = $self->myurl("page" => $name);
  }

  # Return final link.
  return "<a href='$url'$title>" .  &escapeHTML($label) . "</a>";
}

# Convert a time difference into human-friendly short age string.
sub age
{
  my ($diff, $precision) = @_;
  $precision = 'minute' if !defined $precision;
  if (! grep ($precision eq $_, qw(second minute)) ) {
      die "Bad args to age()\n";
  }

  my $str = "";
  my $full = 0;

  if ($precision ne 'minute' &&  abs($diff) <= 3600) {
      $str .= sprintf("%dm", $diff / 60);
      $diff %= 60;
      $str .=  sprintf("%02d", $diff);
      return $str;
  }

  if (abs($diff) >= 86400)
  {
    $str .= sprintf("%dd", $diff / 86400);
    $diff %= 86400;
    $full = 1;
  }
  $str .= sprintf("%dh", $diff / 3600);
  $diff %= 3600;
  $str .= sprintf("%02d", $diff / 60);
  return $str;
}

# Convert a time span into human-friendly long string.
sub format_timespan
{
  my $span = shift;
  if ($span >= 86400)
  {
    $span /= 86400;
    return $span == 1 ? "day" : "$span days";
  }
  elsif ($span >= 3600)
  {
    $span /= 3600;
    return $span == 1 ? "hour" : "$span hours";
  } elsif ($span >= 60) {
    $span /= 60;
    return $span == 1 ? "minute" : "$span minutes";
  } else {
    return $span == 1 ? "second" : "$span seconds";
  }
}

sub breakAtSlash
{
  my ($val) = @_;
  return unless $val;
  my $agent = $ENV{HTTP_USER_AGENT} || "";
  $val =~ s,/,/&\#8203;,g if ($agent =~ /Mozilla/ && $agent !~ /MSIE/);
  return $val;
}

# Generate an alert into the output.
sub alert
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='alert'>",
    "<p><b>Error:</b> ", @_, "</p></div></center>\n";
}

# Generate a warning into the output.
sub warning
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='warning'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate a note into the output.
sub note
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='note'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate hide/show help
sub help
{
    my ($linktext, $helpsubject, @help) = @_;
    my $id = 'help'.rand();
    return 
	"<a class='help' href='#' onclick='return hideshow(this,\"$id\",0)'>$linktext</a>",
	"<div id='$id' style='display:none' class='help'>",
	"<a href='#' class='closelink' onclick='return hideshow(this, \"$id\", 0)'>[close]</a>",
	"<p class='title'>$helpsubject</p>",
	"<p class='body'>",
	@help,
	"</p>",
	"</div>";
}


# Format a number as a string.  Zero is converted into a dash.
sub format_num
{
  my ($n) = @_;
  return $n ? "$n" : '&#8211;';
}

# Format number as percent.  Zero is converted into a dash.
sub format_percent
{
  my ($n) = @_;
  return $n ? sprintf("%.1f \%", $n*100) : '&#8211;';
}


# Format a file size as a string.  The value is automatically
# abbreviated with a k/M/G/T/P/E suffix, either the first that
# applies or a minimum scale requested by the caller.  The default
# precision is one decimal point, but the caller can change this.
sub format_size {
  my ($bytes, $nodash, $precision, $minscale) = @_;
  return undef if (!defined $bytes && $nodash);

  my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		[ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
  my ($val, $unit, $minus) = ($bytes, '', $bytes < 0 ? "-" : "");
  do { $val = -$val; $bytes = -$bytes; } if $minus;
  while (@bounds && ($bytes >= $bounds [0][0] || defined $minscale))
  {
    $val = $bytes / $bounds[0][0];
    $unit = $bounds[0][1];
    undef $minscale if (defined $minscale && $minscale eq $unit);
    shift (@bounds);
  }

  $precision = "1" if ! defined $precision;
  return $bytes || $nodash
    ? sprintf("%s%.${precision}f %sB", $minus, $val, $unit)
    : '&#8211;';
}

# Returns a clipped version of a long string with a toggle control to expand the string
sub shorten {
    my ($tag, $id, $width, $string) = @_;
    return $string;  #TODO:  Actually get this working.
    my $uniq_id = $tag.'_'.$id;
    my $twidth = $width+2;
    return "<div id='$uniq_id' style='width:${twidth}em' class='short'><span class='short' style='width:${width}em;'>$string</span>".
	"<a class='shorttoggle' href='#' onclick='return shortlong(this,\"$uniq_id\",${width})'>...</a></div>";
}

# Tidy up SQL statement
sub dbsql
{
  my ($sql) = @_;
  $sql =~ s/--.*//mg;
  $sql =~ s/^\s+//mg;
  $sql =~ s/\s+$//mg;
  $sql =~ s/\n/ /g;
  return $sql;
}

# Simple utility to prepare a SQL statement
sub dbprep
{
  my ($dbh, $sql) = @_;
  return $dbh->prepare (&dbsql ($sql));
}

# Simple utility to prepare, bind and execute a SQL statement.
sub dbexec
{
  my ($dbh, $sql, %params) = @_;
  my $stmt = &dbprep ($dbh, $sql);
  my $rv = &dbbindexec ($stmt, %params);
  return wantarray ? ($stmt, $rv) : $stmt;
}

# Simple bind and execute a SQL statement.
sub dbbindexec
{
  my ($stmt, %params) = @_;
  my $isarray = 0;
  while (my ($param, $val) = each %params)
  {
    if (ref $val eq 'ARRAY')
    {
      $stmt->bind_param_array ($param, $val);
      $isarray++;
    }
    elsif (ref $val)
    {
      $stmt->bind_param_inout ($param, $val, 4096);
    }
    else
    {
      $stmt->bind_param ($param, $val);
    }
  }

  return $isarray
    ? $stmt->execute_array({ ArrayTupleResult => [] })
    : $stmt->execute();
}

# Retrun an sql fragment and a bind hash for an SQL "IN" list
sub dbinlist
{
    my ($prefix, @binds) = @_;
    my $in_list = join(', ', map { ":${prefix}_".($_+1) } (0..$#binds));                                                            
    my %in_binds = map { (":${prefix}_".($_+1) => $binds[$_]) } (0..$#binds); 
    return $in_list, %in_binds;
}


# Convenience wrapper for automatically constructing an object
# with requested set of attributes.
sub makeObjWithAttrs
{
  my ($dbh, $kind, $link, $obj, @attrs) = @_;
  my ($tname, $sname) = ("t_$kind", "seq_$kind");
  my @objfields = keys %$obj;
  my %objattrs = map { (":attr_$_" => $$obj{$_}) } @objfields;

  my $objsql =
    "insert into $tname ("
    . join(", ", "id", @objfields)
    . ")\n values ("
    . join(", ", "$sname.nextval", map { ":attr_$_" } @objfields)
    . ")\n returning id into :id";
  my $id = undef;
  &dbexec($dbh, $objsql, ":id" => \$id, %objattrs);

  $tname .= "_attr"; $sname .= "_attr";
  while (@attrs)
  {
    my ($name, $value) = splice(@attrs, 0, 2);
    &dbexec($dbh, qq{
      insert into $tname (id, $link, name, value)
      values ($sname.nextval, :Id, :name, :value)},
      ":id" => $id, ":name" => $name, ":value" => $value);
  }

  return $id;
}

# Print a help message about authentication requirements
# Takes a hash of $power => [@requirements]
# The first entry of @requirements should be the authentication level,
# the rest are the required roles for $power
sub auth_help_msg 
{
    my ($self, %powers) = @_;

    my $cert_login_url = $self->myurl("secure" => 1);
    my $passwd_login_url = $self->myurl("secure" => 1, "SecModPwd" => 1);

    my $sitedb_url = $$self{CONFIG}{SITEDB_URL} || 'blank';
    my $gridcert_help_url = $$self{CONFIG}{GRIDCERT_HELP_URL} || 'blank';
    my $contact_mail = "mailto:$$self{CONFIG}{FEEDBACK_MAIL}";

    my %auth_words = ( 'cert' => 'grid certificate authentication',
		       'passwd' => 'password authentication',
		       'anyauth' => 'to log in via grid certificate or password');
    my $msg = '';
    my %help;
    sub or_list {
	my $last = pop @_;
	return join(', ', @_)." or $last";
    }

    foreach my $power (keys %powers) {
	my @requirements = @{$powers{$power}};
	my $auth_level = shift @requirements;
	$help{$auth_level} = 1;
	$msg .= "You need <b>$auth_words{$auth_level}</b>";
	if (@requirements) {
	    @requirements = map { "<b>'$_'</b>" } @requirements;
	    $help{'sitedb'} = 1;
	    $msg .= ' and to be a '.&or_list(@requirements);
	}
	$msg .= " in order to $power.<br/>  ";
    }
    $msg .= "<br/>";

    if (exists $help{'passwd'} || exists $help{'anyauth'}) {
	$msg .= "Passwords are managed via <a href='$sitedb_url'>SiteDB</a> ".
	    "and are synced with the CMS hypernews passwords.  ";
    }

    if (exists $help{'cert'} || exists $help{'anyauth'}) {
	$msg .= "You can go <a href='$gridcert_help_url'>here</a> to find help on obtaining a grid certificate.  ";
    }

    if (exists $help{'sitedb'}) {
	$msg .= "Authorization roles are handled by <a href='$sitedb_url'>SiteDB.</a> ";
    }

    my $login_msg;
    if (exists $help{'anyauth'} || (exists $help{'cert'} && exists $help{'passwd'})) {
	$login_msg = "logged in <a href='$cert_login_url'>with your certificate</a> ".
	    "or <a href='$passwd_login_url'>password</a>";
    } elsif (exists $help{'cert'}) {
	$login_msg = "logged in <a href='$cert_login_url'>with your certificate</a>";
    } else {
	$login_msg = "logged in <a href='$passwd_login_url'>with your password</a>";
    }

    $msg .= "If you think you have the necessary rights in SiteDB ".
	"and are $login_msg but you are still ".
	"having problems with this page you may <a href='$contact_mail'>contact the PhEDEx developers</a>.  ";

    return $msg;
}

sub auth_help_popup 
{
    my ($self, %powers) = @_;
    print {$$self{CONTENT}} &help('Privilaged Activities Help', 'Privilaged Activities', $self->auth_help_msg(%powers), "<br/>");
}

sub auth_help_warning
{
    my ($self, %powers) = @_;
    $self->warning($self->auth_help_msg(%powers));
}


# Returns a list of nodes.
# If argument 'with_ids' is true, returns a hash of node_name => node_id
# else it returns an array of nodes
#
# If web_user_auth is set with the name of some role (e.g. 'Data
# Manager'), we check the security module to find out if the user has
# that role, find out for which sites they have that role, and return
# a list of nodes associated with those sites.
#
# web_user_auth can be set with multiple roles separated by '||', for
# which all authorized nodes among those roles will be returned.
# (e.g. web_user_auth => 'Data Manager||Site Admin')
#
# The role 'Global Admin' need not be specified in web_user_auth.  If
# the user is a Global Admin then all nodes are always returned.
#
# Otherwise it returns from t_adm_node table, which contains all nodes.
# The default behavior is to return an array of all nodes from t_adm_node.
sub fetch_nodes
{
    my ($self, %args) = @_;

    my @auth_nodes;
    if (exists $args{web_user_auth} && $args{web_user_auth}) {
	my $roles = $$self{SECMOD}->getRoles();
	my @to_check = split /\|\|/, $args{web_user_auth};
	my $roles_ok = 0;
	foreach my $role (@to_check) {
	    if (grep $role eq $_, keys %{$roles}) {
		$roles_ok = 1;
	    }
	}

	my $global_admin = (exists $$roles{'Global Admin'} &&
			    grep $_ = 'phedex', @{$$roles{'Global Admin'}}) || 0;

	return unless ($roles && ($roles_ok || $global_admin));
	
	# If the user is not a global admin, make a list of sites and
	# nodes they are authorized for.  If they are a global admin
	# we continue below where all nodes will be returned.
	if (!$global_admin) {
	    my %node_map = $$self{SECMOD}->getPhedexNodeToSiteMap();
	    my %auth_sites;
	    foreach my $role (@to_check) {
		if (exists $$roles{$role}) {
		    foreach my $site (@{$$roles{$role}}) {
			$auth_sites{$site} = 1;
		    }
		}
	    }
	    foreach my $node (keys %node_map) {
		foreach my $site (keys %auth_sites) {
		    push @auth_nodes, $node if $node_map{$node} eq $site;
		}
	    }
	}
    }

    my $sql = qq{select name, id from t_adm_node};
    my $q = &dbexec($$self{DBH}, $sql);
    
    my %nodes;
    while (my ($node, $node_id) = $q->fetchrow()) {
	# Filter by auth_nodes if there are any
	if (!@auth_nodes || grep $node eq $_, @auth_nodes) {
	    $nodes{$node} = $node_id;
	}
    }
    if (exists $args{with_ids} && $args{with_ids}) {
	return %nodes;
    } else {
	return keys %nodes;
    }
}



# Returns a list of DBSes.
# If argument 'with_ids' is true, then return a hash of name => id
# else return an array of DBS names
sub fetch_dbses
{
    my ($self, %args) = @_;

    my %dbses;
    my $q = &dbexec($$self{DBH}, qq{select name, id from t_dps_dbs});
    while (my ($dbs, $dbs_id) = $q->fetchrow()) {
	$dbses{$dbs} = $dbs_id;
    }
    
    if (exists $args{with_ids} && $args{with_ids}) {
	return %dbses;
    } else {
	return keys %dbses;
    }
}


# Tries to resolve the user's identity and returns it.  Also logs the
# identity to the t_adm_identity table, if it is not already there.
# Note:  does not commit this logging activity, this is left to the function caller
sub fetch_identity
{
    my ($self, $secmodUser) = @_;

    my $id = {};
    my @to_sync;

    if (! $secmodUser ) {
	if (! $$self{SECMOD}->isAuthenticated() ) { return; }

	$$id{SECMOD_ID} = $$self{SECMOD}->getID();
	$$id{NAME} = $$self{SECMOD}->getForename() .' '. $$self{SECMOD}->getSurname();
	$$id{EMAIL} = $$self{SECMOD}->getEmail();

	if ($$self{SECMOD}->isCertAuthenticated()) {
	    @to_sync = qw(SECMOD_ID NAME EMAIL DN CERTIFICATE);
	    $$id{DN} = $$self{SECMOD}->getDN();
	    $$id{CERTIFICATE} = $$self{SECMOD}->getCert();
	} elsif ($$self{SECMOD}->isPasswdAuthenticated()) {
	    @to_sync = qw(SECMOD_ID NAME EMAIL USERNAME);
	    $$id{USERNAME} = $$self{SECMOD}->getUsername();
	}
    } else {
	$$id{SECMOD_ID} = $$secmodUser{ID};
	$$id{NAME} = $$secmodUser{FORENAME} .' '. $$secmodUser{SURNAME};
	$$id{EMAIL} = $$secmodUser{EMAIL};
	$$id{DN} = $$secmodUser{DN};
	$$id{USERNAME} = $$secmodUser{USERNAME};
	@to_sync = qw(SECMOD_ID NAME EMAIL DN USERNAME);
    }
    my $now = time();

    # Look up a logged identity by either the SecurityModule ID or the DN
    my $q = &dbexec($$self{DBH},
		    qq{ select id, secmod_id, name, email, dn, certificate, username
			    from t_adm_identity where secmod_id = :secmod_id or dn = :dn
			    order by time_update desc },
		    ':secmod_id' => $$id{SECMOD_ID},
		    ':dn' => ($$id{DN} || 'dummy')
		    );

    my $logged_id = $q->fetchrow_hashref();

    my $synced = ($logged_id ? 1 : 0);
    foreach my $param (@to_sync) {
	last if !$synced;
	no warnings;  # we need to compare undef values too
	$synced &&= $$logged_id{$param} eq $$id{$param};
    }

    if ($logged_id && $synced) {
	# If everything is logged and up-to-date, return the identity information
	return $logged_id;
    } elsif ($logged_id && !$synced) {
	# If it is logged, but out of date, update it then return the information by recursing
	my $sql = qq{ update t_adm_identity set };
	my @params = map { "$_ = :$_" } (@to_sync, "TIME_UPDATE");
	$sql .= join(', ', @params);
	$sql .= qq{ where id = :id };
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;
	$binds{':ID'} = $$logged_id{ID};

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    } else {
	# If it is not logged, log it then recurse
	my $sql = qq{ insert into t_adm_identity };
	$sql .= '('.join(', ', "ID", @to_sync, "TIME_UPDATE").') ';
	$sql .= 'values ('.join(', ', "seq_adm_identity.nextval", map { ":$_" } (@to_sync,'TIME_UPDATE')).')';
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    }
}

sub send_email
{
    my (%args) = @_;

    # Required arguments
    foreach (qw(subject from to message)) {
	return 0 unless exists $args{$_};
    }

    # Make to and cc arrays unique
    foreach (qw(to cc)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    my %unique;
	    $unique{$_} = 1 foreach @{$args{$_}};
	    $args{$_} = [keys %unique];
	}
    }

    # Ensure names are not duplicated from to to cc
    if (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	&& ref $args{to} eq 'ARRAY') {
	my @uniquecc;
	foreach my $mail (@{$args{cc}}) {
	    push @uniquecc, $mail unless grep $_ eq $mail, @{$args{to}};	    
	}
	$args{cc} = [ @uniquecc ];
    } elsif (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	     && ref $args{to} ne 'ARRAY') {
	$args{cc} = [ grep $_ ne $args{to}, @{$args{cc}} ];
    } elsif (exists $args{cc}
	     && ref $args{to} eq 'ARRAY') {
	delete $args{cc} if grep $_ eq $args{cc}, @{$args{to}};
    } elsif (exists $args{cc}) {
	delete $args{cc} if $args{cc} eq $args{to};
    }
    
    foreach (qw(from to cc replyto)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    $args{$_} = join(', ', @{$args{$_}});
	} elsif ( exists $args{$_} && ! $args{$_} ) {
	    $args{$_} = '';
	}
    }
    
    foreach (qw(from to cc replyto)) {
	next unless exists $args{$_};
	return 0 unless &validlist($args{$_});
    }

    # For debugging without bothering people
    if ($TESTING) {
	$args{subject} = "TESTING:  $args{subject}";
	$args{message} .= "\n\nTO:  $args{to}\n\n"; $args{to} = $TESTING_MAIL;
	if ($args{cc}) {$args{message} .= "\n\nCC:  $args{cc}\n\n"; delete $args{cc};}
    }

    (open (MAIL, "| /usr/sbin/sendmail -t")
     && (print MAIL
 	 "Subject: $args{subject}\n",
 	 "From: $args{from}\n",
 	 (exists $args{replyto} ? "Reply-To:  $args{replyto}\n" : ''),
 	 "To: $args{to}\n",
 	 (exists $args{cc} ? "Cc: $args{cc}\n" : ''),
 	 "\n",
 	 $args{message},
 	 "\n" )
     && close(MAIL))
 	or do { return 0; };
    
    return %args;
}



sub dn_to_human_name
{
    my $dn = shift @_;
    return undef unless $dn;
    my @names = ($dn =~ m:/CN=([^/]+?)[\s\d]*(/|$):g);
    my $name = $names[0];
    foreach (@names) {
      $name = $_ if length $_ > length $name;
    }
    $name =~ s/\b(\w)/\U$1/g;
    return $name;
}


    
sub yesno 
{ 
    $_ = shift @_;
    return undef unless $_;
    s/^y$/Yes/; s/^n$/No/; 
    return $_; 
}



sub striplabels 
{ 
    my @stripped =  map { s:<[/]*label>::g; $_; } @_; 
    return wantarray ? @stripped : shift @stripped;
}



sub dump_params
{
    my $fh = shift @_;
    use Data::Dumper;
    print { $fh } "<pre>$_:\n", Dumper(param($_)), "</pre>" foreach param();

}


sub dump_var
{
    my ($fh, $name, $var) = @_;
    use Data::Dumper;
    print { $fh } "<pre>$name:\n", Dumper($var), "</pre>";
}


# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
  my ($first, $range, $now) = @_;
  $now ||= time();
  my @series = ();
  $first = int($first);

  if ($range eq 'hour') {
    # Convert first time to UTC hour in units of half a day.  Then
    # make a time series of hours until end of current 4 hours.
    my $low = int($first / 3600);
    my $high = int($now / 3600) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
    }
  } elsif ($range eq 'day') {
    # Convert first time to UTC day at 00:00.  Then make a
    # time series of days until end of today.
    my $low = int($first / 86400);
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
    }
  } elsif ($range eq 'week') {
    # Convert first time to previous Monday.  Then make a
    # time series of weeks until we pass today.
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $low = int($first/86400) - $diff{$wday};
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; $low += 7) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
    }
  } elsif ($range eq 'month') {
    # Convert first time to first of the month.  Then convert
    # into a time-series of months.  This is a bit dodgy, we
    # go by day so we don't need to worry about month dates.
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $start = int(($first - ($mday-1)*86400)/86400);
    my $limit = int($now / 86400) + 1;
    while ($start < $limit)
    {
      my $low = $start;
      my ($prevyear, $prevmon) = ($year, $mon);
      while ($year == $prevyear && $mon == $prevmon)
      {
	($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
	  = gmtime ((++$start) * 86400);
      }
      push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
    }
  }

  return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
  my ($time, $range) = @_;
  return undef unless ($time && $range);
  return undef if ($time <= 0);
  if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
  elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
  elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
  elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
  elsif ($range eq 'stamp') { return strftime ('%Y-%m-%d %H:%M:%S UTC', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
  my @args = @_;
  my $t1 = mktime (@args);
  my @gmt = gmtime ($t1);
  my $t2 = mktime (@gmt);
  return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
  my ($value) = @_;
  if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
  {
    my %scale = ('k' => 2**10, 'M' => 2**20, 'G' => 2**30,
		 'T' => 2**40, 'P' => 2**50, 'E' => 2**60);
    $value = $1 * $scale{$2};
  }
  return $value * 1.0;
}

# Takes an array of user data clobs and parses out single dataset and block globs
# Returns a hash of key:  glob pattern value: item type (DATASET or BLOCK)
sub parse_userdata
{
    my ($self, @userdata) = @_;
    my %parsed;
    foreach my $string (@userdata) {
	$string =~ s/^\s+//;  $string =~ s/\s+$//;
	my @data = split(/\s+/, $string);
	foreach my $item (@data) {
	    if ($item =~ m<^/[^/]+/[^/]+(/[^/]+|\#[^\#]+)$>) {
		$parsed{$item} = ($1 =~ /\#/ ? 'BLOCK' : 'DATASET');
	    } else {
		$parsed{$item} = undef;
	    }
	}
    }
    return %parsed;
}

sub dbs_lookup
{
    my ($dbs, $pattern) = @_;

    ### Security:  Strict list of characters allowed to go to shell
    my $reg = qr/[^\w\.\*\-\#\/\?=:\+\&]/;
    foreach (@_) {
	if (/$reg/) {
	    die "Invalid string '$_' given to dbs_lookup()";
	}
    }
        
    # TODO:  set this up in the apache config
    if ($dbs =~ /^https/) {
	# remove secure connection
	$dbs =~ s/^https/http/;
	$dbs =~ s|:\d+/|/|;
	$dbs =~ s/_writer//;
    }

    my $dbscmdsetup = 
	"source /opt/aptinstaller/slc4_ia32_gcc345/cms/dbs-client/DBS_1_0_5/etc/profile.d/init.sh;";
    my $dbslookup = '/opt/aptinstaller/slc4_ia32_gcc345/cms/PHEDEX/PHEDEX_2_5_3_3/Toolkit/DBS/DBSLookup';
    my $dbscmd = "$dbscmdsetup $dbslookup -u '$dbs' -d '$pattern'";
    my $dbsresults = `$dbscmd`;
    
    my @paths;
    if ($dbsresults) {
	foreach (split "\n", $dbsresults) {
	    push @paths, $_ if /^\//;
	}
    }
    return @paths;
}



# Resolve user datasets;  Search DPS and DBS for glob patterns
# Fill data object with results:
# $$resolved{$userglob} = [ { params }, ... ]
# Where { params } contains:
#   DBS = dbs the data was found in PhEDEx, not necessarily the one the user specified
#   LEVEL = 'BLOCK' or  'DATASET'
#   DATASET = Dataset name
#   BLOCK = Block name.  undef if LEVEL = DATASET
#   ID = The dps unique id for item
#   FILES = Number of files
#   BYTES = Data size
#   DPS_ISKNOWN = 'y' or 'n'
#   DBS_ISKNOWN = 'y' or 'n'
sub resolve_data
{
    my ($dbh, $userdbs, @userdata) = @_;

    my $resolved = {};
    my $userdupes = {};
    my $dbsdupes = {};
    my $all = {};

    foreach my $level (qw(DATASET BLOCK)) {
	$$all{$level} = [];
    }

    my %has;
    foreach my $userglob (@userdata) {
	my $level = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');
	$has{$level} = 1;
    }

    my $all_datasets = &dbexec($dbh,
        qq{select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset, sum(b.files) files, sum(b.bytes) bytes
	     from t_dps_dataset ds
   	     join t_dps_dbs dbs on dbs.id = ds.dbs
             join t_dps_block b on b.dataset = ds.id
            group by dbs.id, dbs.name, ds.id, ds.name
	    order by ds.id })->fetchall_hashref('DATASET_ID') if $has{DATASET};
    
    my $all_blocks = &dbexec($dbh,
       qq{select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset,
	         b.id block_id, b.name block, b.files, b.bytes
	    from t_dps_block b
	    join t_dps_dataset ds on b.dataset = ds.id
	    join t_dps_dbs dbs on ds.dbs = dbs.id
            order by b.id})->fetchall_hashref('BLOCK_ID') if $has{BLOCK};
    
    my $undef_id = 0;
    foreach my $userglob (@userdata) {
	$$resolved{$userglob} = [];
	my $level = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');

	# Search the DPS for the user's glob
	my $resultset;
	if ($level eq 'DATASET') { 
	    $resultset = $all_datasets; 
	} else {
	    $resultset = $all_blocks; 
	}

	my $pattern = glob_to_regex($userglob);
	my $lastid = -1;
	foreach my $id (sort keys %{$resultset}) {
	    my $row = $$resultset{$id};
	    my $name = $$row{$level};
	    next unless $name =~ $pattern;

	    # Redundancy checking
	    if ($id == $lastid) {
		$$dbsdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	    push @{$$all{$level}}, $id;

	    push @{$$resolved{$userglob}},  { DBS => $$row{DBS},
					      LEVEL => $level,
					      DATASET => $$row{DATASET},
					      BLOCK   => $$row{BLOCK},
					      FILES   => $$row{FILES},
					      BYTES   => $$row{BYTES},
					      DPS_ISKNOWN => 'y',
					      DBS_ISKNOWN => 'y', # XXX This is assuming DPS and DBS are in sync
					      ID => $id };
	}
	
	# User's glob not found in DPS, check their DBS
	if ($userdbs && ! @{$$resolved{$userglob}}) {
	    my @dbsdata = dbs_lookup($userdbs, $userglob);
	    foreach my $name (@dbsdata) {
		$undef_id++;
		push @{$$resolved{$userglob}}, { DBS => $userdbs,
						 LEVEL => $level,
						 DATASET => ($level eq 'DATASET' ? $name : undef),
						 BLOCK   => ($level eq 'BLOCK' ? $name : undef),
						 DPS_ISKNOWN => 'n',
						 DBS_ISKNOWN => 'y',
						 ID => 'undef'.$undef_id };
	    }
	}
    }

    my $lastid = -1;
    foreach my $level (qw(DATASET BLOCK)) {
	foreach my $id (sort @{$$all{$level}}) {
	    if ($id == $lastid) {
		$$userdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	}
    }

    if (wantarray) {
	return ($resolved, $userdupes, $dbsdupes);
    } else {
	return $resolved;
    }
}

# Given a list of dataset IDs and/or block IDs, calculate the number of files and bytes total
sub calculate_size
{
    my ($self, %args);

    my ($datasets, $blocks) = @args{qw(datasets blocks)};
    unless (($datasets && ref $datasets =~ /^ARRAY/) ||
	    ($blocks && ref $blocks =~ /^ARRAY/)) {
	die "calculate size called without dataset or block arrays";
    }

    my @where;
    my %binds;
    if ($datasets) {
	my ($ds_list, %ds_binds) = &dbinlist('ds', @{$datasets});
	push @where, $ds_list;
	$binds{$_} = $ds_binds{$_} foreach keys %ds_binds;
    }

    if ($blocks) {
	my ($b_list, %b_binds) = &dbinlist('b', @{$blocks});
	push @where, $b_list;
	$binds{$_} = $b_binds{$_} foreach keys %b_binds;
    }
    
    my $where_str = join ' or ', @where;
    my $sql = qq{ select sum(b.files), sum(b.bytes)
                    from t_dps_dataset ds
                    join t_dps_block b on b.dataset = ds.id
		    where $where_str };

    my ($files, $bytes) = &dbexec($$self{DBH}, $sql, %binds)->fetchrow();

    return ($files, $bytes);
}


1;


######################################################################
# A tool to create paged results given an SQL query
package Web25::QueryPager;
use strict; use warnings;
use CGI qw(param);
use POSIX qw(ceil);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{RESULTS_PER_PAGE} = 10;
  $$self{BINDS} = {};

  bless $self, $class;
  return $self;
}

# Initialize with
#  $webself  :  A reference to a Web25 object
#  $select   :  SQL to pageinate
#  $binds    :  (Optional, default null)  Hashref of bind parameters for $select
#  $results_per_page  :  (Optional, default 10)  Number of results to show per page
#  $rank_col  :  (Optional, default null) column to group results by
#  $filters  :  (Optional, default null)  hashref of column_name => regexp to filter to post-filter results
sub init
{
    my ($self, $webself, $select, $binds, $results_per_page, $rank_col, $filters) = @_;
    $self->process_filters($filters) if $filters;

    $$self{WEB} = $webself;
    $$self{DBH} = $$webself{DBH};
    $$self{SELECT} = $select;
    $$self{BINDS} = $binds if $binds;
    $$self{RESULTS_PER_PAGE} = $results_per_page if $results_per_page;
    $$self{RANK_COL} = $rank_col;
    $$self{FILTERS} = $filters if $filters && %{$filters};
    $$self{TOTAL_RESULTS} = $self->count_results();
    $$self{TOTAL_PAGES} = $self->total_pages();
    $$self{CURRENT_PAGE} = param('page_num') || 1;
    if ($$self{CURRENT_PAGE} <= 0 
	|| $$self{CURRENT_PAGE} > $$self{TOTAL_PAGES}) {
	$$self{CURRENT_PAGE} = 1;
    }

    if (!$$self{FILTERS}) {
	if (!$$self{RANK_COL}) {
	    $$self{PAGED_SQL} = qq[select * from ( select r.*, rownum as result_number
						   from ($$self{SELECT}) r 
						   where rownum <= :end_result ) 
				   where :start_result <= result_number ];
	} else {
	    $$self{PAGED_SQL} = qq[select * from 
				   (select results.*, dense_rank() over (order by results.$$self{RANK_COL}) result_number
				    from ($$self{SELECT}) results )
				   where result_number >= :start_result and result_number <= :end_result];
	}
	my $start_result = $self->page_to_result();
	my $end_result = $start_result + $$self{RESULTS_PER_PAGE} - 1;
	$$self{BINDS}{':start_result'} = $start_result;
	$$self{BINDS}{':end_result'} = $end_result;
    } else {
	if ($$self{FILTERED_RESULTS}) {
	    my $start_result = $self->page_to_result();
	    my @page_results = splice @{$$self{FILTERED_RESULTS}}, $start_result, $$self{RESULTS_PER_PAGE};
	    my ($result_list, %result_binds) = &dbinlist('result_id', @page_results);
	    $$self{BINDS}{$_} = $result_binds{$_} foreach keys %result_binds;
	    $$self{PAGED_SQL} = qq[select r.*, rownum as result_number, r.rowid
		  	             from ($$self{SELECT}) r
			            where r.rowid in ($result_list)];
	} else {
	    $$self{PAGED_SQL} = qq[select r.*, rownum as result_number, r.rowid
		  	             from ($$self{SELECT}) r
			            where 1 = 0];
	}
    }
}


sub get_total_results
{
    my ($self) = @_;
    return $$self{TOTAL_RESULTS};
}

# Returns the pager widget
sub pager
{
    my ($self) = @_;

    my $current_page = $$self{CURRENT_PAGE};
    my $total_pages = $$self{TOTAL_PAGES};

    return if $total_pages == 1;

    my @pager_html;

    push @pager_html, "<div class='pager'>Page $current_page of $total_pages:  ";
   
    if ($current_page > 1) {
	push @pager_html, $self->page_link(1, '[First]'), " \n";
	push @pager_html, $self->page_link(($current_page-1), '[Prev]'), " \n";
    }

    for (my $i = ($current_page-5); $i <= $current_page+5; $i++) {
	next if ($i < 1 || $i > $total_pages);

	if ($i != $current_page) {
	    push @pager_html, $self->page_link($i, $i), " \n";
	} else {
	    push @pager_html, $self->page_link($i, "<strong><big>$i</big></strong>"), " \n";
	}
    }

    if ($current_page < $total_pages) {
	push @pager_html, $self->page_link(($current_page+1), '[Next]'), " \n";
	push @pager_html, $self->page_link($total_pages, '[Last]'), " \n";
    }

    push @pager_html, "</div>";
    return @pager_html;
}

# Returns a query handle with 1 page's worth of results
sub paged_result
{
    my ($self) = @_;
    my $t1 = time();
    my $q = &dbexec($$self{DBH}, $$self{PAGED_SQL}, %{$$self{BINDS}});
    my $t2 = time();
    $$self{TIME_RESULT} = $t2 - $t1;
    return $q;
}

### Private functions ###

sub process_filters
{
    my ($self, $filters) = @_;
    foreach (keys %{$filters}) {
	my $f = $$filters{$_};
	if (!defined $f ||
	    $f eq '' ||
	    $f eq '.*') {
	    delete $$filters{$_};
	}
    }
}

# Return a link to a page
sub page_link
{
    my ($self, $page_num, $linktext) = @_;
# Using this method screws up when using https which seems like a CGI bug
# unfortunately this binds us to using the myurl() function...
#     my @ignore = qw(page);
#     my $cgi = new CGI;
#     $cgi->delete(@ignore);
#     $cgi->param('page_num', $page_num);
#     my $url = $cgi->self_url(-secure=>1);
    my $url = $$self{WEB}->myurl('page_num' => $page_num);
    return "<a href='$url'>$linktext</a>";
}

sub total_pages
{
    my $self = shift @_;
    my ($total_results, $results_per_page) = ($$self{TOTAL_RESULTS}, $$self{RESULTS_PER_PAGE});
    if ($total_results < 1) { $total_results = 1; }
    return POSIX::ceil($total_results/$results_per_page);
}

sub page_to_result
{
    my $self = shift @_;
    my ($current_page, $results_per_page) = ($$self{CURRENT_PAGE}, $$self{RESULTS_PER_PAGE});
    return ( ($current_page - 1 ) * $results_per_page + 1 );
}

sub count_results
{
    my $self = shift @_;

    my $t1 = time();
    my $num_results;
    if (!$$self{FILTERS}) {
	# No post-processing required, get results from sql query
	my $sql;
	if (!$$self{RANK_COL}) {
	    $sql = qq[select count(*) as num_results from ($$self{SELECT})];
	} else {
	    $sql = qq[select max(rank) from 
		      (select results.*, dense_rank() over (order by results.$$self{RANK_COL}) rank
                       from ($$self{SELECT}) results)];
	}
	my $q = &dbexec($$self{DBH}, $sql, %{$$self{BINDS}});
	($num_results) = $q->fetchrow();
    } else {
	# Full get all results, applying filters to get count, and caching rowid
	my $t1 = time();
	$$self{FILTERED_RESULTS} = [];
	my $sql = qq[select r.*, rownum as result_number, r.rowid
		       from ($$self{SELECT}) r ];
	my $q = &dbexec($$self{DBH}, $sql, %{$$self{BINDS}});
	while (my $row = $q->fetchrow_hashref()) {
	    my $keep = 1;
	    foreach my $col (keys %{$$self{FILTERS}}) {
		$keep &&= ($$row{$col} =~ /$$self{FILTERS}{$col}/);
	    }
	    push @{$$self{FILTERED_RESULTS}}, $$row{ROWID} if $keep;
	}
	$num_results = scalar @{$$self{FILTERED_RESULTS}};
    }
    my $t2 = time();
    $$self{TIME_COUNT} = $t2 - $t1;

    return $num_results || 0;
}

1;



######################################################################
# A tool to print an html table
# many options for formatting cell data, row style and cell style
# based on given subrefs

package Web25::TableSpool;
use strict; use warnings;
use CGI qw(param);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{FH} = *STDOUT;
  $$self{STRIPE} = undef;
  $$self{ROWCNT} = 0;
  $$self{COLCNT} = 0;
  $$self{TABLECOLS}   = undef;
  $$self{TABLEHEAD}   = undef;
  $$self{TABLECLASS}  = undef;
  $$self{STRIPECLASS} = undef;
  $$self{DATAFORMATS} = undef;
  $$self{ROWFORMATS}  = undef;
  $$self{CELLFORMATS} = undef;
  $$self{PSEUDOCOLS}  = undef;
  $$self{QUERYCOLS}   = undef;
  $$self{STATCOLS}    = undef;
  $$self{STATS}       = undef;
  $$self{FILTERS}     = undef;

  bless $self, $class;
  return $self;
}

# Set filehandle to print to 
sub set_filehandle
{
    my ($self, $fh) = @_;
    $$self{FH} = $fh;
}

# $cols: array ref of DB_column_names to output (others are ignored)
sub set_tablecols
{
    my ($self, $cols) = @_;
    $$self{TABLECOLS} = $cols;
}

# Sets columns to display based on CGI query parameters
# takes a list of column descriptions of the form
# (label, querykey, columnkeys, is_default)
# If no specified query variables are found, the 'is_default' columns are shown
sub set_querycols
{
    my ($self, @column_descriptions) = @_;
    $$self{QUERYCOLS} = [@column_descriptions];
    my %checked_querykeys;
    my @foundcols;
    my @defaultcols;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	unless (exists $checked_querykeys{$querykey}) {
	    foreach my $param_columnkeys (param($querykey)) {
		push @foundcols, split( /:/, $param_columnkeys);
	    }
	}
	$checked_querykeys{$querykey} = 1;
	push @defaultcols, split( /:/, $columnkeys ) if $is_default;
    }

    if (@foundcols) { $self->set_tablecols([ @foundcols ]); }
    else { $self->set_tablecols([ @defaultcols ]); }
}


# $th : hash of DB_column_name=>Pretty_column_name for table headers
sub set_tablehead
{
    my ($self, $th) = @_;
    $$self{TABLEHEAD} = $th;
}

# $class :  CSS class for the HTML table
sub set_tableclass
{
    my ($self, $class) = @_;
    $$self{TABLECLASS} = $class;
}

# $stripe :  CSS class for striped rows
sub set_stripeclass
{
    my ($self, $class) = @_;
    $$self{STRIPECLASS} = $class;
}
# $dataformats : hash of DB_column_name=>formatting_subroutine($data, $rowref) for formatting data
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_dataformats
{
    my ($self, $df) = @_;
    $$self{DATAFORMATS} = $df;
}

# $cellformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the cell (<td>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_cellformats
{
    my ($self, $cf) = @_;
    $$self{CELLFORMATS} = $cf;
}

# $rowformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the row (<tr>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_rowformats
{
    my ($self, $rf) = @_;
    $$self{ROWFORMATS} = $rf;
}

# $sc : hashref of DB_column_name =>function name
# function name may be SUM, COUNT or AVERAGE
sub set_statcols
{
    my ($self, $sc) = @_;
    $$self{STATCOLS} = $sc;
    $$self{STATS} = {};
    foreach my $name (keys %{$sc}) {
	die "TableSpool::set_statscols:  Unknown function requested" 
	    unless (grep $$sc{$name} eq $_, qw(SUM COUNT AVERAGE));
	$$self{STATS}{$name}{COUNT} = 0;
	$$self{STATS}{$name}{SUM}   = 0;
    }
}

# $f : hashref of DB_column_name => subref
# subref is passed the data of DB_column_name in $_[0], and the rest of the columns in $_[1]
# if the subroutine returns true the row is kept, otherwise this row is not printed
# works on pre-formatted data
sub set_filters
{
    my ($self, $f) = @_;
    $$self{FILTERS} = $f;
}

# Returns the earlier requested statistics
sub get_stats
{
    my ($self) = @_;

    my $res = {};
    foreach my $name (keys %{$$self{STATS}}) {
	next unless grep ($name eq $_, @{$$self{TABLECOLS}});
	my $func = $$self{STATCOLS}{$name};
	my $sum = $$self{STATS}{$name}{SUM};
	my $count = $$self{STATS}{$name}{COUNT};
	if ($func eq 'SUM') {
	    $$res{$name} = $sum;
	} elsif ($func eq 'COUNT') {
	    $$res{$name} = $count;
	} elsif ($func eq 'AVERAGE') {
	    $$res{$name} = sprintf("%.2f", $sum/$count) unless $count == 0;
	}
    }
    return keys %{$res} ? $res : undef;
}

# $pseudocols : hash with key 'name' (column name) and value 'generator' (sub ref)
# for generating a pseudocolumn in the table.  Requires 'name' to be in TABLEHEAD for output.
# 'generator' is passed the hash of the current row data, before any processing
sub add_pseudocolumn
{
    my ($self, $name, $generator) = @_;
    $$self{PSEUDOCOLS} = {} unless $$self{PSEUDOCOLS};
    $$self{PSEUDOCOLS}->{$name} = $generator;
}



# Print the beginning of the table
sub start
{
    my ($self) = @_;
    print { $$self{FH} }
    "<table ", $$self{TABLECLASS} ? "class='$$self{TABLECLASS}'" : '', ">\n";
}

# Print the title columns
sub head
{
    my ($self, @headers) = @_;

    if (@headers) {
	# Do nothing
    } elsif ($$self{TABLECOLS} && $$self{TABLEHEAD}) {
	foreach (@{$$self{TABLECOLS}}) {
	    my $colhead;
	    if (exists $$self{TABLEHEAD}{$_}) {
		$colhead = $$self{TABLEHEAD}{$_};
	    } else {
		$colhead = $_;
	    }
	    push @headers, $colhead;
	}
    } elsif ($$self{TABLECOLS}) {
	@headers = @{$$self{TABLECOLS}};
    }

    if (!@headers) {
	die "TableSpool::head called without any column information\n";
    }

    print { $$self{FH} } "<thead>\n";
    print { $$self{FH} } "<tr>";
    print { $$self{FH} } "<th>$_</th>" foreach (@headers);
    print { $$self{FH} } "</tr>\n";
    print { $$self{FH} } "</thead>\n";
    print { $$self{FH} } "<tbody>\n";

    $$self{COLCNT} = scalar @headers;
}

# Prints a row, taking either an array of data
# or a hashref of labled data (name=>val)
sub row
{
    my ($self, @row) = @_;

    if (ref $row[0] eq 'HASH') {
	$self->hash_row($row[0]);
    } else {
	if (ref $row[0] eq 'ARRAY') {
	    @row = @{$row[0]};
	}

	my $rowclass = '';
	if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	    $rowclass = " class='$$self{STRIPECLASS}'";
	}
	
	print { $$self{FH} } "<tr$rowclass>";
	print { $$self{FH} } "<td>$_</td>" foreach (@row);
	print { $$self{FH} } "</tr>";
	$$self{ROWCNT}++;
    }
    return $$self{ROWCNT};
}

sub rows
{
    my ($self, $row_ary) = @_;
    foreach my $row (@{$row_ary}) {
	$self->row($row);
    }
}

# Print a row from a hash applying all features
sub hash_row
{
    my ($self, $row, $rowclass) = @_;
    $rowclass = '' if !defined $rowclass;

    # Copy the row
    my $myrow = {%{$row}};

    # Add the pseudocolumns to the row
    if ($$self{PSEUDOCOLS}) {
	foreach my $name (keys %{$$self{PSEUDOCOLS}}) {
	    $myrow->{$name} = &{$$self{PSEUDOCOLS}->{$name}}(undef, $myrow);
	}
    }

    # Check filters
    if ($$self{FILTERS}) {
	foreach my $name (keys %{$$self{FILTERS}}) {
	    return 0 unless &{$$self{FILTERS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Format data row if format sub provided   
    if ($$self{ROWFORMATS}) {
	my $rowclass_ary = [];
	foreach my $name (keys %{$$self{ROWFORMATS}}) {
	    push @{$rowclass_ary}, &{$$self{ROWFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
	$rowclass = join(' ', $rowclass, @{$rowclass_ary});
    }

    # Format data cell if format sub provided
    my $cellclass_hash = {};
    if ($$self{CELLFORMATS}) {
	foreach my $name (keys %{$$self{CELLFORMATS}}) {
	    $cellclass_hash->{$name} = &{$$self{CELLFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Gather statistics for columns
    if ($$self{STATCOLS}) {
	foreach my $name (keys %{$$self{STATCOLS}}) {
	    # Get number
	    next unless defined $myrow->{$name};
	    my ($val) = ($myrow->{$name} =~ /([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?)/);
	    $$self{STATS}{$name}{COUNT}++ if defined $val;
	    $$self{STATS}{$name}{SUM} += $val if defined $val;
	}
    }

    # Format data columns if format sub provided
    if ($$self{DATAFORMATS}) {
	foreach my $name (keys %{$$self{DATAFORMATS}}) {
	    $myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Print out the row with the appropriate classes
    if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	$rowclass .= ' '.$$self{STRIPECLASS};
    }

    if ($rowclass) { $rowclass = " class='$rowclass'"; }
  
    print { $$self{FH} } "<tr$rowclass>";

    foreach my $name (@{$$self{TABLECOLS}}) {
	my $cellclass = '';
	if (exists $cellclass_hash->{$name}) {
	    $cellclass = " class='".$cellclass_hash->{$name}."'";
	}
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td$cellclass>$val</td>";
    }
    print { $$self{FH} } "</tr>\n";
    $$self{ROWCNT}++;
    return $$self{ROWCNT};
}

# Prints a <tfoot> section and a single row - for stats.
sub footrow
{
    my ($self, $myrow) = @_;

    print { $$self{FH} } "<tfoot><tr>";
    foreach my $name (@{$$self{TABLECOLS}}) {
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td>$val</td>";
    }
    print { $$self{FH} } "</tr></tfoot>";
}


# Finish, returns number of rows printed
sub finish
{
    my ($self) = @_;
    print { $$self{FH} } "</tbody>\n";

    my $results = $self->get_stats();

    if ($results) {
	my $myrow = {%{$results}};  # copy

	# Format data columns if format sub provided
	if ($$self{DATAFORMATS}) {
	    foreach my $name (keys %{$$self{DATAFORMATS}}) {
		next unless exists $myrow->{$name};
		$myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	    }
	}

	$self->footrow($myrow);
    }

    print { $$self{FH} } "</table>\n";
    return $$self{ROWCNT};
}

# Returns form inputs for column selection
# requires set_querycols
sub columns_form
{
    my ($self) = @_;

    my @checked;
    my @defaults;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	foreach my $param_columnkeys (param($querykey)) {
	    push @checked, $label if ($param_columnkeys eq $columnkeys);
	}
	push @defaults, $label if ($is_default);
    }

    unless (@checked) {
	@checked = @defaults;
    }


    my $form = "";
    $form .= "<p><i>Display Columns</i></p>\n";
    foreach my $desc (@{$$self{QUERYCOLS}})
    {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	$form .= "<input type='checkbox' name='$querykey' value='$columnkeys'";
	$form .= (grep $_ eq $label, @checked) ? " checked='checked'" : "";
	$form .= " />&nbsp;$label<br/>\n";
    }
    
    return $form;
}


1;



######################################################################
# A simple class to print an HTML table of a DB query
package Web25::DBTable;
use strict; use warnings;
use base "Web25::TableSpool";

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  bless $self, $class;
  return $self;
}



# Output a table given a statement handle $sth,
# $sth : database handle to iterate on
sub output
{
    my ($self, $sth) = @_;

    if (! $$self{TABLECOLS}) {
	$self->set_tablecols($sth->{NAME});
    }

    if (! $$self{TABLEHEAD}) {
	my $th = {};
	$th->{$_} = $_ foreach (@{$sth->{NAME}});
	$self->set_tablehead($th);
    }

    $self->start();    
    $self->head();
    while (my $row = $sth->fetchrow_hashref()) {
	$self->row($row);
    }
    return $self->finish();
}

1;



######################################################################
package Web25::OptsPane;
use strict; use warnings;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{TABS} = [];
  $$self{HIDDEN} = [];
  $$self{TARGET} = "#";

  bless $self, $class;
  return $self;
}

sub set_form_target
{
    my ($self, $target) = @_;
    $$self{TARGET} = $target;
}

sub add_tab
{
    my ($self, $name, $form) = @_;
    my $id = scalar @{$$self{TABS}};
    push @{$$self{TABS}}, { id => $id, name => $name, form => $form };
}

sub add_hidden
{
    my ($self, $form) = @_;
    push @{$$self{HIDDEN}}, $form;
}

sub output
{
    my ($self) = @_;

    my $html = "";

    $html .= "<form method='get' action='$$self{TARGET}'>\n";

    $html .= "<div id='optsnav'>\n";
    foreach my $tab (@{$$self{TABS}}) {
	my $class = $tab->{id} == 0 ? 'raised' : 'lowered';
	$html .= "<div class='$class' onclick='return showtab($tab->{id})' id='optstab$tab->{id}'><a href='#'>$tab->{name}</a></div>\n";
    }
    $html .= "</div>\n";


    foreach my $tab (@{$$self{TABS}}) {
	my $display = $tab->{id} == 0 ? '' : 'style=\'display:none;\'';
	$html .= "<div class='optscontent' $display id='optspane$tab->{id}'>\n";
	$html .= $tab->{form};
	$html .= "</div>\n";
    }
    foreach my $hidden (@{$$self{HIDDEN}}) {
	$html .= $hidden;
    }

    $html .= "<div id='optsfoot'>\n";
    $html .= "<input type='submit' value='Cancel' onclick='return hideshow(this,\"opts\",0)'/>&nbsp;\n";
    $html .= "<input type='submit' value='Apply' />\n";
    $html .= "</div>\n";

    $html .= "</form>\n";


    return $html;
}

sub link
{
    my ($self, $linkname) = @_;
    "<a href='#' onclick='return hideshow(this,\"opts\",0)'>$linkname</a><br/>\n";
}



1;


######################################################################
package Web25::Page;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

our $TEMPLATE_DEFAULT = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style25.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }

function shortlong(link,item,width) {
    var obj = document.getElementById(item);
    if (obj.style.width != width) {
	obj.style.width = (width+2) + "em";
        content = obj.getElementsByTagName("span")[0];
        content.style.width = width + "em";
    } else {
        obj.style.width = "auto";
        content = obj.getElementsByTagName("span")[0];
        content.style.width = "auto"
    }
    return false;
}

    function showtab(tab) {
	var i=0;
	var tabobj;
	var paneobj;
	for (i=0;i<10;i++) {
	    tabobj = document.getElementById('optstab'+i);
	    paneobj = document.getElementById('optspane'+i);
	    if (tab == i) {
		tabobj.className = 'raised';
		paneobj.style.display = '';
	    } else {
		tabobj.className = 'lowered';
		paneobj.style.display = 'none';
	    }
        }
	return false;
    }

function select_all(form_id, name, value) {
    var formblock= document.getElementById(form_id);
    var forminputs = formblock.getElementsByTagName('input');
    for (i = 0; i < forminputs.length; i++) {
	if (forminputs[i].getAttribute('name') == name) {
	    if (value == '1') {
		forminputs[i].checked = true;
	    } else {
		forminputs[i].checked = false;
	    }
	}
    }
}

--></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>

  <!-- Page-specific head elements -->
  @HEAD@
  <!-- /head -->
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
'>
<div id="page">
<div id="header">
 <!-- Logo and page title -->
 <div id="logo">
  <a href="@HOMEPAGE@" title="PhEDEx Home Page"
    ><img src="@ROOTURL@phedex-logo-small.gif" alt="PhEDEx" height="80" /></a>
 </div> <!-- /logo -->

 <div id="heading">
  <h1 class="title">@PAGEHEADING@</h1>
  <div class="pagenav">
   @TOCSELECTOR@
   @PAGESELECTOR@
  </div> <!-- /pagenav -->
 </div> <!-- /heading -->
</div> <!-- /header -->

<!-- main content -->
<div id="content">
@THIS_IS_A_TEST@
@CONTENT@
</div>
</div> <!-- /page -->

<!-- corner navigation panel -->
<div class="viewnav">
@DBSELECTOR@
@IDENTITY@
@MYPAGE@
</div>

<!-- options panel -->
<div id="opts" style="display:none;">
@OPTIONS@
</div>

</body>
</html>
END_OF_TEMPLATE

our $TEMPLATE_BARE = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }
   --></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
' style='background: none; margin: .5em'>

<!-- main content -->
<div id="content" style='border: none'>
@CONTENT@
</div>
</body>
</html>
END_OF_TEMPLATE

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};
  bless $self, $class;
  return $self;
}

sub initSecurityModule
{
    my ($self, $secmod_config) = @_;
    $$self{SECMOD} = new CMSWebTools::SecurityModule::Oracle({CONFIG => $secmod_config});
}

sub toc
{
  my ($self) = @_;
  my @result = ();
  foreach (keys %{Web25::})
  {
    next if ! /::$/;
    next if ! exists ${$Web25::{$_}}{TOC};
    push (@result, ${$Web25::{$_}}{TOC});
  }
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

sub index
{
  my ($self) = @_;
  my @result = ();

  # Get the type of dynamic type of this page and navigate to
  # the namespace scope just above it (e.g. Web25::Request::).
  no strict "refs";
  my $scope = ref $self;
  $scope =~ s/[^:]+$//;

  # Search the scope for sub-types with $INDEX.  These are
  # web pages we'll offer to make visible.
  foreach (keys %$scope)
  {
    push (@result, ${$$scope{$_}}{INDEX})
      if /::$/ && exists ${$$scope{$_}}{INDEX};
  }

  # Sort the pages by order tag.
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

# Return a hash of existing valid parameters
sub urlparams
{
  my ($self, @names) = @_;
  my %known = map { $_ => 1 } param();
  my %result = ();

  foreach my $name (@names)
  {
    $result{$name} = [ param($name) ]
      if exists $known{$name};
  }
  return %result;
}

# Return a URL to this page, i.e. a URL which would come back to this
# page, plus additional query parameters.  The page can be changed
# with "page" parametre and database instance with "db" parametre;
# these are automatically converted into script path components such
# that the final URL is "/path/to/script[/DB[/PAGE]][?QUERY]".
sub myurl
{
  my $self = shift(@_);

  my $curpage = param('page');
  my $curview = param('view');
  my $curlayout = param('layout');
  my $currefresh = param('refresh');
  my $cursecure = $$self{SECMOD}->isSecure();
  my $curquery = query_string();
  my %args = ('db' => $$self{DBID},
	      ($cursecure ? ('secure' => 1) : ()),
	      ($curview ? ('view' => $curview) : ()),
	      ($curpage ? ('page' => $curpage) : ()),
	      ($curlayout ? ('layout' => $curlayout) : ()),
	      ($currefresh ? ('refresh' => $currefresh) : ()),
	      @_);
  my $page = $args{'page'}; delete $args{'page'};
  my $db = $args{'db'}; delete $args{'db'};
  my $secure = $args{'secure'}; delete $args{'secure'};
  my $fullurl = $args{'fullurl'}; delete $args{'fullurl'};

  my $newcgi = new CGI ("");
  $newcgi->param ($_, ref $args{$_} ? @{$args{$_}} : $args{$_}) for keys %args;
  my $url = $$self{CONFIG}{SERVICE_PATH};
  my $q = $newcgi->query_string();

  if (($cursecure || 0) != ($secure || 0) 
      || $fullurl) {
      $url = $$self{CONFIG}{$secure ? "SSL_SERVER_ROOT" : "SERVER_ROOT"} . $url;
  }

  $url .= "/$db";
  $url .= "/$page" if $page;
  $url .= "?$q" if $q;
  
  return $url;
}



sub generate
{
  my ($self, $config, $db) = @_;
  $$self{CONFIG} = $config;
  $$self{DBID} = $db;

  # Fire up the security module
  $$self{SECMOD}->setPwdHandler($self->myurl('fullurl' => 1, 'secure' => 1, 'page'=>'Security::Password'));
  $$self{SECMOD}->setSignupHandler($self->myurl('fullurl' => 1, 'secure' => 1, 'page'=>'Security::SignUp'));
  $$self{SECMOD}->setReqCertFailHandler($self->myurl('fullurl' => 1, 'secure' => 0, 'page'=>'Security::SignUp'));
  $$self{SECMOD}->setCallerURL($self->myurl('fullurl' => 1));
  $$self{SECMOD}->init();

  # Find the class scope index of this page instance.
  my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

  # Force redirect to https if using http
  if ($$index{SECURE} && !$$self{SECMOD}->isSecure() && param('page') !~ /^Security/) {
      print redirect(-uri => $self->myurl("fullurl" => 1, "secure" => 1, "view" => "my"));
      return;
  }
  
  # Check if the client's identity was verified
  if ($$self{SECMOD}->isAuthenticated())
  {
    $$self{USER_NAME} = $$self{SECMOD}->getForename()." ".$$self{SECMOD}->getSurname();
    $$self{LOGIN_MESSAGE} =
	"<p>". &escapeHTML($$self{USER_NAME}) .
	" | <a href='" . $self->myurl("secure" => 1, "fullurl" => 1, "SecModLogout" => 1, page=>"Info::Main") . "'>Sign out</a></p>";
    if ($TESTING) {
	use Data::Dumper;
	my $roles = Dumper($$self{SECMOD}->getRoles());
	$$self{LOGIN_MESSAGE} .= "<p>$roles</p>", 
    }
  }
  else
  {
      $$self{LOGIN_MESSAGE} = 
	  "<p>Sign in ".
	  "<a href='" . $self->myurl("secure" => 1, "view" => "my") . "'>via Cert</a> or ".
	  "<a href='" . $self->myurl("secure" => 1, "view" => "my", "SecModPwd" => 1) . "'>via Password</a>".
	  "</p>";
  }
  my $login_state = $$self{SECMOD}->getAuthnState();
  if ($login_state eq 'cert') { $login_state = 'Logged in via Certificate'; }
  elsif ($login_state eq 'passwd') { $login_state = 'Logged in via Password'; }
  elsif ($login_state eq 'failed') { $login_state = 'Not logged in'; }
  $$self{LOGIN_MESSAGE} .= "<p>$login_state</p>";
  
  # Check whether we are looking at our vs. global view
  if (! $$self{SECMOD}->isAuthenticated() )
  {
      $$self{MY_VIEW} = 0;
      param('view', 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>global</strong></p>";
  }
    elsif (!param('view') || param('view') eq 'my')
  {
      $$self{MY_VIEW} = 1;
      my $otherurl = $self->myurl('view' => 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>my</strong> | <a href='$otherurl'>global</a></p>";
  }
  else
  {
      $$self{MY_VIEW} = 0;
      my $otherurl = $self->myurl('view' => 'my');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><a href='$otherurl'>my</a> | <strong>global</strong></p>";
  }

  # Select page we are visiting
  my %pagemap;
  my @pages = grep(${$$_}{LIST}, $self->index());
  foreach (@pages)
  {
    my ($name) = (*{$_}{PACKAGE} =~ /Web25::(.*)/);
    $pagemap{$_} = $name;
  }

  my $page = param('page');
  my @toc = $self->toc();
  my $cat = do {
    no strict "refs";
    my $scope = ref $self;
    $scope =~ s/[^:]+$//;
    exists $$scope{TOC} ? ${"${scope}TOC"} : undef
  };

  # Check if this is running against a test location and obnoxiously warn if so
  my $testwarn = "";
  my $pageheading = 'PhEDEx &#8211; CMS Data Transfers';
  if ($ENV{PHEDEX_DEV}) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $prod =~ s!/dev/$ENV{PHEDEX_DEV}/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a development server for <b>$ENV{PHEDEX_DEV}</b>. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>($ENV{PHEDEX_DEV}'s Development)</blink>";
  } elsif ($ENV{SCRIPT_NAME} =~ m!/test/!) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a test server for the developers. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>(TEST)</blink>";
  }

  # Initialise page template
  my $ndb = 0;
  my $replacements = {
    'HEAD' => '',
    'THIS_IS_A_TEST' => $testwarn,
    'CONTENT' => '',
    'PAGETITLE' =>
      ($cat ? $$cat{TITLE} . " &#8211; " . $$index{TITLE} : $$index{TITLE}),
    'PAGEHEADING' => $pageheading,
    'HOMEPAGE' => $self->myurl('page'=>'Info::Main'),
    'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
    'DBTITLE' => $$config{INSTANCES}{$db}{TITLE},
    'ROOTURL' => "$$self{CONFIG}{SERVICE_PATH}/",
    'REFRESH' => (param('refresh') ? "<meta http-equiv='refresh' content='600'>" : ""),
    'DBSELECTOR' =>
      ("<div class='dbopt'>\n" .
       "<label>DB Instance:</label><strong>$$config{INSTANCES}{$db}{TITLE}</strong>&nbsp;" .
       "<a href='@{[$self->myurl('page'=>'DB')]}'" .
       " onclick='return hideshow(this,\"dbopts\",0)'>&#187;&#187;</a>\n" .
       "  <div id='dbopts' style='display:none'>\n" .
       "   <a class='closelink' href='#' onclick='return hideshow(this,\"dbopts\",0)'>[close]</a>\n" .
       join ("",
             map { &dblink ($self, $db, $_) . "<br />\n" }
	     sort { $$a{RANK} <=> $$b{RANK} }
	     grep($$_{ID} ne $db, values %{$$config{INSTANCES}})) .
       "  </div>\n" .
       " </div>"),
    'TOCSELECTOR' =>
      (@toc ?
       "<div class='catopt'>\n" .
       " <ul>\n" .
       join("", map { "  <li"
		      . ($cat && $$_ == $cat
			 ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
			 : (">" . &toclink($self, $_)))
		      . "</li>\n" } @toc) .
       " </ul>\n" .
       "</div>" : ""),
    'PAGESELECTOR' =>
      (@pages ?
       "<div class='menuopt'>\n" .
       " <ul>\n" .
       join("",
	    map { "  <li" .
		  ("Web25::$page" eq *{$_}{PACKAGE}
		   ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
		   : (">" . &pagelink($self, $_)))
		  . "</li>\n" }
	    @pages) .
       " </ul>\n" .
       "</div>" : ""),
    'IDENTITY' =>
      (" <div>\n" .
       "$$self{LOGIN_MESSAGE}\n" .
       " </div>"),
    'MYPAGE' => "<div>$$self{VIEW_MESSAGE}</div>",
  };

  # Hide these things on the password page
  if (param('page') eq 'Security::Password') { 
      $$replacements{MYPAGE} = '';
      $$replacements{IDENTITY} = '';
      $$replacements{DBSELECTOR} = '';
      $$replacements{PAGESELECTOR} = '';
      $$replacements{TOCSELECTOR} = '';
      $$replacements{THIS_IS_A_TEST} = '';
  }

  # Prepare our cookies
  my @cookies;
  if ($$index{SESSION}) {
      require CGI::Session;
      require CGI::Cookie;
      my $session = new CGI::Session("driver:File", undef, {Directory=>'/tmp/cgi-sessions'});
      $$self{SESSION} = $session;
      $$self{SESSIONID} = $session->id();
      my $cookie = new CGI::Cookie(-name=>'CGISESSID', -value=>$session->id());
      push @cookies, $cookie;
  }

  if(( my $cookie = $$self{SECMOD}->getCookie() )) {
      push @cookies, $cookie;
  }
  


  # Execute the desired page.  We save old STDOUT to print to it
  # later, then redirect the page routine's output to CONTENT.
  my ($output, $options, $head) = ("", "", "");
  open ($$self{HEAD}, ">", \$head);
  open ($$self{CONTENT}, ">", \$output);
  open ($$self{OPTIONS}, ">", \$options);
  eval
  {
    # Connect to the database, do the page, the disconnect
    if (! $$index{NOLOGIN})
    {
      eval
      {
	my $dbtns = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBNAME};
        my $dbuser = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBUSER};
        my $dbpass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBPASS};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;

	if (exists $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE}) {
	    my $role_name = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE};
	    my $role_pass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}
      };
      if ($@)
      {
	my $msg = $@;
	my $feedbackurl =
	  "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
	  . "PhEDEx%20web%20is%20inaccessible";

	print { $$self{CONTENT} }
	  "<center><div class='alert'>\n",
	  " <p>This PhEDEx instance is not available at this time.",
	  " Please try again at another time, or if the problem",
	  " persists and this is an instance you should be using,",
	  " please <a href='$feedbackurl'>notify the administrators</a>.",
	  "</p>",
          # "<p>The database error was: <i>", &escapeHTML($@), "</i></p>",
          "</div></center>\n";

	print STDERR "$0: Internal error: $msg\n";
	return;
      }
    }
    $self->output();
    if ($$self{DBH})
    {
      $$self{DBH}->disconnect() if $$self{DBH};
      delete $$self{DBH};
    }
  };
  if ($@)
  {
    my $message = $@;
    $message = &escapeHTML($message);

    my $feedbackurl =
      "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
      . "PhEDEx%20web%20server%20trouble";

    if ($message =~ /ORA-00942/) # table or view doesn't exist
    {
      print { $$self{CONTENT} }
        "<center><div class='warning'>\n",
        " <p>This PhEDEx instance is not capable of providing",
        " this feature.  Perhaps you meant to select another PhEDEx",
        " instance in the instance menu above?</p></div></center>\n";
    }
    else
    {
      print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Apologies, looks like we have an internal server error,",
        " details of which below.  If the problem persists, please",
        " <a href='$feedbackurl'>notify the administrators</a>.</p>\n",
        " <p><i>$message</i></p>\n",
        "</div></center>\n";
    }
  }
  close($$self{HEAD});
  close($$self{CONTENT});
  close($$self{OPTIONS});
  $$replacements{HEAD} = join("\n", $head);
  $$replacements{CONTENT} = join("\n", $output);
  $$replacements{OPTIONS} = join("\n", $options);

  # Instantiate the desired template and spit it out
  my $template = param('layout');
  $template = 'default'
    if (! $template || ! grep($template eq $_, qw(default bare)));

  my $result = ($template eq 'bare' ? $TEMPLATE_BARE : $TEMPLATE_DEFAULT);
  while (my ($key, $value) = each %$replacements)
  {
    $result =~ s/\@$key\@/$value/g;
  }

  print header(-type => 'text/html', -cookie=>\@cookies), $result;
  
}


1;

######################################################################
package Web25::XML;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};
  bless $self, $class;
  return $self;
}



sub generate
{
    my ($self, $config, $db) = @_;
    $$self{CONFIG} = $config;
    $$self{DBID} = $db;
    my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

    my ($output) = ("");
    open ($$self{CONTENT}, ">", \$output);
    eval
    {
	my $dbtns = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBNAME};
        my $dbuser = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBUSER};
        my $dbpass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBPASS};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;
	
	if (exists $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE}) {
	    my $role_name = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE};
	    my $role_pass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}

	$self->output();
	if ($$self{DBH})
	{
	    $$self{DBH}->disconnect() if $$self{DBH};
	    delete $$self{DBH};
	}
	close($$self{CONTENT});
    };
    if ($@) {
	my $message = $@;
	$message = &escapeHTML($message);
	print {$$self{CONTENT}} "<error>$message</error>";
    }

    my $root = $$index{ROOT} ? $$index{ROOT} : 'data';
   
    print header(-type => 'text/xml', -encoding=>'ISO-8859-1');
    print "<?xml version='1.0' encoding='ISO-8859-1'?>\n";
    print "<$root>";
    print $output;
    print "</$root>";
}

1;



######################################################################
package Web25::XML::TransferStatus;
use strict; use warnings;
use base "Web25::XML";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { ROOT => 'ajax-response' };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    
    my @datasets = param('dataset');
    my @se_names = param('se_name');
    my $id_suffix = param('id_suffix');

    if (!@datasets or !@se_names) {
	die "Missing parameters.  'dataset' and 'se_name' are required.\n";
    }

    my $multiple_se = 0;
    if (grep(/^\*$/, @se_names) || scalar @se_names > 1) {
	$multiple_se = 1;
    }

    # Get the number of files at an se
    # If the site has MSS, return the MSS rows only
    my $sql = qq{ select n.name node, n.se_name se_name, ds.name,
		  sum(br.node_files) node_files, sum(b.files) total_files
		      from t_dps_block_replica br
		      join t_adm_node n on n.id = br.node
                 left join t_adm_node m on m.se_name = n.se_name
                                       and m.kind = 'MSS'
		      join t_dps_block b on b.id = br.block
		      join t_dps_dataset ds on ds.id = b.dataset
		      where (m.id is null or n.kind = 'MSS')
                        and WHERE
		      group by n.name, n.se_name, ds.name
		      order by n.name, ds.name
		  };

    my @where;
    my %binds;
    if (grep /^\*$/, @se_names) {
	push @where, "n.se_name is not null";
    } else {
	my ($se_list, %se_binds) = &dbinlist('se_name', @se_names);
	push @where, "n.se_name in ($se_list)";
	$binds{$_} = $se_binds{$_} foreach keys %se_binds;
    }
    my ($ds_list, %ds_binds) = &dbinlist('ds', @datasets);
    push @where, "ds.name in ($ds_list)";
    $binds{$_} = $ds_binds{$_} foreach keys %ds_binds;

    my $where_str = join ' and ', @where;
    $sql =~ s/WHERE/$where_str/m;

    my $sth = &dbexec($$self{DBH}, $sql, %binds);
    my $nrows = 0;
    my $responses = {};
    while (my ($node, $se_name, $dataset, $node_files, $total_files) = $sth->fetchrow()) {
	$nrows++;
	my $id;
	if ($multiple_se) {
	    $id = join ':', 'multiple', $dataset;
	} else {
	    $id = join ':', $se_names[0], $dataset;
	}
	$id .= ':'.$id_suffix if $id_suffix;

	my $ratio = sprintf("%.1f", ($node_files / $total_files) * 100);
	my $color;
	if ($ratio == 0) { $color = 'red'; } 
	elsif ($ratio == 100) { $color = 'green'; } 
	else { $color = 'orange'; }

	my $line = "<div name='phedex_transfer_status' style='color:$color;'>".
	    "$node ($se_name) $node_files / $total_files (${ratio}%)".
	    "</div>";

	$$responses{$id}{$line} = 1;
    }

    if ($nrows) {
	foreach my $id (keys %{$responses}) {
	    print {$$self{CONTENT}}	"<response type='object' id='$id'>";
	    foreach my $line (keys %{$$responses{$id}}) {
		print {$$self{CONTENT}} $line;
	    }
	    print {$$self{CONTENT}} "</response>";
	}
    } else {
	# make fake result sets when there are no results
	# so Valentin's framework doesn't choke...
	foreach my $dataset (@datasets) {
	    my $id;
	    if ($multiple_se) {
		$id = join ':', 'multiple', $dataset;
	    } else {
		$id = join ':', $se_names[0], $dataset;
	    }
	    $id .= ':'.$id_suffix if $id_suffix;
	print {$$self{CONTENT}}	"<response id='$id'>No results</response>";
	}
    }

}

1;



######################################################################
package Web25::Security::Password;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 0, NOLOGIN => 1, TITLE => "Password Sign-In" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $caller_url = param('caller_url');
    $caller_url =~ s,^http://[^/]+,$$self{CONFIG}{SSL_SERVER_ROOT},;
    my $msg = param('msg');

    print {$$self{CONTENT}} 
    "<h1>Password Sign-In</h1><br/>",
    "<p>Sign in with your CMS SiteDB/Hypernews password</p>",
    ($msg ? "<p style='color:red'>$msg</p>" : ''),
    "<form class='nice' method='post' action='$caller_url'>",
    "<label>Username</label>",textfield(-name=>'SecModLogin', -class=>'labeled'),"<br/>",
    "<label>Password</label>",password_field(-name=>'SecModPwd', -class=>'labeled'),"<br/>",
    "<label>&nbsp;</label>", submit(-name=>'Submit', -value=>'submit'),
    "</form>";
}

1;



######################################################################
package Web25::Security::SignUp;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 0, NOLOGIN => 1, TITLE => "Password Sign-In" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $caller_url = param('caller_url');

    my $sitedb_url = $$self{CONFIG}{SITEDB_URL} || 'blank';
    my $sitedb = "<a href='$sitedb_url'>SiteDB</a>";
    my $gridcert_help_url = $$self{CONFIG}{GRIDCERT_HELP_URL} || 'blank';

    my $dn = $$self{SECMOD}->getBrowserDN();
    my $dn_ok = ($dn && $dn ne '(null)') ? 1 : 0;

    print {$$self{CONTENT}} 
    "<h1>Have You Signed Up?</h1><br/>",
    "<p class='blocktext'>You need to sign up with CMS Web Services in order to log in ",
    "and use privileged features.  Signing up can be done via ",
    "$sitedb.</p>",
    "<p class='blocktext'>If you have already signed up with SiteDB, it ",
    "is possible that your certificate or password information is out ",
    "of date there.  In that case go back to $sitedb and update your ",
    "information.</p>",
    "<p>For your information, the DN your browser presents is:</p>",
    ($dn_ok ? "<p>$dn</p>" : "<p><b>No certificate presented by your browser!</b></p>");

    if (!$dn_ok) {
	print {$$self{CONTENT}}
	"<p>For information on obtaining and loading certificates into ",
	"your browser, please visit <a href='$gridcert_help_url'>this ",
	"page</a>";
    }
}

1;


######################################################################
package Web25::Info::Main;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 1, ORDER => 0, NOLOGIN => 1, TITLE => "Overview" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  no strict "refs";
  foreach my $toc ($self->toc())
  {
    next if ! ${$$toc}{LIST};
    my $type = *{$toc}{PACKAGE};
    print { $$self{CONTENT} }
      (${$$toc}{ORDER} % 3 ? "" : "<p style='clear: left'></p>\n"),
      "<div class='toc'>\n",
      " <h2>", &escapeHTML(${$$toc}{TITLE}), "</h2>\n",
      " <ul>\n";

    my @pages = ();
    my $scope = "${type}::";
    foreach (keys %$scope)
    {
      next if ! /::$/;
      next if ! exists ${$$scope{$_}}{INDEX};
      push(@pages, ${$$scope{$_}}{INDEX});
    }

    print { $$self{CONTENT} }
      map { "  <li>" . &pagelink($self, $_) . "</li>\n" }
      sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} }
      grep (${$$_}{LIST}, @pages);

    print { $$self{CONTENT} } " </ul>\n</div>";
  }
}

1;



######################################################################
package Web25::Info; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 0, TITLE => "Info" }; 1;

package Web25::Activity; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 1, TITLE => "Activity" }; 1;

package Web25::Data; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 2, TITLE => "Data" }; 1;

package Web25::Request; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 3, TITLE => "Requests" }; 1;

package Web25::Components; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 4, TITLE => "Components" }; 1;

package Web25::Reports; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 5, TITLE => "Reports" }; 1;


######################################################################
package Web25::Info::About; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "About",
	       LINK => "about.html",
	       LINK_TITLE => "General Information" };
1;

package Web25::Info::Documentation; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Documentation",
	       LINK => "documents.html",
	       LINK_TITLE => "READMEs and Other Documentation" };
1;

package Web25::Info::Presentations; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Presentations",
	       LINK => "presentations.html",
	       LINK_TITLE => "PhEDEx Presentations" };
1;

package Web25::Info::HyperNews; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "HyperNews Forum",
	       LINK => "https://hypernews.cern.ch/HyperNews/CMS/get/phedex.html",
	       LINK_TITLE => "Mailing List and HyperNews Forum" };
1;

package Web25::Info::Support; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Support Tracker",
	       LINK => "http://savannah.cern.ch/projects/cmscompinfrasup/",
	       LINK_TITLE => "Support Tracker" };
1;


package Web25::Info::Developers; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Developers",
	       LINK => "developers.html",
	       LINK_TITLE => "Developer info" };
1;

######################################################################
package Web25::Request::Page;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

our @reqstates = (
  { STATE => 0, RANK => 0, LABEL => "Pending approval" },
  { STATE => 2, RANK => 3, LABEL => "Partially disapproved" },
  { STATE => 3, RANK => 4, LABEL => "Partially approved" },
  { STATE => 4, RANK => 9, LABEL => "Disapproved" },
  { STATE => 5, RANK => 5, LABEL => "Approved" }
);
our %reqstatenames  = map { ($$_{STATE} => $$_{LABEL}) } @reqstates;
our %reqstatevalues = map { ($$_{LABEL} => $$_{STATE}) } @reqstates;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub logClientInfo
{
    my ($self) = @_;

    # Is there a case for logging anonymous access?
    # If so we will want to change this function...
    if (!$$self{SECMOD}->isAuthenticated()) { return undef; }

    my $identity = $self->fetch_identity();

    my $cid = &makeObjWithAttrs
	($$self{DBH}, "adm_contact", "contact", {},
	 "Remote host" => $ENV{HTTP_X_FORWARDED_FOR},
	 "User agent" => user_agent());
    
    my $client = &makeObjWithAttrs
	($$self{DBH}, "adm_client", undef,
	 { "identity" => $$identity{ID}, "contact" => $cid });
    
    return $client;
}


sub getClientData 
{
    my ($self, $clientid) = @_;
    my $contactsql = qq{ select name, value 
                             from t_adm_contact_attr con_attr 
                             join t_adm_contact con on con.id = con_attr.contact
                             join t_adm_client cli on cli.contact = con.id
			     where cli.id = :id order by con_attr.id};
    my $identsql  = qq{ select ident.name, ident.email, ident.dn, ident.certificate
                            from t_adm_identity ident
                            join t_adm_client cli on cli.identity = ident.id
			    where cli.id = :id order by ident.id};
    
    
    my %types = ('CONTACT_ATTR'  => $contactsql, 
		 'IDENTITY' => $identsql);
    
    my $result = {};
    
    while (my ($type, $sql) = each %types) {
	my $q = &dbexec($$self{DBH}, $sql, ':id' => $clientid);
	if ($type eq 'CONTACT_ATTR') {
	    $result->{$type} = {};
	    while (my ($name, $value) = $q->fetchrow_array()) {
		$result->{$type}->{$name} = $value;
	    }
	} elsif ($type eq 'IDENTITY') {
	    $result->{$type} = $q->fetchrow_hashref();
	}
    }
    return $result;
}

sub formatClientData
{
    my ($self, $data) = @_;
    my @html;
    
    my %nice_names = ('NAME' => 'Name',
		      'DN' => 'Distinguished name',
		      'EMAIL' => 'E-mail');
    foreach my $name (sort keys %{$data->{IDENTITY}}) {
	if ($name ne 'CERTIFICATE') {
	    push @html, "<label>$nice_names{$name}:</label><span class='labeled'>", 
	    ($data->{IDENTITY}->{$name} or 'Unknown'), "</span><br/>";
	} else {
	    push @html, "<label>Certificate:</label>";
	    if ($data->{IDENTITY}->{$name}) {
		push @html, 
		"<div class='labeled' style='height:100px;overflow:scroll;'><pre>", 
		$data->{IDENTITY}->{$name},
		"</pre></div><br/>";
	    } else { push @html, "<div class='labeled'>Unavailable</div><br/>"; }
	}
    }
    
    foreach my $name (sort keys %{$data->{CONTACT_ATTR}}) {
	push @html, "<label>$name:</label><span class='labeled'>", 
	($data->{CONTACT_ATTR}->{$name} or 'Unknown'), "</span><br/>";
    }
    
    return @html;
}


sub formatAction
{
    my ($self, $aid, $action, $tid) = @_;
    my @html;

    my $actionid = "action$aid";
    my $actionclientid = "actionclient$aid";
    if ($tid) {
	$actionid = "task$tid".$actionid;
	$actionclientid = "task$tid".$actionclientid;
    }

    push @html,
    "<h1><a href='#' onclick='return hideshow(this,\"$actionid\",0)'>",
    $$action{ACTION_NAME}, "</a></h1>",
    "<div id='$actionid' style='display:none;'>",
    "<label>Time:</label>", "<span class='labeled'>", &formatTime($$action{ACTION_TIME}, 'stamp'), "</span><br/>",
    "<label>Client:</label>", "<span class='labeled'>",
    "<a href='#' onclick='return hideshow(this, \"$actionclientid\", 0)'>",
    ($$action{ACTION_CREATOR}{IDENTITY}{NAME} or 'Unknown'), "</a></span><br/>",
    "<div id='$actionclientid' class='hideaway' style='display:none;'>",
    $self->formatClientData($$action{ACTION_CREATOR}),
    "</div>";
    
    sub formatAttr
    {
	my $attr = shift;
	if ($$attr{NAME} eq 'Priority') {
	    my $fmt = { 0 => 'High', 1 => 'Normal', 2 => 'Low' };
	    return $$fmt{$$attr{VALUE}};
	} elsif ($$attr{NAME} eq 'Transient' or 'Move') {
	    return &yesno($$attr{VALUE});
	}
	return $$attr{VALUE};
    }

    foreach my $attr (sort { $$a{ID} <=> $$b{ID} } @{ $$action{ATTR} } ) {
	next unless $$attr{VALUE};
	my $commentclass = (grep $$attr{NAME} eq $_,  qw(Comment Message)) ? ' comment' : '';
	push @html, "<label>$$attr{NAME}:</label><span class='labeled$commentclass'>", 
	&formatAttr($attr),"</span><br/>";
    }
    
    push @html, "</div>";

    return @html;
}

1;

######################################################################
package Web25::Request::Main;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 0, TITLE => "Overview",
	       LINK_TITLE => "Quick overview of transfer requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my ($qtask, $qreq);
  if ($$self{MY_VIEW}) {
      my $identity = $self->fetch_identity();
      
      $qtask = &dbexec($$self{DBH},
		     qq{ select count(t.id)
			     from t_req_task t
			     where t.person = :identity },
		     ":identity" => $$identity{ID});

    $qreq = &dbexec($$self{DBH}, qq{
	select req.state, count(req.id)
	    from t_adm_client c
	    join t_req_request req on req.creator = c.id
	    where c.identity = :identity
	    group by req.state},
		    ":identity" => $$identity{ID});
  } else {
    $qtask = &dbexec($$self{DBH}, qq{
      select count(t.id) from t_req_task t});

    $qreq = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      group by req.state});
  }

  my ($tasks) = $qtask->fetchrow();
  my $your = $$self{MY_VIEW} ? "Your" : "All";
  print { $$self{CONTENT} }
    "<div align='left'>",
    "<p><a href='@{[$self->myurl('page' => 'Request::Admin')]}'>$your pending tasks</a></p>\n",
    "<ul>\n",
    " <li> ", ($tasks ? "$tasks Tasks" : "None"), "</li>\n",
    "</ul>\n",
    "<p><a href='@{[$self->myurl('page' => 'Request::Requests')]}'>$your transfer requests</a></p>\n",
    "<ul>\n";

  my $n = 0;
  my %status = ();
  while (my ($state, $count) = $qreq->fetchrow())
  {
    $status{$state} = $count;
  }

  foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
  {
    my $s = $$state{STATE};
    next if ! $status{$s};
    print { $$self{CONTENT} } " <li> $status{$s} $$state{LABEL}</li>\n";
    $n += $status{$s};
  }

  print { $$self{CONTENT} } "</div>\n";
}

1;

######################################################################
package Web25::Request::Admin;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Administer Requests",
	       LINK_TITLE => "Browse and carry out pending tasks",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $task = param('task');
  my $request = param('request');


  my @where;  my %binds;
  my $identity = $self->fetch_identity()->{ID};

  if ($$self{MY_VIEW}) {
      push @where, qq{ t.person = :identity };
      $binds{':identity'} = $identity;
  }

  if ($task) {
      push @where, 't.id = :task';
      $binds{':task'} = $task;
  }

  if ($request) {
      push @where, 'r.id = :request';
      $binds{':request'} = $request;
  }

  my $where_bit = @where ? 'where '.join(' and ', @where) : '';

  my $sql = qq{
      select t.id tid, a.id aid, r.id rid, i.name assigned_to, i.id assigned_to_id, t.time_create, r.state, r.creator,
             a.action, a.time_apply, a.client, a_attr.id, a_attr.name, a_attr.value
      from t_req_task t
      join t_adm_identity i on t.person = i.id
      join t_req_action a on a.id = t.action
      join t_req_request r on r.id = a.request
      left join t_req_action_attr a_attr on a_attr.action = a.id
      $where_bit
  };

  my $pager = new Web25::QueryPager;
  $pager->init($self, $sql, {%binds}, 10, 'tid desc');
  my $n_tasks = $pager->get_total_results();
  
  if (! $n_tasks) {
      print { $$self{CONTENT} } "<p>No tasks to show.</p>";
      return;
  }

  print {$$self{CONTENT}} $pager->pager();
  my $qtask = $pager->paged_result();

  my %task;
  while (my ($tid, $aid, $rid, $tassigned, $tassigned_id, $tcreate, $rstate, $rcreator,
	     $action, $atime, $aclient, $attrid, $name, $value) = $qtask->fetchrow()) {
      if (not exists $task{$tid}) {
	  $task{$tid}{TASK_ASSIGNED} = $tassigned;
	  $task{$tid}{TASK_ASSIGNED_ID} = $tassigned_id;
	  $task{$tid}{TASK_CREATED}  = $tcreate;
	  $task{$tid}{REQUEST_ID} = $rid;
	  $task{$tid}{REQUEST_STATE} = $rstate;
	  $task{$tid}{REQUEST_CREATOR} = $self->getClientData($rcreator);
      }
      if (not exists $task{$tid}{ACTIONS}{$aid}) {
	  $task{$tid}{ACTIONS}{$aid}{ACTION_NAME} = $action;
	  $task{$tid}{ACTIONS}{$aid}{ACTION_TIME} = $atime;
	  $task{$tid}{ACTIONS}{$aid}{ACTION_CREATOR} = $self->getClientData($aclient);
	  $task{$tid}{ACTIONS}{$aid}{ATTR} = [];
      }
      push @{$task{$tid}{ACTIONS}{$aid}{ATTR}}, {ID => $attrid, NAME=> $name, VALUE=> $value};
  }

  foreach my $tid (reverse sort { $a <=> $b } keys %task) {
      my $details_url = $self->myurl(page => 'Request::Detail', 'request' => $task{$tid}{REQUEST_ID});

      print { $$self{CONTENT} } 
      "<div class='nice paramblock lev1'>",
      "<h1>Task $tid</h1>",
      "<label>Task Assigned to:</label>", "<span class='labeled'>", $task{$tid}{TASK_ASSIGNED}, "</span><br/>",
      "<label>Task Created:</label>", "<span class='labeled'>", &formatTime($task{$tid}{TASK_CREATED}, 'stamp' ), "</span><br/>",
      "<label>Request #:</label><span class='labeled'>", $task{$tid}{REQUEST_ID}, "<a href='$details_url'>(details)</a></span><br/>",
      "<label>Requestor:</label>", "<span class='labeled'>",
      "<a href='#' onclick='return hideshow(this, \"creator$tid\", 0)'>",
      ($task{$tid}{REQUEST_CREATOR}{IDENTITY}{NAME} or 'Unknown'), "</a></span><br/>",
      "<div id='creator$tid' class='hideaway' style='display:none;'>",
      $self->formatClientData($task{$tid}{REQUEST_CREATOR}),
      "</div>",
      "<label>Request State:</label>", "<span class='labeled'>", $reqstatenames{$task{$tid}{REQUEST_STATE}}, "</span><br/>";

      foreach my $aid (sort { $task{$tid}{ACTIONS}{$a}{ACTION_TIME} <=>
			      $task{$tid}{ACTIONS}{$b}{ACTION_TIME} } keys %{$task{$tid}{ACTIONS}}) {
	  print { $$self{CONTENT} }
	  "<div class='paramblock lev2'>",
	  $self->formatAction($aid, $task{$tid}{ACTIONS}{$aid}, $tid),
	  "</div>";

	  if ($task{$tid}{TASK_ASSIGNED_ID} == $identity
	      && $task{$tid}{ACTIONS}{$aid}{ACTION_NAME} eq 'Created') {
	      my @destinations;
	      foreach my $attr (@{$task{$tid}{ACTIONS}{$aid}{ATTR}}) {
		  if ($$attr{NAME} eq 'Destination Node') {
		      push @destinations, $$attr{VALUE};
		  }
	      }

	      my @auth_nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');

	      my @auth_dests;
	      foreach my $dest (@destinations) {
		  push @auth_dests, $dest if grep $dest eq $_, @auth_nodes;
	      }

	      my $formurl = $self->myurl(page=>'Request::NewAction');
	      print { $$self{CONTENT} }
	      "<form method='post' action='$formurl'>",
	      hidden(-name=>'request', -value=>$task{$tid}{REQUEST_ID}),
	      hidden(-name=>'task', -value=>$tid),
	      hidden(-name=>'action', -value=>$aid),
	      "<label>Next Action:</label>",
	      popup_menu(-name=>'newaction', 
			 -values=>['subscribe', 'disapprove'],
			 -labels=>{'subscribe' => 'Subscribe',
				   'disapprove' => 'Disapprove'},
			 -class=>'labeled'
			 ),
			     "<br/><label>For Nodes:</label>", checkbox_group(-name=>'nodes',
									      -values=>[@auth_dests],
									      -default=>[@auth_dests],
									      -class=>'labeled',
									      -columns=>3
									      ),
	      "<label>Comment:<br/><span class='note'>(Optional)</span></label>",
	      textarea(-name=>'comment', -rows=>10, -cols=>60, -class=>'labeled'), "<br/>",
			     "<label>&nbsp;</label>",
			     submit(-value=>'Submit', -class=>'labeled'), "<br/>",
	      "</form>";
	  }
      }
      print { $$self{CONTENT} } "</div>"; # close task
  }
  print {$$self{CONTENT}} $pager->pager();
}



1;

######################################################################
package Web25::Request::NewAction;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 0, ORDER => 100, TITLE => "New Action",
	       LINK_TITLE => "Create a new action on a task",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    
    my $newaction = param('newaction');
    my $oldaction = param('action');
    my $request = param('request');
    my $person = $self->fetch_identity()->{ID};
    my $task = param('task');
    my @nodes = param('nodes');
    my $comment = param('comment');

    if (!$newaction || !$request || !$task || !$person) {
	alert('Missing parameters');
	return;
    }

    # Check that the user is authorized to approve/deny requests
    unless ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Global Admin', 'phedex') || $$self{SECMOD}->hasRole('Data Manager'))) {
	$self->auth_help_popup('approve requests' => ['cert', 'Data Manager', 'Global Admin']);
	return;
    }

    # Check that some nodes have been selected
    unless (@nodes) {
	$self->alert("No nodes selected for this action.  Please go back and select some nodes");
	return;
    }

    # Check that the user is authorized to act on these nodes
    my @auth_nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');
    foreach my $node (@nodes) {
	if (! grep $node eq $_, @auth_nodes) {
	    $self->alert("You are not authorized to approve requests for the node '$node'");
	    return;
	}
    }

    my @action_attr;
    my $newactionname;
    my $now = time();
    
    foreach my $node (@nodes) {
	push @action_attr, ('For Node' => $node);
    }

    if ($comment) {
	push @action_attr, ('Comment' => $comment);
    }
    
    if ($newaction eq 'subscribe') {
	$newactionname = 'Subscribed';
	my $n_subs = &subscribe_request($$self{DBH}, $request, [@nodes], $now);
	if ($n_subs == 0) {
	    my $msg = 'Warning:  Request approval did not create any new subscriptions.  Possible reasons are:  '.
		'1. All data items requested were already subscribed via another request or '.
		'2. The data items are no longer known to phedex.';
	    $self->note($msg);
	    push @action_attr, ('Message', $msg);
	}
    } elsif ($newaction eq 'disapprove') {
	unless (&disapprove_request($$self{DBH}, $request, [@nodes], $now)) {
	    $self->alert("Disapproval failed.  Please notify the developers.");
	    return;
	}
	$newactionname = 'Disapproved';
    } else { &alert("Unknown action type '$newaction'"); return; }
    
    my $client = $self->logClientInfo();

    my $aid = &makeObjWithAttrs
	($$self{DBH}, "req_action", "action",
	 { "request" => $request,
	   "action" => $newactionname,
	   "client" => $client,
	   "time_apply" => $now },
	 @action_attr
	 );

    my $newstate = &get_request_state($$self{DBH}, $request);

    # If the request has been handled for all nodes, we delete all
    # tasks associated with this request.  Otherwise, we only delete
    # the task for the current user.
    if ($newstate !~ /^Partially/) {
	&dbexec($$self{DBH}, qq{delete from t_req_task where action = :aid},
		':aid' => $oldaction);
    } else {
	&dbexec($$self{DBH}, qq{delete from t_req_task where action = :aid and person = :person},
		':aid' => $oldaction, ':person' => $person);
    }

    # Update the state
    &dbexec($$self{DBH}, qq{update t_req_request set state = :newstate where id = :request},
	    ':newstate' => $reqstatevalues{$newstate}, ':request' => $request);

    $$self{DBH}->commit();
    
    print { $$self{CONTENT} }
    "<h1>Task Completed</h1>",
    "<p>You have $newactionname request \#$request for ",
    join(", ", @nodes),".</p>",
    "<p><a href='",$self->myurl(page=>'Request::Admin'),"'>View tasks again</a></p>";
   
    my $q = &dbexec($$self{DBH}, 
		    qq{ select creator from t_req_request where id = :id },
		    ':id' => $request);

    # Get a list of the sites involved in this request
    my %node_sites = $$self{SECMOD}->getPhedexNodeToSiteMap();
    my %sites;  # for unique list
    foreach my $dest (@nodes) {
	$sites{ $node_sites{$dest} } = 1 if exists $node_sites{$dest};
    }
    
    # Get the list of Data Managers affected by this request
    my @data_managers;
    foreach my $site (keys %sites) {
	push @data_managers, $$self{SECMOD}->getUsersWithRoleForSite('Data Manager', $site);
    }

    # Get the list of Site Admins affected by this request
    my @site_admins;
    foreach my $site (keys %sites) {
	push @site_admins, $$self{SECMOD}->getUsersWithRoleForSite('Site Admin', $site);
    }

    my ($creator_id) = $q->fetchrow();
    my $creator_data = $self->getClientData($creator_id);
    my $creator_name = $$creator_data{IDENTITY}{NAME};
    my $creator_email = $$creator_data{IDENTITY}{EMAIL};
    my $detail_url = $self->myurl(page => 'Request::Requests', request => $request, fullurl => 1);
    my $admin_email = $$self{SECMOD}->getEmail();
    my $msg_comment = ($comment ? "\nThe person who handled this had the following comment:\n\n\"$comment\"\n" : '');
    my $nodes_str = join(', ', @nodes);

    my @cc;
    push @cc, $$_{EMAIL} foreach @data_managers, @site_admins;

    my $message=<<ENDEMAIL;
Dear $creator_name,

Your request \#$request has been $newactionname by $$self{USER_NAME} for $nodes_str.
$msg_comment
This request is now $newstate.

To review details of the request, please go to:

$detail_url

To inquire further about this request, you may reply to this email.

This message has also been CCed to the Data Managers and Site Admins of the sites involved.

Yours truly,
  PhEDEx transfer request webpage

ENDEMAIL

    send_email(subject => "PhEDEx Request $newactionname (request \#$request)",
	       to => [ $creator_email ],
	       cc => [ @cc ],
	       from => "PhEDEx Web Requests <$$self{CONFIG}{FEEDBACK_MAIL}>",
	       replyto => [ $admin_email ],
	       message => $message
	      );
}


sub subscribe_request
{
    my ($dbh, $request, $nodes, $now) = @_;

    my ($node_list, %node_binds) = &dbinlist('node', @{$nodes});

    my ($sth, $rv) = &dbexec($dbh,
	    qq[ insert into t_dps_subscription 
		  (dataset, block, destination, priority, is_move, is_transient, time_create)
		select dataset, block, destination, priority, is_move, is_transient, time_create
                 from (
		select ds.id dataset, NULL block, dest.destination, priority, is_move, is_transient, :now time_create
		  from t_req_info_dest dest
		  join t_req_info_dataset req_ds on dest.request = req_ds.request
		  join t_dps_dataset ds on req_ds.dataset = ds.name
                  join t_dps_dbs dbs on ds.dbs = dbs.id
		 where dest.request = :rid and dbs.name = req_ds.dbs
                   and req_ds.dps_isknown = 'y' and req_ds.dbs_isknown = 'y'
                union
                select NULL dataset, b.id block, dest.destination, priority, is_move, is_transient, :now time_create
                  from t_req_info_dest dest
		  join t_req_info_block req_b on dest.request = req_b.request
                  join t_dps_block b on req_b.block = b.name
		  join t_dps_dataset ds on b.dataset = ds.id
                  join t_dps_dbs dbs on ds.dbs = dbs.id
		 where dest.request = :rid and dbs.name = req_b.dbs
                   and req_b.dps_isknown = 'y' and req_b.dbs_isknown = 'y' 
		) requests
                join t_adm_node n on n.id = requests.destination
                where n.name in ($node_list)
                and not exists (select 1 from t_dps_subscription s 
                                 where s.dataset = requests.dataset
                                       and (s.block = requests.block
                                            or s.destination = requests.destination)) ],
	    ':now' => $now,
	    ':rid' => $request,
	    ':now' => $now,
	    ':rid' => $request,
	     %node_binds);

    return (!$rv || $rv == 0) ? 0 : $rv;
}


sub disapprove_request
{
    return 1;
}

sub get_request_state
{
    my ($dbh, $request) = @_;

    my $sql = qq{
      select create_attr.value dest, subs_attr.value subscribed, dis_attr.value disapproved
       from t_req_action create_act join t_req_action_attr create_attr
              on create_attr.action = create_act.id 
                 and create_act.action = 'Created' and create_attr.name = 'Destination Node'
            left join (
              t_req_action subs_act join t_req_action_attr subs_attr
              on subs_attr.action = subs_act.id
                 and subs_act.action = 'Subscribed' and subs_attr.name = 'For Node'
            ) on subs_act.request = create_act.request and subs_attr.value = create_attr.value
            left join (
              t_req_action dis_act join t_req_action_attr dis_attr
              on dis_attr.action = dis_act.id
                 and dis_act.action = 'Disapproved' and dis_attr.name = 'For Node'
            ) on dis_act.request = create_act.request and dis_attr.value = create_attr.value
      where create_act.request = :request
  };

    my $q = &dbexec($dbh, $sql, ':request' => $request);
    
    my $res = {};
    my ($n_dest, $n_subs, $n_dis) = (0) x 3;
    while (my ($dest, $subs, $dis) = $q->fetchrow()) {
	$$res{$dest} = { 'SUBSCRIBED' => $subs, 'DISAPPROVED' => $dis };
	$n_dest++;
	$n_subs++ if $subs;
	$n_dis++ if $dis;
    }

    my $state;
    if    ($n_dest == $n_subs)          { $state = 'Approved'; }
    elsif ($n_dest == $n_dis)           { $state = 'Disapproved'; }
    elsif ($n_subs == 0 && $n_dis == 0) { $state = 'Pending approval'; }
    elsif ($n_subs !=0)                 { $state = 'Partially approved'; }
    elsif ($n_dis !=0)                  { $state = 'Partially disapproved'; }

    return wantarray ? ($state, $res) : $state;
}

1;



######################################################################
package Web25::Request::Requests;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "View Requests",
	       LINK_TITLE => "Browse requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $request = param('request');

    my @where; my %binds;
    if ($$self{MY_VIEW}) {
	push @where, 'ident.id = :identity';
	$binds{':identity'} = $self->fetch_identity()->{ID};
    }

    if ($request) {
	push @where, 'r.id = :request';
	$binds{':request'} = $request;
    }

    my $where_bit = @where ? 'where '.join(' and ', @where) : '';

    my $sql = qq{
      select r.id rid, r.state, r.creator, a.id aid, a.action, a.time_apply, a.client, a_attr.id attr_id, a_attr.name, a_attr.value
      from t_req_request r
      join t_req_action a on a.request = r.id
      join t_adm_client client on client.id = r.creator
      join t_adm_identity ident on ident.id = client.identity
      left join t_req_action_attr a_attr on a_attr.action = a.id
      $where_bit
    };

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, {%binds}, 10, 'rid desc');
    my $n_requests = $pager->get_total_results();

    if (! $n_requests) {
	print { $$self{CONTENT} } "<p>No requests to show.</p>";
	return;
    }

    print {$$self{CONTENT}} $pager->pager();
    my $qreq = $pager->paged_result();

    my %req;
    while (my ($rid, $rstate, $rcreator, $aid, $action, $atime,
	       $aclient, $attrid, $name, $value) = $qreq->fetchrow()) {
	if (not exists $req{$rid}) {
	    $req{$rid}{REQUEST_STATE} = $rstate;
	    $req{$rid}{REQUEST_CREATOR} = $self->getClientData($rcreator);
	}
	if (not exists $req{$rid}{ACTIONS}{$aid}) {
	    $req{$rid}{ACTIONS}{$aid}{ACTION_NAME} = $action;
	    $req{$rid}{ACTIONS}{$aid}{ACTION_TIME} = $atime;
	    $req{$rid}{ACTIONS}{$aid}{ACTION_CREATOR} = $self->getClientData($aclient);
	    $req{$rid}{ACTIONS}{$aid}{ATTR} = [];
	}
	push @{$req{$rid}{ACTIONS}{$aid}{ATTR}}, {ID => $attrid, NAME=> $name, VALUE=> $value} if ($name);
    }

    foreach my $rid (reverse sort { $a <=> $b } keys %req) {
      my $details_url = $self->myurl(page => 'Request::Detail', 'request' => $rid);
      print { $$self{CONTENT} } 
      "<div class='nice paramblock lev1'>",
      "<h1>Request $rid <a href='$details_url'>(details)</a></h1>",
      "<label>Requestor:</label>", "<span class='labeled'>",
      "<a href='#' onclick='return hideshow(this, \"creator$rid\", 0)'>",
      ($req{$rid}{REQUEST_CREATOR}{IDENTITY}{NAME} or 'Unknown'), "</a></span><br/>",
      "<div id='creator$rid' class='hideaway' style='display:none;'>",
      $self->formatClientData($req{$rid}{REQUEST_CREATOR}),
      "</div>",
      "<label>Request State:</label>", "<span class='labeled'>", 
      $reqstatenames{$req{$rid}{REQUEST_STATE}}, "</span><br/>";

      foreach my $aid (sort { $req{$rid}{ACTIONS}{$a}{ACTION_TIME} <=>
			      $req{$rid}{ACTIONS}{$b}{ACTION_TIME} } keys %{$req{$rid}{ACTIONS}}) {
 	  print { $$self{CONTENT} }
 	  "<div class='paramblock lev2'>",
	  $self->formatAction($aid, $req{$rid}{ACTIONS}{$aid}),
 	  "</div>";
      }

      print { $$self{CONTENT} } "</div>";
  }
    print {$$self{CONTENT}} $pager->pager();
}


1;

######################################################################
package Web25::Request::Detail;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Request Details",
	       LINK_TITLE => "Explore request details",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $request = param('request');
  my $where_bit = $request ? 'where req.id = :request' : '';
  my %binds = $request ? (':request' => $request) : ();

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $req_info = {};
  my $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id, req.creator creator_id, req.state req_state,
                             ident.name requestor,
		             req_info.time_update updated
		        from t_req_request req
                        join t_adm_client client on client.id = req.creator
                        join t_adm_identity ident on ident.id = client.identity
		        join t_req_info req_info on req_info.request = req.id
		        $where_bit ], %binds);

  while (my $row = $q->fetchrow_hashref()) {
      $$req_info{$$row{REQ_ID}} = $row;
  }

  my $req_dest = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id, node.name dest_name
		        from t_req_request req
		        join t_req_info_dest req_dest on req_dest.request = req.id
		        join t_adm_node node on node.id = req_dest.destination
		      $where_bit ], %binds);

  while (my ($rid, $node) = $q->fetchrow()) {
      if (!exists $$req_dest{$rid}) {
	  $$req_dest{$rid} = [];
      }
      push @{$$req_dest{$rid}}, $node;
  }

  my $req_datasets = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id,
		             req_ds.dbs req_dbs, req_ds.dataset, req_ds.dbs_isknown, req_ds.dps_isknown
		        from t_req_request req
		        join t_req_info_dataset req_ds on req_ds.request = req.id
		      $where_bit ], %binds);

  while (my ($rid, $dbs, $dataset, $dbs_isknown, $dps_isknown) = $q->fetchrow()) {
      $$req_datasets{$rid}{$dataset} = { DBS => $dbs,
					 DBS_ISKNOWN => $dbs_isknown,
					 DPS_ISKNOWN => $dps_isknown };
  }

  my $req_blocks = {};
  $q = &dbexec($$self{DBH},
		  qq[ select req.id req_id,
		             req_b.dbs req_dbs, req_b.block, req_b.dbs_isknown, req_b.dps_isknown
		        from t_req_request req
		        join t_req_info_block req_b on req_b.request = req.id
		      ]);

  while (my ($rid, $dbs, $block, $dbs_isknown, $dps_isknown) = $q->fetchrow()) {
      $$req_blocks{$rid}{$block} = { DBS => $dbs,
				     DBS_ISKNOWN => $dbs_isknown,
				     DPS_ISKNOWN => $dps_isknown };
  }

  my $table = new Web25::TableSpool;
  $table->set_filehandle( $$self{ CONTENT } );

  $table->set_querycols( [('Request #', 'col', 'REQUEST', 1)],
			 [('DBS', 'col', 'DBS', 1)],
			 [('Data Item', 'col', 'DATA_ITEM', 1)],
			 [('Destinations', 'col', 'DESTINATIONS', 1)],
			 [('Requestor', 'col', 'REQUESTOR', 1)],
			 [('Updated', 'col', 'UPDATED', 1)],
			 [('Known to DBS?', 'col', 'DBS_ISKNOWN', 1)],
			 [('Known to PhEDEx?', 'col', 'DPS_ISKNOWN', 1)]
			 );

  $table->set_tablehead({REQUEST => 'Request #',
			 DBS => 'DBS',
			 DATA_ITEM => 'Data Item',
			 DESTINATIONS => 'Destinations',
			 REQUESTOR => 'Requestor',
			 UPDATED => 'Request Updated',
			 DBS_ISKNOWN => 'Known to DBS?',
			 DPS_ISKNOWN => 'Known to PhEDEx?' });


  $table->set_tableclass('data');
  $table->set_stripeclass('stripe');

  $table->set_dataformats({ UPDATED   => sub { &formatTime($_[0], 'stamp') },
			    DBS_ISKNOWN => \&yesno,
			    DPS_ISKNOWN => \&yesno
			});

  $table->set_cellformats({DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			   DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});

  $table->start();
  $table->head();

  foreach my $rid (reverse sort { $a <=> $b } keys %{$req_info}) {
      my $dests;
      if (!$$req_dest{$rid}) { $dests = 'None (Node deleted?)'; }
      else {
	  $dests = join ', ', @{$$req_dest{$rid}};
	  $dests = &shorten('nodes', $rid, 10, $dests) if scalar @{$$req_dest{$rid}} > 1;
      }
      my $row = { REQUEST => $rid, DESTINATIONS => $dests };
      $$row{$_} = $$req_info{$rid}{$_} foreach (qw(REQUESTOR UPDATED));
      
      foreach my $dataset (sort keys %{$$req_datasets{$rid}}) {
	  $$row{DATA_ITEM} = $dataset;
	  $$row{$_} = $$req_datasets{$rid}{$dataset}{$_} foreach(qw(DBS DBS_ISKNOWN DPS_ISKNOWN));
	  $table->row($row);
      }

      foreach my $block (sort keys %{$$req_blocks{$rid}}) {
	  $$row{DATA_ITEM} = $block;
	  $$row{$_} = $$req_blocks{$rid}{$block}{$_} foreach(qw(DBS DBS_ISKNOWN DPS_ISKNOWN));
	  $table->row($row);
      }
  }

  $table->finish();

  #  Options form
  my $optspane = new Web25::OptsPane;
  $optspane->add_hidden( hidden('request', $request) ) if $request;
  my $target = $self->myurl();
  $optspane->set_form_target($target);
  
  my $form = $table->columns_form();
  $optspane->add_tab('Columns', $form);
  
  print { $$self{OPTIONS} } $optspane->output();

}



1;

######################################################################
package Web25::Request::CreateTools;
use strict; use warnings;
use base "Exporter";
import Web25::Common;
use CGI qw(:standard);
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} 
	|| "./"; $__scriptdir =~ s,[^/]+$,,;
	unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;

our @EXPORT = qw(get_request_nodes
		 create_check_access
		 create_check_identity
		 create_check_email
		 create_check_comment
		 create_check_dbs
		 create_check_data
		 create_check_dest
		 create_check_options
		 create_check_bad
);

sub get_request_nodes
{
    my ($self) = shift @_;
    my %nodes = $self->fetch_nodes(with_ids=>1);
    foreach my $node (keys %nodes) {
	delete $nodes{$node} if ($node =~ /(.*)_(Buffer|Stage)$/ && exists $nodes{"$1_MSS"});
    }
    return sort keys %nodes;
}

sub create_check_access
{
  my ($self, $bad) = @_;
  return if $$bad;

  if (request_method() ne 'POST')
  {
    alert($self, "This form can only be accessed with 'POST' method.");
    $$bad = 1;
  }
}

sub create_check_identity
{
  my ($self, $bad) = @_;
  return if $$bad;

  # Make sure this page can be used
  if (! $$self{SECMOD}->isAuthenticated() ) {
      $self->auth_help_warning('create a transfer request' => ['anyauth']);
      $$bad = 1;
      return;
  }
}

sub create_check_email
{
  my ($self, $bad, $email) = @_;
  return undef if $$bad;

  if (! $email)
  {
    alert($self, "No requestor e-mail, please supply one.");
    $$bad = 1;
    return undef;
  }

  my ($nrvalidmails, @emails) = validlist ($email);
  if ($email ne '' && ! $nrvalidmails)
  {
    alert($self, "Requestor e-mail &ldquo;@{[&escapeHTML($email)]}&rdquo; is",
	  " not a valid RFC822 e-mail address or address list.");
    $$bad = 1;
  }

    return $$bad ? undef : $email;
}

sub create_check_comment
{
  my ($self, $bad, $comment) = @_;
  return undef if $$bad;
  return $comment;
}

sub create_check_dbs
{
  my ($self, $bad, $dbs) = @_;
  return undef if $$bad;
  if (! $dbs)
  {
    alert($self, "No DBS selected, please choose a value.");
    $$bad = 1;
    return undef;
  }

  if ($dbs !~ m|^[-=+_:/?&;.a-zA-Z0-9]+$|)
  {
    alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	  " contains unsafe characters.");
    $$bad = 1;
  }

  my $SAFE_HOST = "[-A-Za-z0-9_+.]+";
  my $SAFE_PATH = "[-A-Za-z0-9_+.:/&%;]*";
  if ($dbs !~ m,^https?://($SAFE_HOST)(:\d+)?/($SAFE_PATH)\?.*instance=$SAFE_PATH$,)
  {
      my @dbses = $self->fetch_dbses();
      if (! grep($_ eq $dbs, @dbses))
    {
      alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " is not a URL for a DBS service.  Please use a URL of",
	    " the form http://server/path?instance=name.");
      $$bad = 1;
    }
  }
  else
  {
    my $hostname = $1;
    my ($name,$aliases,$addrtype,$length,@addrs)
      = CORE::gethostbyname($hostname);
    if (! $name)
    {
      alert($self, "The host name of the DBS service, &ldquo;",
	    &escapeHTML($hostname), "&rdquo;, did not resolve.",
	    " Please make sure the host is accessible.");
      $$bad = 1;
    }

    my $info = qx(wget -qO- '$dbs;api=listPrimaryDatasets;pattern=/zilch');
    if (! $info || $info !~ /<dbs>/s)
    {
      alert($self, "The DBS contact, &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " does not respond to aliveness check.  Please make sure",
	    " the contact URL points to a correct service.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : $dbs;
}



sub create_check_data
{
  my ($self, $bad, $data) = @_;
  return undef if $$bad;

  my %userdata = $self->parse_userdata($data);
  if (! %userdata) {
    alert($self, "No data specified.");
    $$bad = 1;
  }

  foreach my $data (keys %userdata) {
      if (! $userdata{$data} ) {
	  $self->alert("The data pattern is &ldquo;@{[&escapeHTML($data)]}&rdquo;",
		       " does not match pattern of type /PRIMARY/TIER/DATASET or /PRIMARY/DATASET#BLOCK.");
	  $$bad = 1;
      }
  }

  return $$bad ? undef : keys %userdata;
}

sub create_check_dest
{
  my ($self, $bad, @dests) = @_;
  return undef if $$bad;

  if (! @dests)
  {
    alert($self, "No destination selected, please select some.");
    $$bad = 1;
    return undef;
  }

  my @nodes = $self->get_request_nodes();

  foreach my $node (@dests)
  {
    if (! grep ($_ eq $node, @nodes))
    {
      alert($self, "Node name &ldquo;@{[&escapeHTML($node)]}&rdquo;",
	    " is not known to PhEDEx.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : sort @dests;
}

sub create_check_options
{
  my ($self, $bad) = @_;
  return undef if $$bad;

  my $opts = {};

  foreach ('is_move', 'is_transient') {
      if (!param($_) && param($_) !~ /^[yn]$/) {
	  $self->alert("Option '$_' missing or illegal value");
	  $$bad = 0;
	  return undef;
      }
  }
  
  if (!param('priority') && param('priority') !~ /^[012]$/) {
      $self->alert("Option 'priority' missing or illegal value");
      $$bad = 0;
      return undef;
  }
  return (param('is_move'), param('is_transient'), param('priority'));
}

sub create_check_bad
{
  my ($self, $bad) = @_;
  print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n" if $bad;
  return $bad;
}

1;

######################################################################
package Web25::Request::Create;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Create Request",
	       SESSION => 1,
	       LINK_TITLE => "Create a new transfer request",
	       SECURE => 0 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  return if $bad;

  my $email_contact = $$self{SECMOD}->getEmail();
  
  my @dbsnames = $self->fetch_dbses();
  my $defaultdbs = $$self{CONFIG}{DEFAULT_DBS} || 'blank';
  my @nodes = $self->get_request_nodes();

  my $dbs_selection =  popup_menu(-name=>'dbs', 
				  -values=>[ map { &escapeHTML($_) } @dbsnames ],
				  -default=>&escapeHTML($defaultdbs) );

  print { $$self{CONTENT} }
  "<form class='nice' method='post' action='@{[$self->myurl('page' => 'Request::CreateCheck')]}'>\n",
  "<label>E-mail:</label>", textfield(-name=>'email', -default=>$email_contact, -class=>'labeled', -style=>'width:450px'), "<br/>\n",

  &hidden(-name=>'dbschoice', 'value'=>'known'),
  "<label>DBS:</label>",  "<div class='labeled'>",$dbs_selection, "</div><br/>",

  "<label>Data Items:<br/><br/>",
  "<span class='note'>/Primary/Processed/Tier<br/>or<br/>",
  "/Primary/Processed/Tier#Block<br/>(Use * as wildcard)</span><br/>",
  &help("More Help", "Data Item List", 
	"A whitespace separated list of the datasets or blocks you are ",
	"requesting.  Glob-style wildcards may be used, but the dataset ",
	"path separators are required.  E.g. to subscribe to all ",
	"datasets you would have to write '/*/*/*', not '*'."), 
  "</label>\n",
  textarea(-name=>'data', -value=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), 
  "<br/>",

  "<label>Destinations</label>",
  "<div class='labeled'  style='font-size:8pt;width:450px;height:150px;overflow:scroll;border:thin solid black;' >",
  "<table><tr valign='top'>",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   sort grep (/^T1_|T0_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   grep (/^T2_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'dest', -label=>'', -value=>$_)."$_<br/>") }
   grep (! /^T[012]_/, @nodes)),
  "  </td>\n",
  " </tr></table></div><br/>\n",
  "<label>Transfer Type:</label>", popup_menu(-name=>'is_move', 
					      -values=>['y', 'n'],
					      -default=>'n',
					      -labels=>{'n' => 'Replica', 'y' => 'Move'},
					      -class=>'labeled'),
  &help("What's this?", "Transfer Type", "A <b>replica</b> replicates ",
	"data from the source to the destination, while a <b>move</b> ",
	"replicates the data then deletes the data at the source.  Note that ",
	"moves are only used for moving data from T2s to T1s."),
  "<br/>",
  "<label>Subscription Type:</label>", popup_menu(-name=>'is_transient', 
					       -values=>['y', 'n'],
					       -default=>'n',
					       -labels=>{'n' => 'Open', 'y' => 'Closed' },
					       -class=>'labeled'), 
  &help("What's this?", "Subscription Type", 
	"An <b>open</b> subscription downloads blocks/files added to open ",
	"datasets/blocks as they become available, until the dataset/block is ",
	"closed.  A <b>closed</b> subscription will only transfer the blocks/files ",
	"available at the time the subscription is made.  In a sense an open ",
	"subscription is a true \"subscription\" and a closed subscription is a snapshot."),
  "<br/>",
  "<label>Priority:</label>", popup_menu(-name=>'priority', 
					 -values=>[0, 1, 2], 
					 -default=>1,
					 -labels=>{ 0 => 'High',
						    1 => 'Normal',
						    2 => 'Low' },
					 -class=>'labeled'),
  &help("What's this?", "Priority",
	"Priority is used to determine which data items get priority when resources are limited."),
  "<br/>",
  "<label>Comment:</label>", textarea(-name=>'comment', -default=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), "<br/>\n",

  "<label>&nbsp;</label>", submit(-name=>'submit', -value=>'Submit Request', -class=>'labeled'),
  "</form>";
}

1;



######################################################################
package Web25::Request::CreateCheck;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Submit Request",
	       SESSION => 1, SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $bad = 0;
  my %params;

  &create_check_identity($self, \$bad);
  &create_check_access($self, \$bad);
  if (!param('go_ahead')) {
      $params{email} = &create_check_email($self, \$bad, param('email'));
      $params{comment} = &create_check_comment($self, \$bad, param('comment'));
      if (param('dbschoice') eq 'known') { $params{dbs} = param('dbs') }
      elsif (param('dbschoice') eq 'user') { $params{dbs} = param('userdbs') } 
      else { $self->alert("Missing or unknown DBS parameters"); return; }
      $params{dbs} = &create_check_dbs($self, \$bad, $params{dbs});
      $params{data} = [&create_check_data($self, \$bad, param('data'))];
      $params{dest} = [&create_check_dest($self, \$bad, param('dest'))];
      ($params{is_move}, $params{is_transient}, $params{priority}) = &create_check_options($self, \$bad);
  }

  if ($bad)
  {
    print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n";
    return;
  }

  if (param('go_ahead') && param('is_move') && param('is_move') eq 'y' 
      && !(param('move_confirm') && param('move_confirm') eq 'y')) {
      $self->note('You need to really think about the move request and click the confirmation box!');
      return;
  }

  if (param('go_ahead') && param('go_ahead') eq 'y') {
      $self->write_request();
      return;
  }

  # Clear any previous request
  $$self{SESSION}->clear();

  my $subscription_type = &subscription_type($params{priority}, $params{is_transient}, $params{is_move});

  print { $$self{CONTENT} } 
  "<form method='post' action='@{[$self->myurl()]}'>\n",
  "<p>Please review these request details and confirm below.  If you would like to ",
  "change your request, use the back button in your browser.</p>",
  "<h1>Request Information</h1>",
  "<div class='nice'>",
  "<label>Requestor:</label><span class='labeled'>$$self{USER_NAME}</span><br/>",
  "<label>email:</label><span class='labeled'>$params{email}</span><br/>",
  "<label>DBS:</label><span class='labeled'>$params{dbs}</span><br/>",
  "<label>Data:</label><span class='labeled'>", join('<br/>', @{$params{data}}), "</span><br/>",
  "<label>Destination:</label><span class='labeled'>", join('<br/>', @{$params{dest}}), "</span><br/>",
  "<label>Subscription Type:</label><span class='labeled'>$subscription_type</span><br/>",
  "</div>";

  # Warnings
  if ($params{is_move} eq 'y' && grep($_ !~ /^T1_\w*_MSS$/, @{$params{dest}})) {
      $self->alert("You have requested a move to an unsupported destination (e.g. not a Mass Storage System ",
		   "at a T1 centre).  Please change the destination, or choose to trigger a replication ",
		   "instead of a move");
      return;
  } elsif ($params{is_move} eq 'y' && grep(/^T1_\w*_MSS$/, @{$params{dest}})) {
      $self->note("You have chosen to move data to ", join(', ', @{$params{dest}}), ". Once the transfer is complete this will ",
		  "remove the data at the source sites.  Furthermore, only Global Admins may approve move requests.  ",
		  "Please confirm that this is what you want to do by checking ",
		  "the box.<br/><br/>",
		  ( param('go_ahead') ? "<p class='alarm'><b>You must confirm!</b></p>" : ''),
		  checkbox(-name=>'move_confirm', -value=>'y', -label=>'Yes, I understand'));
  }

  if ($params{is_transient} eq 'n') {
      $self->note("You are requesting an open subscription.  The nodes selected will continue to ",
		  "receive files from open blocks if they are made available.  Please carefully monitor ",
		  "your disks, as the size of this subscription could grow significantly.");
  }
  

  print { $$self{CONTENT} } "<h1>Data Item Lookup</h1>",
  "<p>The following table summarizes an attempt to look for your requested data items in PhEDEx.  ",
  "Items in red may be problematic and require extra consideration by the PhEDEx admins.</p>";
  
  # Pull all subscriptions into a hash organized by node for subscription duplication checking
  my $subscriptions = {};
  my $q = &dbexec($$self{DBH}, qq{ select NVL2(s.block, 'BLOCK', 'DATASET') lvl,
				          NVL2(s.block, s.block, s.dataset) id,
				          n.name node
                                   from t_dps_subscription s
                                   join t_adm_node n on s.destination = n.id });
  
  while (my ($level, $id, $node) = $q->fetchrow_array()) {
      $$subscriptions{$node}{$level}{$id} = 1;
  }

  my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, $params{dbs}, @{$params{data}});

  my $table = new Web25::TableSpool;
  $table->set_filehandle( $$self{CONTENT} );
  $table->set_tableclass('data');
  $table->set_stripeclass('stripe');
  $table->set_tablecols([qw(LEVEL ITEM FILES BYTES DPS_ISKNOWN DBS_ISKNOWN COMMENT)]);
  $table->set_tablehead({LEVEL => 'Data Level', 
			 ITEM => 'Data Item',
			 FILES => 'Files',
			 BYTES => 'Size',
			 DPS_ISKNOWN => 'Known to PhEDEx', 
			 DBS_ISKNOWN => 'Known to DBS', 
			 COMMENT => 'Comment'});
  $table->set_cellformats({COMMENT     => sub { $_[1]->{WARN} ? 'alarm' : '' },
			   DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			   DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});

  $table->set_dataformats({DPS_ISKNOWN => \&yesno,
		           DBS_ISKNOWN => \&yesno,
			   LEVEL => sub { ucfirst lc $_[0] },
		           BYTES => sub { &format_size($_[0], 1, 2, 'G') }});
  $table->set_statcols({FILES => 'SUM', BYTES => 'SUM'});

  $table->start();
  $table->head();

  my $problems = 0;
  my @request;
  foreach my $userglob (sort @{$params{data}}) {
      if (! @{$$resolved{$userglob}} ) {
	  $table->row({LEVEL => 'User Search',
		       ITEM  => $userglob,
		       DPS_ISKNOWN => 'n',
		       DBS_ISKNOWN => 'n',
		       COMMENT => 'Data item not found anywhere',
		       WARN => 1});
	  $problems = 1;
      } else {
	  foreach my $res (@{$$resolved{$userglob}}) {
	      my @comments;
	      my $warn = 0;
	      
	      if ($$res{DBS} ne $params{dbs})  { push @comments, "Known to PhEDEx in another DBS ($$res{DBS})"; $warn = 1; $problems = 1; }
	      if ($$userdupes{$$res{LEVEL}}{$$res{ID}}) { push @comments, "User duplicated requests"; $warn = 1; }
	      if ($$dbsdupes{$$res{LEVEL}}{$$res{ID}})  { 
		  push @comments, "Data item known to PhEDEx in multiple DBSes";
		  $warn = 1; 
	      }
	      
	      foreach my $node (@{$params{dest}}) {
		  if ($$subscriptions{$node}{$$res{LEVEL}}{$$res{ID}}) {
		      push @comments, "Already subscribed to $node";
		      $warn = 1;
		  }
	      }

	      $$res{ITEM} = $$res{$$res{LEVEL}}; # Name of dataset or block, depending on which it is for
	      $$res{COMMENT} = join('<br/>', @comments);
	      $$res{WARN} = $warn;
	      
	      if ($warn) { $problems = 1; }
	      if ($$res{DPS_ISKNOWN} eq 'n' || $$res{DBS_ISKNOWN} eq 'n') { $problems = 1; }
	      $table->row($res);
	      
	      # Request session storage format
	      my @item;
	      $$res{LEVEL} eq 'DATASET' ? push @item, $$res{DATASET} : push @item, $$res{DATASET}, $$res{BLOCK};
	      push @request, join(',', $$res{DBS}, $$res{LEVEL}, @item) ;
	  }
      }
  }

  $table->finish();

  unless ($problems) {
      # Save the previous state
      my $cgi = new CGI;
      $$self{SESSION}->save_param($cgi, [qw(email comment dbschoice dbs userdbs
					    is_move is_transient priority)]);
      $$self{SESSION}->param($_, $params{$_}) foreach qw(data dest);
      $$self{SESSION}->param('request', [@request]);
      my $stats = $table->get_stats();
      $$self{SESSION}->param('sum_files' => $$stats{FILES});
      $$self{SESSION}->param('sum_bytes' => $$stats{BYTES});
      print { $$self{CONTENT} }
      hidden('is_move'),
      hidden(-name=>'go_ahead', -value=>'y'),
      "<p><center>", submit(-value=>'Confirm'), "</p>";
  } else {
      $self->alert("Sorry, due to the problems with your request (in red) it cannot be submitted.  ",
		   "Please go back and resolve the problems if you can, or ",
		   "<a href='mailto:$$self{CONFIG}{FEEDBACK_MAIL}'>mail the admins</a> if you have a question.");
  }
  print { $$self{CONTENT} } "</form>";
}
  


sub write_request
{
    my ($self) = @_;
    
    my %params;
    foreach (qw(email comment dbs data dest is_move is_transient priority request sum_files sum_bytes)) {
	unless (defined $$self{SESSION}->param($_)) {
	    $self->alert('Insuficcient parameters from session');
	    return;
	}
	$params{$_} = $$self{SESSION}->param($_);
    }
    
    my $now = time();

    # Write information about the Client
    my $client = $self->logClientInfo();
    
    # Write the request
    my $rid = &makeObjWithAttrs
	($$self{DBH}, "req_request", undef,
	 { "creator" => $client, "state" => 0 });

    # Write the request attributes
    my $aid = &makeObjWithAttrs
	($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "Created",
	   "client" => $client,
	   "time_apply" => $now },
	 "Comment" => $params{comment},
	 "E-mail" => $params{email},
	 "DBSURL" => $params{dbs},
	 map( { ("Destination Node" => $_) } @{$params{dest}}),
	 map( { ("Data" => $_) } @{$params{data}}),
	 "Priority" => $params{priority},
	 "Transient" => $params{is_transient},
	 "Move" => $params{is_move},
	 "Files" => $params{sum_files},
	 "Bytes" => &format_size($params{sum_bytes})
	 );
    
    # Get a list of the sites involved in this request
    my %node_sites = $$self{SECMOD}->getPhedexNodeToSiteMap();
    my %sites;  # for unique list
    foreach my $dest (@{$params{dest}}) {
	$sites{ $node_sites{$dest} } = 1; # TODO:  Handle null Site...
    }
    
    # Get the list of Global admins
    my @global_admins = $$self{SECMOD}->getUsersWithRoleForGroup('Global Admin', 'phedex');
    if (!@global_admins) {
	alert("Sorry, the request cannot be created.",
	      "The database does not contain any global admins.",
	      "Please contact the PhEDEx group about this!"); 
	return;
    }

    # Get the list of Data Managers affected by this request
    my @data_managers;
    foreach my $site (keys %sites) {
	push @data_managers, $$self{SECMOD}->getUsersWithRoleForSite('Data Manager', $site);
    }

    # Get the list of Site Admins affected by this request
    my @site_admins;
    foreach my $site (keys %sites) {
	push @site_admins, $$self{SECMOD}->getUsersWithRoleForSite('Site Admin', $site);
    }

    # Write a task with this request for each of the global admins and
    # data managers authorized to approve this
    my %task_people;  # use a hash to ensure no duplicates
    my @auth_admins;
    if ($params{'is_move'} eq 'y') {
	@auth_admins = @global_admins;
    } else {
	@auth_admins = (@global_admins, @data_managers);
    }

    foreach my $admin (@auth_admins) {
	my $ident = $self->fetch_identity($admin);
	$task_people{$$ident{ID}} = 1;
    }
    foreach my $person (keys %task_people) {
	&makeObjWithAttrs
	    ($$self{DBH}, "req_task", undef,
	     { "action" => $aid,
	       "person" => $person,
	       "time_create" => $now
	       }
	     );
    }

    # Write the request details (resolved datasets/blocks) to the DB
    &dbexec($$self{DBH}, qq[ insert into t_req_info (request, time_update)
			     values ( :rid, :time_update ) ],
	    ':rid' => $rid,
	    ':time_update' => $now);


    my @rv;
    foreach my $item (@{$params{request}}) {
	my ($dbs, $level, $dataset, $block) = split /,/, $item;
	if ($level eq 'DATASET') {
	    @rv = &dbexec($$self{DBH}, 
			  qq[ insert into t_req_info_dataset (request, dbs, dataset, dbs_isknown, dps_isknown,
							      is_move, is_transient, priority)
			      values ( :rid, :dbs, :dataset, :dbs_isknown, :dps_isknown,
				       :is_move, :is_transient, :priority) ],
			  ':rid'          => $rid,
			  ':dbs'          => $dbs,
			  ':dataset'      => $dataset,
			  ':dbs_isknown'  => 'y',
			  ':dps_isknown'  => 'y',
			  ':is_move'      => $params{is_move},
			  ':is_transient' => $params{is_transient},
			  ':priority'     => $params{priority}
			  );
	} elsif ($level eq 'BLOCK') {
	    @rv = &dbexec($$self{DBH},
			  qq[ insert into t_req_info_block ( request, dbs, dataset, block,
							     dbs_isknown, dps_isknown,
							     is_move, is_transient, priority)
			      values ( :rid, :dbs, :dataset, :block, :dbs_isknown, :dps_isknown,
				       :is_move, :is_transient, :priority) ],
			  ':rid' => $rid,
			  ':dbs' => $dbs,
			  ':dataset' => $dataset,
			  ':block' => $block,
			  ':dbs_isknown' => 'y',
			  ':dps_isknown' => 'y',
			  ':is_move'      => $params{is_move},
			  ':is_transient' => $params{is_transient},
			  ':priority'     => $params{priority}
			  );
	}
	unless ($rv[1] > 0) {
	    $$self{DBH}->rollback();
	    $self->alert("Request creation failed");
	    return;
	}
    }
    
    
    foreach my $node (@{$params{dest}}) {
	&dbexec($$self{DBH},
		qq[ insert into t_req_info_dest (request, destination)
		    select :rid, id node_id from t_adm_node where name = :node ],
		':rid' => $rid, ':node' => $node);
    }

    $$self{DBH}->commit();

    # Send an email to the requestor, the global admins, the data managers, and the site admins
    my $instance = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE};
    my $subscription_type =  &subscription_type(@params{qw(priority is_transient is_move)});
    my @to;
    push @to, $$_{EMAIL} foreach (@global_admins, @data_managers);
    my @cc = ($params{email});
    push @cc, $$_{EMAIL} foreach @site_admins;
    
    my $admin_url = $self->myurl('fullurl' => 1,
				 'secure' => 1,
				 'page' => 'Request::Admin',
				 'view' => 'my',
				 'request' => $rid);
    my $name = $$self{USER_NAME};
    my $dn = $$self{SECMOD}->getDN();
    my $auth = "";
    if ($$self{SECMOD}->isCertAuthenticated()) {
	$auth = "DN:  ".$$self{SECMOD}->getDN();
    } elsif ($$self{SECMOD}->isPasswdAuthenticated()) {
	$auth = "Username:  ".$$self{SECMOD}->getUsername();
    }
    my $move_msg = '';
    if ($params{'is_move'} eq 'y') {
	$move_msg = 'Note:  This is a request for a data MOVE '.
	    'and can only be approved by the Global Admins.';
    }
    my $files = $params{sum_files};
    my $bytes = &format_size($params{sum_bytes});
    
    my $message =<<ENDEMAIL;
Greetings PhEDEx Data Managers,

You may wish to take note of the following new transfer request:

* Requestor:
   Name:  $name
   Authentication $auth
   Host: $ENV{HTTP_X_FORWARDED_FOR}
   Agent: @{[user_agent()]}

* Request:
   Type:
     $subscription_type
   Database:
     $instance
   Contact:
     $params{email}
   DBS:
     $params{dbs}
   Data:
ENDEMAIL

    $message .= join('', map( { "     $_\n" } @{$params{data}})).
    "   Destination Nodes:\n".
    join('', map( { "     $_ (Site: $node_sites{$_})\n" } @{$params{dest}}));

    $message .=<<ENDEMAIL;
   Size:
     $files files, $bytes
   Comments:
     "$params{comment}"

$move_msg
 
This mail has also been sent to the requestor, the PhEDEx global
admins, and the site admins of the relevant sites.

Go to
  $admin_url
to handle this request.

Yours truly,
  PhEDEx Transfer Request Web Form
ENDEMAIL
    
send_email(subject => "PhEDEx Transfer Request ($instance instance)",
	   to => [ @to ],
	   cc => [ @cc ],
	   from => "PhEDEx Request Form <$$self{CONFIG}{FEEDBACK_MAIL}>",
	   message => $message)
or $self->alert("Sending request email to admins failed, sorry");
    
    
    print { $$self{ CONTENT } }
    "<h1>Request Confirmed</h1>",
    "<p>Your request has been logged to the database and the admins have been notified.  ",
    "You will receive updates about this request via e-mail.</p>";

    # Delete the session
    $$self{SESSION}->delete();
}

sub subscription_type
{
    my ($priority, $is_transient, $is_move) = @_;
    my $nice = 
    {
	is_move => { y => 'move', n => 'replication' },
	is_transient => { y => 'closed', n => 'open' },
	priority => { 0 => 'High', 1 => 'Normal', 2 => 'Low' }
    };

    return "$$nice{priority}{$priority} priority $$nice{is_transient}{$is_transient} $$nice{is_move}{$is_move}";
}

1;



######################################################################
package Web25::Components::Status;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Status",
	       LINK_TITLE => "View recently active PhEDEx components" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my %offline_thresholds = ( 'FileDownload' => 60*30,
			     'FileExport'   => 60*90,
			     'InfoFileSize' => 60*30,
			     'BlockDLSUpdate' => 60*60,
			     'OTHER'        => 60*15 );
  
  
  my $now = time ();
  my $query = &dbexec($$self{DBH}, qq{
      select n.name, a.name, ast.label, ast.time_update
	  from t_agent_status ast
	  join t_adm_node n on n.id = ast.node
	  join t_agent a on a.id = ast.agent});

  my (%agents, %status);
  while (my $row = $query->fetchrow_arrayref)
  {
      my ($node, $agent, $label, $contact) = @$row;
      $status{$node}{$agent}{$label} = $contact;
      $agents{$agent} = 1;
  }

  my @standard = grep (/^File/, sort keys %agents);
  my @admin = grep (/^(Block)/, sort keys %agents);
  my @support = grep (/^(?!File|Block|InfoDrop)/, sort keys %agents);

  foreach my $item ([ "Common", @standard ], [ "Administrative", @admin ], [ "Support", @support ])
  {
      my ($type, @agents) = @{$item};

      my @nodes;
      if ($type eq 'Common') {
	  @nodes = sort keys %status;
      } else {
	  push @nodes, 'T0_CERN_Export';
      }

      print { $$self{CONTENT} }
      "<p><table class='striped'>\n",
      "<tbody>\n",
      "<tr class='selected'>\n",
      " <td align='center' colspan='" . (scalar @agents + 1) . "'>$type Agents</td>\n",
      "</tr>\n",
      "<tr class='selected'>\n",
      " <th>Node</th>\n",
      (map { " <th>$_</th>\n" } @agents),
      "</tr>\n";

      foreach my $node (@nodes)
      {
	  next if ! grep (defined $status{$node}{$_}, @agents);

	  print { $$self{CONTENT} } "<tr>\n", " <td>$node</td>\n";
	  foreach my $agent (@agents)
	  {
	      my $offline = ( $offline_thresholds{$agent} || $offline_thresholds{OTHER} );
	      my $active = $offline / 3;

	      my @labels = keys %{$status{$node}{$agent}};
	      if (!@labels)
	      {
		  print { $$self{CONTENT} } " <td>&nbsp;</td>\n";
		  next;
	      }	

	      my $nagents = scalar @labels;
	      my %upstatus;
	      my $nup = 0;
	      my $recent_contact = 0;
	      my $recent_agent = $labels[0];
	      foreach my $label (@labels) {
		  my $contact = $status{$node}{$agent}{$label};
		  my $ago = &age($now - $contact);
		  if ($contact > $recent_contact) {
		      $recent_contact = $contact;
		      $recent_agent = $label;
		  }
		  
		  if (($now - $contact) < $active) {
		      $upstatus{$label} = { STATUS => 'UP', COLOR => $goodcolor};
		      $nup++;
		  } elsif (($now - $contact) < $offline) {
		      $upstatus{$label} = { STATUS => "UP ($ago ago)", COLOR => $goodcolor};
		      $nup++;
		  } else {
		      $upstatus{$label} = { STATUS => "DOWN ($ago ago)", COLOR => $badcolor};
		  }
	      }
	      my $overall_status = $upstatus{$recent_agent}{STATUS};
	      my $color = $upstatus{$recent_agent}{COLOR};
	      my $upratio = '';
	      if ($nagents > 1) {
		  $upratio = "<br/>(${nup}/${nagents} agents)";
	      }

	      print { $$self{CONTENT} } "<td align='center' bgcolor='$color'>$overall_status $upratio</td>";

	  }
	  print { $$self{CONTENT} } "</tr>\n";
      }
      print { $$self{CONTENT} } "</tbody>\n", "</table>\n";
  }
}

1;

######################################################################
package Web25::Components::Agents;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Processes",
	       LINK_TITLE => "View details about PhEDEx processes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

    my $now = time();

    # Group by host, 
    my $sql = qq[ select s.time_update time_update,
                         n.name node_name, 
                         s.host_name,
                         s.directory_path,
                         a.name agent_name,
                         v.filename,
                         v.release,
                         v.revision,
                         v.tag,
                         s.label agent_label,
                         s.process_id pid,
                         s.worker_id, 
                         s.queue_pending q_pend,
                         s.queue_received q_recv,
                         s.queue_work q_work,
                         s.queue_completed q_comp,
                         s.queue_bad q_bad,
                         s.queue_outgoing q_out,
                         s.state state
 		    from t_agent_status s
                    join (select host_name, agent, label, min(node) node
			         from t_agent_status group by host_name, agent, label) s_sub
                      on s_sub.host_name = s.host_name and s_sub.agent = s.agent 
                     and s_sub.label = s.label and s_sub.node = s.node
		    join t_adm_node n on s.node = n.id
                    join t_agent a on s.agent = a.id
                    left join t_agent_version v on v.agent = a.id and v.node = n.id and v.filename = a.name
		   order by n.name, s.host_name, s.directory_path, s.label, s.worker_id ];
    my $q = &dbexec($$self{DBH}, $sql);

    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{ CONTENT });
    
    $dbtable->set_querycols( [('Age', 'pcolumn', 'TIME_UPDATE', 1)],
			     [('Node', 'pcolumn', 'NODE_NAME', 1)],
			     [('Host', 'pcolumn', 'HOST_NAME', 1)],
			     [('Path', 'pcolumn', 'DIRECTORY_PATH', 1)],
			     [('Agent Name', 'pcolumn', 'AGENT_NAME', 1)],
			     [('File and Version Columns', 'pcolumn', 'FILENAME:RELEASE:REVISION:TAG', 0)],
			     [('Agent Label', 'pcolumn', 'AGENT_LABEL', 1)],
			     [('Process', 'pcolumn', 'PID', 1)],
			     [('Worker', 'pcolumn', 'WORKER_ID', 1)],
			     [('Queue State Columns', 'pcolumn', 'Q_PEND:Q_RECV:Q_WORK:Q_BAD:Q_OUT', 1)] 
			     );
    $dbtable->set_tablehead({
	TIME_UPDATE => 'Age',
	NODE_NAME => 'Node',
	AGENT_NAME => 'Agent Name',
	AGENT_LABEL => 'Agent Label',
	PID => 'Process',
	HOST_NAME => 'Host',
	WORKER_ID => 'Worker',
	Q_PEND => 'Pending',
	Q_RECV => 'Received',
	Q_WORK => 'Work',
	Q_COMP => 'Completed',
	Q_BAD => 'Bad',
	Q_OUT => 'Outgoing',
	FILENAME => 'Filename',
	DIRECTORY_PATH => 'Path',
	RELEASE => 'Version Release',
	REVISION => 'Version Revision',
	TAG => 'Version Tag'
	});

    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');

    $dbtable->set_dataformats({
	TIME_UPDATE => sub { &age($now - $_[0]) }
    });

    my $nullsub = sub { $_[0] ? 'goodbg' : '' };
    $dbtable->set_cellformats({
	TIME_UPDATE => sub { $now - $_[0] <= (1.5)*3600 ? '' : 'alarm' },
	P_ID => sub { $_[1]->{STATE} ? '' : 'alarm' },
	Q_PEND => $nullsub,
	Q_RECV => $nullsub,
	Q_WORK => $nullsub,
	Q_COMP => $nullsub,
	Q_BAD => $nullsub,
	Q_OUT => $nullsub
    });

    my $nrows = $dbtable->output($q);
    if ($nrows == 0) {
	$self->alert("No process data available.");
    }

    #  Options form
    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = $dbtable->columns_form();
    $optspane->add_tab('Columns', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;



######################################################################
package Web25::Components::Links;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Links",
	       LINK_TITLE => "View PhEDEx Topology" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    my $from_filter = param('from_filter') || '.*';
    my $to_filter = param('to_filter') || '.*';
    my $andor = param('andor') || 'and';

    print {$$self{CONTENT}}
    "<form method='get' action='#' class='nice'/>",
    "<label class='inline'>Show links matching from </label>",
    textfield(-name=>'from_filter', -value=>$from_filter, -class=>'labeled'),
    popup_menu(-name=>'andor',
	       -values=>['and', 'or'],
	       -class=>'labeled'),
    "<label class='inline'>to</label>",    
    textfield(-name=>'to_filter', -value=>$to_filter, -class=>'labeled'),
    submit(-name=>'Update', -class=>'labeled'), "<br/>",
    "</form>";

    my @legend = (['Link exists and is valid', 'green'],
		  ['Link exists, but agents are down', 'red'],
		  ['Link exists, but is excluded', 'orange'],
		  ['Link does not exist', 'white'],
		  ['Self-reference', 'black']);
    
    print {$$self{CONTENT}} 
    "<table style='float:left;border: 1px solid black;margin-bottom:3px;'><tr><th colspan='2' align='center'>Legend</th></tr>";
    foreach my $pair (@legend) {
	my ($def, $color) = @{$pair};
	print {$$self{CONTENT}}
	"<tr><td><div style='border:1px solid black;width:40px;background-color:$color;'>&nbsp;</div></td>",
	"<td>$def</td></tr>";
    }
    print {$$self{CONTENT}} "</table>";

    print {$$self{CONTENT}}
    "<p style='float:left;width:35em;margin-left:1em;'>",
    "This page displays links between nodes in PhEDEx.  Valid links ",
    "are required for transfers to be possible.  ",
    "Links are invalid when the source/destination node agents are down or they actively ",
    "exclude the other node with the -ignore/-accept options.  ",
    "<b>Warning:</b> Nodes that have never connected to the database are marked as excluded, which is not correct.",
    "</p><br clear='all'/>";
    $from_filter = qr/$from_filter/;
    $to_filter = qr/$to_filter/;

    my $sql = qq{ select fn.name from_node, tn.name to_node, fn.kind from_kind, tn.kind to_kind,
		         xso.time_update source_update, xso.protocols source_protos,
		         xsi.time_update sink_update,   xsi.protocols sink_protos
		    from t_adm_link l
		    join t_adm_node fn on fn.id = l.from_node
		    join t_adm_node tn on tn.id = l.to_node
		    left join t_xfer_source xso
		      on xso.from_node = fn.id
		     and xso.to_node = tn.id
		    left join t_xfer_sink xsi
		      on xsi.from_node = fn.id
		     and xsi.to_node = tn.id
	       };
    my $now = time();
    my $downtime = 5400 + 15*60;  # Hour and a half (real expiration) + 15 minutes grace time
    my $links = &dbexec($$self{DBH}, $sql)->fetchall_arrayref();
    my %link_params;

    my (%from_nodes, %to_nodes);
    foreach my $link (@{$links}) {
	my ($from, $to, $from_kind, $to_kind, $xso_update, $xso_protos, $xsi_update, $xsi_protos) = @{$link};
	my $key = $from.'-->'.$to;
	$link_params{$key} = { EXISTS => 1,
			       XSI_UPDATE => $xsi_update,
			       XSO_UPDATE => $xso_update,
			       FROM_KIND => $from_kind,
			       TO_KIND => $to_kind,
			       XSO_PROTOS => $xso_protos,
			       XSI_PROTOS => $xsi_protos
			       };

	# Explain why links are valid or invalid.  For now we benefit
	# from the fact the xfer_source/xfer_sink tables are never
	# cleaned up.  Exclusion deletes from xfer_source, and
	# xfer_sink, so if there is an old update we know the agent is
	# down, if there is no entry, we know the node has been
	# excluded.  It would be nice to do a more explicit check for
	# this but for now the logic is ok.
	if ($from_kind eq 'MSS' && $to_kind eq 'Buffer') { # Staging link
	    $link_params{$key}{VALID} = 1;
	    $link_params{$key}{REASON} = 'Staging link OK';
	} elsif ($from_kind eq 'Buffer' && $to_kind eq 'MSS') { # Migration link
	    if (!$xsi_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Migration agent excluded';
	    } elsif ($xsi_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Migration agent down';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    } else {
		$link_params{$key}{VALID} = 1;
		$link_params{$key}{REASON} = 'Migration link OK';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    }
	} else { # WAN link
	    if (!$xso_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Source agent excluded';
	    } elsif ($xso_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Source agent down';
		$link_params{$key}{XSO_AGE} = &age($now - $xso_update);
	    } elsif (!$xsi_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Destination agent excluded';
	    } elsif ($xsi_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Destination agent down';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    } else {
		$link_params{$key}{VALID} = 1;
		$link_params{$key}{REASON} = 'WAN Link OK';
		$link_params{$key}{XSO_AGE} = &age($now - $xso_update);
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    }
	}
	
	# Check protocols
	if ($link_params{$key}{VALID}) {
	    my @from_protos = split(/\s+/, $xso_protos || '');
	    my @to_protos   = split(/\s+/, $xso_protos || '');
	    my $match = 0;
	    foreach my $p (@to_protos) {
		next if ! grep($_ eq $p, @from_protos);
		$match = 1;
		last;
	    }
	    unless ($match) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = "No matching protocol";
	    }
	}

	my $from_match =  ($from =~ /$from_filter/);
	my $to_match = ($to =~ /$to_filter/);
	if (($andor eq 'and' && ($from_match && $to_match)) ||
	    ($andor eq 'or'  && ($from_match || $to_match))) {
	    $from_nodes{$from} = 1;
	    $to_nodes{$to} = 1;
	}
    }
    my @from_nodes = sort keys %from_nodes;
    my @to_nodes = sort keys %to_nodes;

    my $table = new Web25::TableSpool;
    $table->set_filehandle($$self{CONTENT});
    $table->set_tableclass('data dense rspace');
    $table->set_tablecols(['FROM_NODE', @to_nodes]);
    $table->set_tablehead({'FROM_NODE' => 'From Node &darr; To Node &rarr;'});
    $table->set_cellformats({FROM_NODE => sub { 'head' }});
    
    $table->start();
    $table->head();
    
    foreach my $from (@from_nodes) {
	my $row = {};
	foreach my $to (@to_nodes) {
	    $$row{FROM_NODE} = $from;
	    my $key = $from.'-->'.$to;
	    my $link = $link_params{$key};
	    my $color;
	    if ($from eq $to) { 
		$color = 'black';
	    } elsif ($$link{EXISTS} 
		     && $$link{VALID}) {
		$color = 'green';
	    } elsif ($$link{EXCLUDED}) {
		$color = 'orange';
	    } elsif ( $$link{EXISTS} ) {
		$color = 'red';
	    } else {
		$color = 'white';
	    }
	    # Tooltips only for existing links, for performance reasons
	    my $tooltip = $$link{EXISTS} ? $self->get_tooltip($key, $link, $now) : '';
	    my $cell = "<div class='ttp' style='background-color:$color;'>&nbsp;$tooltip</div>"; 
	    $$row{$to} = $cell;
	}
	$table->row($row);
    }
    
    $table->finish();
}

sub get_tooltip
{
    my ($self, $key, $link, $now) = @_;
    $key =~ s/-->/ &rarr; /;
    my $msg = '';
    my $color = $$link{VALID} ? 'green' : 'red';
    if ($$link{EXISTS}) {
	$msg .= "<p>$$link{REASON}</p>";
	$msg .= "<p>Source update:  $$link{XSO_AGE} ago</p>" if $$link{XSO_AGE};
	$msg .= "<p>Destination update:  $$link{XSI_AGE} ago</p>" if $$link{XSI_AGE};
    } else {
	$msg = $$link{COMMENT};
    }
    return "<div class='tt'><p><b>$key</b></p><span style='color:$color;'>$msg</span></div>";
}

1;



######################################################################
package Web25::Activity::Rate;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Rate",
	       LINK_TITLE => "Show recent transfer rates in tabular form" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(span errors tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::TransferRate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  @save = qw(andor tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::TransferDetails");
  @save = qw(tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::ErrorInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my %stats = ();
  my @spans = qw(h 2h d w m);
  my %spans = (h => [ 'Last hour', $now, 3600 ],
	       '2h' => [ 'Last 2 hours', $now, 3600*2 ],
	       d => [ 'Last day', $now, 86400 ],
	       w => [ 'Last 7 days', int($now/86400)*86400, 7*86400 ],
	       m => [ 'Last 30 days', int($now/86400)*86400, 30*86400 ]);
  my $span = param('span') || $spans[0];
  $span = $spans[0] if ! grep($span eq $_, @spans);
  my $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(sum(h.done_files),0) done_files,
      nvl(sum(h.done_bytes),0) done_bytes,
      nvl(sum(h.fail_files),0) fail_files,
      nvl(sum(h.expire_files),0) expire_files
    from t_history_link_events h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    $stats{$span}{N}{$key} = $row;
  }

  $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(avg(h.param_rate),0) param_rate,
      nvl(avg(h.param_latency),0) param_latency
    from t_history_link_stats h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    next if ! exists $stats{$span};
    $stats{$span}{N}{$key}{PARAM_RATE} = $$row{PARAM_RATE};
    $stats{$span}{N}{$key}{PARAM_LATENCY} = $$row{PARAM_LATENCY};
  }

  $stats{$span}{T}{1} = { DONE_FILES => 0, DONE_BYTES => 0, FAIL_FILES => 0, EXPIRE_FILES => 0 };
  my $errors = param('errors') ? "checked='checked'" : "";
  my $tofilter = param('tofilter') || "";
  my $fromfilter = param('fromfilter') || "";
  my $andor = param('andor') || 'or';
  print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<label for='span'>Time span</label>\n",
    "<select name='span' onchange='submit()'>",
    (map { (" <option", ($span eq $_ ? " selected='selected'" : ""),
	    "  value='$_'>$spans{$_}[0]</option>") } @spans),
    "</select>\n",
    "&nbsp;<input type='checkbox' name='errors' $errors>\n",
    "<label for='errors'>Include links with nothing but errors</label> ",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'><tbody>\n",

    "<tr class='selected'>\n",
    " <th colspan='10'>",
    "Last @{[&format_timespan($spans{$span}[2])]}",
    "</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>To</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From</th>\n",
    " <th rowspan='2'>Files</th>\n",
    " <th rowspan='2'>Total Size</th>\n",
    " <th rowspan='2'>Rate</th>\n",
    " <th rowspan='2'>Errors</th>\n",
    " <th rowspan='2'>Expired</th>\n",
    " <th rowspan='2'>Avg. Est. Rate</th>\n",
    " <th rowspan='2'>Avg. Est. Latency</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "<th>",
    "<select name='andor' onchange='submit()'>",
    " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
    "  value='and'>and</option>",
    " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
    "  value='or'>or</option>",
    "</select>",
    "</th>",
    " <th>",
    textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
		       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "</tr>\n";

  foreach my $kind (qw(N T))
  {
    foreach my $row (sort { $$b{DONE_BYTES} <=> $$a{DONE_BYTES}
			    || $$b{FAIL_FILES} <=> $$a{FAIL_FILES}
			    || $$b{EXPIRE_FILES} <=> $$a{EXPIRE_FILES}
			    || $$a{TO_NODE} cmp $$b{TO_NODE}
			    || $$a{FROM_NODE} cmp $$b{FROM_NODE} }
		     values %{$stats{$span}{$kind}})
    {
      next if ($kind eq 'N'
	       && ($fromfilter || $tofilter)
	       && ($andor eq 'or'
		   ? ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			|| ($tofilter && $$row{TO_NODE} =~ /$tofilter/))
		   : ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			&& ($tofilter && $$row{TO_NODE} =~ /$tofilter/))));
      next if $kind eq 'N' && ! $errors && ! $$row{DONE_FILES};
      next if $kind eq 'N' && ! $$row{DONE_FILES} && ! $$row{FAIL_FILES} && ! $$row{EXPIRE_FILES};
      my $bps = $$row{DONE_BYTES} / $spans{$span}[2];

      my $errorcolumn = &format_num($$row{FAIL_FILES});
      if ($$row{FAIL_FILES} && $$row{FROM_NODE} && $$row{TO_NODE}) {
	  my $errorurl = $self->myurl(page => 'Activity::ErrorInfo',
				      fromfilter => $$row{FROM_NODE},
				      tofilter => $$row{TO_NODE});
	  $errorcolumn = "<a href='$errorurl'>$errorcolumn</a>";
      }

      print { $$self{CONTENT} }
	"<tr>",
	($$row{FROM_NODE}
	 ? "<td>$$row{TO_NODE}</td><td>&nbsp;</td><td>$$row{FROM_NODE}</td>"
	 : "<td colspan='3'>Total</td>"),
	"<td align='right'>@{[&format_num($$row{DONE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{DONE_BYTES})]}</td>",
	"<td align='right'>", ($bps >= 0 ? &format_size($bps) . '/s' : &format_num(0)), "</td>",
	"<td align='right'>$errorcolumn</a></td>",
	"<td align='right'>@{[&format_num($$row{EXPIRE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{PARAM_RATE} || 0)]}/s</td>",
	"<td align='right'>@{[&age($$row{PARAM_LATENCY} || 0)]}</td>",
	"</tr>\n";

      if ($kind eq 'N')
      {
	$stats{$span}{T}{1}{DONE_FILES} += $$row{DONE_FILES};
	$stats{$span}{T}{1}{DONE_BYTES} += $$row{DONE_BYTES};
	$stats{$span}{T}{1}{FAIL_FILES} += $$row{FAIL_FILES};
	$stats{$span}{T}{1}{EXPIRE_FILES} += $$row{EXPIRE_FILES};
      }
    }
  }
  print { $$self{CONTENT} } "</tbody></table></p></form>\n";
}

1;

######################################################################
package Web25::Activity::PlotPage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use File::Temp ':mktemp';

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  $$self{PERIOD_ORDER} = [ qw(l24h l48h l72h l96h l132h l7d l14d l30d l45d l90d l120d
			    l6w l26w l52w ad aw am) ];
  $$self{PERIODS} = { "l24h" => [ "24:hour", "Last 24 Hours" ],
		    "l48h" => [ "48:hour", "Last 48 Hours" ],
	            "l72h" => [ "72:hour", "Last 72 Hours" ],
	            "l96h" => [ "96:hour", "Last 96 Hours" ],
	            "l132h" => [ "132:hour", "Last 132 Hours" ],
	            "l7d" => [ "7:day", "Last 7 Days" ],
	            "l14d" => [ "14:day", "Last 14 Days" ],
	            "l30d" => [ "30:day", "Last 30 Days" ],
	            "l45d" => [ "45:day", "Last 45 Days" ],
	            "l90d" => [ "90:day", "Last 90 Days" ],
	            "l120d" => [ "120:day", "Last 120 Days" ],
	            "l6w" => [ "6:week", "Last 6 Weeks" ],
	            "l26w" => [ "26:week", "Last 26 Weeks" ],
	            "l52w" => [ "52:week", "Last 52 Weeks" ],
	            "ad" => [ "0:day", "Daily Since Start" ],
	            "aw" => [ "0:week", "Weekly Since Start" ],
	            "am" => [ "0:month", "Monthly Since Start" ] };
  $$self{DEFAULT_PERIOD} = 'l96h';
  $$self{DEFAULT_GRAPH} = undef;
  $$self{GRAPH_ORDER} = [];
  $$self{GRAPHS} = {};
  $$self{ENTITY_ORDER} = [qw(dest src link)];
  $$self{ENTITIES} = {dest => 'Destination', src => 'Source', link => 'Link'};
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(period graph entity src_filter dest_filter no_mss upto);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Activity::RatePlots"
        && $args{"page"} ne "Activity::QueuePlots"
        && $args{"page"} ne "Activity::QualityPlots");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  $$self{PLOT_SCRIPT} = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/phedex-cgi.sh";

  my $page = param("page");
  my $period = param("period");
  my $graph = param("graph");
  my $entity = param("entity");
  my $src_filter = param("src_filter") || '';
  my $dest_filter = param("dest_filter") || '';
  my $no_mss = param("no_mss");
  if (!defined $no_mss) { $no_mss = 'true'; } # Filter MSS by default
  my $upto = param("upto") || '';
  $period = $$self{DEFAULT_PERIOD} if (! $period || ! exists $$self{PERIODS}{$period});
  $graph = $$self{DEFAULT_GRAPH} if (! $graph || ! exists $$self{GRAPHS}{$graph});
  $entity = 'dest' if (! $entity || ! grep($_ eq $entity, @{$$self{ENTITY_ORDER}} ));
  

  my $dest_filter_name = 'destination';
  if (exists $$self{DEST_ONLY_GRAPHS}
      && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      $$self{ENTITY_ORDER} = ['dest'];
      $$self{ENTITIES} = { dest => 'Node' };
      $dest_filter_name = 'node';
  }

  my $formurl = $self->myurl();

  print { $$self{CONTENT} } 
  "<form method='get' action='$formurl' class='nice'>\n",
  "<label for='graph' class='inline'>Graph</label>\n",
  popup_menu(-name=>'graph', -onchange=>'submit()',
	     -values=>$$self{GRAPH_ORDER},
	     -labels=>$$self{GRAPHS},
	     -class=>'labeled'),
  "<label for='entity' class='inline'>by</label> ",
  popup_menu(-name=>'entity', -onchange=>'submit()', 
	     -values=>$$self{ENTITY_ORDER},
	     -labels=>$$self{ENTITIES},
	     -class=>'labeled'),
  "<label class='inline'>filter</label>";

  unless (exists $$self{DEST_ONLY_GRAPHS} && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      print { $$self{CONTENT} }
      "<label class='inline' for='src_filter'>source</label>",
      textfield(-name=>'src_filter', -size=>15,
		-title=>("Regular expression to match against node names. "
			 ."Only those matching the expression will be shown."),
		-class=>'labeled');
  } else { print {$$self{CONTENT}} hidden('src_filter'); }

  print { $$self{CONTENT} }
  "<label class='inline' for='dest_filter'>$dest_filter_name</label>",
  textfield(-name=>'dest_filter', -size=>15,
	    -title=>("Regular expression to match against node names. "
		     ."Only those matching the expression will be shown."),
	    -class=>'labeled'),
  popup_menu(-name=>'no_mss', -values=>['true', 'false'], -labels=>{'true' => 'hide MSS nodes', 'false' => 'show MSS nodes'},
	     -default=>$no_mss, -onchange=>'submit()', -class=>'labeled'),
  "<br/>";
  
  print { $$self{CONTENT} }
  "<label for='period' class='inline'>Period</label>\n",
  popup_menu(-name=>'period', -onchange=>'submit()',
	     -values=>$$self{PERIOD_ORDER},
	     -labels=>{ map { $_ => $$self{PERIODS}{$_}[1] } @{$$self{PERIOD_ORDER}} },
	     -default=>$period,
	     -class=>'labeled'),
  "<label for='upto' class='inline'>up to</label>",
  textfield(-name=>'upto', -size=>15,
	    -title=>("Time up to and including which results will be shown. "
		     ."Specify the time in format matching the selected period:\n"
		     ."YYYYMMDDZHHMM for hourly periods;\n"
		     ."YYYYMMDD for daily periods;\n"
		     ."YYYYMM for monthly periods;\n"
		     ."YYYYWW for weekly periods."),
	    -class=>'labeled'),
		     submit(-label=>'Update', -class=>'labeled'), "<br/>",
		     "</form>";

  my ($last, $unit) = $$self{PERIODS}{$period}[0] =~ /([^:]+)/g;
  my %span = ("hour" => 3600, "day" => 86400, "week" => 7*86400, "month" => 86400);
  my %round = (%span, 'week' => 86400);
  my $now = time();
  my $end = (int($now/$round{$unit})+1)*$round{$unit};
  if ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)Z(\d\d)\d\d$/)
  {
    $end = timegm(0, 0, $4, $3, $2-1, $1-1900) + 3600;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, $3, $2-1, $1-1900) + 86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/ && $unit eq 'week')
  {
    # January 4th is always in (ISO) week one, so find out what
    # day of week that is, then go back to Monday of that week,
    # and advance specified number of weeks plus one.
    my $jan4 = timegm(0, 0, 0, 4, 0, $1-1900);
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($jan4);
    $end = $jan4 + (-$diff{$wday} + 7*$2)*86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, 1, $2, $1-1900);
  }

  my $start = ($last ? $end - $last*$span{$unit} : 0);
  # The new plot package really does set range to time 0.
  # Need to provide a more reasonable range.  PhEDEx started taking data in Sep 2004.
  $start = timegm(0, 0, 0, 1, 9, 2004-1900) if $start == 0;  

  my $conn = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{CONNECTION};

  my %args = ('conn' => $conn, 'unit' => $unit, 'span' => $span{$unit}, 'by' => $entity, 'last' => $last,
              'src_filter' => $src_filter, 'dest_filter' => $dest_filter, 'no_mss' => $no_mss,
	      'upto' => $upto, 'starttime' => $start, 'endtime' => $end);
  
  my $imgsrc = $self->imgsrc($graph, %args);
  print {$$self{CONTENT}} "<p><img src='$imgsrc' /></p>";

#   &dump_var($$self{CONTENT}, 'tns_admin', $ENV{TNS_ADMIN});
#   print {$$self{CONTENT}} "<pre>";
#   print {$$self{CONTENT}}<<STOP;
#       no_mss:  $no_mss
#  dest_filter:  $dest_filter
#   src_filter:  $src_filter
#      formurl:  $formurl
#       imgsrc:  $imgsrc
# STOP
# print {$$self{CONTENT}} "</pre>";
#   &dump_var($$self{CONTENT}, 'args', {%args});
#   &dump_params($$self{CONTENT});

}

1;

######################################################################
package Web25::Activity::RatePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Rate Plots",
	       LINK_TITLE => "Show recent transfer rate as plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'quantity_rates';
  $$self{GRAPH_ORDER} = [ 'quantity_rates', 'quantity', 'quantity_cumulative' ];
  $$self{GRAPHS} = { 'quantity_rates' => "Transfer Rate", 
		     'quantity' => "Transfer Volume", 
		     'quantity_cumulative' => "Cumulative Rate" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('graph' => $graph,
		   'from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{PLOT_SCRIPT}.'?'. &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::QueuePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Queue Plots",
	       LINK_TITLE => "Show pending transfer queue plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'destined';
  $$self{GRAPH_ORDER} = [ 'destined', 'resident', 'pending', 'request', 'idle', 'cooloff' ];
  $$self{GRAPHS} = { 'destined' => "Volume Routed",    # by dest only
		     'resident' => "Volume Resident",     # by dest only
		     'pending'  => "Volume Queued", # any
		     'request'  => "Volume Requested",    # by dest only
		     'idle'     => "Volume Idle",  # by dest only
		     'cooloff'  => 'Volume Cool-off' };   # any

  $$self{DEST_ONLY_GRAPHS} = [ qw( destined resident request idle ) ];

  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('graph' => $graph,
		   'from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $dest_only = (grep($graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) ? 1 : 0);
  if ($dest_only && $args{by} ne 'dest') {
      $self->alert("The \"$$self{GRAPHS}{$graph}\" graph can only show data by destination");
      return;
  } elsif ($dest_only) {
      $graphargs{node} = $to_node;
      delete $graphargs{from_node};
      delete $graphargs{to_node};
  }

  my $imgsrc = $$self{PLOT_SCRIPT}.'?'. &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::QualityPlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Quality Plots",
	       LINK_TITLE => "Show transfer quality plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = [ 'quality_all' ];
  $$self{GRAPH_ORDER} = [ 'quality_all', 'quality_try', 'quality_done', 'quality_fail' ];
  $$self{GRAPHS} = { 'quality_all' => "Quality Map",
		     'quality_try' => "Attempts",
		     'quality_done' => "Successes",
		     'quality_fail' => "Failures" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('graph' => $graph,
		   'to_node' => $to_node,
		   'from_node' => $from_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{PLOT_SCRIPT}.'?'. &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::Routing;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Routing",
	       LINK_TITLE => "Show current routing information" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $tofilter = param('tofilter') || ".*";
  my $fromfilter = param('fromfilter') || ".*";
  my $priority = param('priority') || 'any';
  my $blockfilter = param('blockfilter') || '.*';
  my $showinvalid = param('showinvalid') || 0;

  my $now = time();
  my @nodes = sort $self->fetch_nodes();

  print {$$self{CONTENT}}
  "<form class='nice' method='get' action='#'>",
  "<label>Show paths on links to </label>",
  textfield(-name=>'tofilter', -default=>$tofilter, -size=>15, -class=>'labeled'),
  "<label class='inline'>and from </label>",
  textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15, -class=>'labeled'),
  "<label class='inline'> with  </label>",
  popup_menu(-name=>'priority', -values=>['any', 'high', 'normal', 'low'],
	     -default=>$priority, -onchange=>'submit()', -class=>'labeled'),
  "<label class='inline'> priority  </label>",
  checkbox(-name=>'showinvalid', -checked=>$showinvalid, -label=>'Show Invalid Paths', -class=>'labeled'),
  "<br/><label>Filter blocks </label>",
  textfield(-name=>'blockfilter', -default=>$blockfilter, -size=>15, -class=>'labeled'),
  " ", submit(-name=>'Update'),
  "</form><br clear='all'>";

  my $query = qq{
      select nd.name destination, ns.name source, b.name block,
             s.priority, s.is_valid, s.route_files, s.route_bytes, s.xfer_attempts, s.time_request
       from t_status_block_path s
       join t_adm_node nd on nd.id = s.destination
       join t_adm_node ns on ns.id = s.src_node
       join t_dps_block b on b.id = s.block
       order by s.time_request
  };

  my $q = &dbexec($$self{DBH}, $query);

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  my @cols = qw(DESTINATION SOURCE BLOCK PRIORITY ROUTE_FILES ROUTE_BYTES
		XFER_ATTEMPTS AVG_ATTEMPTS TIME_REQUEST);
  unshift(@cols, 'IS_VALID') if $showinvalid;

  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead({
      DESTINATION => 'Destination',
      SOURCE => 'Source',
      BLOCK => 'Block Name',
      PRIORITY => 'Priority',
      IS_VALID => 'Valid?',
      ROUTE_FILES => 'Routed<br/>Files',
      ROUTE_BYTES => 'Routed<br/>Bytes',
      XFER_ATTEMPTS => 'Transfer<br/>Attempts',
      AVG_ATTEMPTS => 'Average<br/>Attempts',
      TIME_REQUEST => 'Earliest<br/>Request'
      });

  $dbtable->set_dataformats({
       'PRIORITY' => sub { my $name;
 			  if    ($_[0] == 0) {$name = 'high'}
 			  elsif ($_[0] == 1) {$name = 'normal'}
 			  else               {$name = 'low' }
 			  return $name; },
      'IS_VALID' => sub { $_[0] ? 'valid' : 'invalid' },
      'ROUTE_BYTES' => sub { &format_size($_[0]) },
      'TIME_REQUEST' => sub { &age($now - $_[0])." ago" },
      'AVG_ATTEMPTS' => sub { sprintf("%.2f", $_[0]) }
  });

  $dbtable->add_pseudocolumn('AVG_ATTEMPTS', sub { return $_[1]->{ROUTE_FILES} ? 
						       $_[1]->{XFER_ATTEMPTS} / $_[1]->{ROUTE_FILES}
						   : 'N/A' });

  $dbtable->set_filters({
      'DESTINATION' => sub { $_[0] =~ /$tofilter/ ? 1 : 0 },
      'SOURCE' => sub { $_[0] =~ /$fromfilter/ ? 1 : 0 },
      'BLOCK' => sub { $_[0] =~ /$blockfilter/ ? 1 : 0 },
      'IS_VALID' => sub { $showinvalid || $_[0] == 1 ? 1 : 0 },
      'PRIORITY' => sub { ($priority eq 'any'
			   || ($priority eq 'high'   && $_[0] == 0)
			   || ($priority eq 'normal' && $_[0] == 1)
			   || ($priority eq 'low'    && $_[0] >= 2)) ? 1 : 0 }
  });

  $dbtable->set_cellformats({
      'AVG_ATTEMPTS' => sub { $_[0] >= 3 ? 'alarm' : '' },
      'TIME_REQUEST' => sub { ($now - $_[0]) > 3600*24*3 ? 'alarm' : '' },
      'IS_VALID' => sub { $showinvalid && $_[0] == 0 ? 'alarm' : '' }
  });

  $dbtable->set_statcols({
      'ROUTE_FILES' => 'SUM',
      'ROUTE_BYTES' => 'SUM'
      });

  my $nrows = $dbtable->output($q);

  if ($nrows == 0) {
      $self->note("No results available.");
  }
}

1;

######################################################################
package Web25::Activity::TransferDetails;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Transfer Details",
	       LINK_TITLE => "Browse transfer state details" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
    my ($self) = @_;

    # Transfer state details
    my $rows = 0;
    my $now = time();
    my %total = ();
    my $tofilter = param('tofilter') || "";
    my $fromfilter = param('fromfilter') || "";
    my $andor = param('andor') || 'or';
    my $query = &dbexec($$self{DBH}, qq{
    select
      time_update,
      nd.name, ns.name,
      state, priority,
      files, bytes
    from t_status_task xs
      join t_adm_node ns on ns.id = xs.from_node
      join t_adm_node nd on nd.id = xs.to_node
    order by nd.name, ns.name, state});

    print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='10' align='center'>Transfer State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th rowspan='2'>Age</th>\n",
    " <th>To Node</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From Node</th>\n",
    " <th rowspan='2'>State</th>\n",
    " <th rowspan='2'>Transfer</th>\n",
    " <th rowspan='2'>Priority</th>\n",
    " <th rowspan='2'>N Files</th>\n",
    " <th rowspan='2'>Size</th>\n",
    " <th rowspan='2'>Detail</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th>\n",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")
	      ),
     "</th>",
     "<th>",
     "<select name='andor' onchange='submit()'>",
     " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
     "  value='and'>and</option>",
     " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
     "  value='or'>or</option>",
     "</select>",
     "</th>",
     "<th>",
     textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	       -title=>("Regular expression to match against node or link names. "
			."Only those matching the expression will be shown.")),
     "</th>",
     "</tr>\n";
    
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($stamp,
	    $to_node, $from_node,
	    $state, $priority,
	    $files, $bytes) = @$row;

	next if (($fromfilter || $tofilter)
		 && ($andor eq 'or'
		     ? ! (($fromfilter && $from_node =~ /$fromfilter/)
			  || ($tofilter && $to_node =~ /$tofilter/))
		     : ! (($fromfilter && $from_node =~ /$fromfilter/)
			  && ($tofilter && $to_node =~ /$tofilter/))));
	$total{$state} ||= { FILES => 0, BYTES => 0 };
	$total{$state}{FILES} += $files;
	$total{$state}{BYTES} += $bytes;
	my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
	my $transfer_name = ($priority % 2 == 0 ? 'local' : 'remote'); # Local even, remote odd
	my $priority_name = ($priority == 0 || $priority == 1 ? 'high'
			     : $priority == 2 || $priority == 3 ? 'normal'
			     : $priority == 4 || $priority == 5 ? 'low'
			     : 'unknown');
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	my $url = $self->myurl("page" => "Activity::FileInfo",
			       "to_node" => $to_node,
			       "from_node" => $from_node,
			       "state" => $state_name,
			       "priority" => $priority
			       );
	print { $$self{CONTENT} }
	"<tr>\n",
	" <td$stampcolor>", ($now - $stamp < 5*60 ? 'current' : &age($now - $stamp)), "</td>\n",
	" <td>$to_node</td>\n",
	" <td align='right'>&nbsp;</td>\n",
	" <td>$from_node</td>\n",
	" <td align='left'>$state_name</td>\n",
	" <td align='left'>$transfer_name</td>\n",
	" <td align='left'>$priority_name</td>\n",
	" <td align='right'>@{[&format_num($files)]}</td>\n",
	" <td align='right'>@{[&format_size($bytes)]}</td>\n",
	" <td align='center'><a href='$url'>(Files)</a></td>\n",
	"</tr>\n";
    }
    
    my $first_total = 1;
    my ($tfiles, $tbytes) = (0, 0);
    foreach my $state (sort keys %total)
    {
	$tfiles += $total{$state}{FILES};
	$tbytes += $total{$state}{BYTES};
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	
	print { $$self{CONTENT} }
        "<tr>\n",
        " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
        " <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>$state_name</td>\n",
	" <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
	" <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
	" <th align='right'>&nbsp;</th>\n",
	"</tr>\n";
	$first_total = 0;
    }

    print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    " <th align='right'>&nbsp;</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n";

    # Destined
    $rows = 0;
    $query = &dbexec($$self{DBH}, qq{
    select
      n.name, max(br.time_update),
      sum(br.dest_files), sum(br.dest_bytes),
      sum(br.node_files), sum(br.node_bytes),
      sum(br.xfer_files), sum(br.xfer_bytes)
     from t_dps_block_replica br join t_adm_node n on n.id = br.node
     group by n.name order by n.name});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    "<th align='center' colspan='8'>Destined Data</th>\n",
    "</tr>",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Last<br>Change</th>\n",
    " <th rowspan='2'>Node</th>\n",
    " <th colspan='2'>Destined</th>\n",
    " <th colspan='2'>On Site</th>\n",
    " <th colspan='2'>In Transfer</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    "</tr>\n";

 my ($tdest_files, $tdest_size,
     $tnode_files, $tnode_size,
     $txfer_files, $txfer_size) = (0) x 6;

  while (my $row = $query->fetchrow_arrayref)
  {
    my ($n, $stamp,
	$dest_files, $dest_size,
	$node_files, $node_size,
	$xfer_files, $xfer_size) = @$row;

    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $n =~ /$fromfilter/)
		   || ($tofilter && $n =~ /$tofilter/)));

    $tdest_files += $dest_files; $tdest_size += $dest_size;
    $tnode_files += $node_files; $tnode_size += $node_size;
    $txfer_files += $xfer_files; $txfer_size += $xfer_size;

    my $node_color = (($dest_files && $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : $xfer_files ? " bgcolor='$pendcolor'" : "");
    my $xfer_color = (($xfer_files) ? " bgcolor='$goodcolor'"
		      : ($xfer_files + $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : "");

    print { $$self{CONTENT} }
      "<tr>\n",
      " <td>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$n</td>\n",
      " <td align='right'>@{[&format_num($dest_files)]}</td>\n",
      " <td align='right'>@{[&format_size($dest_size)]}</td>\n",
      " <td align='right'$node_color>@{[&format_num($node_files)]}</td>\n",
      " <td align='right'$node_color>@{[&format_size($node_size)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_num($xfer_files)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_size($xfer_size)]}</td>\n",
      "</tr>\n";
  }
  my $node_color = (($tdest_files && $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : ($txfer_files) ? " bgcolor='$pendcolor'" : "");
  my $xfer_color = (($txfer_files) ? " bgcolor='$goodcolor'"
		    : ($txfer_files + $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : "");

  print { $$self{CONTENT} }
    "<tr>\n",
    " <th>&nbsp;</th>\n",
    " <th align='left'>Total</th>\n",
    " <th align='right'>@{[&format_num($tdest_files)]}</th>\n",
    " <th align='right'>@{[&format_size($tdest_size)]}</th>\n",
    " <th align='right'$node_color>@{[&format_num($tnode_files)]}</th>\n",
    " <th align='right'$node_color>@{[&format_size($tnode_size)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_num($txfer_files)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_size($txfer_size)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n";


    # Replicas
  $query = &dbexec($$self{DBH}, qq{
    select xr.time_update, n.name, xr.state, xr.files, xr.bytes
    from t_status_replica xr join t_adm_node n on n.id = xr.node
    order by n.name, state});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='5' align='center'>Replica State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Age</th>",
    " <th rowspan='2'>Node</th>",
    " <th rowspan='2'>State</th>",
    " <th colspan='2'>Files</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>N</th>\n",
    " <th>Size</th>\n",
    "</tr>\n";

  %total = ();
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($stamp, $node, $state, $files, $bytes) = @$row;
    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $node =~ /$fromfilter/)
		   || ($tofilter && $node =~ /$tofilter/)));
    $total{$state} ||= { FILES => 0, BYTES => 0 };
    $total{$state}{FILES} += $files;
    $total{$state}{BYTES} += $bytes;
    my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    my $color = (($state == 1) ? " bgcolor='$goodcolor'" : "");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$node</td>\n",
      " <td$color align='right'>$state_name</td>\n",
      " <td$color align='right'>@{[&format_num($files)]}</td>\n",
      " <td$color align='right'>@{[&format_size($bytes)]}</td>\n",
      "</tr>\n";
  }

  $first_total = 1;
  ($tfiles, $tbytes) = (0, 0);
  foreach my $state (sort keys %total)
  {
    $tfiles += $total{$state}{FILES};
    $tbytes += $total{$state}{BYTES};
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
      " <th align='right'>$state_name</td>\n",
      " <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
      " <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
      "</tr>\n";
    $first_total = 0;
  }
  print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n",
    "</form>\n";
}

1;

######################################################################
package Web25::Activity::FileInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "File Info" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(to_node from_node state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::FileInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $to_node = param('to_node');
  my $from_node = param('from_node');
  my $state = param('state');
  my $priority = param('priority');
  if (! defined $to_node || $to_node eq ''
      || ! defined $from_node || $from_node eq ''
      || ! defined $state || $state eq ''
      || ! defined $priority || $priority eq ''
      )
  {
    print { $$self{CONTENT} }
    $self->alert('Missing Arguments');
    return;
  }

  my $state_join = '';
  my $state_where = '';
  if    ($state eq 'exported')     { 
      $state_join = 'join t_xfer_task_export ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_inxfer )';
  } elsif ($state eq 'transferring') { 
      $state_join = 'join t_xfer_task_inxfer ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_done )';
  } elsif ($state eq 'transferred')  { 
      $state_join = 'join t_xfer_task_done ts on ts.task = xt.id'; }
  elsif ($state eq 'assigned') {
      $state_where = 'and xt.id not in ( select task from t_xfer_task_export )';
  } else {
      $self->alert('Invalid state');
  }
     
  my $sql = qq{
    select f.id, f.logical_name, f.filesize, xt.from_pfn, xt.to_pfn,
	   xt.time_assign, err.cnt num_errors
      from t_xfer_task xt
      $state_join
      join t_xfer_file f on f.id = xt.fileid
      join t_adm_node ns on ns.id = xt.from_node
      join t_adm_node nd on nd.id = xt.to_node
      left join (select xe.fileid, xe.from_node, xe.to_node, count(*) cnt 
                   from t_xfer_error xe
                  group by xe.fileid, xe.from_node, xe.to_node
                 ) err 
           on     err.fileid = xt.fileid 
              and err.from_node= xt.from_node 
              and err.to_node = xt.to_node
    where ns.name = :from_node
      and nd.name = :to_node
      and xt.priority = :priority
      $state_where
      order by xt.time_assign, f.logical_name};

  my $query = &dbexec($$self{DBH}, $sql, 
		      ':from_node' => $from_node,
		      ':to_node' => $to_node,
		      ':priority' => $priority);
  print { $$self{CONTENT} }
    "<h1>Files $state from $from_node to $to_node.</h1>\n",
    "<ol align='left'>\n";
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($fileid, $lfn, $size, $from_pfn, $to_pfn, $assigned, $nerrors) = @$row;
    my $errorurl = $self->myurl('page' => 'Activity::ErrorInfo',
				'tofilter' => $to_node,
				'fromfilter' => $from_node,
				'fileid' => $fileid);
    print { $$self{CONTENT} }
    "<li><b>lfn</b>=@{[&escapeHTML($lfn)]}<br />",
    "<b>size</b>=$size<br />",
    ($from_pfn ? "<b>from_pfn</b>=@{[&escapeHTML($from_pfn)]}<br />" : ""),
    ($to_pfn ? "<b>to_pfn</b>=@{[&escapeHTML($to_pfn)]}<br />" : ""),
    ($nerrors ? "<span class='alarm'><b>errors</b>=$nerrors</span> <a href='$errorurl'>(View)</a><br />"  : ""),
    ($assigned ? "<b>time_assign</b>=@{[strftime('%Y-%m-%d %H:%M:%S', gmtime($assigned))]} UTC<br />" : ""),
    "<br /></li>\n";
  }
  print { $$self{CONTENT} } "</ol></p>\n";
}

1;



######################################################################
package Web25::Activity::ErrorInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 7, TITLE => "Recent Errors" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor
		report_code xfer_code from_pfn to_pfn log_detail log_validate);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}



sub output
{
    my ($self) = @_;

    my $fileid = param('fileid');
    my $tofilter = param('tofilter') || '.*';
    my $fromfilter = param('fromfilter') || '.*';

    my @filter_list = qw(report_code xfer_code from_pfn to_pfn log_detail log_validate);
    my $error_filters = {};
    foreach (@filter_list) {
	$$error_filters{$_} = param($_) || '.*';
    }

    my @nodes = sort $self->fetch_nodes();

    my @where;
    my %binds;
    if ($fileid) {
	push @where, qq[xe.fileid = :fileid];
	$binds{':fileid'} = $fileid;
    } else {
	print {$$self{CONTENT}}
	&help("Filtering Help", "Filtering Help", 
	      "The <b>to</b> and <b>from</b> node filters are perl regular expressions.  ",
	      "The rest of the filters are Oracle regular expressions (regexp_like function) ",
	      "with one special option: You may put '!' as the first ",
	      "character in the field to only return results which do ",
	      "NOT match the given regular expession.  For performance ",
	      "reasons, you must filter one of <b>to</b> or <b>from</b> ",
	      "if you wish to filter on any of the other fields.   Log</b> cannot be ",
	      "filtered."),
   	"<form method='get' action='#' class='nice'/>",
	"<label>Show errors on links to </label>",
	textfield(-name=>'tofilter', -value=>$tofilter, -class=>'labeled'),
	"<label>from</label>",
	textfield(-name=>'fromfilter', -value=>$fromfilter, -class=>'labeled'), "<br/>",
	"<label>Report Code:</label>",
	textfield(-name=>'report_code', -value=>$$error_filters{report_code}, -class=>'labeled'),
	"<label>Transfer Code:</label>",
	textfield(-name=>'xfer_code', -value=>$$error_filters{xfer_code}, -class=>'labeled'), "<br/>",
	"<label>To PFN:</label>",
	textfield(-name=>'to_pfn', -value=>$$error_filters{to_pfn}, -class=>'labeled'),
	"<label>From PFN:</label>",
	textfield(-name=>'from_pfn', -value=>$$error_filters{from_pfn}, -class=>'labeled'), "<br/>",
	"<label>Detail Log:</label>",
	textfield(-name=>'log_detail', -value=>$$error_filters{log_detail}, -class=>'labeled'),
	"<label>Validate Log:</label>",
	textfield(-name=>'log_validate', -value=>$$error_filters{log_validate}, -class=>'labeled'), "<br/>",
	"<label>&nbsp;</label>", submit(-name=>'Update', -class=>'labeled'), "<br/>",
	"</form>";
    }

    my @from = grep /$fromfilter/, @nodes;
    if (scalar @from != scalar @nodes) {
	my ($from_list, %from_binds) = &dbinlist('from', @from);
	push @where, "ns.name in ($from_list)";
	$binds{$_} = $from_binds{$_} foreach (keys %from_binds);
    }
    my @to = grep /$tofilter/, @nodes;
    if (scalar @to != scalar @nodes) {
	my ($to_list, %to_binds) = &dbinlist('to', @to);
	push @where, "nd.name in ($to_list)";
	$binds{$_} = $to_binds{$_} foreach (keys %to_binds);
    }

    foreach my $col (keys %{$error_filters}) {
	my $f = $$error_filters{$col};
	my $not = substr($f, 0, 1) eq '!' ? 'not ' : '';
	$f = substr($f, 1) if $not;
	next if !defined $f || $f eq '' || $f eq '.*';
	my $bind_label = ":${col}_rxp";
	push @where, "${not}regexp_like($col, $bind_label)";
	$binds{$bind_label} = $f;
    }

    my $where = @where ? " where ".join(' and ', @where) : '';

    # Make sure the nodes are filtered if we are filtering with regexp_like
    # TODO:  Remove these restrictions with error pre-processing
    if ($where =~ /regexp_like/ &&
	($where !~ /nd.name|ns.name/ ||
	 $where =~ /ns.name in/ && scalar @from > 5 ||
	 $where =~ /nd.name in/ && scalar @to > 5)) {
	$self->alert("You must reduce the number of links you search  if you wish to use the other ",
		     "filters.  Filter also on link <b>to</b> or <b>from</b>.");
	return;
    }

    my $sql = qq{ select ns.name from_node, nd.name to_node,
		         time_assign, time_expire, time_export, time_inxfer, time_xfer, time_done,
		         report_code, xfer_code, from_pfn, to_pfn,
		         log_xfer, log_detail, log_validate
		    from t_xfer_error xe
                    join t_adm_node nd on nd.id = xe.to_node
		    join t_adm_node ns on ns.id = xe.from_node
                  $where
		order by time_done desc
	    };

    my $max_log_length = 100_000;
    $$self{DBH}->{LongReadLen} = $max_log_length;
    $$self{DBH}->{LongTruncOk} = 1;

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, {%binds}, 10);
    my $n_errors = $pager->get_total_results();

    if ($fileid) {
	my $alllink = $self->myurl('fromfilter' => $fromfilter, 'tofilter' => $tofilter);
	print {$$self{CONTENT}}
	"<p><a href='$alllink'>Show all errors for this link</a></p>";
    } else {
	print {$$self{CONTENT}} 
	"<h1>$n_errors recent errors on links to ", &escapeHTML($tofilter), 
	" from ", &escapeHTML($fromfilter), "</h1>";
    }

    if ($n_errors >= 100) {
	print {$$self{CONTENT}} 
	"<p>Please note that PhEDEx only stores the last 100 link errors to the database ",
	"for a limited period of time. More errors may have occurred that are not visible here.</p>"
    }

    print {$$self{CONTENT}} $pager->pager();

    my $q = $pager->paged_result();

    my $time_labels = { TIME_ASSIGN => "Time Assigned",
			TIME_EXPORT => "Time Exported",
			TIME_INXFER => "Time Pumped",
			TIME_XFER   => "Time Transfer Start",
			TIME_DONE   => "Time Transfer Done",
			TIME_EXPIRE => "Time Transfer Expires" };

    my $log_labels = { LOG_XFER => "Transfer Log",
		       LOG_DETAIL => "Detail Log",
		       LOG_VALIDATE => "Validate Log" };

    my $now = time();
    ERROR: while (my $error = $q->fetchrow_hashref()) {
	print { $$self{CONTENT} }
	"<div class='nice errorinfo'>",
	"<h1>Error $$error{RESULT_NUMBER}</h1>";

	print { $$self{CONTENT} }
	"<label>To Node:</label><span class='labeled halfwidefield'>$$error{TO_NODE}</span>",
	"<label>From Node:</label><span class='labeled halfwidefield'>$$error{FROM_NODE}</span><br/>";

	my $time_assign = $$error{TIME_ASSIGN};
	my $tn = 0;
	foreach my $time (qw(TIME_ASSIGN TIME_XFER TIME_EXPORT TIME_DONE TIME_INXFER TIME_EXPIRE)) {
	    my $timestamp   = &formatTime($$error{$time}, 'stamp');
	    my $diff_assign = &age($$error{$time} - $time_assign, 'second');
	    my $diff_now    = &age($$error{$time} - $now, 'second');

	    print { $$self{CONTENT} }
	    "<label>$$time_labels{$time}:</label><span class='labeled halfwidefield'>", 
	    ($timestamp ? ($timestamp,
			   " <span class='diff_assigned'>($diff_assign since assigned)</span> ",
			   " <span class='diff_now'>($diff_now from now)</span>") :
	     $$error{$time} ),
	     "</span>",
	     (++$tn % 2 == 0 ? "<br/>" : '');
	}

	print { $$self{CONTENT} }
	"<hr/>",
	"<label>Report Code:</label><span class='labeled halfwidefield'>$$error{REPORT_CODE}</span>",
	"<label>Transfer Code:</label><span class='labeled halfwidefield'>$$error{XFER_CODE}</span><br/>",
	"<hr/>",
	"<label>To PFN:</label><span class='labeled'>$$error{TO_PFN}</span><br/>",
	"<label>From PFN:</label><span class='labeled'>$$error{FROM_PFN}</span><br/>",
	"<hr/>";

	foreach my $log (qw(LOG_XFER LOG_DETAIL LOG_VALIDATE)) {
	    if (! defined $$error{$log} ) { $$error{$log} = ''; }
	    my $chars = length $$error{$log};
	    my $trunc = ($chars == $max_log_length ? "<br/><span class='alarm'>Truncated</span>" : '');
	    $$error{$log} =~ s/\s*$/\n/;
	    my $lines = ($$error{$log} =~ tr/\n/\n/);
	    $lines = 0 if $chars == 0;
	   
	    print { $$self{CONTENT} }
	    "<label>$$log_labels{$log}:<br/><span class='note'>($lines lines)<br/>($chars chars)$trunc</span></label>",
	    "<div class='labeled logbox'>$$error{$log}</div><br/>";	    
 	}
	print { $$self{CONTENT} } "</div>";
    }
    print {$$self{CONTENT}} $pager->pager();
}

1;


######################################################################
package Web25::Data::ExplorePage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use Sort::Key::Natural;
use Sort::Key::Maker sort_dbs =>
  sub { $$_{LABEL}, ($$_{BASE} || ''), $$_{ID} }, qw(nat nat int);
use Sort::Key::Maker sort_dataset_dbs =>
  sub { $$_{DBS}{LABEL}, ($$_{DBS}{BASE}||''), $$_{DBS}{ID}, $$_{NAME}, $$_{ID} },
  qw(nat nat int nat int);
use Sort::Key::Maker sort_name_id =>
  sub { $$_{NAME}, $$_{ID} }, qw(nat int);
use Sort::Key::Maker sort_name =>
  sub { $$_{NAME} }, qw(nat);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{SAVE_DB}   = [ qw(filter dcolumn rcolumn nvalue scolumn rows) ];
  $$self{SAVE_PAGE} = [ @{$$self{SAVE_DB}}, qw(dbs node dexp bexp) ];
  bless $self, $class;
  return $self;
}

sub init
{
    my $self = shift @_;
    $$self{NODE_LIST} = [ sort_name $self->node_list() ];
    my %nodesel = defined param('node')
	? (map { $_ => 1 } param('node'))
	: (map { $$_{ID} => 1 } grep($$_{NAME} =~ /CERN_MSS/, @{$$self{NODE_LIST}}));
    $$self{NODE_SHOWN} = [ grep($nodesel{$$_{ID}}, @{$$self{NODE_LIST}}) ];
    $$_{IS_SHOWN} = 1 for @{$$self{NODE_SHOWN}};
}

sub myurl
{
  my ($self, %args) = @_;

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Data::Replicas"
        && $args{"page"} ne "Data::Subscriptions");

  # If we stay in the same database, keep all, otherwise strip off db-specific
  my @save = $args{"db"} && $args{"db"} ne $$self{DBID}
    ? @{$$self{SAVE_DB}} : @{$$self{SAVE_PAGE}};

  # Return a URL with saved parameters
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub saveform
{
  my ($self, @omit) = @_;
  my $result = "";
  foreach my $option ('view', @{$$self{SAVE_PAGE}})
  {
    next if grep($option eq $_, @omit) || !defined param($option);
    if ($option eq 'nvalue')
    {
      $result .= "<input type='hidden' name='$option' value='$$self{NVALUE}' />";
    }
    elsif (grep($option eq $_, qw(dcolumn rcolumn scolumn)))
    {
      $result .= "<input type='hidden' name='$option' value='$_' />"
	for grep($$self{uc($option)}{$_}, param($option));
    }
    elsif (grep($option eq $_, qw(dbs node dexp bexp)))
    {
      $result .= "<input type='hidden' name='$option'"
		 . " value='@{[&escapeHTML($_)]}' />"
	for param($option);
    }
    else
    {
      $result .= "<input type='hidden' name='$option'"
	  . " value='@{[&escapeHTML(param($option))]}' />";
    }
  }

  return $result;
}

sub dbs_list
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select id, name, dls from t_dps_dbs
    order by name asc});

  my (%bases, @result);
  while (my ($id, $name, $dls) = $q->fetchrow())
  {
    # Build DBS object
    my $dbs = { ID => $id, URL => $name, DLS => $dls,
		BASE => undef, LABEL => $name };
    if ($name =~ /^(http.*)\?instance=(.*)/)
    {
      $$dbs{BASE} = $1;
      $$dbs{LABEL} = $2;
      $$dbs{LABEL} =~ s,/Writer$,,;
    }

    # Add HTML-formatted data
    my $htmllabel = &escapeHTML($$dbs{LABEL});
    my $htmldls = &breakAtSlash(&escapeHTML($$dbs{DLS}));
    my $suplink = "";
    if ($$dbs{BASE})
    {
      $bases{$$dbs{BASE}} = scalar(keys %bases) + 1
	if ! exists $bases{$$dbs{BASE}};
  
      $$dbs{BASE_ID} = $bases{$$dbs{BASE}};
      $suplink = "<sup><small>$$dbs{BASE_ID}</small></sup>";
    }
    $$dbs{HTML_DBS} = "$htmllabel$suplink";
    $$dbs{HTML_DLS} = $htmldls || '&nbsp;';

    # Add to the result
    push(@result, $dbs);
  }

  $q->finish();
  return @result;
}

sub dataset_list
{
  my ($self, @dbses) = @_;
  my $q = &dbprep($$self{DBH}, qq{
    select ds.id, ds.name, ds.is_open, ds.is_transient,
           nvl(count(b.id),0), nvl(sum(b.files),0), nvl(sum(b.bytes),0)
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
    where dbs = :dbsid
    group by ds.id, ds.name, ds.is_open, ds.is_transient
    order by ds.name asc});

  my @result = ();
  foreach my $dbs (@dbses)
  {
    &dbbindexec($q, ":dbsid" => $$dbs{ID});
    while (my ($id, $name, $open, $transient, $nblocks, $nfiles, $nbytes) = $q->fetchrow())
    {
      push(@result, {
	DBS => $dbs,
	ID => $id,
	NAME => $name,
	IS_OPEN => $open,
	IS_TRANSIENT => $transient,
	BLOCKS => $nblocks,
	FILES => $nfiles,
	BYTES => $nbytes });
    }
    $q->finish();
  }

  return @result;
}

sub dataset_replicas
{
  my ($self, @datasets) = @_;

  # "where in" lists are limited to 1000 entries
  my ($where, %binds) = ("", ());
  if (scalar @datasets < 1000) {
      my $list;
      ($list, %binds) = &dbinlist('dataset', map { $$_{ID} } @datasets);
      $where = " where ds.id in ($list) ";
  }

  my $q = &dbexec($$self{DBH}, qq{
    select ds.id dataset, n.id node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
      from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
      join t_dps_block_replica br on br.block = b.id
      join t_adm_node n on n.id = br.node
      $where
     group by ds.id, n.id}, %binds);

  my %byid = map { $$_{ID} => $_ } @datasets;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{DATASET}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_list
{
  my ($self, $dataset) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, b.name, b.is_open, b.files, b.bytes
    from t_dps_block b where b.dataset = :dsid},
    ":dsid" => $$dataset{ID});

  my @result = ();
  while (my ($id, $name, $open, $nfiles, $nbytes) = $q->fetchrow())
  {
    push(@result, {
      DATASET => $dataset,
      ID => $id,
      NAME => $name,
      IS_OPEN => $open,
      BLOCKS => 1,
      FILES => $nfiles,
      BYTES => $nbytes });
  }

  $q->finish();
  return @result;
}

sub file_list
{
  my ($self, $block) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select f.id, f.logical_name, f.filesize, n.name
    from t_dps_file f join t_adm_node n on n.id = f.node
    where inblock = :bid},
    ":bid" => $$block{ID});

  my @result = ();
  while (my ($id, $name, $size, $source) = $q->fetchrow())
  {
    push(@result, {
      BLOCK => $block,
      SOURCE => $source,
      ID => $id,
      NAME => $name,
      SIZE => $size });
  }

  $q->finish();
  return @result;
}

sub block_replicas
{
  my ($self, @blocks) = @_;
  my ($list, %binds) = &dbinlist('block', map { $$_{ID} } @blocks);
  my $q = &dbexec($$self{DBH}, 
		  qq{ select b.id block, br.node node,
                        nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
                        nvl(sum(br.dest_files),0) dest_files,
                        nvl(sum(br.dest_bytes),0) dest_bytes,
                        nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
                        nvl(sum(br.node_files),0) node_files,
                        nvl(sum(br.node_bytes),0) node_bytes
                      from t_dps_block b
                      join t_dps_block_replica br on br.block = b.id
                     where b.id in ($list)
                     group by b.id, br.node}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{BLOCK}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_sources
{
  my ($self, @blocks) = @_;
  my ($list, %binds) = &dbinlist('block', map { $$_{ID} } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, f.node, n.name
    from t_dps_block b
      join t_dps_file f on f.inblock = b.id
      join t_adm_node n on n.id = f.node
    where b.id in ($list)
    group by b.id, f.node, n.name}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $node, $name) = $q->fetchrow())
  {
    $byid{$block}{SOURCES}{$node} = $name;
    $byid{$block}{DATASET}{SOURCES}{$node} = $name;
  }

  $q->finish ();
}

sub file_replicas
{
  my ($self, @blocks) = @_;
  my ($list, %binds) =  &dbinlist('block', map { $$_{ID} } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, f.id, xr.node
    from t_dps_block b
      join t_xfer_file f on f.inblock = b.id
      join t_xfer_replica xr on xr.fileid = f.id
    where b.id in ($list)}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $file, $node) = $q->fetchrow())
  {
    $byid{$block}{FILE_REPLICAS}{$file}{$node} = 1;
  }

  $q->finish ();
}

sub node_list
{
  my ($self) = @_;

  my @result = ();
  my %nodes = $self->fetch_nodes(with_ids=>1);
  while (my ($name, $id) = each %nodes) {
    push(@result, { ID => $id, NAME => $name });
  }

  return @result;
}

sub apply_options
{
  my ($self) = @_;

  # Determine which dataset options we are showing (in dataset mode)
  $$self{DCOLUMN_NAMES} = [ qw(DBS Name Blocks Files Bytes Open Transient Id) ];
  $$self{DCOLUMN} = { "DBS" => 0, "Name" => 1, "Blocks" => 0, "Files" => 1,
                      "Bytes" => 1, "Open" => 0, "Transient" => 0, "Id" => 0 };
  if (defined param('dcolumn'))
  {
    $$self{DCOLUMN}{$_} = 0 for keys %{$$self{DCOLUMN}};
    $$self{DCOLUMN}{$_} = 1 for grep(exists $$self{DCOLUMN}{$_}, param('dcolumn'));
  }

  # Determine which replica options we are showing (in replica mode)
  $$self{RCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{RCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
		    
  if (defined param('rcolumn'))
  {
    $$self{RCOLUMN}{$_} = 0 for keys %{$$self{RCOLUMN}};
    $$self{RCOLUMN}{$_} = 1 for grep(exists $$self{RCOLUMN}{$_}, param('rcolumn'));
  }

  # Determine which replica options we are showing (in subscription mode)
  $$self{SCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{SCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
  if (defined param('scolumn'))
  {
    $$self{SCOLUMN}{$_} = 0 for keys %{$$self{SCOLUMN}};
    $$self{SCOLUMN}{$_} = 1 for grep(exists $$self{SCOLUMN}{$_}, param('scolumn'));
  }

  # Determine which replica value we show (in replica mode)
  $$self{NVALUES} = [ "Node blocks", "Node files", "Node bytes",
		      "Destined blocks", "Destined files", "Destined bytes",
		      "Missing blocks", "Missing files", "Missing bytes",
		      "% Complete (files)", "% Complete (bytes)"
		      ];
  $$self{NVALUE} = param('nvalue') || "Node files";
  $$self{NVALUE} = "Node files" if !grep($$self{NVALUE} eq $_, @{$$self{NVALUES}});

  # Determine if we are showing all or interesting rows
  $$self{ROWS} = param('rows') || 'all';
  $$self{ROWS} = 'all' if !grep($$self{ROWS} eq $_, qw(all interesting));
}

sub fetch_data
{
  my ($self) = @_;

  # Obtain the list of DBSes, sort them and pick the ones we show.
  my %shown = map { $_ => 1 } param('dbs');
  $$self{DBS_LIST} = [ sort_dbs $self->dbs_list() ];

  if (keys %shown)
  {
    $$self{DBS_SHOWN} = [ grep(exists $shown{$$_{ID}}, @{$$self{DBS_LIST}}) ];
  }
  else
  {
    $$self{DBS_SHOWN} = $$self{DBS_LIST};
  }

  $$_{IS_SHOWN} = 1 for @{$$self{DBS_SHOWN}};

  # Now get a sorted list of the datasets we are interested in
  my $filter = param('filter');
  $filter = "." if ! defined $filter || $filter eq '';
  my @datasets = grep($$_{NAME} =~ /$filter/,
		      $self->dataset_list(@{$$self{DBS_SHOWN}}));
  if ($$self{DCOLUMN}{"DBS"})
  {
    $$self{DATASET_LIST} = [ sort_dataset_dbs @datasets ];
  }
  else
  {
    $$self{DATASET_LIST} = [ sort_name_id @datasets ];
  }

  # Fetch blocks and block replicas
  my %dexpand = map { $_ => 1 } param('dexp');
  my %bexpand = map { $_ => 1 } param('bexp');
  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    if (! $dexpand{$$ds{ID}})
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ $$ds{ID}, param('dexp') ]) .
        "#d$$ds{ID}'>&#187;</a>";
    }
    else
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ grep($_ != $$ds{ID}, param('dexp')) ]) .
        "#d$$ds{ID}'>&#171;&#171;</a>";
    }

    # Pass if not expanded
    next if ! $dexpand{$$ds{ID}};

    # Expanded, obtain block list
    $$ds{BLOCK_LIST} = [ sort_name $self->block_list($ds) ];
    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      if (! $bexpand{$$block{ID}})
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ $$block{ID}, param('bexp') ]) .
          "#b$$block{ID}'>&#187;</a>";
      }
      else
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ grep($_ != $$block{ID}, param('bexp')) ]) .
          "#b$$block{ID}'>&#171;&#171;</a>";
      }

      # Pass if not expanded
      next if ! $bexpand{$$block{ID}};

      # Expanded, obtain file list
      $$block{FILE_LIST} = [ sort_name $self->file_list($block) ];
    }
  }

  # Fetch per-node replicas for datasets, blocks and files in expanded view
  if (ref ($self) !~ /Datasets/)
  {
    $self->dataset_replicas(@{$$self{DATASET_LIST}})
      if @{$$self{DATASET_LIST}};

    my @allblocks = map { @{$$_{BLOCK_LIST}} } grep($$_{BLOCK_LIST}, @{$$self{DATASET_LIST}});

    $self->block_replicas(@allblocks)
      if @allblocks;

    $self->block_sources(@allblocks)
      if (@allblocks
	  && ((ref ($self) =~ /::Replicas/ && $$self{RCOLUMN}{"Source"})
	      || (ref ($self) =~ /::Subs/ && $$self{SCOLUMN}{"Source"})));

    my @expblock = grep($bexpand{$$_{ID}}, @allblocks);
    $self->file_replicas(@expblock) if @expblock;
  }
}


sub dbs_form
{
    my ($self) = @_;

    my $form = "";
    $form .= "<div id='dbschoice'>\n";
    $form .= "  <div id='dbsmenu' style='width:100%;font-size:0.9em'>\n";
    $form .= "    <table>\n";
    $form .= "     <thead>\n";
    $form .= "      <tr>\n";
    $form .= "       <th width='4%' align='center'>Show</th>\n";
    $form .= "       <th width='20%' align='left'>DBS</th>\n";
    $form .= "       <th width='100%' align='left'>DLS contact</th>\n";
    $form .= "       <th width='4%' align='right'>Id</th>\n";
    $form .= "      </tr>\n";
    $form .= "     </thead>\n";
    $form .= "     <tbody>\n";

    my $n = 0;
    foreach my $dbs (@{$$self{DBS_LIST}})
    {
	my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
	$form .= "      <tr$rowcolor>\n";
	$form .= "       <td align='center'><input type='checkbox' name='dbs' value='$$dbs{ID}'";
	$form .= ($$dbs{IS_SHOWN} ? " checked='checked'" : '') . " /></td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DBS}</td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DLS}</td>\n";
	$form .= "       <td align='right' style='color:#666'>$$dbs{ID}</td>\n";
	$form .= "      </tr>\n";
    }
    $form .= "     </tbody>\n";
    $form .= "    </table>\n";
    $form .= "  </div>\n";
    $form .= "</div>\n";
    return $form;
}

sub node_form
{
  my ($self) = @_;

  my $form = "";

  $form .= "<div id='nodechoice'>\n";
  $form .= "<input type='button' value='Select all' onclick=\"select_all('nodechoice', 'node', '1')\"/>\n",
  $form .= "<input type='button' value='Select none' onclick=\"select_all('nodechoice', 'node', '0')\"/>\n",

  my (@all, @columns) = @{$$self{NODE_LIST}};
  my $percolumn = int(scalar(@all)/4 + 0.5);
  $percolumn = 4 if ! $percolumn;
  push (@columns, [ splice(@all, 0, $percolumn) ]) while @all;

  $form .= "  <div id='nodemenu' style='font-size:0.9em'>\n";
  $form .= "    <table style='white-space:  nowrap;'>\n";
  $form .= "     <tbody>\n";
  $form .= "      <tr>\n";

  foreach my $col (@columns)
  {
      $form .= "       <td>\n";
      $form .= join("\n", (map { "        <input type='checkbox' name='node' value='$$_{ID}'" .
				     ($$_{IS_SHOWN} ? " checked='checked'" : "") .
				     " />&nbsp;" . &escapeHTML($$_{NAME}) . "<br />" }
			   @$col));
      $form .= "       </td>\n";
  }
  
  $form .= "     </tr>\n";
  $form .= "    </tbody>\n";
  $form .= "   </table>\n";
  $form .= " </div>\n";
  $form .= "</div>\n";
  return $form;
}


sub columns_form
{
    my ($self, @display_columns) = @_;

    my $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Display Columns</i></p>\n";
    foreach my $pair (@display_columns)
    {
	my ($dataset, $column) = @{$pair};

	$form .= "   <input type='checkbox' name='$dataset' value='$column'" .
	    ($$self{uc($dataset)}{$column} ? " checked='checked'" : "") .
	    " />&nbsp;$column<br/>\n";
    }
    
    return $form;
}

sub output_filter
{
  my ($self) = @_;
  my $filter = param('filter');
  my $filterform = "" .
    "<form style='display:inline' method='get' action='@{[$self->myurl()]}'>" .
    $self->saveform('filter') .
    textfield(-name=>'filter', -default=>$filter, -size=>15,
	      -title=>("Regular expression to match against the name column. "
		       ."Only those matching the expression will be shown.")) .
    " <input type='submit' value='Filter' />" .
    "</form>";

  return ($filter, $filterform);
}

sub output
{
  my ($self) = @_;

  # Apply form options and fetch the data we show on this form
  $self->apply_options();
  $self->init();
  $self->output_page();
  $self->output_options_form();
}

1;


######################################################################
package Web25::Data::Replicas;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Replicas",
	       LINK_TITLE => "Explore replicas" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  $self->fetch_data(); # puts all data into $self

  my ($filter, $filterform) = $self->output_filter();

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $node_th = $$self{NVALUE};
  $node_th =~ s/Node\s+//;
  $node_th =~ s/ +/\&nbsp;/g;
  $node_th = ucfirst($node_th);

  print { $$self{CONTENT} }
    "<table>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{RCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{RCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{DCOLUMN}{"Blocks"}    ? "   <th width='4%' align='center'>Blocks</th>\n" : ()),
    ($$self{RCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{RCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{RCOLUMN}{"Source"}    ? "   <th width='6%' align='left'>Source</th>\n" : ()),
    ($$self{DCOLUMN}{"Open"}      ? "   <th width='4%' align='center'>Open</th>\n" : ()),
    ($$self{DCOLUMN}{"Transient"} ? "   <th width='4%' align='center'>Transient</th>\n" : ()),
    (map { "   <th width='4%' align='center'>@{[&escapeHTML($$_{NAME})]} $node_th</th>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody class='nowrap'>\n";

  my $n = 0;
  my %total = (BLOCKS => 0, FILES => 0, BYTES => 0);
  $total{$$_{ID}} = { VALUE => 0, ATTR => "" } for @{$$self{NODE_SHOWN}};
  my ($quantity, $formatter) = ("", sub { return -1, 0 }, sub { return @_ });
  if ($$self{NVALUE} eq "Node blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = (($$obj{NODE_BLOCKS} || $$obj{DEST_BLOCKS}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = ($$obj{DEST_BLOCKS} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BLOCKS} || 0) - ($$obj{NODE_BLOCKS} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BLOCKS} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = (($$obj{NODE_FILES} || $$obj{DEST_FILES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = ($$obj{DEST_FILES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_FILES} || 0) - ($$obj{NODE_FILES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = (($$obj{NODE_BYTES} || $$obj{DEST_BYTES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = ($$obj{DEST_BYTES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BYTES} || 0) - ($$obj{NODE_BYTES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  } 
  elsif ($$self{NVALUE} eq "% Complete (files)")
  {
      $formatter = \&format_percent;
      $quantity = sub { my ($ref, $obj) = @_;
        my $value = max(0, ($$obj{NODE_FILES} || 0) / ($$obj{DEST_FILES} || -1));
        my $refvalue = 1;
        my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
  	return ($value, $refvalue, $interesting);  };
  } elsif ($$self{NVALUE} eq "% Complete (bytes)")
  {
      $formatter = \&format_percent;
      $quantity = sub { my ($ref, $obj) = @_;
        my $value = max(0, ($$obj{NODE_BYTES} || 0) / ($$obj{DEST_BYTES} || -1));
        my $refvalue = 1;
        my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
  	return ($value, $refvalue, $interesting);  };
  }


  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my %values = ();
    my $interesting = 0;
    foreach my $node (@{$$self{NODE_SHOWN}})
    {
      my ($value, $refvalue, $intr) = &$quantity($ds, $$ds{REPLICAS}{$$node{ID}});
      my $attr = $value == $refvalue ? "" : " style='color:#d00'";
      $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
      $interesting ||= $intr;
    }

    next if $$self{ROWS} eq 'interesting' && ! $interesting;

    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    my @sources = ($$ds{SOURCES} ? values %{$$ds{SOURCES}}
		   : "<span style='color:#666'>(Expand)</span>");
    my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		  ? "<span style='color:#666'>(Multiple)</span>"
		  : $sources[0]);
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{RCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>@{[&format_num($$ds{BLOCKS})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
      ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$ds{IS_OPEN}</td>\n" : ()),
      ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>$$ds{IS_TRANSIENT}</td>\n" : ()),
    (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
      "  </tr>\n";

    $total{BYTES} += $$ds{BYTES};
    $total{BLOCKS} += $$ds{BLOCKS};
    $total{FILES} += $$ds{FILES};
    for (@{$$self{NODE_SHOWN}})
    {
	if ($$self{NVALUE} !~ /^%/) {
	    $total{$$_{ID}}{VALUE} += $values{$$_{ID}}{VALUE};
	} else {
	    $total{$$_{ID}}{VALUE} = 0; # TODO:  Properly sum part/whole for percents
	}
	$total{$$_{ID}}{ATTR} ||= $values{$$_{ID}}{ATTR};
    }

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      %values = ();
      $interesting = 0;
      foreach my $node (@{$$self{NODE_SHOWN}})
      {
        my ($value, $refvalue, $intr) = &$quantity($block, $$block{REPLICAS}{$$node{ID}});
        my $attr = $value == $refvalue ? "" : " style='color:#d00'";
        $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
        $interesting ||= $intr;
      }

      next if $$self{ROWS} eq 'interesting' && ! $interesting;

      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      my @sources = ($$block{SOURCES} ? values %{$$block{SOURCES}}
		     : "<span style='color:#666'>(Expand)</span>");
      my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		    ? "<span style='color:#666'>(Multiple)</span>"
		    : &escapeHTML($sources[0]));
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>&nbsp;</td>\n" : ()),
        ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
        ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$block{IS_OPEN}</td>\n" : ()),
        ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
        (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
        "  </tr>\n";

      foreach my $file (@{$$block{FILE_LIST}})
      {
        my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
        my $span = 1; $span++ if $$self{RCOLUMN}{"Files"};
        my $have = "<span style='color:#666'>y</span>";
        my $havenot = "<span style='color:#d00'>N</span>";
        my $goal = ($$self{NVALUE} =~ /Missing/ ? $havenot : $have);
	my %nodeattr = map { $$_{ID} => ($$block{FILE_REPLICAS}{$$file{ID}}{$$_{ID}}
			                 ? $have : $havenot) }
		      @{$$self{NODE_SHOWN}};
	$interesting = scalar(grep($_ eq $goal, values %nodeattr));
	next if $$self{ROWS} eq 'interesting' && ! $interesting;

        print { $$self{CONTENT} }
          "  <tr$rowcolor>\n",
          "   <td>&nbsp;</td>\n",
          ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
          ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:3em' colspan='$span'>@{[&escapeHTML($$file{NAME})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$file{SIZE})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>@{[&escapeHTML($$file{SOURCE})]}</td>\n" : ()),
          ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
          (map { "   <td align='right'>$nodeattr{$$_{ID}}</td>\n" } @{$$self{NODE_SHOWN}}),
          "  </tr>\n";
      }
    }
  }

  # Footer, sum totals
  print { $$self{CONTENT} }
  " </tbody>\n",
  " <tfoot>\n",
  "   <tr bgcolor='#f8f8f8'>\n",
  "    <th>&nbsp;</th>\n",
  ($$self{RCOLUMN}{"DBS"} && $$self{RCOLUMN}{"Name"}
   ? "   <th colspan='2' align='left'>Total</th>\n"
   : $$self{RCOLUMN}{"DBS"} || $$self{RCOLUMN}{"Name"}
   ? "   <th align='left'>Total</th>\n"
   : ()),
       ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>@{[&format_num($total{BLOCKS})]}</td>\n" : ()),
       ($$self{RCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Source"}    ? "   <th align='right'>&nbsp;</th>\n" : ()),
       ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
       ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
       (map { "   <td align='right'$total{$$_{ID}}{ATTR}>@{[&$formatter($total{$$_{ID}}{VALUE})]}</td>\n" } @{$$self{NODE_SHOWN}}),
       "   </tr>\n",
       " </tfoot>\n",
       "</table>\n";
  
  # Produce "footnotes" for the DBS URL base strings
  my %bases = map { $$_{BASE_ID} => $$_{BASE} } grep($$_{BASE}, @{$$self{DBS_LIST}});
  if (keys %bases)
  {
      print { $$self{CONTENT} }
      "<div style='font-size: 0.9em;margin-top:1em'>\n<hr>\n",
      (map { ("<sup><small>$_</small></sup>",
	      "&nbsp;", &breakAtSlash(&escapeHTML($bases{$_})), "<br />\n") }
       sort keys %bases),
      "</div>";
  }
}

# Produce content to the options panel
sub output_options_form
{
    my ($self) = @_;

    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = "";

    # Save everything except what this form controls
    $form = $self->saveform(qw(dcolumn rcolumn node nvalue dbs rows));
    $optspane->add_hidden($form);

   # Columns Tab
    my @display_columns;
    push @display_columns, 
    [('rcolumn', 'DBS')], 
    [('rcolumn', 'Name')], 
    [('dcolumn', 'Blocks')],
    [('rcolumn', 'Files')], 
    [('rcolumn', 'Bytes')], 
    [('rcolumn', 'Source')], 
    [('dcolumn', 'Open')], 
    [('dcolumn', 'Transient')];

    $form = $self->columns_form(@display_columns);
    $optspane->add_tab('Columns', $form);

    # DBS Source tab
    $form = $self->dbs_form();
    $optspane->add_tab('DBS Sources', $form);

    # Node Selection tab
    $form = $self->node_form();
    $optspane->add_tab('Nodes Shown', $form);
    
    # Node Values tab
    $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Node Values</i></p>\n";
    foreach my $opt (@{$$self{NVALUES}})
    {
	$form .= "  <input type='radio' name='nvalue' value='$opt'" .
	    ($$self{NVALUE} eq $opt ? " checked='checked'" : "") .
	    " />&nbsp;$opt<br/>\n";
    }

    $form .= "   <p style='margin-top:1ex'><i>Filter rows</i></p>\n" .
	"   <input type='radio' name='rows' value='all'" .
	($$self{ROWS} eq 'all' ? " checked='checked'" : "") .
	" />&nbsp;Show all rows<br/>\n" .
	"   <input type='radio' name='rows' value='interesting'" .
	($$self{ROWS} eq 'interesting' ? " checked='checked'" : "") .
	" />&nbsp;Show interesting rows<br/>\n";

    $optspane->add_tab('Node Values', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;

######################################################################
package Web25::Data::Subscriptions;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Subscriptions",
	       LINK_TITLE => "Explore subscriptions" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  if (!$$self{SECMOD}->isAuthenticated() &&
      !($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
	$$self{SECMOD}->hasRole('Data Manager') ||
	$$self{SECMOD}->hasRole('Site Admin'))) {
      $self->auth_help_popup('suspend/unsuspend subscriptions'
		       => ['anyauth', 'Data Manager', 'Site Admin', 'Global Admin'],
		       'change priorities of subscriptions'
		       => ['cert', 'Data Manager', 'Global Admin']);
      }

  my %admin_opts = ('suspend' => 'Suspend subscriptions',
		    'unsuspend' => 'Unsuspend subscriptions',
		    'priorityhi' => 'Make high priority',
		    'prioritymd' => 'Make normal priority',
		    'prioritylo' => 'Make low priority');
  my %admin_grps = ('suspend' => ['suspend', 'unsuspend'],
		    'priority' => ['priorityhi', 'prioritymd', 'prioritylo']);
  my @admin_auth;
  if ($$self{SECMOD}->isAuthenticated() &&
      ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
      $$self{SECMOD}->hasRole('Data Manager') ||
      $$self{SECMOD}->hasRole('Site Admin'))) {
      push @admin_auth, 'suspend';
  }

  if ($$self{SECMOD}->isCertAuthenticated() &&
      ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
      $$self{SECMOD}->hasRole('Data Manager'))) {
      push @admin_auth, 'priority';
  }

  if (param('subsaction')) {
      $self->update_subscriptions();
  }

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $q =$self->data_subscriptions();
  
  my @cols = qw(SELECT ITEM_LEVEL ITEM_NAME NODE_NAME PRIORITY PCT_FILES PCT_BYTES
		IS_MOVE IS_TRANSIENT TIME_SUSPEND_UNTIL ITEM_OPEN
		TIME_CREATE TIME_COMPLETE TIME_DONE
		);
  my $th =
  { SELECT => 'Select',
    ITEM_LEVEL => 'Data Level',
    ITEM_NAME => 'Data Item',
    NODE_NAME => 'Node',
    PRIORITY => 'Priority',
    PCT_FILES => '% Files',
    PCT_BYTES => '% Bytes',
    IS_MOVE => 'Replica/Move',
    IS_TRANSIENT => 'Open/Closed',
    TIME_SUSPEND_UNTIL => 'Active/Suspended',
    ITEM_OPEN => 'Item Open',
    TIME_CREATE => 'Time Create',
    TIME_COMPLETE => 'Time Complete',
    TIME_DONE => 'Time Done'
    };
  
  # Special data fromats
  my $now = time();
  my $df = 
  { 
      PRIORITY => sub { if ($_[0] == 0) { return 'High'; }
			if ($_[0] == 1) { return 'Normal'; }
			if ($_[0] == 2) { return 'Low'; } },
      IS_MOVE => sub { return $_[0] eq 'y' ? 'Move' : 'Replica'; },
      TIME_SUSPEND_UNTIL => sub { 
	  my $susp_time = $_[0];
	  if (!defined $susp_time || $susp_time <= $now) { return 'Active'; }
	  elsif ($susp_time == 9_999_999_999)            { return 'Suspended Forever'; }
	  else { return 'Suspended Until  '.&formatTime($susp_time, 'stamp') }
      },
      IS_TRANSIENT => sub { return $_[0] eq 'y' ? 'Closed' : 'Open'; },
      ITEM_OPEN => \&yesno,
      TIME_CREATE =>   sub { &formatTime($_[0], 'stamp') || '&#8211;' },
      TIME_COMPLETE => sub { &formatTime($_[0], 'stamp') || '&#8211;' },
      TIME_DONE =>     sub { &formatTime($_[0], 'stamp') || '&#8211;' },
      PCT_FILES => \&format_percent,
      PCT_BYTES => \&format_percent
  };

  # Special cell formats
  my $cf = 
  { 
      TIME_SUSPEND_UNTIL => sub { return defined $_[0] && $_[0] >= $now ? 'alarm' : ''; },
      PCT_FILES => sub { return defined $_[0] && $_[0] == 1 ? '' : 'bad' },
      PCT_BYTES => sub { return defined $_[0] && $_[0] == 1 ? '' : 'bad' }
  };

  # Pseudo columns
  my %pseudo =
      (
       'SELECT'  => sub { "<input type='checkbox' name='s_id' value='$_[1]->{ITEM_LEVEL}:$_[1]->{ITEM_ID}:$_[1]->{NODE_ID}'/>" },
       'PCT_FILES' => sub { ($_[1]->{NODE_FILES} || 0) / ($_[1]->{DEST_FILES} || -1); },
       'PCT_BYTES' => sub { ($_[1]->{NODE_BYTES} || 0) / ($_[1]->{DEST_BYTES} || -1); }
       );
  
  if (!@admin_auth) {
      delete $pseudo{SELECT};
      delete $df->{SELECT};
      delete $th->{SELECT};
      @cols = grep !/SELECT/, @cols;
  }

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead($th);
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats($df);
  $dbtable->set_cellformats($cf);
  $dbtable->add_pseudocolumn($_, $pseudo{$_}) foreach (keys %pseudo);
  my @querycols;
  foreach (@cols) {
      my $default = $_ =~ /PCT_FILES|ITEM_OPEN|TIME_COMPLETE|TIME_DONE/ ? 0 : 1;
      push @querycols, [ ($$th{$_}, 'col', $_,  $default) ];
  }
  $dbtable->set_querycols( @querycols );


  if (@admin_auth) {
      print { $$self{CONTENT} }
      "<p><label>Selections:</label>\n",
      "<input type='button' value='Select all' onclick=\"select_all('subsform', 's_id', '1')\"/>\n",
      "<input type='button' value='Select none' onclick=\"select_all('subsform', 's_id', '0')\"/>\n",
      "</p>\n";

      my $target = $self->myurl();
      print { $$self{CONTENT} }
      "<form id='subsform' method='post' action='$target'>",
      $self->saveform(),
      "<p>\n",
      "<label>Actions:</label>\n",
      "<select class='labeled' name='subsaction'>\n";
      foreach my $auth (@admin_auth) {
	  foreach my $opt (@{$admin_grps{$auth}}) {
	      print { $$self{CONTENT} } 
	      "<option value='$opt'>$admin_opts{$opt}</option>\n";
	  }
      }
      print { $$self{CONTENT} }
      "</select>\n",
      "<input type='submit' value='Update'/>\n",
      "</p>\n";

  }

  my $nrows = $dbtable->output($q);

  if (@admin_auth) {
      print { $$self{CONTENT} } "</form>\n";
  }

  if ($nrows == 0) {
      $self->alert("No data exists for your selected nodes.");
  }

  my $optspane = new Web25::OptsPane;
  
  my $target = $self->myurl();
  $optspane->set_form_target($target);

  my $form = "";

  # Save everything except what this form controls
  $form = $self->saveform(qw(node));
  $optspane->add_hidden($form);

  $form = $dbtable->columns_form();
  $optspane->add_tab('Columns', $form);

  # Node Selection tab
  $form = $self->node_form();
  $optspane->add_tab('Nodes Shown', $form);

  print { $$self{OPTIONS} } $optspane->output();

}

sub output_options_form { }

sub update_subscriptions
{
    my ($self) = @_;

    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager||Site Admin', with_ids => 1);
    
    my %all_nodes = reverse $self->fetch_nodes(with_ids => 1); # just a hash of id => name

    my $upd_suspend = qq[ update t_dps_subscription set time_suspend_until = :val
			  where _ITEM_ = :id and destination = :dest ];
    my $upd_priority = qq[ update t_dps_subscription set priority = :val
			   where _ITEM_ = :id and destination = :dest];

    my $action_list = 
    {
	suspend => { desc => ' suspended',
		     sql  => $upd_suspend,
		     val  => 9_999_999_999 },
    	unsuspend => { desc => ' unsuspended',
		       sql  => $upd_suspend,
		       val  => undef },
	priorityhi => { desc => ' set to high priority',
			sql => $upd_priority,
			val => 0 },
	prioritymd => { desc => ' set to medium priority',
			sql => $upd_priority,
			val => 1 },
	prioritylo => { desc => ' set to low priority',
			sql => $upd_priority,
			val => 2 }
    };

    # Execute the update
    my $action = $action_list->{param('subsaction')};

    my $n_changed = 0;
    my %warn_hash;  # to keep unique warnings

    foreach (param('s_id')) {
	my ($level, $id, $destination) = split /:/;
	if (grep $destination == $_, values %auth_nodes) { # Check permission
	    my $sql = $$action{sql};
	    $sql =~ s/_ITEM_/$level/;

	    my @rv = &dbexec($$self{DBH}, $sql, 
			     ':val' => $$action{val},
			     ':id'  => $id,
			     ':dest' => $destination);
	    $n_changed += $rv[1];
	} else {
	    my $warn = "<p class='alarm'>Sorry, you don't have permission to update ".
		"$all_nodes{$destination} subscriptions!</p>";
	    $warn_hash{$warn} = 1;
	}
    }

    $$self{DBH}->commit();

    # Print scoldings
    print { $$self{CONTENT} } keys %warn_hash;

    # Report the changes
    if ($n_changed) {
	print { $$self{CONTENT} } "<p class='note'>$n_changed data items $action->{desc}!</p>";
    } else {
	print { $$self{CONTENT} } "<p class='alarm'>Nothing was changed!<p>";
    }
}

sub data_subscriptions
{
  my ($self) = @_;
  $self->fetch_nodes();
  my @node_ids = map { $$_{IS_SHOWN} ? $$_{ID} : '' } @{$$self{NODE_LIST}};
  @node_ids = grep /\d+/, @node_ids;
  my ($node_list, %node_binds) = &dbinlist('node', @node_ids );

  my $q = &dbexec($$self{DBH}, qq{
    select NVL2(s.block, 'BLOCK', 'DATASET') item_level,
           NVL2(s.block, s.block, s.dataset) item_id,
           NVL2(s.block, b.name, ds.name) item_name,
           NVL2(s.block, b.is_open, ds.is_open) item_open,
           n.id node_id, n.name node_name,
           s.priority, s.is_move, s.is_transient,
           s.time_suspend_until, s.time_create,
           s.time_complete, s.time_done,
           reps.node_files, reps.dest_files,
           reps.node_bytes, reps.dest_bytes
      from t_dps_subscription s
      join
      (select br.node, b2.dataset, b2.id block,
              sum(br.node_files) node_files, sum(br.dest_files) dest_files,
              sum(br.node_bytes) node_bytes, sum(br.dest_bytes) dest_bytes
         from t_dps_block b2
         join t_dps_block_replica br on br.block = b2.id                                                  
        group by br.node, rollup (b2.dataset, b2.id)
      ) reps
        on reps.node = s.destination
           and ((reps.block is null and reps.dataset = s.dataset) or reps.block = s.block)
      join t_adm_node n on n.id = s.destination
      left join t_dps_dataset ds on ds.id = s.dataset
      left join t_dps_block b on b.id = s.block
     where n.id in ($node_list)
     order by s.time_create desc, s.dataset desc, s.block desc, n.name
  }, %node_binds);

  return $q;
}


1;

######################################################################
package Web25::Data::Delete;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Delete",
	       LINK_TITLE => "Delete datasets or blocks from PhEDEx database",
               SECURE => 0 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  if ($$self{SECMOD}->isCertAuthenticated() &&
      ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
       $$self{SECMOD}->hasRole('Data Manager'))) {
      $self->deletion_form();
  } else {
      $self->auth_help_popup('delete datasets and blocks' => ['cert', 'Data Manager', 'Global Admin']);
  }
  $self->deletion_queue();
}

sub deletion_form
{
    my $self = shift @_;

    my $del_url = $self->myurl('page' => 'Data::DeleteConfirm');
    my @nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');
    
    print { $$self{CONTENT} }
    "<h1>Delete Data</h1>",
    "<p>Enter the data items you would like to delete.  Deletions are ",
    "added to the queue and are actually deleted when the deletion agents ",
    "get around to it.</p>",
    
    "<form class='nice' method='post' action='$del_url'>";

    if ($$self{SECMOD}->hasRole('Global Admin', 'phedex')) {
	print {$$self{CONTENT}}
	"<label>Nodes:</label>",
	"<div class='labeled'  style='font-size:8pt;width:450px;height:150px;overflow:scroll;border:thin solid black;' >",
	"<table><tr valign='top'>",
	"  <td>\n",
	(map { &striplabels(checkbox(-name=>'node', -label=>'', -value=>$_)."$_<br/>") }
	 sort grep (/^T1_|T0_/, @nodes)),
	"  </td>\n",
	"  <td>\n",
	(map { &striplabels(checkbox(-name=>'node', -label=>'', -value=>$_)."$_<br/>") }
	 grep (/^T2_/, @nodes)),
	"  </td>\n",
	"  <td>\n",
	(map { &striplabels(checkbox(-name=>'node', -label=>'', -value=>$_)."$_<br/>") }
	 grep (! /^T[012]_/, @nodes)),
	"  </td>\n",
	" </tr></table></div><br/>\n";
    } else {
	print {$$self{CONTENT}}
	"<label>Node:</label>",
	popup_menu(-name=>'node', -values=>[@nodes], -class=>'labeled'),
	"<br/>";
    }
    
    print {$$self{CONTENT}}
    "<label>Data Items:<br/><br/>",
    "<span class='note'>/Primary/Processed/Dataset<br/>or<br/>",
    "/Primary/Processed/Tier#Block<br/>(Use * as wildcard)</span><br/>",
    &help("More Help", "Data Item List", 
	  "A whitespace separated list of the datasets or blocks you are ",
	  "deleting.  Glob-style wildcards may be used, but the dataset ",
	  "path separators are required.  E.g. to delete all ",
	  "datasets you would have to write '/*/*/*', not '*'."), 
    "</label>\n",
    textarea(-name=>'data', -value=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), 
    "<br/>",

    "<label>Remove Subscriptions?:</label>",
    popup_menu(-name=>'rm_subscriptions', -values=>[qw(y n)], -labels=>{y => 'Yes', n => 'No'}, -class=>'labeled'),
    &help("[what's this?]", "Remove Subscriptions",
	  "If you choose not to remove the subscription when deleting data PhEDEx will ",
	  "retransfer the data to your node after the deletion is complete."),
    "<br/>",

    "<label>&nbsp;</label>", 
    submit(-class=>'labeled', -value=>'Go to Confirmation'), "<br/>",
    "</form>";
}

sub deletion_queue
{
    my $self = shift @_;

    print { $$self{CONTENT} }
    "<h1>Deletion Queue</h1>",
    "<p>This table contains the blocks which are queued for deletion.</p>";
    
    my $sql = qq{ select n.name node, ds.name dataset, b.name block, del.time_request, del.time_complete
		      from t_dps_block_delete del
		      join t_dps_block b on b.id = del.block
		      join t_dps_dataset ds on ds.id = del.dataset
		      join t_adm_node n on n.id = del.node
		      order by del.time_complete desc, del.time_request desc };
    
    my $q = &dbexec($$self{DBH}, $sql);
    
    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{CONTENT});
    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');
    $dbtable->set_tablehead({ DATASET => 'Dataset',
			      BLOCK => 'Block',
			      NODE => 'Node',
			      TIME_REQUEST => 'Requested',
			      TIME_COMPLETE => 'Completed' });
    $dbtable->set_dataformats({ TIME_REQUEST  => sub { &formatTime($_[0], 'stamp') },
				TIME_COMPLETE => sub { $_[0] ? &formatTime($_[0], 'stamp') : 'Pending' } });
    
    $dbtable->output($q);
}

1;

######################################################################
package Web25::Data::DeleteConfirm;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use Text::Glob 'glob_to_regex';
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Delete Confirmation",
	       LINK_TITLE => "Delete datasets or blocks from PhEDEx database",
               SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    if (request_method() ne 'POST') {
    	alert($self, "This form can only be accessed with 'POST' method.");
	return;
    }

    unless ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Global Admin', 'phedex') ||
	     $$self{SECMOD}->hasRole('Data Manager'))) {
	$self->auth_help_popup('delete datasets and blocks' => ['cert', 'Data Manager', 'Global Admin']);
	return;
    }

    my $bad = 0;
    unless (param('node') || param('data') || param('rm_subscriptions')) {
	$self->alert("Insufficient parameters");
	$bad = 1;
    }

    my $data = param('data');
    unless ($data) { $self->alert("No data items given"); $bad = 1; }
    my @nodes = param('node');
    unless (@nodes) { $self->alert("No nodes given"); $bad = 1; }

    my $rm_subscriptions = (param('rm_subscriptions') eq 'y' ? 1 : 0);

    my @auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager');
    foreach my $node (@nodes) {
	if (! grep $node eq $_, @auth_nodes) {
	    $self->alert("You don't have permission to delete data from $node.");
	    $bad = 1;
	}
    }
    
    # Parse users data field
    my %userdata = $self->parse_userdata($data);
    foreach (keys %userdata) {
	if (! $userdata{$_} ) {
	    $self->alert("The data pattern is &ldquo;@{[&escapeHTML($_)]}&rdquo;",
			 " does not match pattern of type /PRIMARY/TIER/DATASET or /PRIMARY/DATASET#BLOCK.");
	    $bad = 1;
	}
    }

    return if $bad;

#    &dump_var($$self{CONTENT}, 'userdata', {%userdata});

    # Find matches in replicas tables for the given nodes
    my ($node_list, %node_binds) = &dbinlist('node', @nodes);
    my $sql = qq{select n.id node_id, n.name node,
		        ds.id dataset_id, ds.name dataset,
		        b.id block_id, b.name block, b.bytes,
		        NVL2(dataset_subs.destination, 'y', 'n') dataset_subscribed,
		        NVL2(block_subs.destination, 'y', 'n') block_subscribed,
                        bd.block block_queued
   	           from t_dps_dataset ds
		   join t_dps_block b on b.dataset = ds.id
                   join t_dps_block_replica br on br.block = b.id
                   join t_adm_node n on n.id = br.node
              left join t_dps_subscription block_subs on block_subs.destination = n.id and block_subs.block = b.id
              left join t_dps_subscription dataset_subs on dataset_subs.destination = n.id and dataset_subs.dataset = ds.id
              left join t_dps_block_delete bd on bd.block = b.id and bd.node = n.id
		  where n.name in ($node_list)
	          order by n.name, ds.name };

    my $q = &dbexec($$self{DBH}, $sql, %node_binds);
    my @matches;
    my @dupes;
    my %usermatch = map { $_ => 0 } keys %userdata;
    my $blockwarnings = 0;
    ITEM: while (my $row = $q->fetchrow_hashref()) {
	foreach (keys %userdata) {
	    my $kind = $userdata{$_}; # DATASET or BLOCK
	    my $pattern = glob_to_regex($_);
	    if ($$row{$kind} =~ $pattern) {
		if ($rm_subscriptions && $kind eq 'BLOCK' && $$row{DATASET_SUBSCRIBED} eq 'y') {
		    $$row{BLOCKWARN} = 1;
		    $blockwarnings++;
		}
		if ($$row{BLOCK_QUEUED}) {
		    push @dupes, $row;
		} else {
		    push @matches, $row;
		}
		$usermatch{$_}++;
		next ITEM;
	    }
	}
    }
    my @nomatch = grep $usermatch{$_} == 0, keys %usermatch;

 #   &dump_var($$self{CONTENT}, 'matches', [@matches]);

    if (!param('execute')) {
	if (@matches) {
	    print {$$self{CONTENT}}
	    "<h1>Confirm Deletion</h1>",
	    "<h2>Blocks To Be Deleted</h2>",
	    "<p>The following blocks matched your selection and will be deleted upon your confirmation.</p>",
	    ($rm_subscriptions ? "<p>Subscriptions, where they exist,  will also be deleted.</p>" :
	     "<p>Subscriptions will <b>not</b> be removed, so you can expect a retransfer to be initiated</p>");
	    
	    # List matches for user confirmation
	    my $table = new Web25::TableSpool;
	    $table->set_filehandle($$self{CONTENT});
	    $table->set_tableclass('data');
	    $table->set_stripeclass('stripe');
	    $table->set_tablecols([qw(NODE DATASET BLOCK SUBSCRIBED BYTES)]);
	    $table->set_tablehead({NODE => 'Node',
				   DATASET => 'Dataset',
				   BLOCK => 'Block',
				   SUBSCRIBED => 'Block Subscribed?',
				   BYTES => 'Bytes' });
	    $table->add_pseudocolumn( SUBSCRIBED => sub { my ($ds, $b) = ($_[1]->{DATASET_SUBSCRIBED}, 
									  $_[1]->{BLOCK_SUBSCRIBED});
							  if ($ds eq 'y') { return 'Yes, via dataset'; }
							  elsif ($b eq 'y') { return 'Yes' }
							  else { return 'No' } });
	    $table->set_dataformats({ BYTES => sub { &format_size($_[0]) } });
	    $table->set_rowformats({ BLOCKWARN => sub { return $_[0] ? 'alarm' : '' } });
	    $table->start();
	    $table->head();
	    $table->row($_) foreach @matches;
	    $table->finish();
	}

	if (@dupes) {
	    print {$$self{CONTENT}}
	    "<h2>Blocks Already Queued</h2>",
	    "<p>Patience!  The following blocks you selected are already queued for deletion!  ",
	    "They will not be queued again.</p>";
	    my $table = new Web25::TableSpool;
	    $table->set_filehandle($$self{CONTENT});
	    $table->set_tableclass('data');
	    $table->set_stripeclass('stripe');
	    $table->set_tablecols([qw(NODE DATASET BLOCK)]);
	    $table->set_tablehead({NODE => 'Node',
				   DATASET => 'Dataset',
				   BLOCK => 'Block'});
	    $table->start();
	    $table->head();
	    $table->row($_) foreach @dupes;
	    $table->finish();
	}
	
	if (@nomatch) {
	    print {$$self{CONTENT}}
	    "<h2>Not Matched</h2>",
	    "<p>These selections did not match any known replicas that PhEDEx can delete.</p>";
	    my $table = new Web25::TableSpool;
	    $table->set_filehandle($$self{CONTENT});
	    $table->set_tableclass('data');
	    $table->set_stripeclass('stripe');
	    $table->start();
	    $table->head('Selection');
	    $table->row($_) foreach @nomatch;
	    $table->finish();
	}
	
	if (!@matches) {
	    $self->alert("None of your selections matched replicas PhEDEx can delete.");
	    return;
	}

	if ($blockwarnings) {
	    $self->alert("You are trying to delete a <b>specific block and its subscription</b> for which a ",
			 "<b>dataset subscription</b> exists (offending block shown in red).  This is not ",
			 "allowed by the system.  You must go back and choose:",
			 "<ol style='text-align:  left'><li>Not to delete subscriptions (block will be retransferred), or</li>",
			 "    <li>Not to delete the block in question, or</li>",
			 "    <li>To delete the dataset the block belongs to, instead of only the block</li></ul>");
	    return;
	}

	my $delete_url = $self->myurl();
	my @save = map { hidden($_, param($_)) } param();
 	print {$$self{CONTENT}}
	"<form method='post' action='$delete_url'>",
	hidden(-name=>'execute', -value=>1),
	@save,
	"<p>", submit(-value=>'Yes, I really want to delete all this data'), "</p>",
	"</form>";
    } else {
	my $data_delete_sql = qq{ insert into t_dps_block_delete (time_request, node, dataset, block)
				  values (:time, :node, :dataset, :block) };
	my $subs_delete_sql = qq{ delete from t_dps_subscription where destination = :dest and THING = :id };

	my $subs_update_sql = qq{ update t_dps_subscription set time_complete = NULL
				   where destination = :dest and THING = :id };

	my $now = time();

	my ($n_delete, $n_rm_subs) = (0, 0);
	my ($sth, $rv);
	MATCH: foreach (@matches) {
	    ($sth, $rv) = &dbexec($$self{DBH}, $data_delete_sql,
				     ':time' => $now,
				     ':node' => $$_{NODE_ID},
				     ':dataset' => $$_{DATASET_ID},
				     ':block' => $$_{BLOCK_ID});
	    $n_delete += $rv;

	    # Delete subscriptions if the user requested it, otherwise
	    # leave the subscription in place but set time_complete to
	    # be null
	    my ($item, $id);
	    if ($$_{DATASET_SUBSCRIBED} eq 'y') {
		$item = 'dataset';
		$id = $$_{DATASET_ID};
	    } elsif ($$_{BLOCK_SUBSCRIBED} eq 'y') {
		$item = 'block';
		$id = $$_{BLOCK_ID};
	    } else {
		next MATCH;
	    }
	    my $subs_sql = $rm_subscriptions ? $subs_delete_sql : $subs_update_sql;;
	    $subs_sql =~ s/THING/$item/;
	    ($sth, $rv) = &dbexec($$self{DBH}, $subs_sql,
				  ':dest' => $$_{NODE_ID},
				  ':id' => $id);
	    $n_rm_subs += $rv if $rm_subscriptions;
	    
	}
	$$self{DBH}->commit();

	print {$$self{CONTENT}}
	"<h1>Delete Confirmed</h1>",
	"<p>$n_delete blocks queued for deletion.</p>",
	( $rm_subscriptions ? "<p>$n_rm_subs subscriptions removed</p>" : '');
    }
}

1;



######################################################################
package Web25::Reports::DailyReports;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Daily Reports",
	       LINK_TITLE => "Browse all daily reports" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my @reports = sort <$reportdir/$dbname-*.txt*>;
  print { $$self{CONTENT} }
    "<p><table class='striped'><tbody>\n",
    "<tr class='selected'><th colspan='32'>Available reports</th></tr>\n",
    "<tr class='selected'>\n",
    " <th>Month</td>\n",
    (map { sprintf " <th>%02d</th>\n", $_ } 1 .. 31),
    "</tr>\n";
  my $prev = "";
  my $prevday = 0;
  foreach my $file (@reports)
  {
    my $basename = $file; $basename =~ s|.*/||;
    my $cleanname = $basename; $cleanname =~ s|^$dbname-||;
    my $url = $self->myurl("page" => "Reports::DailyReport", "reportfile" => $cleanname);
    my ($year, $month, $day) = ($cleanname =~ /(\d\d\d\d)(\d\d)(\d\d)\..*/);
    if ("$year-$month" ne $prev)
    {
      if ($prev)
      {
        while (++$prevday <= 31) { print { $$self{CONTENT} } "<td></td>\n"; }
        print { $$self{CONTENT} } "</tr>\n";
      }

      print { $$self{CONTENT} } "<tr>\n <td>$year&#8209;$month</td>\n";
      $prev = "$year-$month";
      $prevday = 0;
    }
    while (++$prevday < $day) { print { $$self{CONTENT} } " <td></td>\n"; }
    print { $$self{CONTENT} } "<td align='center'><a href='$url'>R</a></td>\n";
    $prevday = $day;
  }

  print { $$self{CONTENT} } "</tbody></table></p>\n";
}

1;

######################################################################
package Web25::Reports::DailyReport;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Daily Report",
	       LINK_TITLE => "Show today's daily report" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(reportfile);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Reports::DailyReport");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my $report = param('reportfile') || (strftime('%Y%m%d', gmtime()) . ".txt");
  print { $$self{CONTENT} } "<pre class='wide' align='left'>\n";
  if ($report && $report =~ m|^[-A-Za-z0-9.]+$|)
  {
    my $reportfile = (<$reportdir/$dbname-$report>)[0];
    if (-f $reportfile)
    {
      local $/ = undef;
      open (REPORT, $reportfile =~ /.gz$/ ? "gzip -dc < $reportfile |" : "< $reportfile");
      my $report = <REPORT>;
      close (REPORT);
      $report =~ s/&/&amp;/gso;
      $report =~ s/</&lt;/gso;
      $report =~ s/>/&gt;/gso;
      $report =~ s/\"/&quot;/gso;
      print { $$self{CONTENT} } $report;
    }
  }
  print { $$self{CONTENT} } "</pre>\n";
}

1;

######################################################################
package Web25::Reports::Size;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "File Sizes",
	       LINK_TITLE => "Show file size distribution and other statistics" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my $overview = $$self{DBH}->selectrow_arrayref(qq{
    select time_update, n_files, sz_total, sz_min, sz_max, sz_mean, sz_median
    from t_status_file_size_overview});
  my $histo = $$self{DBH}->selectall_arrayref(qq{
    select time_update, bin_low, bin_width, n_total, sz_total
    from t_status_file_size_histogram order by bin_low asc});

  print { $$self{CONTENT} }
    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='6'>File size statistics ", &age($now - $overview->[0]), " ago</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    " <th>Min Size</th>\n",
    " <th>Max Size</th>\n",
    " <th>Mean Size</th>\n",
    " <th>Median Size</th>\n",
    "</tr>\n",
    "<tr>\n",
    " <td align='right'>@{[&format_num($overview->[1])]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[2], 0, 2, 'T')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[3], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[4], 0, 2, 'G')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[5], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[6], 0, 2, 'M')]}</td>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>",

    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='4'>File size breakdown</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th colspan='2'>Bin</th>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    "</tr>\n";

  foreach my $row (@$histo)
  {
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td align='right'>@{[&format_size($row->[1] * $row->[2],1,2,'G')]} ..</td>\n",
      " <td align='right'>@{[&format_size(($row->[1]+1) * $row->[2],1,2,'G')]}</td>\n",
      " <td align='right'>@{[&format_num($row->[3])]}</td>\n",
      " <td align='right'>@{[&format_size($row->[4],1,2,'T')]}</td>\n",
      "</tr>\n";
  }

  print { $$self{CONTENT} } "</tbody>\n</table>\n</p>\n";
}

1;

######################################################################
package Web25::Test::Test;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use CGI::Session;

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Test Functions",
	       SESSION => 1,
	       LINK_TITLE => "Testing Page" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  

  &dump_var($$self{CONTENT}, 'TESTING', $TESTING);
  return if (!$TESTING);  # For security
  &dump_var($$self{CONTENT}, '$PERL_VERSION', sprintf("v%vd", $^V));
  &dump_var($$self{CONTENT}, 'CGI::VERSION', $CGI::VERSION);
  &dump_var($$self{CONTENT}, 'CGI::Session::VERSION', $CGI::Session::VERSION);
  &dump_var($$self{CONTENT}, 'DBI::VERSION', $DBI::VERSION);
  &dump_var($$self{CONTENT}, 'DBD::Oracle::VERSION', $DBD::Oracle::VERSION);
#  &dump_var($$self{CONTENT}, '@INC', [@INC]);
  &dump_var($$self{CONTENT}, 'TESTING_MAIL', $TESTING_MAIL);
  &dump_var($$self{CONTENT}, 'SESSION', $$self{SESSION} ? 'Session OK' : 'NO SESSION');
  &dump_var($$self{CONTENT}, 'SESSIONID', $$self{SESSIONID});
  if ($$self{SESSION} && param('data')) {
      $$self{SESSION}->param('data', param('data'));
      print {$$self{CONTENT}} "<p>Saved data</p>";
  } else {
      print {$$self{CONTENT}} "<form action='#' method='post'>",
      textfield(-name=>'data'),
      submit(),
      "</form>";
  }
  
  my $data = $$self{SESSION}->param('data');
  if ($data) {
      print {$$self{CONTENT}} "<p>Your saved data is $data</p>";
  } else {
      print {$$self{CONTENT}} "<p>No session data.</p>";
  }

  #&dump_var($$self{CONTENT}, 'Config', $$self{CONFIG});
  #&dump_var($$self{CONTENT}, 'Env', {%ENV});
  print {$$self{CONTENT}} 
  "<p>Full URL current  ",     $self->myurl('fullurl'=>1),"</p>",
  "<p>Full URL security on  ", $self->myurl('fullurl'=>1, 'secure'=>1),"</p>",
  "<p>Full URL security off  ",$self->myurl('fullurl'=>1, 'secure'=>0),"</p>",
  "<p>Normal URL current ", $self->myurl(),"</p>",
  "<p>Normal URL security on  ", $self->myurl('secure'=>1),"</p>",
  "<p>Normal URL security off ", $self->myurl('secure'=>0),"</p>";
  
  &dump_var($$self{CONTENT}, 'ENV{HTTPS}', $ENV{HTTPS});
  &dump_var($$self{CONTENT}, 'ENV{HTTP_HTTPS}', $ENV{HTTP_HTTPS});
#   &dump_var($$self{CONTENT}, 'SecMod CertAuth', $$self{SECMOD}->isCertAuthenticated());
#   &dump_var($$self{CONTENT}, 'SecMod PassAuth', $$self{SECMOD}->isPasswdAuthenticated());
#   &dump_var($$self{CONTENT}, 'SecMod Forename', $$self{SECMOD}->getForename());
#   &dump_var($$self{CONTENT}, 'SecMod Surname', $$self{SECMOD}->getSurname());
#   &dump_var($$self{CONTENT}, 'SecMod Username', $$self{SECMOD}->getUsername());
#   &dump_var($$self{CONTENT}, 'SecMod DN', $$self{SECMOD}->getDN());
#   &dump_var($$self{CONTENT}, 'SecMod CERT', $$self{SECMOD}->getCert());

#   &dump_var($$self{CONTENT}, 'SecMod Roles', $$self{SECMOD}->getRoles());

#   &dump_var($$self{CONTENT}, 'authorized nodes', [ $self->fetch_nodes(web_user_auth=>'Site Admin||Data Manager') ]);

#   &dump_var($$self{CONTENT}, 'SecMod Node Map', {$$self{SECMOD}->getPhedexNodeToSiteMap()});
  
#   &dump_var($$self{CONTENT}, 'SecMod CERN Site Admins', [$$self{SECMOD}->getUsersWithRoleForSite('Site Admin', 'CERN')]);

#   &dump_var($$self{CONTENT}, 'SecMod Global Admins', [$$self{SECMOD}->getUsersWithRoleForGroup('Global Admin', 'phedex')]);


}

1;

######################################################################
package main;
BEGIN { use strict; use warnings; $^W=1; }
use CGI qw(:standard);

# Run the script main routine.  Determine which page we are looking
# at, instantiate it, then ask the page to generate itself.
sub runme
{
  # Read PhEDEx web server configuration
  my $config = &read_config();
  #eval "use CGI::Carp qw(fatalsToBrowser)";
  my $secmod_config = $$config{SECMOD_CONFIG};
  if (!$secmod_config) {
      die "ERROR:  SecurityModule config file not set";
  }

  # Set debug mode
  $TESTING = $$config{TESTING_MODE} ? 1 : 0;
  $TESTING_MAIL = $$config{TESTING_MAIL} || undef;

  # Interpret the trailing path suffix: /DB/PAGE?QUERY
  my $path = path_info() || "/prod";
  my ($db, $cgipage) = ("prod", "Info::Main");
  $db = $1 if ($path =~ m!\G/([^/]+)!g);
  $cgipage = $1 if ($path =~ m!\G/([^/]+)!g);

  # Grab the database name from the path info
  $db = "prod" if ! $db || ! exists $$config{INSTANCES}{$db};
  
  # Get the scope object for the page.
  no strict "refs";
  my $type = "Web25::Info::Main";
  $type = "Web25::$cgipage"
    if ($cgipage =~ /^[A-Za-z0-9]+(::[A-Za-z0-9]+)*/
	&& exists ${"Web25::$cgipage\::"}{INDEX}
	&& exists ${"Web25::$cgipage\::"}{new});

  # Instantiate the page object and remember it as a CGI parameter
  # so we can use it in generating links to other pages.
  my $page = &{"$type\::new"}($type);
  $type =~ s!^Web25::!!;
  param('page', $type);
  
  # Initialize the SecurityModule
  unless ($cgipage =~ /^XML/) {
      $page->initSecurityModule($secmod_config);
  }

  # Generate the page
  $page->generate($config, $db);
}

# Parses DBParam file, returns a configuration object
# TODO:  Should just use Toolkit/Common/UtilsDB
sub parseDatabaseInfo
{
    my ($file, $section) = @_;
    my $self = {};
    $$self{DBCONFIG} = $file.':'.$section;

    $$self{DBH_LIFE} = 86400;
    $$self{DBH_AGE} = 0;
    if ($$self{DBCONFIG} =~ /(.*):(.*)/)
    {
	$$self{DBCONFIG} = $1;
	$$self{DBSECTION} = $2;
    }

    my $insection = $$self{DBSECTION} ? 0 : 1;
    open (DBCONF, "< $$self{DBCONFIG}")
	or die "$$self{DBCONFIG}: $!\n";

    while (<DBCONF>)
    {
	chomp; s/#.*//; s/^\s+//; s/\s+$//; s/\s+/ /g; next if /^$/;
	if (/^Section (\S+)$/) {
	    $insection = ($1 eq $$self{DBSECTION});
	} elsif (/^Interface (\S+)$/) {
	    $$self{DBH_DBITYPE} = $1 if $insection;
	} elsif (/^Database (\S+)$/) {
	    $$self{DBH_DBNAME} = $1 if $insection;
	} elsif (/^AuthDBUsername (\S+)$/) {
	    $$self{DBH_DBUSER} = $1 if $insection;
	} elsif (/^AuthDBPassword (\S+)$/) {
	    $$self{DBH_DBPASS} = $1 if $insection;
	} elsif (/^AuthRole (\S+)$/) {
	    $$self{DBH_DBROLE} = $1 if $insection;
	} elsif (/^AuthRolePassword (\S+)$/) {
	    $$self{DBH_DBROLE_PASS} = $1 if $insection;
	} elsif (/^ConnectionLife (\d+)$/) {
	    $$self{DBH_LIFE} = $1 if $insection;
	    $$self{DBH_CACHE} = 0 if $insection && $1 == 0;
	} elsif (/^LogConnection (on|off)$/) {
	    $$self{DBH_LOGGING} = ($1 eq 'on') if $insection;
	} elsif (/^LogSQL (on|off)$/) {
	    $ENV{PHEDEX_LOG_SQL} = ($1 eq 'on') if $insection;
	} elsif (/^SessionSQL (.*)$/) {
	    push(@{$$self{DBH_SESSION_SQL}}, $1);
	} else {
	    die "$$self{DBCONFIG}: $.: Unrecognised line\n";
	}
    }
    close (DBCONF);

    die "$$self{DBCONFIG}: database parameters not found\n"
	if (! $$self{DBH_DBITYPE} || ! $$self{DBH_DBNAME}
	    || ! $$self{DBH_DBUSER} || ! $$self{DBH_DBPASS});

    die "$$self{DBCONFIG}: role specified without username or password\n"
	if ($$self{DBH_DBROLE} && ! $$self{DBH_DBROLE_PASS});
    return $self;
}

sub read_config
{
  my $config_file = $ENV{PHEDEX_SERVER_CONFIG}
    || die "No server configuration.\n";

  $config_file =~ s/DEVNAME/$ENV{PHEDEX_DEV}/;
  open (CONFIG, "< $config_file")
    || die "$config_file: cannot read server configuration: $!\n";

  my $config = {};
  my $instance_rank = 0;
  while (1)
  {
    my $line = &parse_line($config_file);
    if (! defined $line)
    {
      last;
    }
    elsif ($line =~ /^$/)
    {
      next;
    }
    elsif ($line =~ /^([-a-zA-Z0-9]+):\s+(\S+)$/)
    {
	my $name = uc $1;
	my $value = $2;
	$name =~ s/-/_/g;
	
	$$config{$name} = $value;
    }
    elsif ($line =~ /^instance:\s+([\S\s]+)$/)
    {
      my $rest = $1;
      my $info = {};
      while ($rest =~ /\G([-a-z]+)\s*=\s*(\S+)\s*/g)
      {
        my $name = uc($1);
        my $value = $2;
        $name =~ s/-/_/g;
        $$info{$name} = $value;
      }

      my @required = qw(ID TITLE CONNECTION);
      my @missing = map { s/_/-/g; lc; } grep(! exists $$info{$_}, @required);
      die "$config_file: instance is missing parameters '@missing'\n" if @missing;
      my $dbparam_config = &parseDatabaseInfo($$config{DBPARAM}, $$info{CONNECTION});
      $$info{DBPARAM} = $dbparam_config;
      $$info{RANK} = $instance_rank++;
      $$config{INSTANCES}{$$info{ID}} = $info;
    }
    else
    {
      die "$config_file: unexpected parameters '$line'\n";
    }
  }

  close (CONFIG);
  return $config;
}

sub input_line
{
  my $line = <CONFIG>;
  return undef if ! defined $line;

  chomp($line);
  $line =~ s/#.*//;
  $line =~ s/^\s+//;
  $line =~ s/\s+$//;
  $line =~ s/\s+/ /;
  return $line;
}

sub parse_line
{
  my ($file) = @_;
  my $line = &input_line();
  return undef if ! defined $line;

  while (substr($line,-1,1) eq '\\')
  {
    chop($line);
    my $next = &input_line();
    die "$file: file ends in '\\', expected continued line\n"
      if ! defined $next;
    $line .= " ";
    $line .= $next;
  }

  return $line;
}

&runme();
exit(0);
