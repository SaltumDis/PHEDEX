#!/usr/bin/env perl
package requests23; use strict; use warnings; use base 'Exporter';
use CGI qw(:standard);
use CGI::Carp qw(fatalsToBrowser);
use DBI;
use Net::hostent;
require Socket;

sub runme
{
  my $thispage = param('page');
  if (! $thispage || ! exists $Web::Request::{"${thispage}::"})
  {
    param('page', $thispage = 'Main');
  }

  my $page = &{$Web::Request::{"${thispage}::"}{new}}("Web::Request::$thispage");
  $page->generate(@_);
}

######################################################################
package Web::Common; use strict; use warnings; use base "Exporter";
use CGI qw(:standard);

our @EXPORT = qw(relurl baseurl urlencode dblink
		 alert warning note
		 format_num format_size
		 badcolor warncolor pendcolor goodcolor altcolor
		 dbexec dbprep dbbindexec makeObjWithAttrs);

our $badcolor = '#ff9e9e';
our $warncolor = '#ffd89e';
our $pendcolor = '#ccccff'; # ececff
our $goodcolor = '#ccffcc';
our $altcolor = '#e8e8e8';

sub relurl
{
  my $self = shift(@_);
  my %args = ('db' => $$self{DB}, @_);
  my $newcgi = new CGI (query_string());
  map { $newcgi->param ($_, $args{$_}) } keys %args;
  return $newcgi->self_url(-full=>0, -relative=>1);
}

sub baseurl
{
  my $self = shift(@_);
  my $curpage = param('page');
  my $curview = param('view');
  my %args = ('db' => $$self{DB},
	      ($curview ? ('view' => $curview) : ()),
	      ($curpage ? ('page' => $curpage) : ()),
	      @_);
  my $newcgi = new CGI ("");
  map { $newcgi->param ($_, $args{$_}) } keys %args;
  return $newcgi->self_url(-full=>0, -relative=>1);
}

sub urlencode
{
  eval "use CGI '-oldstyle_urls'";
  my %args = @_; return new CGI (\%args)->query_string();
}

sub dblink
{
  my ($self, $db, $dbother) = @_;
  my $othername = $$self{DATABASES}{$dbother}[3];
  return "<a href='" . &baseurl ($self, 'db' => $dbother)
    . ($db eq $dbother ? "' class='selected' " : "' ")
    . "title='$othername Database Instance'>$othername</a>";
}

sub alert
{
  my $self = shift(@_);
  print { $$self{OUT} } "<div class='alert'><p><b>Error:</b> ", @_, "</p></div>\n";
}

sub warning
{
  my $self = shift(@_);
  print { $$self{OUT} } "<div class='warning'><p><b>Warning:</b> ", @_, "</p></div>\n";
}

sub note
{
  my $self = shift(@_);
  print { $$self{OUT} } "<div class='note'><p>", @_, "</p></div>\n";
}

sub format_num
{
  my ($n) = @_;
  return $n ? "$n" : '&#8211;';
}

sub format_size
{
  my ($bytes, $nodash) = @_;
  my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		[ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
  my ($val, $unit) = ($bytes, '');
  while (@bounds && $bytes >= $bounds [0][0])
  {
    $val = $bytes / $bounds[0][0];
    $unit = $bounds[0][1];
    shift (@bounds);
  }

  return $bytes || $nodash ? sprintf('%.1f&nbsp;%sB', $val, $unit) : '&#8211;';
}

sub dbexec
{
  my ($dbh, $sql, %attrs) = @_;
  note($$dbh{private_self}, "<pre>", &escapeHTML($sql), "\n",
       (map { (" * ", &escapeHTML($_), " = ",
	       &escapeHTML($attrs{$_}), "\n") }
	keys %attrs),
       "</pre>");
  foreach my $val (values %attrs)
  {
    $$val = 123 if ref $val;
  }
}

sub makeObjWithAttrs
{
  my ($dbh, $kind, $link, $obj, @attrs) = @_;
  my ($tname, $sname) = ("t_$kind", "seq_$kind");
  my @objfields = keys %$obj;
  my %objattrs = map { (":attr_$_" => $$obj{$_}) } @objfields;
  my $objsql =
    "insert into $tname ("
    . join(", ", "id", @objfields)
    . ")\n values ("
    . join(", ", "$sname.nextval", map { ":attr_$_" } @objfields)
    . ")\n returning id into :id";
  my $id = undef;
  &dbexec($dbh, $objsql, ":id" => \$id, %objattrs);

  $tname .= "_attr"; $sname .= "_attr";
  while (@attrs)
  {
    my ($name, $value) = splice(@attrs, 0, 2);
    &dbexec($dbh, qq{
      insert into $tname (id, $link, name, value)
      values ($sname.nextval, :id, :name, :value)},
      ":id" => $id, ":name" => $name, ":value" => $value);
  }

  return $id;
}

######################################################################
package Web::Request::Page;
use strict; use warnings;
use base "Exporter";
use CGI qw(:standard);
use POSIX qw(strftime);
import Web::Common;

our @reqstates = (
    { STATE => 0, RANK => 0, LABEL => "In preparation" },
    { STATE => 1, RANK => 2, LABEL => "Pending approval" },
    { STATE => 2, RANK => 1, LABEL => "Pending feedback" },
    { STATE => 3, RANK => 3, LABEL => "Approved" },
    { STATE => 4, RANK => 9, LABEL => "Disapproved" },
    { STATE => 5, RANK => 5, LABEL => "Active" },
    { STATE => 6, RANK => 6, LABEL => "Suspended" },
    { STATE => 7, RANK => 7, LABEL => "Completed" },
    { STATE => 8, RANK => 8, LABEL => "Disabled" } );

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {}; # $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub index
{
  my ($self) = @_;
  my @result = ();
  foreach (keys %{Web::Request::})
  {
    next if ! /::$/;
    next if ! exists ${Web::Request::{$_}}{INDEX};
    push (@result, ${Web::Request::{$_}}{INDEX});
  }

  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

sub generate
{
  my ($self, $databases, $db, @dbnames) = @_;
  my ($dbtns, $dbuser, $dbpass, $dbid, $dbversion) = @{$$databases{$db}};
  $$self{DATABASES} = $databases;
  $$self{DB} = $db;

  # Force redirect to https if using http
  if (0 && ($ENV{HTTPS} || 'nope') ne 'on')
  {
    my $url = self_url();
    $url =~ s/^http:/https:/;
    print redirect(-url => $url);
    return;
  }

  # Check if the client's identity was verified
  if ($ENV{SSL_CLIENT_S_DN})
  {
    $$self{SSL_IDENTITY} = $ENV{SSL_CLIENT_S_DN};
    $$self{SSL_CERT} = $ENV{SSL_CLIENT_CERT};
    $$self{SSL_IDENTITY_HTML} = &escapeHTML($$self{SSL_IDENTITY});
    $$self{SSL_IDENTITY_HTML} =~ s|/|/&#8203;|g;
    $$self{SSL_MESSAGE} = "<div class='warningbox'><p><b>Unverified identity,</b> $$self{SSL_IDENTITY_HTML}</p></div>";
    if (($ENV{SSL_CLIENT_VERIFY} || '') eq 'SUCCESS')
    {
      $$self{SSL_VERIFIED} = 1;
      $$self{SSL_MESSAGE} = "<div class='notebox'><p><b>Verified identity,</b> $$self{SSL_IDENTITY_HTML}</p></div>";
    }
  }
  else
  {
    $$self{SSL_MESSAGE} = "<div class='alertbox'><p><b>You are not authenticated.</b></p></div>";
  }

  # Check whether we are looking at our vs. global view
  if ($$self{MY_VIEW} = ((param('view') || 'my') eq 'my'))
  {
    my $otherurl = &baseurl($self, 'view' => 'global');
    $$self{VIEW_MESSAGE} = qq!
      <div class='notebox'>
        <p><b>Your</b> view.  <a href='$otherurl'>View all.</a></p>
      </div>!;
  }
  else
  {
    my $otherurl = &baseurl($self, 'view' => 'my');
    $$self{VIEW_MESSAGE} = qq!
      <div class='warningbox'>
        <p><b>Complete</b> view.  <a href='$otherurl'>View yours.</a></p>
      </div>!;
  }

  # Select page we are visiting
  my %pagemap;
  my @pages = $self->index();
  foreach (@pages)
  {
    my ($name) = (*{$_}{PACKAGE} =~ /.*::(.*)/);
    $pagemap{$_} = $name;
  }

  my $page = param('page');

  # Initialise page template
  my $templatef = $0; $templatef =~ s|/[^/]+$||; $templatef .= "/req-template.html";
  my $template = do { open(T, "< $templatef"); local $/; undef $/; my $x = <T>; close(T); $x };

  my $replacements = {
    'CONTENT' => '',
    'PAGETITLE' => ${${$Web::Request::{"${page}::"}{INDEX}}}{TITLE},
    'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
    'DBID' => $dbid,
    'DB' => $db,
    'DBSELECTOR' =>
      ("  <ul id='navmain'>\n" .
       "    <li class='first'>Database: " .  &dblink ($self, $db, $dbnames[0]) .
       "</li>\n    " .
       join ("\n    ",
             map { "<li>" . &dblink ($self, $db, $_) . "</li>" }
	     @dbnames[1 .. $#dbnames]) .
       "\n  </ul>\n"),
    'PAGESELECTOR' =>
      (join("", map { (${$$_}{ORDER} > 0 ? "<br>" : "")
		      . ($pagemap{$_} eq $page ? "<b>"
		         : ("<a href='" . &baseurl ($self, 'page' => $pagemap{$_}) .  "'>"))
		      . ${$$_}{TITLE}
		      . ($pagemap{$_} eq $page ? "</b>" : "</a>") . "\n    " }
	    grep (${$$_}{LIST}, @pages))),
    'IDENTITY' => $$self{SSL_MESSAGE},
    'MYPAGE' => $$self{VIEW_MESSAGE},
  };

  # Execute the desired page.  We save old STDOUT to print to it
  # later, then redirect the page routine's output to CONTENT.
  my $output = "";
  open ($$self{OUT}, ">", \$output);
  eval
  {
    # print { $$self{OUT} } "<pre>\n", (map { "$_ = $ENV{$_}\n" } sort keys %ENV), "</pre>\n";
    # Connect to the database, do the page, the disconnect
    $$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		        { RaiseError=>1, AutoCommit =>1 });
    $$self{DBH}{private_self} = $self;
    $self->output();
    $$self{DBH}->disconnect();
    delete $$self{DBH};
  };

  if ($@)
  {
    my $message = $@;
    $message = &escapeHTML($message);
    print { $$self{OUT} }
      "<div align='left'>\n",
      "<p>Apologies, looks like we have a server error,",
      " details of which below.</p>\n",
      "<p><i>$message</i></p>\n",
      "</div>\n";
  }
  close($$self{OUT});
  $$replacements{CONTENT} = join("\n", $output);

  # Instantiate the template and spit it out
  while (my ($key, $value) = each %$replacements)
  {
    $template =~ s/\@$key\@/$value/g;
  }

  print header(-type => 'text/html'), $template;
}

1;

######################################################################
package Web::Request::Main;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 0, TITLE => "Overview" };
use CGI qw(:standard);
import Web::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my ($qtask, $qreq, $qsite);
    if ($$self{MY_VIEW})
    {
	$qtask = $$self{DBH}->prepare(qq{
	    select count(t.id)
	    from t_adm_identity_attr ia
	      join t_req_task t
	        on t.person = ia.identity
	    where ia.name = 'Distinguished Name'
	      and ia.value = :client_dn});
	$qtask->bind_param(":client_dn", $$self{SSL_IDENTITY});

	$qreq = $$self{DBH}->prepare(qq{
	    select req.state, count(req.id)
	    from t_adm_identity_attr ia
	      join t_adm_client c
	        on c.identity = ia.identity
	      join t_req_request req
	        on req.creator = c.id
	    where ia.name = 'Distinguished Name'
	      and ia.value = :client_dn
	    group by req.state});
	$qreq->bind_param(":client_dn", $$self{SSL_IDENTITY});

	$qsite = $$self{DBH}->prepare(qq{
	    select req.state, count(req.id)
	    from t_req_request req
	    where exists
	      (select 1
	       from t_req_action ra
	         join t_req_action_attr raa on raa.action = ra.id
	         join t_node n on n.name = raa.value
		 join t_adm_site_node sn on sn.node = n.id
		 join t_adm_site_admin sa on sa.site = sn.site
		 join t_adm_identity_attr ia on ia.identity = sa.identity
	       where ra.request = req.id
	         and raa.name = 'Destination'
	         and ia.name = 'Distinguished Name'
	         and ia.value = :client_dn)
	    group by req.state});
        $qsite->bind_param(":client_dn", $$self{SSL_IDENTITY});
    }
    else
    {
	$qtask = $$self{DBH}->prepare(qq{
	    select count(t.id)
	    from t_req_task t});

	$qreq = $$self{DBH}->prepare(qq{
	    select req.state, count(req.id)
	    from t_req_request req
	    group by req.state});

	$qsite = $qreq;
    }

    $qtask->execute();
    my ($tasks) = $qtask->fetchrow();

    my $your = $$self{MY_VIEW} ? "Your" : "All";
    print { $$self{OUT} }
        "<div align='left'>",
        "<p><a href='@{[&baseurl($self, 'page' => 'Tasks')]}'>$your pending tasks</a></p>\n",
        "<ul>\n",
        " <li> ", ($tasks ? "$tasks Tasks" : "None"), "</li>\n",
        "</ul>\n",
	"<p><a href='@{[&baseurl($self, 'page' => 'Requests')]}'>$your transfer requests</a></p>\n",
        "<ul>\n";

    my $n = 0;
    my %status = ();
    $qreq->execute();
    while (my ($state, $count) = $qreq->fetchrow())
    {
	$status{$state} = $count;
    }

    foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
    {
	my $s = $$state{STATE};
	next if ! $status{$s};
	print { $$self{OUT} } " <li> $status{$s} $$state{LABEL}</li>\n";
	$n += $status{$s};
    }

    print { $$self{OUT} }
        " <li> ", ($n ? "$n Total" : "None"), "</li>\n",
        "</ul>\n",
        "<p><a href='@{[&baseurl($self, 'page' => 'Site')]}'>Site activity for @{[lc($your)]} sites</a></p>\n",
        "<ul>\n";

    $n = 0;
    %status = ();
    $qsite->execute();
    while (my ($state, $count) = $qsite->fetchrow())
    {
	$status{$state} = $count;
    }

    foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
    {
	my $s = $$state{STATE};
	next if ! $status{$s};
	print { $$self{OUT} } " <li> $status{$s} $$state{LABEL}</li>\n";
	$n += $status{$s};
    }

    print { $$self{OUT} }
        " <li> ", ($n ? "$n Total" : "None"), "</li>\n",
        "</ul>\n",
        "</div>\n";
}

######################################################################
package Web::Request::Tasks;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Tasks" };
use CGI qw(:standard);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my $qtask;
    if ($$self{MY_VIEW})
    {
	$qtask = $$self{DBH}->prepare(qq{
	    select t.id, t.time_create, r.id, r.name, r.state, a.action
	    from t_adm_identity_attr ia
	      join t_req_task t on t.person = ia.identity
	      join t_req_action a on a.id = t.action
	      join t_req_request r on r.id = a.request
	    where ia.name = 'Distinguished Name'
	      and ia.value = :client_dn
            order by a.action, t.time_create asc, r.id asc});
	$qtask->bind_param(":client_dn", $$self{SSL_IDENTITY});
    }
    else
    {
	$qtask = $$self{DBH}->prepare(qq{
	    select t.id, t.time_create, r.id, r.name, r.state, a.action
	    from t_req_task t
	      join t_req_action a on a.id = t.action
	      join t_req_request r on r.id = a.request
	    order by a.action, t.time_create asc, r.id asc});
    }

    my $n = 0;
    $qtask->execute();
    while (my ($tid, $tcreate, $rid, $rname, $rstate, $action) = $qtask->fetchrow())
    {
	print { $$self{OUT} } "<pre>$action $rname ($tid $tcreate $rid $rstate)</pre>";
	++$n;
    }

    if (! $n)
    {
	print { $$self{OUT} } "<p>No pending tasks to show.</p>";
    }
}

######################################################################
package Web::Request::Site;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Site Status" };
use CGI qw(:standard);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
}

######################################################################
package Web::Request::Requests;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Requests" };
use CGI qw(:standard);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my $rquery;
    my $dquery = $$self{DBH}->prepare(qq{
	select
	  ri.time_update, n.name,

	  count(rid.dataset),
	  sum(case when rid.dbs_isknown = 'y' then 1 else 0 end),
	  sum(case when rid.dps_isknown = 'y' then 1 else 0 end),

	  count(rib.block),
	  sum(case when rib.dbs_isknown = 'y' then 1 else 0 end),
	  sum(rib.dbs_files), sum(rib.dbs_bytes),
	  sum(rib.dbs_only_files), sum(rib.dbs_only_bytes),
	  sum(case when rib.dps_isknown = 'y' then 1 else 0 end),
	  sum(rib.dps_files), sum(rib.dps_bytes),
	  sum(rib.dps_only_files), sum(rib.dps_only_bytes),

	  sum(dbr.node_files), sum(dbr.node_bytes)
	from t_req_info ri
	  left join t_req_info_dest rin
	    on rin.request = ri.request
	  left join t_node n
	    on n.id = rin.destination
	  left join t_req_info_dataset rid
	    on rid.request = ri.request
	  left join t_req_info_block rib
	    on rib.request = ri.request
	    and rib.dbs = rid.dbs
	    and rib.dataset = rid.dataset
          left join t_dps_dbs ddbs
	    on ddbs.name = rid.dbs
	  left join t_dps_dataset dds
	    on dds.dbs = ddbs.id
	    and dds.name = rid.dataset
          left join t_dps_block db
	    on db.dataset = dds.id
	    and db.name = rib.block
    	  left join t_dps_block_replica dbr
	    on dbr.block = db.id
	    and dbr.node = rin.destination
    	where ri.request = :request
	group by ri.time_update, n.name});

    if ($$self{MY_VIEW})
    {
	$rquery = $$self{DBH}->prepare(qq{
	    select req.id, req.name, req.state, ranew.time_apply
	    from t_adm_identity_attr aia
	      join t_adm_client acl
	        on acl.identity = aia.identity
	      join t_req_request req
	        on req.creator = acl.id
	      left join t_req_action ranew
	        on ranew.request = req.id
		and ranew.action = 'Create'
	    where aia.name = 'Distinguished Name'
	      and aia.value = :client_dn});
	$rquery->bind_param(":client_dn", $$self{SSL_IDENTITY});
    }
    else
    {
	$rquery = $$self{DBH}->prepare(qq{
	    select req.id, req.name, req.status, ranew.time_apply
	    from t_req_request req
	      left join t_req_action ranew
	        on ranew.request = req.id
		and ranew.action = 'Create'});
    }

    my %status = ();
    $rquery->execute();
    while (my ($req, $name, $state, $created) = $rquery->fetchrow())
    {
	$status{$req} = {
	    ID => $req,
	    NAME => $name,
	    STATE => $state,
	    CREATED => $created
        };

	$dquery->bind_param(":request", $req);
	$dquery->execute();
	while (my @row = $dquery->fetchrow())
	{
	    $status{$req}{STATS}{$row[1]} = [ @row ];
	}
    }

    use Data::Dumper;
    print { $$self{OUT} } "<pre>\n",
          &escapeHTML(Dumper(\%status)),
	  "</pre>\n";
    return;

    print { $$self{OUT} }
          "<table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='8'>Transfer request status</th>",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th rowspan='2'>Request</th>\n",
	  " <th rowspan='2'>Destination</th>\n",
	  " <th colspan='2'>Known Files</th>\n",
	  " <th colspan='2'>Destination</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  "</tr>\n";

    foreach my $req (sort { $b cmp $a } keys %status)
    {
	my @dest = sort keys %{$status{$req}};
	for (my $i = 0; $i <= $#dest; ++$i)
	{
	    my $dest = $dest[$i];
	    my $x = $status{$req}{$dest};
	    my $tmdb_color = ($x->{TMDB_FILES} == $x->{DBS_FILES} ? "" : " bgcolor='$pendcolor'");
	    my $node_color = ($x->{NODE_FILES} == $x->{TMDB_FILES} ? "" : " bgcolor='$pendcolor'");
	    print { $$self{OUT} } "<tr>\n",
	          ($i != 0 ? "" :
		   (" <td rowspan='@{[scalar @dest]}'><a href='" .
		    &baseurl($self, 'page' => 'Detail', 'request' => quotemeta($req)) .
		    "'>$req</a></td>\n")),
	          " <td>$dest</td>\n",
	          " <td align='right'$tmdb_color>", &format_num ($x->{TMDB_FILES}), "</td>\n",
	          " <td align='right'$tmdb_color>", &format_size ($x->{TMDB_BYTES}), "</td>\n",
	          " <td align='right'$node_color>", &format_num ($x->{NODE_FILES}), "</td>\n",
	          " <td align='right'$node_color>", &format_size ($x->{NODE_BYTES}), "</td>\n",
	          "</tr>\n";
	}
    }

    print { $$self{OUT} } "</tbody>\n",
          "</table>\n",
	  "</p>\n";
}

######################################################################
package Web::Request::Detail;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Request Details" };
use CGI qw(:standard);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my %status = ();
    my $reqparam = param('request') || '';
    my $rquery = $$self{DBH}->prepare(qq{
	select
	  r.name, s.block,
	  min(s.dbs_files), min(s.dbs_bytes),
	  min(s.tmdb_files), min(s.tmdb_bytes),
	  min(s.common_files), min(s.dbs_only_files), min(s.tmdb_only_files)
	from t_request r join t_request_status s on s.request = r.id
	group by r.name, s.block});
    $rquery->execute();
    while (my ($req, $block,
	       $dbs_files, $dbs_bytes,
	       $tmdb_files, $tmdb_bytes,
	       $common, $dbs_only, $tmdb_only) = $rquery->fetchrow())
    {
	$status{$req}{$block} = {
	    DBS_FILES => $dbs_files, DBS_BYTES => $dbs_bytes,
	    TMDB_FILES => $tmdb_files, TMDB_BYTES => $tmdb_bytes,
	    COMMON => $common, DBS_ONLY => $dbs_only, TMDB_ONLY => $tmdb_only
	};
    }

    print { $$self{OUT} } "<p>",
          "<form method='GET' action='@{[&baseurl($self)]}'>\n",
          "<input type='hidden' name='page' value='@{[param('page')]}'>\n",
          "<input type='hidden' name='db' value='$$self{DB}'>\n",
          "Filter Request: ",
          textfield(-name=>'request', -default=>$reqparam, -size=>30),
          " <input type='submit' value='Update'></form></p>\n",

	  "<p>\n",
          "<table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='8'>Transfer request status</th>",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th rowspan='2'>Block</th>\n",
	  " <th colspan='2'>DBS</th>\n",
	  " <th colspan='2'>TMDB</th>\n",
	  " <th colspan='3'>Difference</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  " <th>Common</th>\n",
	  " <th>DBS</th>\n",
	  " <th>TMDB</th>\n",
	  "</tr>\n";

    foreach my $req (sort { $b cmp $a } keys %status)
    {
	next if $reqparam && $req !~ /$reqparam/;

	my @blocks = sort keys %{$status{$req}};
	for (my $i = 0; $i <= $#blocks; ++$i)
	{
	    my $block = $blocks[$i];
	    my $x = $status{$req}{$block};
	    my $tmdb_color = ($x->{TMDB_FILES} == $x->{DBS_FILES} ? "" : " bgcolor='$pendcolor'");
	    my $common_color = ($x->{COMMON} == $x->{DBS_FILES} ? "" : " bgcolor='$warncolor'");
	    my $dbs_only_color = (!$x->{DBS_ONLY} ? "" : " bgcolor='$warncolor'");
	    my $tmdb_only_color = (!$x->{TMDB_ONLY} ? "" : " bgcolor='$warncolor'");
	    print { $$self{OUT} } "<tr class='selected'>\n",
	          " <td colspan='8'>$req</td>\n",
		  "</tr>\n"
		if $i == 0;
	    print { $$self{OUT} } "<tr>\n",
	          " <td>$block</td>\n",
	          " <td align='right'>", &format_num ($x->{DBS_FILES}), "</td>\n",
	          " <td align='right'>", &format_size ($x->{DBS_BYTES}), "</td>\n",
	          " <td align='right'$tmdb_color>", &format_num ($x->{TMDB_FILES}), "</td>\n",
	          " <td align='right'$tmdb_color>", &format_size ($x->{TMDB_BYTES}), "</td>\n",
	          " <td align='right'$common_color>", &format_num ($x->{COMMON}), "</td>\n",
	          " <td align='right'$dbs_only_color>", &format_num ($x->{DBS_ONLY}), "</td>\n",
	          " <td align='right'$tmdb_only_color>", &format_num ($x->{TMDB_ONLY}), "</td>\n",
	          "</tr>\n";
	}
    }

    print { $$self{OUT} } "</tbody>\n",
          "</table>\n",
	  "</p>\n";
}

######################################################################
package Web::Request::CreateTools;
use strict; use warnings;
use base "Exporter";
import Web::Common;
use CGI qw(:standard);
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;

our @EXPORT = qw(getdbslist getnodelist getrequests
		 create_default_email
		 create_check_access
		 create_check_identity
		 create_check_reqname
		 create_check_email
		 create_check_comment
		 create_check_dbs
		 create_check_deps
		 create_check_data
		 create_check_dest
		 create_check_bad);

sub getdbslist
{
  my ($dbh) = @_;
  my %list = ();
  my $q = $dbh->prepare(qq{select id, name from t_dps_dbs});
  $q->execute();
  while (my ($id, $name) = $q->fetchrow()) {
    $list{$name} = $id;
  }
  return %list;
}

sub getnodelist
{
  my ($dbh) = @_;
  my %nodes = ();
  my $qnodes = $dbh->prepare(qq{select name from t_node});
  $qnodes->execute();
  while (my ($node) = $qnodes->fetchrow()) {
    $nodes{$node} = 1;
  }
  foreach my $node (keys %nodes) {
    delete $nodes{$node} if ($node =~ /(.*)_(Buffer|Stage)$/ && exists $nodes{"$1_MSS"});
  }

  return sort keys %nodes;
}

sub getrequests
{
  my ($dbh) = @_;
  my @reqnames = ();
  my $q = $dbh->prepare(qq{select name from t_req_request}); $q->execute();
  while (my ($name) = $q->fetchrow()) {
    push (@reqnames, $name);
  }

  return sort @reqnames;
}

sub create_default_email
{
  my ($self) = @_;
  return undef if ! $ENV{SSL_CLIENT_CERT};
  my $email = qx(echo "\$SSL_CLIENT_CERT" | openssl x509 -noout -email);
  chomp($email);
  return $email;
}

sub create_check_access
{
  my ($self, $bad) = @_;
  return if $$bad;

  if (request_method() != 'POST')
  {
    alert($self, "This form can only be accessed with 'POST' method.");
    $$bad = 1;
  }
}

sub create_check_identity
{
  my ($self, $bad) = @_;
  return if $$bad;

  # Make sure this page can be used
  if (! $$self{SSL_IDENTITY})
  {
    alert($self,
	  "You have not been authenticated and cannot create requests.</p>",
	  "<p>Please make sure you are accessing this service using",
	  " https protocol signed with your grid certificate.  You",
	  " may need to load your grid certificate into your browser",
	  " to achieve that.  The little box on the left will automatically",
	  " indicate when your identity has been successfully verified.");
    $$bad = 1;
    return;
  }

  if (! $$self{SSL_VERIFIED})
  {
    warning($self,
	    "Your identity has not been verified.  The certificate",
	    " presented by your web browser is not a recognised grid",
	    " certificate.  For now you are still allowed to create",
	    " a transfer request.");
  }
}

sub create_check_reqname
{
  my ($self, $bad, $reqname) = @_;
  return undef if $$bad;
  if (! $reqname)
  {
    alert($self, "Request has no name, please supply one.");
    $$bad = 1;
  }

  if ($reqname =~ /DESCRIPTION/)
  {
    alert($self, "Request name &ldquo;@{[&escapeHTML($reqname)]}&rdquo; contains",
	  " template material.  Please replace DESCRIPTION with a succint",
	  " description of why the request is being created.  Note that",
	  " request names must be unique, so please use one that is not",
	  " unnecessarily general.");
    $$bad = 1;
  }

  my @reqnames = &getrequests($$self{DBH});
  if (grep ($reqname eq $_, @reqnames))
  {
    alert($self, "The request name &ldquo;@{[&escapeHTML($reqname)]}&rdquo;",
	  " is already in use.  Please select a different name.");
    $$bad = 1;
  }

  return $$bad ? undef : $reqname;
}

sub create_check_email
{
  my ($self, $bad, $email, $email_list) = @_;
  return undef if $$bad;

  if (! $email)
  {
    alert($self, "No requestor e-mail, please supply one.");
    $$bad = 1;
  }

  my ($nrvalidmails, @emails) = validlist ($email);
  if ($email ne '' && ! $nrvalidmails)
  {
    alert($self, "Requestor e-mail &ldquo;@{[&escapeHTML($email)]}&rdquo; is",
	  " not a valid RFC822 e-mail address or address list.");
    $$bad = 1;
  }

  @$email_list = @emails if $email_list && ! $$bad;
  return $$bad ? undef : $email;
}

sub create_check_comment
{
  my ($self, $bad, $comment) = @_;
  return undef if $$bad;
  return $comment;
}

sub create_check_dbs
{
  my ($self, $bad, $dbs) = @_;
  return undef if $$bad;
  if (! $dbs)
  {
    alert($self, "No DBS selected, please choose a value.");
    $$bad = 1;
  }

  if ($dbs !~ m|^[-=+_:/?&;.a-zA-Z0-9]+$|)
  {
    alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	  " contains unsafe characters.");
    $$bad = 1;
  }

  if ($dbs !~ m!^http://([^/:]+)(:\d+)?/.*\?.*instance=.+!)
  {
    my %dbses = &getdbslist($$self{DBH});
    if (! grep($_ eq $dbs, keys %dbses))
    {
      alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " is not a URL for a DBS service.  Please use a URL of",
	    " the form http://server/path?instance=name.");
      $$bad = 1;
    }
  }
  else
  {
    my $hostname = $1;
    my ($name,$aliases,$addrtype,$length,@addrs)
      = CORE::gethostbyname($hostname);
    if (! $name)
    {
      alert($self, "The host name of the DBS service, &ldquo;",
	    &escapeHTML($hostname), "&rdquo;, did not resolve.",
	    " Please make sure the host is accessible.");
      $$bad = 1;
    }

    my $info = qx(wget -qO- '$dbs;api=listPrimaryDatasets');
    chomp $info if $info;
    if (! $info)
    {
      alert($self, "The DBS contact, &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " does not respond to aliveness check.  Please make sure",
	    " the contact URL points to a correct service.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : $dbs;
}

sub create_check_deps
{
  my ($self, $bad, $deps) = @_;
  return undef if $$bad;

  if (! $deps)
  {
    alert($self, "No selection made for dependencies, please supply one.");
    $$bad = 1;
  }

  if (! grep ($deps eq $_, qw(Yes No)))
  {
    alert($self, "&ldquo;@{[&escapeHTML($deps)]}&rdquo;",
	  " is not a valid dependencies selection.");
    $$bad = 1;
  }

  return $$bad ? undef : $deps;
}

sub create_check_data
{
  my ($self, $bad, $data) = @_;
  return undef if $$bad;

  my @data = split(/\s+/, $data);
  if (! @data)
  {
    alert($self, "No data specified.");
    $$bad = 1;
  }

  foreach my $data (@data)
  {
    if ($data !~ m|^/[^/]+/[^/]+/[^/]+$|)
    {
      warning($self, "The data pattern is &ldquo;@{[&escapeHTML($data)]}&rdquo;",
	      " does not match pattern of type /PRIMARY/TIER/DATASET.");
    }
  }

  return $$bad ? undef : @data;
}

sub create_check_dest
{
  my ($self, $bad, @dests) = @_;
  return undef if $$bad;

  if (! @dests)
  {
    alert($self, "No destination selected, please select some.");
    $$bad = 1;
  }

  my @nodes = &getnodelist($$self{DBH});
  foreach my $node (@dests)
  {
    if (! grep ($_ eq $node, @nodes))
    {
      alert($self, "Node name &ldquo;@{[&escapeHTML($node)]}&rdquo;",
	    " is not known to PhEDEx.");
      $$bad = 1;
    }
  }

  my %destreqs = (T2_Caltech_Buffer	=> 'T1_FNAL_MSS',
	    	  T2_Florida_Buffer	=> 'T1_FNAL_MSS',
		  T2_Nebraska_Buffer	=> 'T1_FNAL_MSS',
		  T2_Purdue_Buffer	=> 'T1_FNAL_MSS',
		  T2_UCSD_Buffer	=> 'T1_FNAL_MSS',
		  T2_Wisconsin_Buffer	=> 'T1_FNAL_MSS',
		  T3_UIowa_Buffer	=> 'T1_FNAL_MSS');


  foreach my $node (@dests)
  {
    next if ! exists $destreqs{$node};
    push (@dests, $destreqs{$node})
    if (! grep ($_ eq $destreqs{$node}, @dests));
  }

  return $$bad ? undef : sort @dests;
}

sub create_check_bad
{
  my ($self, $bad) = @_;
  print { $$self{OUT} } "<p>Please resubmit the form with corrected information.</p>\n" if $bad;
  return $bad;
}

######################################################################
package Web::Request::Create;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Create Request" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my $bad = 0;
    &create_check_identity($self, \$bad);
    return if $bad;

    # Get the client's e-mail address.  By default, use an e-mail
    # from the database if we have one.  Failing that, use the
    # address from the certificate itself.  This order allows the
    # users to change their preferred e-mail address and make the
    # choice sticky.
    my $qemail = $$self{DBH}->prepare(qq{
	select email.value
	from t_adm_identity_attr dn
	  join t_adm_identity_attr email
	    on email.identity = dn.identity
	    and email.name = 'E-mail'
        where dn.name = 'Distinguished Name'
	  and dn.value = :client_dn});
    $qemail->bind_param(':client_dn', $$self{SSL_IDENTITY});
    $qemail->execute();
    my ($email_contact) = $qemail->fetchrow();
    $email_contact = &create_default_email() if ! $email_contact;

    print { $$self{OUT} } "<p>",
    	  "<form method='POST' action='@{[&baseurl($self)]}'>\n",
	  "<input type='hidden' name='page' value='CreateDBS' />\n",
	  "<input type='hidden' name='db' value='$$self{DB}' />\n",
          "<table class='striped'>\n",
	  " <tr class='selected'><th colspan='2'>Create a new request</th></tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Request name</td>\n",
	  "  <td>", textfield(-name=>'reqname', -default=>'DESCRIPTION', -size=>50), "</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Requestor e-mail</td>\n",
	  "  <td>", textfield(-name=>'email', -default=>$email_contact, -size=>50), "</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Additional information</td>\n",
	  "  <td>", textarea('comment', '', 10, 50), "</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td colspan='2' align='center'>", submit('submit', 'Next'), "</td>\n",
	  " </tr>\n",
	  "</table>\n",
	  "</form>\n",
	  "</p>\n";
}

######################################################################
package Web::Request::CreateDBS;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 6, TITLE => "Select DBS for Request" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my $bad = 0;
    &create_check_identity($self, \$bad);
    my $reqname = &create_check_reqname($self, \$bad, param('reqname'));
    my $email = &create_check_email($self, \$bad, param('email'));
    my $comment = &create_check_comment($self, \$bad, param('comment'));
    return if &create_check_bad($self, $bad);

    my %dbses = &getdbslist($$self{DBH});
    my @dbsnames = sort keys %dbses;
    print { $$self{OUT} } "<p>",
    	  "<form method='POST' action='@{[&baseurl($self)]}'>\n",
	  "<input type='hidden' name='page' value='CreateData' />\n",
	  "<input type='hidden' name='db' value='$$self{DB}' />\n",
	  "<input type='hidden' name='reqname' value='@{[&escapeHTML($reqname)]}' />\n",
	  "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
	  "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
          "<table class='striped'>\n",
	  " <tr class='selected'><th colspan='2'>Create a new request</th></tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>DBS instance</td>\n",
	  "  <td>",
	  (map { "   <input type='radio' name='dbs' value='@{[&escapeHTML($_)]}' />&nbsp;" .
		 &escapeHTML($_) . "<br />\n" } @dbsnames),
	  "   <input type='radio' name='dbs' value='NEW' />&nbsp;Other:&nbsp;",
	  textfield(-name=>'newdbs', -default=>'http://path?instance=value', -size=>50),
	  "  </td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td colspan='2' align='center'>", submit('submit', 'Next'), "</td>\n",
	  " </tr>\n",
	  "</table>\n",
	  "</form>\n",
	  "</p>\n";
}

######################################################################
package Web::Request::CreateData;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 7, TITLE => "Select Datasets for Request" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my $bad = 0;
    &create_check_identity($self, \$bad);
    my $reqname = &create_check_reqname($self, \$bad, param('reqname'));
    my $email = &create_check_email($self, \$bad, param('email'));
    my $comment = &create_check_comment($self, \$bad, param('comment'));
    my $dbs = param('dbs');
    $dbs = param('newdbs') if $dbs && $dbs eq 'NEW';
    $dbs = &create_check_dbs($self, \$bad, $dbs);
    return if &create_check_bad($self, $bad);

    print { $$self{OUT} } "<p>",
    	  "<form method='POST' action='@{[&baseurl($self)]}'>\n",
	  "<input type='hidden' name='page' value='CreateDest' />\n",
	  "<input type='hidden' name='db' value='$$self{DB}' />\n",
	  "<input type='hidden' name='reqname' value='@{[&escapeHTML($reqname)]}' />\n",
	  "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
	  "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
	  "<input type='hidden' name='dbs' value='@{[&escapeHTML($dbs)]}' />\n",
          "<table class='striped'>\n",
	  " <tr class='selected'><th colspan='2'>Create a new request</th></tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Include dependencies</td>\n",
	  "  <td>",
	  "<input type='radio' name='dependencies' value='No' />&nbsp;",
	  "No, only the requested datasets<br />\n",
	  "<input type='radio' name='dependencies' value='Yes' />&nbsp;",
	  "Yes, selected datasets and their dependencies</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>/Primary/Tier/Dataset names<br />(glob patterns)</td>\n",
	  "  <td>", textarea('data', '', 10, 50), "</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td colspan='2' align='center'>", submit('submit', 'Next'), "</td>\n",
	  " </tr>\n",
	  "</table>\n",
	  "</form>\n",
	  "</p>\n";
}

######################################################################
package Web::Request::CreateDest;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 8, TITLE => "Select Destinations for Request" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my $bad = 0;
    &create_check_identity($self, \$bad);
    my $reqname = &create_check_reqname($self, \$bad, param('reqname'));
    my $email = &create_check_email($self, \$bad, param('email'));
    my $comment = &create_check_comment($self, \$bad, param('comment'));
    my $dbs = &create_check_dbs($self, \$bad, param('dbs'));
    my $deps = &create_check_deps($self, \$bad, param('dependencies'));
    my @data = &create_check_data($self, \$bad, param('data'));
    return if &create_check_bad($self, $bad);

    # Get list of nodes, but suppress Buffer nodes where MSS exists
    my @nodes = &getnodelist($$self{DBH});
    print { $$self{OUT} } "<p>",
    	  "<form method='POST' action='@{[&baseurl($self)]}'>\n",
	  "<input type='hidden' name='page' value='CreateConfirm' />\n",
	  "<input type='hidden' name='db' value='$$self{DB}' />\n",
	  "<input type='hidden' name='reqname' value='@{[&escapeHTML($reqname)]}' />\n",
	  "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
	  "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
	  "<input type='hidden' name='dbs' value='@{[&escapeHTML($dbs)]}' />\n",
	  "<input type='hidden' name='dependencies' value='@{[&escapeHTML($deps)]}' />\n",
	  "<input type='hidden' name='data' value='@{[&escapeHTML(join(' ', @data))]}' />\n",
          "<table class='striped'>\n",
	  " <tr class='selected'><th colspan='4'>Create a new request</th></tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Destinations</td>\n",
	  "  <td>\n",
	  (map { "<input type='checkbox' name='dest' value='$_' />&nbsp;$_<br />" }
	   grep (/^T1_/, @nodes)),
   	  "  </td>\n",
	  "  <td>\n",
	  (map { "<input type='checkbox' name='dest' value='$_' />&nbsp;$_<br />" }
	   grep (/^T2_/, @nodes)),
   	  "  </td>\n",
	  "  <td>\n",
	  (map { "<input type='checkbox' name='dest' value='$_' />&nbsp;$_<br />" }
	   grep (! /^T[12]_/, @nodes)),
   	  "  </td>\n",
   	  " </tr>\n",
	  " <tr>\n",
	  "  <td colspan='4' align='center'>", submit('submit', 'Next'), "</td>\n",
	  " </tr>\n",
	  "</table>\n",
	  "</form>\n",
	  "</p>\n";
}

######################################################################
package Web::Request::CreateConfirm;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 9, TITLE => "Confirm Request" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my @emails;
    my $bad = 0;
    &create_check_identity($self, \$bad);
    my $reqname = &create_check_reqname($self, \$bad, param('reqname'));
    my $email = &create_check_email($self, \$bad, param('email'), \@emails);
    my $comment = &create_check_comment($self, \$bad, param('comment'));
    my $dbs = &create_check_dbs($self, \$bad, param('dbs'));
    my $deps = &create_check_deps($self, \$bad, param('dependencies'));
    my @data = &create_check_data($self, \$bad, param('data'));
    my @dest = &create_check_dest($self, \$bad, param('dest'));
    return if &create_check_bad($self, $bad);

    print { $$self{OUT} } "<p>",
    	  "<form method='POST' action='@{[&baseurl($self)]}'>\n",
	  "<input type='hidden' name='page' value='CreateCheck' />\n",
	  "<input type='hidden' name='db' value='$$self{DB}' />\n",
	  "<input type='hidden' name='reqname' value='@{[&escapeHTML($reqname)]}' />\n",
	  "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
	  "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
	  "<input type='hidden' name='dbs' value='@{[&escapeHTML($dbs)]}' />\n",
	  "<input type='hidden' name='dependencies' value='@{[&escapeHTML($deps)]}' />\n",
	  "<input type='hidden' name='data' value='@{[&escapeHTML(join(' ', @data))]}' />\n",
	  (map { "<input type='hidden' name='dest' value='@{[&escapeHTML($_)]}' />\n" } @dest),
          "<table class='striped'>\n",
	  " <tr valign='top'>\n",
	  "  <td>Request name</td>\n",
	  "  <td>@{[&escapeHTML($reqname)]}</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Requestor e-mail</td>\n",
	  "  <td>", (map { &escapeHTML($_) . "<br />" } @emails), "</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Comments</td>\n",
	  "  <td>@{[&escapeHTML($comment)]}</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>DBS instance</td>\n",
	  "  <td>@{[&escapeHTML($dbs)]}</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Include dependencies</td>\n",
	  "  <td>@{[&escapeHTML($deps)]}</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>/Primary/Tier/Dataset names</td>\n",
	  "  <td>", (map { &escapeHTML($_) . "<br />" } @data), "</td>\n",
	  " </tr>\n",
	  " <tr valign='top'>\n",
	  "  <td>Destinations</td>\n",
	  "  <td>", (map { &escapeHTML($_) . "<br />" } @dest), "</td>\n",
   	  " </tr>\n",
	  " <tr>\n",
	  "  <td colspan='2' align='center'>", submit('submit', 'Confirm'), "</td>\n",
	  " </tr>\n",
	  "</table>\n",
	  "</form>\n",
	  "</p>\n";
}

######################################################################
package Web::Request::CreateCheck;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 10, TITLE => "Submit Request" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
    my @emails;
    my $bad = 0;
    &create_check_identity($self, \$bad);
    &create_check_access($self, \$bad);
    my $reqname = &create_check_reqname($self, \$bad, param('reqname'));
    my $email = &create_check_email($self, \$bad, param('email'), \@emails);
    my $comment = &create_check_comment($self, \$bad, param('comment'));
    my $dbs = &create_check_dbs($self, \$bad, param('dbs'));
    my $deps = &create_check_deps($self, \$bad, param('dependencies'));
    my @data = &create_check_data($self, \$bad, param('data'));
    my @dest = &create_check_dest($self, \$bad, param('dest'));
    if ($bad)
    {
	print { $$self{OUT} } "<p>Please resubmit the form with corrected information.</p>\n";
	return;
    }

    (open (MAIL, "| /usr/sbin/sendmail -t")
     && (print MAIL
	    "Subject: PhEDEx request: $reqname\n",
	    "From: PhEDEx Request Form <cms-phedex-admins\@cern.ch>\n",
	    # "To: cms-phedex-admins\@cern.ch\n",
	    # "Cc:", join(", ", @emails), "\n",
	    "To: lassi.tuura\@cern.ch\n",
	    "\n",
	    "Greetings.  You may wish to take note of the following new\n",
	    "transfer request which is now being processed.  At this time\n",
	    "you need not take any action.  Have a nice day!\n",
	    "\n",
	    "* Requestor:\n",
	    "   Identity: $$self{SSL_IDENTITY}\n",
	    "   Host: @{[remote_host()]}\n",
	    "   Agent: @{[user_agent()]}\n",
	    "\n",
	    "* Request:\n",
	    "   Database: $$self{DATABASES}{$$self{DB}}[3]\n",
	    "   Name: $reqname\n",
	    "   Contacts:\n",
	    join("", map { "     $_\n" } @emails),
	    "   DBS: $dbs\n",
	    "   Dependencies: $deps\n",
	    "   Data:\n",
	    join("", map { "     $_\n" } @data),
	    "   Destinations:\n",
	    join("", map { "     $_\n" } @dest),
	    "\n",
	    "Yours truly,\n",
	    "  PhEDEx transfer request web form\n")
     && close(MAIL))
	or do { alert($self, "Cannot send mail: $!."); return };

    my $now = time();
    my $id = &makeObjWithAttrs
        ($$self{DBH}, "adm_identity", "identity", {},
	 "Distinguished name" => $$self{SSL_IDENTITY},
	 "E-mail" => &create_default_email(),
	 "Certificate" => $$self{SSL_CERT});

    my $cid = &makeObjWithAttrs
	($$self{DBH}, "adm_contact", "contact", {},
	 "Remote host" => remote_host(),
	 "User agent" => user_agent(),
	 "Server" => new CGI ('')->self_url(-full=>1));

    my $client = &makeObjWithAttrs
        ($$self{DBH}, "adm_client", undef,
	 { "identity" => $id, "contact" => $cid });

    my $rid = &makeObjWithAttrs
        ($$self{DBH}, "req_request", undef,
	 { "name" => $reqname, "creator" => $client, "state" => 0 });

    &makeObjWithAttrs
        ($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "Create",
	   "client" => $client,
	   "time_apply" => $now },
   	 "Comment" => $comment);
    &makeObjWithAttrs
        ($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "Contact",
	   "client" => $client,
	   "time_apply" => $now },
   	 map { ("E-mail" => $_) } @emails);
    &makeObjWithAttrs
        ($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "DBS",
	   "client" => $client,
	   "time_apply" => $now },
         "URL" => $dbs);
    &makeObjWithAttrs
        ($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "Destination",
	   "client" => $client,
	   "time_apply" => $now },
   	 map { ("Node" => $_) } @dest);
    &makeObjWithAttrs
        ($$self{DBH}, "req_action", "action",
	 { "request" => $rid,
	   "action" => "Data",
	   "client" => $client,
	   "time_apply" => $now },
	 "Dependencies" => $deps,
   	 map { ("Pattern" => $_) } @data);

    note($self, "Request confirmed!");
}

1;
