#!/usr/bin/env perl

use strict;
use warnings;
use CGI qw(:standard);
use CGI::Carp qw(fatalsToBrowser);
use POSIX;
use DBI;

# Read database access tokens
my $home = $0; $home =~ s|/[^/]*$||; $home = "." if ! $home;
my @dbnames = ();
my %databases = ();
open (DBNAMES, "< $home/.db/names") || die "Failed to read database configuration\n";
while (<DBNAMES>)
{
    chomp;
    my ($db, @args) = split(/\s+/);
    $databases{$db} = [ @args ];
    push (@dbnames, $db);
}
close (DBNAMES);
my $cgi = new CGI;
my $db = $cgi->param("db") || "prod";    # tnsname of the database
$db = "prod" if ! grep ($db eq $_, @dbnames);
my ($dbtns, $dbuser, $dbpass, $dbid, $dbversion) = @{$databases{$db}};
$dbversion ||= 'V2.2';
$dbid ||= '';

my $dbh;
my $badcolor = '#ff9e9e';
my $warncolor = '#ffd89e';
my $pendcolor = '#ccccff'; # ececff
my $goodcolor = '#ccffcc';
my $altcolor = '#e8e8e8';

$cgi->param('db', 'prod') if ! $cgi->param('db');
$cgi->param('page', 'main') if ! $cgi->param('page');

# ###############################################
# Main loop
# ###############################################

runme();

# ###############################################
# Subroutines
# ###############################################

sub relurl
{
    my %args = ('db' => $db, @_);
    my $newcgi = new CGI ($cgi->query_string);
    map { $newcgi->param ($_, $args{$_}) } keys %args;
    return $newcgi->self_url(-full=>0, -relative=>1);
}

sub urlencode
{
    eval "use CGI '-oldstyle_urls'";
    my %args = @_; return new CGI (\%args)->query_string();
}

sub dblink
{
    my ($db, $dbother) = @_;
    my $othername = $databases{$dbother}[3];
    return "<a href='" . &relurl('db', $dbother)
         . ($db eq $dbother ? "' class='selected' " : "' ")
    	 . "title='$othername Database Instance'>$othername</a>";
}

sub runme
{
    # Select page we are visiting
    my @pageinfo = ([ 'main',		\&main,		"Request Status" ],
                    [ 'data',		\&data,		"Request Data" ]);
    my %pagemap = map { $pageinfo[$_][0] => $_ } 0 .. $#pageinfo;
    my $pagename = param('page');
    my $page = ($pagename && exists $pagemap{$pagename} ? $pagemap{$pagename} : 0);

    # Initialise page template
    my $template = do { local $/; undef $/; <DATA> };
    my $replacements = {
     	'CONTENT' => '',
	'PAGETITLE' => $pageinfo[$page][2],
	'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
	'DBID' => $dbid,
	'DB' => $db,
	'DBSELECTOR' =>
	    ("  <ul id='navmain'>\n" .
	     "    <li class='first'>Database: " .  &dblink ($db, $dbnames[0]) .
	     "</li>\n    " .
	     join ("\n    ",
		   map { "<li>" . &dblink ($db, $_) . "</li>" }
		   @dbnames[1 .. $#dbnames]) .
	     "\n  </ul>\n"),
	'PAGESELECTOR' =>
	    (join("", map { ($_ ? "<br>" : "") .
			    "<a href='" . &relurl('page', $pageinfo[$_][0]) .
			    "'>$pageinfo[$_][2]</a>\n    " }
		      grep (defined $pageinfo[$_][2], 0 .. $#pageinfo))),

    };

    # Execute the desired page.  We save old STDOUT to print to it
    # later, then redirect the page routine's output to CONTENT.
    my $capture = new IO::Capture::Stdout;
    $capture->start();
    eval
    {
        # Connect to the database, do the page, the disconnect
        $ENV{TNS_ADMIN} = "/afs/cern.ch/project/oracle/admin";
        $ENV{ORACLE_HOME} = "/afs/cern.ch/project/oracle/\@sys/10103";
        $ENV{LD_LIBRARY_PATH} = "/afs/cern.ch/project/oracle/\@sys/10103/lib";
        $dbh = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		     { RaiseError=>1, AutoCommit =>1 });
	&{$pageinfo[$page][1]} ();
        $dbh->disconnect();
    };

    if ($@)
    {
	my $message = $@;
	$message =~ s/&/&amp;/g;
	$message =~ s/</&lt;/g;
	$message =~ s/>/&gt;/g;
	print "<div align='left'>\n",
	      "<p>Apologies, looks like we have a server error,",
	      " details of which below.</p>\n",
	      "<p><i>$message</i></p>\n",
	      "</div>\n";
    }
    $capture->stop();
    $replacements->{CONTENT} = join("\n", $capture->read());

    # Instantiate the template and spit it out
    while (my ($key, $value) = each %$replacements)
    {
	$template =~ s/\@$key\@/$value/g;
    }

    print $cgi->header();
    print $template;
}

sub main
{
    my %status = ();
    my $rquery = $dbh->prepare(qq{
	select
	  r.name, s.destination,
	  count(s.block),
	  sum(s.dbs_files), sum(s.dbs_bytes),
	  sum(s.tmdb_files), sum(s.tmdb_bytes),
	  sum(s.dest_files), sum(s.dest_bytes)
	from t_request r join t_request_status s on s.request = r.id
	group by r.name, s.destination});
    $rquery->execute();
    while (my ($req, $dest, $blocks,
	       $dbs_files, $dbs_bytes,
	       $tmdb_files, $tmdb_bytes,
	       $node_files, $node_bytes) = $rquery->fetchrow())
    {
	$status{$req}{$dest} = {
	    BLOCKS => $blocks,
	    DBS_FILES => $dbs_files, DBS_BYTES => $dbs_bytes,
	    TMDB_FILES => $tmdb_files, TMDB_BYTES => $tmdb_bytes,
	    NODE_FILES => $node_files, NODE_BYTES => $node_bytes
	};
    }

    print "<p>",
          "<table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='8'>Transfer request status</th>",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th rowspan='2'>Request</th>\n",
	  " <th rowspan='2'>Destination</th>\n",
	  " <th colspan='2'>Known Files</th>\n",
	  " <th colspan='2'>Destination</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  "</tr>\n";

    foreach my $req (sort keys %status)
    {
	my @dests = sort keys %{$status{$req}};
	for (my $i = 0; $i <= $#dests; ++$i)
	{
	    my $dest = $dests[$i];
	    my $x = $status{$req}{$dest};
	    my $tmdb_color = ($x->{TMDB_FILES} == $x->{DBS_FILES} ? "" : " bgcolor='$pendcolor'");
	    my $node_color = ($x->{NODE_FILES} == $x->{TMDB_FILES} ? "" : " bgcolor='$pendcolor'");
	    print "<tr>\n",
	          ($i == 0 ? (" <td rowspan='@{[scalar @dests]}'>$req</td>\n") : ()),
	          " <td>$dest</td>\n",
	          " <td$tmdb_color>", &format_num ($x->{TMDB_FILES}), "</td>\n",
	          " <td$tmdb_color>", &format_size ($x->{TMDB_BYTES}), "</td>\n",
	          " <td$node_color>", &format_num ($x->{NODE_FILES}), "</td>\n",
	          " <td$node_color>", &format_size ($x->{NODE_BYTES}), "</td>\n",
	          "</tr>\n";
	}
    }

    print "</tbody>\n",
          "</table>\n",
	  "</p>\n";
}

sub data
{
    my %status = ();
    my $rquery = $dbh->prepare(qq{
	select
	  r.name, s.block,
	  min(s.dbs_files), min(s.dbs_bytes),
	  min(s.tmdb_files), min(s.tmdb_bytes),
	  min(s.common_files), min(s.dbs_only_files), min(s.tmdb_only_files)
	from t_request r join t_request_status s on s.request = r.id
	group by r.name, s.block});
    $rquery->execute();
    while (my ($req, $block,
	       $dbs_files, $dbs_bytes,
	       $tmdb_files, $tmdb_bytes,
	       $common, $dbs_only, $tmdb_only) = $rquery->fetchrow())
    {
	$status{$req}{$block} = {
	    DBS_FILES => $dbs_files, DBS_BYTES => $dbs_bytes,
	    TMDB_FILES => $tmdb_files, TMDB_BYTES => $tmdb_bytes,
	    COMMON => $common, DBS_ONLY => $dbs_only, TMDB_ONLY => $tmdb_only
	};
    }

    print "<p>",
          "<table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='9'>Transfer request status</th>",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th rowspan='2'>Request</th>\n",
	  " <th rowspan='2'>Block</th>\n",
	  " <th colspan='2'>DBS</th>\n",
	  " <th colspan='2'>TMDB</th>\n",
	  " <th colspan='3'>Difference</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  " <th>Files</th>\n",
	  " <th>Size</th>\n",
	  " <th>Common</th>\n",
	  " <th>DBS</th>\n",
	  " <th>TMDB</th>\n",
	  "</tr>\n";

    foreach my $req (sort keys %status)
    {
	my @blocks = sort keys %{$status{$req}};
	for (my $i = 0; $i <= $#blocks; ++$i)
	{
	    my $block = $blocks[$i];
	    my $x = $status{$req}{$block};
	    my $tmdb_color = ($x->{TMDB_FILES} == $x->{DBS_FILES} ? "" : " bgcolor='$pendcolor'");
	    my $common_color = ($x->{COMMON} == $x->{DBS_FILES} ? "" : " bgcolor='$warncolor'");
	    my $dbs_only_color = (!$x->{DBS_ONLY} ? "" : " bgcolor='$warncolor'");
	    my $tmdb_only_color = (!$x->{TMDB_ONLY} ? "" : " bgcolor='$warncolor'");
	    print "<tr>\n",
	          ($i == 0 ? (" <td rowspan='@{[scalar @blocks]}'>$req</td>\n") : ()),
	          " <td>$block</td>\n",
	          " <td>", &format_num ($x->{DBS_FILES}), "</td>\n",
	          " <td>", &format_size ($x->{DBS_BYTES}), "</td>\n",
	          " <td$tmdb_color>", &format_num ($x->{TMDB_FILES}), "</td>\n",
	          " <td$tmdb_color>", &format_size ($x->{TMDB_BYTES}), "</td>\n",
	          " <td$common_color>", &format_num ($x->{COMMON}), "</td>\n",
	          " <td$dbs_only_color>", &format_num ($x->{DBS_ONLY}), "</td>\n",
	          " <td$tmdb_only_color>", &format_num ($x->{TMDB_ONLY}), "</td>\n",
	          "</tr>\n";
	}
    }

    print "</tbody>\n",
          "</table>\n",
	  "</p>\n";
}

sub format_num {
    my ($n) = @_;
    return $n ? "$n" : '&#8211;';
}

sub format_size {
    my ($bytes, $nodash) = @_;
    my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		  [ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
    my ($val, $unit) = ($bytes, '');
    while (@bounds && $bytes >= $bounds [0][0])
    {
	$val = $bytes / $bounds[0][0];
	$unit = $bounds[0][1];
	shift (@bounds);
    }

    return $bytes || $nodash ? sprintf('%.1f&nbsp;%sB', $val, $unit) : '&#8211;';
}

######################################################################
# Nicked IO::Capture::Stdout from CPAN.
#
# Mark Reynolds <reynolds@sgi.com>; Jon Morgan <jmorgan@sgi.com>.
# Copyright (c) 2003, Mark Reynolds. All Rights Reserved. This module
# is free software. It may be used, redistributed and/or modified under
# the same terms as Perl itself.
package IO::Capture::Tie_STDx;
sub TIEHANDLE { my $class = shift; bless [], $class; }
sub PRINTF { my $self   = shift; my $format = shift; $self->PRINT( sprintf( $format, @_ ) ); }
sub PRINT { my $self = shift; push @$self, join '',@_; }
sub READLINE { my $self = shift; return wantarray ? @$self : shift @$self; }
sub CLOSE { my $self = shift; return close $self; }
1;

package IO::Capture;
use strict;
use Carp;

sub new {
    my $class = shift;
    if (ref $class) {
	carp "WARNING: " . __PACKAGE__ . "::new cannot be called from existing object. (cloned)";
	return;
    }
    my $object = shift || {};
    bless $object, $class;
    $object->_initialize; 
}

sub _check_pre_conditions {
    my $self = shift;

    if( $self->{'IO::Capture::status'} ne "Ready") {
	carp "Start issued on an in progress capture ". ref($self);
	return;
    }

    return 1;
}

sub _initialize {
    my $self = shift;
    if (!ref $self) {
	carp "WARNING: _initialize was called, but not called from a valid object";
	return;
    }

    $self->{'IO::Capture::messages'} = [];
    $self->{'IO::Capture::line_pointer'} = 1;
    $self->{'IO::Capture::status'} = "Ready";
    return $self;
}

sub start {
    my $self = shift;

    if (! $self->_check_pre_conditions) {
	carp "Error: failed _check_pre_confitions in ". ref($self);
	return;
    }

    if (! $self->_save_current_configuration ) { 
	carp "Error saving configuration in " . ref($self);
	return;
    }

    $self->{'IO::Capture::status'} = "Busy";

    if (! $self->_start(@_)) {
	carp "Error starting capture in " . ref($self);
	return;
    }
    return 1;
}

sub stop {
    my $self = shift;

    if( $self->{'IO::Capture::status'} ne "Busy") {
	carp "Stop issued on an unstarted capture ". ref($self);
	return;
    }

    if (! $self->_retrieve_captured_text() ) {
        carp "Error retreaving captured text in " . ref($self);
	return;
    }

    if (!$self->_stop() ) {
	carp "Error return from _stop() " . ref($self) . "\n";
	return;
    }

    $self->{'IO::Capture::status'} = "Ready";
    return 1;
}

sub read {
    my $self = shift;
    $self->_read;
}

#
#  Internal start routine.  This needs to be overriden with instance
#  method
#
sub _start {
    my $self = shift;
    return 1;
}

sub _read {
    my $self = shift;
    my $messages = \@{$self->{'IO::Capture::messages'}};
    my $line_pointer = \$self->{'IO::Capture::line_pointer'};

    if ($self->{'IO::Capture::status'} ne "Ready") {
	carp "Read cannot be done while capture is in progress". ref($self);
	return;
    }

    return if $$line_pointer > @$messages;
    return wantarray ? @$messages :  $messages->[($$line_pointer++)-1];
}

sub _retrieve_captured_text {
    return 1;
    
}

sub _save_current_configuration {
    my $self = shift;
    $self->{'IO::Capture::handler_save'} = $SIG{__WARN__};
    open STDOUT_SAVE, ">&STDOUT";
    $self->{'IO::Capture::stdout_save'} = *STDOUT_SAVE;
    open STDERR_SAVE, ">&STDOUT";
    $self->{'IO::Capture::stderr_save'} = *STDERR_SAVE;
    return $self; 
}

sub _stop {
    my $self = shift;
    return 1;
}

sub line_pointer {
    my $self = shift;
    my $new_number = shift;

    $self->{'IO::Capture::line_pointer'} = $new_number if $new_number;
    return $self->{'IO::Capture::line_pointer'};
}
1;

package IO::Capture::Stdout;
use Carp; use base qw/IO::Capture/;

sub _start {
    my $self = shift;
    $self->line_pointer(1);
    tie *STDOUT, "IO::Capture::Tie_STDx";
}

sub _retrieve_captured_text {
    my $self = shift;
    my $messages = \@{$self->{'IO::Capture::messages'}};
    @$messages = <STDOUT>;
    #$self->line_pointer(1);
    return 1;
}

sub _check_pre_conditions {
    my $self = shift;
    return unless $self->SUPER::_check_pre_conditions;
    if (tied *STDOUT) {
	carp "WARNING: STDOUT already tied, unable to capture";
	return;
    }
    return 1;
}

sub _stop { untie *STDOUT; }
1;
######################################################################
__END__
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  <link rel="stylesheet" href="../style.css" type="text/css" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <script type="text/javascript" src="../stripe.js"></script>

  <title>@DBID@ @PAGETITLE@: PhEDEx Transfer Request</title>
</head>

<body onload='stripe("#fff", "#edf3fe")'>
<div id="page">
<div id="header">
  <!-- Logo and page title -->
  <div id="logo">
    <a href="http://cern.ch/cms-project-phedex/" title="PhEDEx Home Page"
      ><img src="../phedex-logo.gif" alt="PhEDEx" height="120" /></a>
  </div>

  <div id="heading">
    <h1 class="title">PhEDEx Transfer Request</h1>
    <h2>@DBID@ @PAGETITLE@</h2>
    <h4>@TIME@</h4>
  </div>

  <!-- Main navigation bar: public/developers/other -->
  @DBSELECTOR@
</div> <!-- /header -->

<!-- side navigation bar -->
<div id="sidebar">
  <div class="sidetopic"><h2>Request Options</h2>
    <p>@PAGESELECTOR@</p>
  </div>
</div> <!-- /sidebar -->

<!-- main content -->
<div id="content">
<center>
@CONTENT@
<hr />
</center>
</div>
</div>
</body>
</html>
