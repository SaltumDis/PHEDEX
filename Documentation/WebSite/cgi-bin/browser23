#!/usr/bin/env perl

BEGIN { use strict; use warnings; $^W=1; }
use CGI qw(:standard);
use CGI::Carp qw(fatalsToBrowser);
use POSIX;
use DBI;

# Read database access tokens
my @dbnames = ();
my %databases = ();
open (DBNAMES, "< /afs/cern.ch/cms/aprom/phedex/DBAccessInfo/names")
    || die "Failed to read database configuration\n";
while (<DBNAMES>)
{
    chomp;
    my ($db, @args) = split(/\s+/);
    $databases{$db} = [ @args ];
    push (@dbnames, $db);
}
close (DBNAMES);
my $cgi = new CGI;
my $db = $cgi->param("db") || "prod";    # tnsname of the database
$db = "prod" if ! grep ($db eq $_, @dbnames);
my ($dbtns, $dbuser, $dbpass, $dbid, $dbversion) = @{$databases{$db}};
$dbversion ||= 'V2.2';
$dbid ||= '';

my $dbh;
my $badcolor = '#ff9e9e';
my $warncolor = '#ffd89e';
my $pendcolor = '#ccccff'; # ececff
my $goodcolor = '#ccffcc';
my $altcolor = '#e8e8e8';

$cgi->param('db', 'prod') if ! $cgi->param('db');
$cgi->param('page', 'main') if ! $cgi->param('page');

# ###############################################
# Main loop
# ###############################################

runme();

# ###############################################
# Subroutines
# ###############################################

sub relurl
{
    my %args = ('db' => $db, @_);
    my $newcgi = new CGI ($cgi->query_string);
    map { $newcgi->param ($_, $args{$_}) } keys %args;
    return $newcgi->self_url(-full=>0, -relative=>1);
}

sub baseurl
{
    my $curpage = param('page');
    my %args = ('db' => $db, ($curpage ? ('page' => $curpage) : ()), @_);
    my $newcgi = new CGI ("");
    map { $newcgi->param ($_, $args{$_}) } keys %args;
    return $newcgi->self_url(-full=>0, -relative=>1);
}

sub urlencode
{
    eval "use CGI '-oldstyle_urls'";
    my %args = @_; return new CGI (\%args)->query_string();
}

sub dblink
{
    my ($db, $dbother) = @_;
    my $othername = $databases{$dbother}[3];
    return "<a href='" . &baseurl ('db' => $dbother)
         . ($db eq $dbother ? "' class='selected' " : "' ")
    	 . "title='$othername Database Instance'>$othername</a>";
}

sub runme
{
    # Select page we are visiting
    my @pageinfo = ([ 'main',		\&main,		"Component Status" ],
	            [ 'transfer',	\&transfer,	"Transfer State" ],
		    [ 'tstates',	\&tstates,	"Transfer State Details" ],
		    [ 'replicas',	\&replicas,	"Replica State" ],
		    [ 'subs',		\&subs,		"Subscriptions" ],
		    [ 'stats',		\&stats,	"File Size Stats" ],
		    [ 'rates',		\&rates,	"Transfer Rate" ],
		    [ 'rateplot',	\&rateplot,	"Transfer Rate Plots" ],
		    [ 'pplot',		\&rateplot,	"Transfer Queue Plots" ],
		    [ 'qplot',		\&qplot,	"Transfer Quality Plots" ],
		    [ 'agents',		\&agents,	"Agent Status" ],
		    [ 'dbreports',	\&dbreports,	"Daily Reports" ],
		    [ 'dbreport',	\&dbreport,	"Daily Report" ]);
    my %pagemap = map { $pageinfo[$_][0] => $_ } 0 .. $#pageinfo;
    my $pagename = param('page');
    my $page = ($pagename && exists $pagemap{$pagename} ? $pagemap{$pagename} : 0);

    # Initialise page template
    my $template = do { local $/; undef $/; <DATA> };
    my $replacements = {
     	'CONTENT' => '',
	'PAGETITLE' => $pageinfo[$page][2],
	'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
	'DBID' => $dbid,
	'DB' => $db,
	'DBSELECTOR' =>
	    ("  <ul id='navmain'>\n" .
	     "    <li class='first'>Database: " .  &dblink ($db, $dbnames[0]) .
	     "</li>\n    " .
	     join ("\n    ",
		   map { "<li>" . &dblink ($db, $_) . "</li>" }
		   @dbnames[1 .. $#dbnames]) .
	     "\n  </ul>\n"),
	'PAGESELECTOR' =>
	    (join("", map { ($_ ? "<br>" : "") .
			    "<a href='" . &baseurl ('page' => $pageinfo[$_][0]) .
			    "'>$pageinfo[$_][2]</a>\n    " }
		      grep (defined $pageinfo[$_][2], 0 .. $#pageinfo))),

    };

    # Execute the desired page.  We save old STDOUT to print to it
    # later, then redirect the page routine's output to CONTENT.
    my $capture = new IO::Capture::Stdout;
    $capture->start();
    eval
    {
        # Connect to the database, do the page, the disconnect
        $ENV{TNS_ADMIN} = "/afs/cern.ch/project/oracle/admin";
        $ENV{ORACLE_HOME} = "/afs/cern.ch/project/oracle/\@sys/10103";
        $ENV{LD_LIBRARY_PATH} = "/afs/cern.ch/project/oracle/\@sys/10103/lib";
        $dbh = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		     { RaiseError=>1, AutoCommit =>1 });
	&{$pageinfo[$page][1]} ();
        $dbh->disconnect();
    };

    if ($@)
    {
	my $message = $@;
	$message = &escapeHTML($message);
	print "<div align='left'>\n",
	      "<p>Apologies, looks like we have a server error,",
	      " details of which below.</p>\n",
	      "<p><i>$message</i></p>\n",
	      "</div>\n";
    }
    $capture->stop();
    $replacements->{CONTENT} = join("\n", $capture->read());

    # Instantiate the template and spit it out
    while (my ($key, $value) = each %$replacements)
    {
	$template =~ s/\@$key\@/$value/g;
    }

    print $cgi->header();
    print $template;
}

sub main
{
    my $active = 60*5;
    my $offline = 60*15;
    my $now = time ();
    my $query = $dbh->prepare(qq{
	select n.name, a.name, ast.time_update
	from t_agent_status ast
	  join t_node n on n.id = ast.node
	  join t_agent a on a.id = ast.agent});
    my %agents;
    my %status;

    $query->execute();
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($node, $agent, $contact) = @$row;
	$status{$node}{$agent} = $contact;
	$agents{$agent} = 1;
    }
    $query->finish();

    my @standard = grep (!/^(Block|Info(?!Drop)|Perf|Table)/, sort keys %agents);
    my @admin = grep (/^Block/, sort keys %agents);
    my @support = grep (/^(?!File|Block|InfoDrop)/, sort keys %agents);

    foreach my $item ([ "Common", @standard ], [ "Administrative", @admin ], [ "Support", @support ])
    {
	my ($type, @agents) = @{$item};
        print "<p><table class='striped'>\n",
	      "<tbody>\n",
	      "<tr class='selected'>\n",
	      " <td align='center' colspan='" . (scalar @agents + 1) . "'>$type Agents</td>\n",
	      "</tr>\n",
	      "<tr class='selected'>\n",
	      " <th>Node</th>\n",
	      (map { " <th>$_</th>\n" } @agents),
	      "</tr>\n";

        foreach my $node (sort keys %status)
        {
	    next if ! grep (defined $status{$node}{$_}, @agents);

	    print "<tr>\n",
	          " <td>$node</td>\n";
            foreach my $agent (@agents)
	    {
	        my $contact = $status{$node}{$agent};
	        if (! defined $contact)
	        {
		    print " <td>&nbsp;</td>\n";
		    next;
	        }

	        my $ago = &age ($now - $contact);
	        if (($now - $contact) < $active) {
                    print "<td align='center' bgcolor='$goodcolor'>UP</td>\n";
	        } elsif (($now - $contact) < $offline) {
                    print "<td align='center' bgcolor='$goodcolor'>UP ($ago ago)</td>\n";
                } else {
                    print "<td align='center' bgcolor='$badcolor'>DOWN ($ago ago)</td>\n";
                }
	    }
	    print "</tr>\n";
        }
        print "</tbody>\n",
              "</table>\n";
   }
}

sub format_num {
    my ($n) = @_;
    return $n ? "$n" : '&#8211;';
}

sub format_size {
    my ($bytes, $nodash, $precision, $minscale) = @_;
    my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		  [ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
    my ($val, $unit, $minus) = ($bytes, '', $bytes < 0 ? "-" : "");
    do { $val = -$val; $bytes = -$bytes; } if $minus;
    while (@bounds && ($bytes >= $bounds [0][0] || defined $minscale))
    {
	$val = $bytes / $bounds[0][0];
	$unit = $bounds[0][1];
	undef $minscale if (defined $minscale && $minscale eq $unit);
	shift (@bounds);
    }

    $precision = "1" if ! defined $precision;
    return $bytes || $nodash
           ? sprintf("%s%.${precision}f&nbsp;%sB", $minus, $val, $unit)
	   : '&#8211;';
}

sub transfer {
    my $rows = 0;
    my $now = time();
    my $query = $dbh->prepare(qq{
	    select
	      n.name, max(br.time_update),
	      sum(br.dest_files), sum(br.dest_bytes),
	      sum(br.node_files), sum(br.node_bytes),
	      sum(br.xfer_files), sum(br.xfer_bytes)
	    from t_dps_block_replica br join t_node n on n.id = br.node
	    group by n.name order by n.name});

    print "<p><table class='striped'>\n",
          "<tbody>\n",
          "<tr class='selected'>\n",
	  " <th rowspan='2'>Last<br>Change</th>\n",
	  " <th rowspan='2'>Node</th>\n",
    	  " <th colspan='2'>Destined</th>\n",
	  " <th colspan='2'>On Site</th>\n",
	  " <th colspan='2'>In Transfer</th>\n",
          "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th align='right'>N</th><th align='right'>Size</th>\n",
	  " <th align='right'>N</th><th align='right'>Size</th>\n",
	  " <th align='right'>N</th><th align='right'>Size</th>\n",
          "</tr>\n";

    $query->execute();
    my ($tdest_files, $tdest_size,
	$tnode_files, $tnode_size,
	$txfer_files, $txfer_size) = (0) x 6;

    while (my $row = $query->fetchrow_arrayref)
    {
	my ($n, $stamp,
	    $dest_files, $dest_size,
	    $node_files, $node_size,
	    $xfer_files, $xfer_size) = @$row;

    	$tdest_files += $dest_files; $tdest_size += $dest_size;
    	$tnode_files += $node_files; $tnode_size += $node_size;
    	$txfer_files += $xfer_files; $txfer_size += $xfer_size;

	my $node_color = (($dest_files && $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		   	  : $xfer_files ? " bgcolor='$pendcolor'" : "");
	my $xfer_color = (($xfer_files) ? " bgcolor='$goodcolor'"
			  : ($xfer_files + $node_files < $dest_files) ? " bgcolor='$pendcolor'"
			  : "");

        print "<tr>\n",
	      " <td>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
	      " <td>$n</td>\n",
	      " <td align='right'>@{[&format_num($dest_files)]}</td>\n",
	      " <td align='right'>@{[&format_size($dest_size)]}</td>\n",
	      " <td align='right'$node_color>@{[&format_num($node_files)]}</td>\n",
	      " <td align='right'$node_color>@{[&format_size($node_size)]}</td>\n",
	      " <td align='right'$xfer_color>@{[&format_num($xfer_files)]}</td>\n",
	      " <td align='right'$xfer_color>@{[&format_size($xfer_size)]}</td>\n",
	      "</tr>\n";
    }
    my $node_color = (($tdest_files && $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		      : ($txfer_files) ? " bgcolor='$pendcolor'" : "");
    my $xfer_color = (($txfer_files) ? " bgcolor='$goodcolor'"
		      : ($txfer_files + $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		      : "");

    print "<tr>\n",
	  " <th>&nbsp;</th>\n",
	  " <th align='left'>Total</th>\n",
	  " <th align='right'>@{[&format_num($tdest_files)]}</th>\n",
	  " <th align='right'>@{[&format_size($tdest_size)]}</th>\n",
	  " <th align='right'$node_color>@{[&format_num($tnode_files)]}</th>\n",
	  " <th align='right'$node_color>@{[&format_size($tnode_size)]}</th>\n",
	  " <th align='right'$xfer_color>@{[&format_num($txfer_files)]}</th>\n",
	  " <th align='right'$xfer_color>@{[&format_size($txfer_size)]}</th>\n",
	  "</tr>\n";
    $query->finish();
    print "</tbody>\n",
          "</table>\n";
}

sub tstates {
    my $rows = 0;
    my $now = time();
    my $query = $dbh->prepare(qq{
	    select
	      time_update,
	      nd.name, ns.name,
	      to_state, from_state,
	      files, bytes
	    from t_info_xfer_states xs
              join t_node ns on ns.id = xs.from_node
              join t_node nd on nd.id = xs.to_node
	    order by nd.name, ns.name, to_state, from_state});

    print "<p><table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='7' align='center'>Transfer State Details</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th rowspan='2'>Age</th>\n",
	  " <th colspan='2'>To</th>\n",
	  " <th colspan='2'>From</th>\n",
	  " <th colspan='2'>Files</th>\n",
          "</tr>\n",
	  "<tr class='selected'>",
	  " <th>Node</th>\n",
	  " <th>State</th>\n",
	  " <th>Node</th>\n",
	  " <th>State</th>\n",
	  " <th>N</th>\n",
	  " <th>Size</th>\n",
          "</tr>\n";

    my %total = ();
    $query->execute();
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($stamp,
	    $to_node, $from_node,
	    $to_state, $from_state,
	    $files, $bytes) = @$row;

    	$total{$to_state}{$from_state} ||= { FILES => 0, BYTES => 0 };
    	$total{$to_state}{$from_state}{FILES} += $files;
    	$total{$to_state}{$from_state}{BYTES} += $bytes;
	my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
	my $to_state_name = ($to_state == 0 ? "assigned"
			     : $to_state == 1 ? "wanted"
			     : $to_state == 2 ? "in transfer"
			     : $to_state == 3 ? "transferred"
			     : ($to_state >= 100 && $to_state < 999)
			     ? "error cool-off @{[$to_state-100]}"
			     : "unknown");
	my $from_state_name = ($from_state == 0 ? "assigned"
			       : $from_state == 1 ? "transferrable"
			       : "unknown");
	my $to_color = (($to_state == 2) ? " bgcolor='$goodcolor'"
		   	: ($to_state == 1) ? " bgcolor='$pendcolor'"
		   	: ($to_state >= 100) ? " bgcolor='$warncolor'"
			: "");
	my $from_color = ($from_state == 1 ? " bgcolor='$goodcolor'" : "");
        print "<tr>\n",
	      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
	      " <td>$to_node</td>\n",
	      " <td align='right'$to_color>$to_state</td>\n", # ($to_state_name)
	      " <td>$from_node</td>\n",
	      " <td align='right'$from_color>$from_state</td>\n", # ($from_state_name)
	      " <td align='right'>@{[&format_num($files)]}</td>\n",
	      " <td align='right'>@{[&format_size($bytes)]}</td>\n",
	      "</tr>\n";
    }
    $query->finish();

    my $first_total = 1;
    my ($tfiles, $tbytes) = (0, 0);
    foreach my $to_state (sort keys %total)
    {
	foreach my $from_state (sort keys %{$total{$to_state}})
	{
	    $tfiles += $total{$to_state}{$from_state}{FILES};
	    $tbytes += $total{$to_state}{$from_state}{BYTES};
	    print "<tr>\n",
		  " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
		  " <th align='right'>$to_state</td>\n",
		  " <th align='right'>&nbsp;</td>\n",
		  " <th align='right'>$from_state</td>\n",
		  " <th align='right'>@{[&format_num($total{$to_state}{$from_state}{FILES})]}</th>\n",
		  " <th align='right'>@{[&format_size($total{$to_state}{$from_state}{BYTES})]}</th>\n",
		  "</tr>\n";
	    $first_total = 0;
	}
    }
    print "<tr>\n",
	  " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
	  " <th align='right'>All</td>\n",
	  " <th align='right'>&nbsp;</td>\n",
	  " <th align='right'>All</td>\n",
	  " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
	  " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
	  "</tr>\n",
	  "</tbody>\n",
          "</table>\n",
	  "</p>\n";

    $query = $dbh->prepare(qq{
	    select xr.time_update, n.name, xr.state, xr.files, xr.bytes
	    from t_info_xfer_replicas xr join t_node n on n.id = xr.node
            order by n.name, state});

    print "<table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='5' align='center'>Replica State Details</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th rowspan='2'>Age</th>",
	  " <th rowspan='2'>Node</th>",
	  " <th rowspan='2'>State</th>",
	  " <th colspan='2'>Files</th>",
          "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>N</th>\n",
	  " <th>Size</th>\n",
          "</tr>\n";

    %total = ();
    $query->execute();
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($stamp, $node, $state, $files, $bytes) = @$row;
    	$total{$state} ||= { FILES => 0, BYTES => 0 };
	$total{$state}{FILES} += $files;
	$total{$state}{BYTES} += $bytes;
	my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
	my $state_name = ($state == 0 ? "at node"
			     : $state == 1 ? "on disk"
			     : "unknown");
	my $color = (($state == 1) ? " bgcolor='$goodcolor'" : "");
        print "<tr>\n",
	      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
	      " <td>$node</td>\n",
	      " <td$color align='right'>$state</td>\n", # ($state_name)
	      " <td$color align='right'>@{[&format_num($files)]}</td>\n",
	      " <td$color align='right'>@{[&format_size($bytes)]}</td>\n",
	      "</tr>\n";
    }
    $query->finish();

    $first_total = 1;
    ($tfiles, $tbytes) = (0, 0);
    foreach my $state (sort keys %total)
    {
	$tfiles += $total{$state}{FILES};
	$tbytes += $total{$state}{BYTES};
	print "<tr>\n",
	      " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
	      " <th align='right'>$state</td>\n",
	      " <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
	      " <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
	      "</tr>\n";
	$first_total = 0;
    }
    print "<tr>\n",
	  " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
	  " <th align='right'>All</td>\n",
	  " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
	  " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
	  "</tr>\n",
	  "</tbody>\n",
          "</table>\n",
	  "</p>\n";
}

sub replicas {
    my $rows = 0;
    my %data = ();
    my %nodes = ();
    my $nodepat = param('nodepat') || 'CERN';
    my $datapat = param('datapat') || '';
    print "<p style='text-align: left'><form method='GET' action='@{[&baseurl()]}'>\n",
          "<input type='hidden' name='page' value='@{[param('page')]}'>\n",
          "<input type='hidden' name='db' value='@{[param('db')]}'>\n",
          "<label for='datapat'>Filter: Data</label> ",
	  $cgi->textfield(-name=>'datapat', -default=>$datapat, -size=>15,
	  		  -title=>("Regular expression to match against dataset names. "
		  		   ."Only datasets matching the expression will be shown.")),
          " <label for='nodepat'>Nodes</label> ",
	  $cgi->textfield(-name=>'nodepat', -default=>$nodepat, -size=>15,
	  		  -title=>("Regular expression to match against node names. "
			  	   ."Only nodes matching the expression will be shown.")),
    	  " <input type='submit' value='Update'></form></p>\n";

    my $query = $dbh->prepare(qq{select name, files, bytes from t_dps_block});
    $query->execute();
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($b, $files, $total) = @$row;
	next if ($datapat && $b !~ /$datapat/);
	$data{$b} = [ $b, $files, $total, {} ];
    }
    $query->finish();

    $query = $dbh->prepare (qq{
	    select b.name, n.name, br.node_files, br.node_bytes 
	    from t_dps_block_replica br
              join t_dps_block b on b.id = br.block
	      join t_node n on n.id = br.node});
    $query->execute();
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($b, $node, $files, $total) = @$row;
	next if ($datapat && $b !~ /$datapat/);
	next if ($nodepat && $node !~ /$nodepat/);
	$data{$b}[3]{$node} = [ $files, $total ];
	$nodes{$node} = 1;
    }
    $query->finish();

    print "<table><tr bgcolor='$altcolor' valign='top'>",
	  "<th rowspan='2'>Block</th>",
	  "<th colspan='2' align='right'>Files</th>",
	  (map { "<th colspan='2'>$_</th>" } sort keys %nodes),
          "</tr>\n",
	  "<tr bgcolor='$altcolor' valign='top'>",
	  "<th align='right'>N</th><th align='right'>Size</th>",
	  (map { "<th align='right'>N</th><th align='right'>Size</th>" } sort keys %nodes),
	  "</tr>\n";

    foreach my $info (sort { $$a[0] cmp $$b[0] } values %data)
    {
        my $rowcolor = ($rows++ % 8 < 4) ? '' : " bgcolor='$altcolor'";
	my ($b, $files, $total, $nodes) = @$info;
	next if ($nodepat && ! grep (/$nodepat/, keys %$nodes));
        print "<tr valign='top'$rowcolor>",
	      "<td>$b</td>",
	      "<td align='right'>$files</td>",
	      "<td align='right'>@{[&format_size($total)]}</td>";

	foreach my $node (sort keys %nodes)
	{
	    if (exists $$nodes{$node})
	    {
		my ($nfiles, $ntotal) = @{$$nodes{$node}};
		my $ncolor = ($nfiles == $files) ? '' : " bgcolor='$pendcolor'";
		print "<td$ncolor align='right'>@{[&format_num($nfiles)]}</td>",
		      "<td$ncolor align='right'>@{[&format_size($ntotal)]}</td>";
	    }
	    else
	    {
		print "<td colspan='2'>&nbsp;</td>";
	    }
        }
	print "</tr>\n";
    }
    print "</table>";
}

sub subs {
    my $rows = 0;
    my %data = ();
    my %nodes = ();
    my $nodepat = param('nodepat') || 'CERN';
    my $datapat = param('datapat') || '';
    print "<p style='text-align: left'><form method='GET' action='@{[&baseurl()]}'>\n",
          "<input type='hidden' name='page' value='@{[param('page')]}'>\n",
          "<input type='hidden' name='db' value='@{[param('db')]}'>\n",
          "<label for='datapat'>Filter: Data</label> ",
	  $cgi->textfield(-name=>'datapat', -default=>$datapat, -size=>15,
	  		  -title=>("Regular expression to match against dataset names. "
		  		   ."Only datasets matching the expression will be shown.")),
          " <label for='nodepat'>Nodes</label> ",
	  $cgi->textfield(-name=>'nodepat', -default=>$nodepat, -size=>15,
	  		  -title=>("Regular expression to match against node names. "
			  	   ."Only nodes matching the expression will be shown.")),
    	  " <input type='submit' value='Update'></form></p>\n";

    my $query = $dbh->prepare(qq{
	    select
	      ds.name,
	      n.name,
	      nvl(sum(b.files),0),
	      nvl(sum(b.bytes),0),
	      nvl(sum(br.node_files),0),
	      nvl(sum(br.node_bytes),0)
	    from t_dps_dataset ds
	      left join t_dps_subscription s
		on s.dataset = ds.id
	      left join t_node n
		on n.id = s.destination
	      left join t_dps_block b
		on b.dataset = ds.id
	      left join t_dps_block_replica br
		on br.block = b.id and br.node = s.destination
	    group by ds.name, n.name});
    $query->execute();
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($ds, $node, $files, $total, $sfiles, $stotal) = @$row;
	next if ($datapat && $ds !~ /$datapat/);
	next if ($nodepat && $node && $node !~ /$nodepat/);
	$data{$ds} ||= [ $ds, $files, $total, {} ];
	if ($node)
	{
	    $data{$ds}[3]{$node} = [ $sfiles, $stotal ];
	    $nodes{$node} = 1;
        }
    }
    $query->finish();

    print "<table><tr bgcolor='$altcolor' valign='top'>",
	  "<th rowspan='2'>Dataset</th>",
	  "<th colspan='2' align='right'>Files</th>",
	  (map { "<th rowspan='2'>$_</th>" } sort keys %nodes),
          "</tr>\n",
	  "<tr bgcolor='$altcolor' valign='top'>",
	  "<th align='right'>N</th><th align='right'>Size</th>",
	  "</tr>\n";

    foreach my $ds (sort keys %data)
    {
	my ($ds, $files, $total, $dsnodes) = @{$data{$ds}};
        my $rowcolor = ($rows++ % 8 < 4) ? '' : " bgcolor='$altcolor'";
	my $dscolor = (scalar (keys %$dsnodes) ? '' : " bgcolor='$warncolor'");
        print "<tr valign='top'$rowcolor>",
	      "<td$dscolor>$ds</td>",
	      "<td align='right'>@{[&format_num($files)]}</td>",
	      "<td align='right'>@{[&format_size($total)]}</td>";

	foreach my $node (sort keys %nodes)
	{
	    if (exists $$dsnodes{$node})
	    {
		my ($sfiles, $stotal) = @{$$dsnodes{$node}};
		my $scolor = ($sfiles == $files) ? '' : " bgcolor='$pendcolor'";
		my $fracfiles = ($files ? sprintf('%0.2f', $sfiles / $files) : '&#8211;');
		my $fractotal = ($total ? sprintf('%0.2f', $stotal / $total) : '&#8211;');
		print "<td$scolor align='right'>$fracfiles&nbsp;/&nbsp;$fractotal</td>";
	    }
	    else
	    {
		print "<td>&nbsp;</td>";
	    }
        }
	print "</tr>\n";
    }
    print "</table>";
}

sub age {
    my ($diff) = @_;
    my $str = "";
    my $full = 0;
    if ($diff >= 86400) {
	$str .= sprintf("%dd", $diff / 86400);
	$diff %= 86400;
	$full = 1;
    }
    $str .= sprintf("%dh", $diff / 3600);
    $diff %= 3600;
    $str .= sprintf("%02d", $diff / 60);
}

sub stats {
    my $now = time();
    my $overview = $dbh->selectrow_arrayref(qq{
			select
			  time_update,
			  n_files,
			  sz_total,
			  sz_min,
			  sz_max,
			  sz_mean,
			  sz_median
			from t_info_file_size_overview});
    my $histo = $dbh->selectall_arrayref(qq{
	    		select
			  time_update,
			  bin_low,
			  bin_width,
			  n_total,
			  sz_total
			from t_info_file_size_histogram
			order by bin_low asc});

    print "<p>",
          "<table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='6'>File size statistics ", &age($now - $overview->[0]), " ago</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>Files</th>\n",
	  " <th>Total Size</th>\n",
	  " <th>Min Size</th>\n",
	  " <th>Max Size</th>\n",
	  " <th>Mean Size</th>\n",
	  " <th>Median Size</th>\n",
	  "</tr>\n",
	  "<tr>\n",
	  " <td align='right'>@{[&format_num($overview->[1])]}</td>\n",
	  " <td align='right'>@{[&format_size($overview->[2], 0, 2, 'T')]}</td>\n",
	  " <td align='right'>@{[&format_size($overview->[3], 0, 2, 'M')]}</td>\n",
	  " <td align='right'>@{[&format_size($overview->[4], 0, 2, 'G')]}</td>\n",
	  " <td align='right'>@{[&format_size($overview->[5], 0, 2, 'M')]}</td>\n",
	  " <td align='right'>@{[&format_size($overview->[6], 0, 2, 'M')]}</td>\n",
	  "</tr>\n",
	  "</tbody>\n",
	  "</table>\n",
	  "</p>";

    print "<p>",
          "<table class='striped'>\n",
          "<tbody>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='4'>File size breakdown</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th colspan='2'>Bin</th>\n",
	  " <th>Files</th>\n",
	  " <th>Total Size</th>\n",
	  "</tr>\n";
    foreach my $row (@$histo)
    {
	  print "<tr>\n",
	        " <td align='right'>@{[&format_size($row->[1] * $row->[2],1,2,'G')]} ..</td>\n",
		" <td align='right'>@{[&format_size(($row->[1]+1) * $row->[2],1,2,'G')]}</td>\n",
	        " <td align='right'>@{[&format_num($row->[3])]}</td>\n",
	        " <td align='right'>@{[&format_size($row->[4],1,2,'T')]}</td>\n",
	        "</tr>\n";
    }
    print "</tbody>\n",
          "</table>\n",
          "</p>\n";
}

sub agents {
    my $now = time();
    my %info = ();
    my @states = qw(pending received work completed bad outgoing);
    my %states = ();
    my %age = ();
    my %live = ();
    foreach my $row (@{$dbh->selectall_arrayref(qq{
				select
				  time_update,
				  site,
				  host,
				  path,
				  agent,
				  worker,
				  pid,
				  live,
				  state,
				  value
				from t_info_agent_status})})
    {
	my ($stamp, $site, $host, $path, $agent, $worker, $pid, $live, $state, $value) = @$row;
	$age{$site}{$host}{$path} = $stamp;
	$live{$site}{$host}{$path}{$agent}{$worker} = { PID => $pid, LIVE => $live };
	$info{$site}{$host}{$path}{$agent}{$worker}{$state} = $value;
	$states{$state} = 1 if ! grep ($_ eq $state, @states);
    }

    print "<p><table class='striped'><tbody>\n",
          "<tr class='selected'>",
	  " <th>Age</th>",
	  " <th>Site</th>",
	  " <th>Agent</th>",
	  " <th>Process</th>",
	  " <th>Host</th>",
	  " <th>Worker</th>",
	  (map { " <th>$_</th>\n" } @states, sort keys %states),
	  " <th>Path</th>",
	  "</tr>\n";

    foreach my $site (sort keys %info)
    {
	foreach my $host (sort keys %{$info{$site}})
	{
	    foreach my $path (sort keys %{$info{$site}{$host}})
	    {
	        foreach my $agent (sort keys %{$info{$site}{$host}{$path}})
	        {
		    foreach my $worker (sort keys %{$info{$site}{$host}{$path}{$agent}})
		    {
		        my $pid = $live{$site}{$host}{$path}{$agent}{$worker}{PID};
		        my $live = $live{$site}{$host}{$path}{$agent}{$worker}{LIVE};
		        my $agecolor = $now - $age{$site}{$host}{$path} <= 120 ? "" : " bgcolor='$warncolor'";
		        my $pidcolor = $live ? "" : " bgcolor='$warncolor'";
			my $agentname = $agent;
			$agentname =~ s/-/&#8209;/g;
		        print "<tr>\n",
			      " <td$agecolor>", &age($now - $age{$site}{$host}{$path}), "</td>\n",
			      " <td>$site</td>\n",
			      " <td>$agentname</td>\n",
			      " <td$pidcolor>$pid</td>\n",
			      " <td>$host</td>\n",
			      " <td>$worker</td>\n";
		        foreach my $state (@states, sort keys %states)
		        {
			    my $value = $info{$site}{$host}{$path}{$agent}{$worker}{$state};
			    my $color = $value ? " bgcolor='$pendcolor'" : '';
			    print " <td$color>$value</td>\n";
		        }
			print " <td>$path</td>\n",
		              "</tr>\n";
	            }
	        }
	    }
	}
    }
    print "</tbody></table></p>\n";
}

sub format_timespan {
    my $span = shift;
    if ($span >= 86400) {
	$span /= 86400;
	return $span == 1 ? "day" : "$span days";
    } elsif ($span >= 3600) {
	$span /= 3600;
	return $span == 1 ? "hour" : "$span hours";
    } elsif ($span >= 60) {
	$span /= 60;
	return $span == 1 ? "minute" : "$span minutes";
    } else {
	return $span == 1 ? "second" : "$span seconds";
    }
}

sub rates {
    my $now = time();
    my %stats = ();
    my %spans = (H => [ $now, 3600 ],
		 D => [ $now, 86400 ],
		 W => [ int($now/86400)*86400, 7*86400 ],
		 M => [ int($now/86400)*86400, 30*86400 ]);
    my $q = $dbh->prepare(qq{
	select
	  f.name from_node,
	  t.name to_node,

	  nvl(sum(case when h.timebin > :old_h then h.done_files else 0 end),0) h_done_files,
	  nvl(sum(case when h.timebin > :old_d then h.done_files else 0 end),0) d_done_files,
	  nvl(sum(case when h.timebin > :old_w then h.done_files else 0 end),0) w_done_files,
	  nvl(sum(case when h.timebin > :old_m then h.done_files else 0 end),0) m_done_files,

	  nvl(sum(case when h.timebin > :old_h then h.done_bytes else 0 end),0) h_done_bytes,
	  nvl(sum(case when h.timebin > :old_d then h.done_bytes else 0 end),0) d_done_bytes,
	  nvl(sum(case when h.timebin > :old_w then h.done_bytes else 0 end),0) w_done_bytes,
	  nvl(sum(case when h.timebin > :old_m then h.done_bytes else 0 end),0) m_done_bytes,

	  nvl(sum(case when h.timebin > :old_h then h.fail_files else 0 end),0) h_fail_files,
	  nvl(sum(case when h.timebin > :old_d then h.fail_files else 0 end),0) d_fail_files,
	  nvl(sum(case when h.timebin > :old_w then h.fail_files else 0 end),0) w_fail_files,
	  nvl(sum(case when h.timebin > :old_m then h.fail_files else 0 end),0) m_fail_files,

	  nvl(sum(case when h.timebin > :old_h then h.expire_files else 0 end),0) h_expire_files,
	  nvl(sum(case when h.timebin > :old_d then h.expire_files else 0 end),0) d_expire_files,
	  nvl(sum(case when h.timebin > :old_w then h.expire_files else 0 end),0) w_expire_files,
	  nvl(sum(case when h.timebin > :old_m then h.expire_files else 0 end),0) m_expire_files
	from t_link_histogram h
	  join t_node f on f.id = h.from_node
	  join t_node t on t.id = h.to_node
	where h.timebin > :old_m
	group by f.name, t.name});
    $q->bind_param(":old_h", $spans{H}[0]-$spans{H}[1]);
    $q->bind_param(":old_d", $spans{D}[0]-$spans{D}[1]);
    $q->bind_param(":old_w", $spans{W}[0]-$spans{W}[1]);
    $q->bind_param(":old_m", $spans{M}[0]-$spans{M}[1]);
    $q->execute();
    while (my $row = $q->fetchrow_hashref())
    {
	my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
	foreach my $span (qw(H D W M))
	{
	    $stats{$span}{N}{$key} ||= { FROM_NODE => $$row{FROM_NODE},
				         TO_NODE => $$row{TO_NODE},
				         FILES => 0, BYTES => 0,
				         FAILED => 0, EXPIRED => 0 };
	    $stats{$span}{N}{$key}{FILES} += $$row{"${span}_DONE_FILES"};
	    $stats{$span}{N}{$key}{BYTES} += $$row{"${span}_DONE_BYTES"};
	    $stats{$span}{N}{$key}{FAILED} += $$row{"${span}_FAIL_FILES"};
	    $stats{$span}{N}{$key}{EXPIRED} += $$row{"${span}_EXPIRE_FILES"};
	}
    }

    my $errors = param('errors') ? "checked='checked'" : "";
    my $tofilter = param('tofilter') || "";
    my $fromfilter = param('fromfilter') || "";
    print "<form method='GET' action='@{[&baseurl()]}'><p>\n",
          "<input type='hidden' name='page' value='@{[param('page')]}'>\n",
          "<input type='hidden' name='db' value='@{[param('db')]}'>\n",
          "<input type='checkbox' name='errors' $errors>\n",
          "<label for='errors'>Show links with only errors</label> ",
    	  "<input type='submit' value='Update'></p>\n";
    print "<p><table class='striped'><tbody>\n";
    foreach my $span (qw(H D W M))
    {
	$stats{$span}{T}{1} = { FILES => 0, BYTES => 0, FAILED => 0, EXPIRED => 0 };

    	print
	  "<tr class='selected'>\n",
	  " <th colspan='7'>",
	  "Last @{[&format_timespan($spans{$span}[1])]}",
	  "</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>To</th>\n",
	  " <th>From</th>\n",
	  " <th rowspan='2'>Files</th>\n",
	  " <th rowspan='2'>Total Size</th>\n",
	  " <th rowspan='2'>Rate</th>\n",
	  " <th rowspan='2'>Errors</th>\n",
	  " <th rowspan='2'>Expired</th>\n",
	  "</tr>\n",
	  "<tr class='selected'>\n",
	  " <th>",
	  ($span eq 'H' ?
	   $cgi->textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
	  		   -title=>("Regular expression to match against node or link names. "
		  		    ."Only those matching the expression will be shown."))
	   : &escapeHTML($tofilter ? "($tofilter)" : "")), "</th>\n",
	  " <th>",
	  ($span eq 'H' ?
	   $cgi->textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	  		   -title=>("Regular expression to match against node or link names. "
		  		    ."Only those matching the expression will be shown."))
	   : &escapeHTML($fromfilter ? "($fromfilter)" : "")), "</th>\n",
	  "</tr>\n";

	foreach my $kind (qw(N T))
	{
	    foreach my $row (sort { $$b{BYTES} <=> $$a{BYTES}
				    || $$b{FAILED} <=> $$a{FAILED}
				    || $$b{EXPIRED} <=> $$a{EXPIRED}
				    || $$a{TO_NODE} cmp $$b{TO_NODE}
				    || $$a{FROM_NODE} cmp $$b{FROM_NODE} }
			     values %{$stats{$span}{$kind}})
	    {
		next if ($kind eq 'N'
			 && ($fromfilter || $tofilter)
			 && ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			       || ($tofilter && $$row{TO_NODE} =~ /$tofilter/)));
		next if $kind eq 'N' && ! $errors && ! $$row{FILES};
		next if $kind eq 'N' && ! $$row{FILES} && ! $$row{FAILED} && ! $$row{EXPIRED};
	        my $bps = $$row{BYTES} / $spans{$span}[1];
	        print "<tr>",
		      ($$row{FROM_NODE}
		       ? "<td>$$row{TO_NODE}</td><td>$$row{FROM_NODE}</td>"
		       : "<td colspan='2'>Total</td>"),
	              "<td align='right'>@{[&format_num($$row{FILES} || 0)]}</td>",
	              "<td align='right'>@{[&format_size($$row{BYTES})]}</td>",
		      "<td align='right'>", ($bps >= 0 ? &format_size($bps) . '/s' : &format_num(0)), "</td>",
	              "<td align='right'>@{[&format_num($$row{FAILED} || 0)]}</td>",
	              "<td align='right'>@{[&format_num($$row{EXPIRED} || 0)]}</td>",
	              "</tr>\n";

		if ($kind eq 'N')
		{
	            $stats{$span}{T}{1}{FILES} += $$row{FILES};
	            $stats{$span}{T}{1}{BYTES} += $$row{BYTES};
	            $stats{$span}{T}{1}{FAILED} += $$row{FAILED};
	            $stats{$span}{T}{1}{EXPIRED} += $$row{EXPIRED};
		}
	    }
	}
    }
    print "</tbody></table></p></form>\n";
}

sub dbreports
{
    my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
    my @reports = sort <$reportdir/$dbid-*.txt*>;
    print "<p><table class='striped'><tbody>\n",
          "<tr class='selected'><th colspan='32'>Available reports</th></tr>\n",
	  "<tr class='selected'>\n",
	  " <th>Month</td>\n",
	  (map { sprintf " <th>%02d</th>\n", $_ } 1 .. 31),
	  "</tr>\n";
    my $prev = "";
    my $prevday = 0;
    foreach my $file (@reports)
    {
	my $basename = $file; $basename =~ s|.*/||;
	my $cleanname = $basename; $cleanname =~ s|^$dbid-||;
	my $url = &baseurl("page" => "dbreport", "reportfile" => $cleanname);
	my ($year, $month, $day) = ($cleanname =~ /(\d\d\d\d)(\d\d)(\d\d)\..*/);
	if ("$year-$month" ne $prev)
	{
	    if ($prev)
	    {
	        while (++$prevday <= 31) { print "<td></td>\n"; }
	        print "</tr>\n";
	    }

	    print "<tr>\n <td>$year&#8209;$month</td>\n";
	    $prev = "$year-$month";
	    $prevday = 0;
	}
	while (++$prevday < $day) { print " <td></td>\n"; }
	print "<td align='center'><a href='$url'>R</a></td>\n";
	$prevday = $day;
    }

    print "</tbody></table></p>\n";
}

sub dbreport
{
    my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
    my $report = param('reportfile') || (strftime('%Y%m%d', gmtime()) . ".txt");
    print "<pre align='left'>\n";
    if ($report && $report =~ m|^[-A-Za-z0-9.]+$|)
    {
	my $reportfile = "$reportdir/$dbid-$report";
	if (-f $reportfile)
	{
	    local $/ = undef;
	    open (REPORT, $reportfile =~ /.gz$/ ? "gzip -dc < $reportfile |" : "< $reportfile");
	    print escapeHTML (<REPORT>);
	    close (REPORT);
	}
    }
    print "</pre>\n";
}

sub rateplot
{
    my @plotorder = qw(l48h l72h l96h l132h l7d l14d l30d l90d l6w l26w l52w ad aw am);
    my %plots = ("l48h" => [ "48:hour", "Last 48 Hours" ],
	         "l72h" => [ "72:hour", "Last 72 Hours" ],
	         "l96h" => [ "96:hour", "Last 96 Hours" ],
	         "l132h" => [ "132:hour", "Last 132 Hours" ],
	         "l7d" => [ "7:day", "Last 7 Days" ],
	         "l14d" => [ "14:day", "Last 14 Days" ],
	         "l30d" => [ "30:day", "Last 30 Days" ],
	         "l90d" => [ "90:day", "Last 90 Days" ],
		 "l6w" => [ "6:week", "Last 6 Weeks" ],
		 "l26w" => [ "26:week", "Last 26 Weeks" ],
		 "l52w" => [ "52:week", "Last 52 Weeks" ],
	         "ad" => [ "0:day", "Daily Since Start" ],
		 "aw" => [ "0:week", "Weekly Since Start" ],
		 "am" => [ "0:month", "Monthly Since Start" ]);
    my $plot = param("plot");
    my $graph = param("graph") || 'bar';
    my $entity = param("entity") || 'dest';
    my $filter = param("filter") || '';
    my $upto = param("upto") || '';
    $plot = 'l96h' if (! $plot || ! exists $plots{$plot});

    print "<p><form method='GET' action='@{[&baseurl()]}'>\n",
          "<input type='hidden' name='page' value='@{[param('page')]}'>\n",
          "<input type='hidden' name='db' value='@{[param('db')]}'>\n",
          "<label for='graph'>Graph</label>\n",
          "<select name='graph' onchange='submit()'>",
	  " <option", ($graph eq 'bar' ? " selected='selected'" : ""),
	  "  value='bar'>Bar graph</option>",
	  " <option ", ($graph eq 'line' ? 'selected=selected' : ''),
	  "  value='line'>Cumulative</option>",
          "</select>\n",
          "<label for='plot'>Period</label> ",
          "<select name='plot' onchange='submit()'>";
    foreach my $p (@plotorder)
    {
	print "<option", ($plot eq $p ? ' selected=selected' : ''),
	      " value='$p'>$plots{$p}[1]</option>";
    }
    print "</select>\n",
          "<label for='entity'>By</label> ",
    	  "<select name='entity' onchange='submit()'>",
	  " <option ", ($entity eq 'dest' ? 'selected=selected' : ''),
	  "  value='dest'>Destination</option>",
	  " <option ", ($entity eq 'src' ? 'selected=selected' : ''),
	  "  value='src'>Source</option>",
	  " <option ", ($entity eq 'link' ? 'selected=selected' : ''),
	  "  value='link'>Link</option>",
          "</select>\n",
          "<label for='filter'>Filter</label> ",
	  $cgi->textfield(-name=>'filter', -default=>$filter, -size=>15,
	  		  -title=>("Regular expression to match against node or link names. "
		  		   ."Only those matching the expression will be shown.")), "\n",
          "<label for='upto'>Up to</label> ",
	  $cgi->textfield(-name=>'upto', -default=>$upto, -size=>15,
	  		  -title=>("Time up to and including which results will be shown. "
				   ."Specify the time in format matching the selected plot type:\n"
				   ."YYYYMMDDZHHMM for hourly plots;\n"
				   ."YYYYMMDD for daily plots;\n"
				   ."YYYYMM for monthly plots;\n"
				   ."YYYYWW for weekly plots.")), "\n",
    	  "<input type='submit' value='Update'></form></p>\n";
    foreach my $kind (param('page') eq 'rateplot' ? qw(rate total) : qw(pending))
    {
	next if ($graph eq 'line' && $kind ne 'total');
	my ($last, $unit) = $plots{$plot}[0] =~ /([^:]+)/g;
	my $suffix = ($graph eq 'bar' ? '' : '-line');
	print "<p><img width=900 height=406 src='perf-graph$suffix-23.php?",
	      &urlencode('db' => $db, 'span' => $unit, 'kind' => $kind, 'by' => $entity,
		         'last' => $last, 'filter' => $filter, 'upto' => $upto),
	      "' /></p>";
    }
}

sub qplot
{
    my @plotorder = qw(l48h l72h l96h l132h l7d l14d l30d l90d l6w l26w l52w ad aw am);
    my %plots = ("l48h" => [ "48:hour", "Last 48 Hours" ],
	         "l72h" => [ "72:hour", "Last 72 Hours" ],
	         "l96h" => [ "96:hour", "Last 96 Hours" ],
	         "l132h" => [ "132:hour", "Last 132 Hours" ],
	         "l7d" => [ "7:day", "Last 7 Days" ],
	         "l14d" => [ "14:day", "Last 14 Days" ],
	         "l30d" => [ "30:day", "Last 30 Days" ],
	         "l90d" => [ "90:day", "Last 90 Days" ],
		 "l6w" => [ "6:week", "Last 6 Weeks" ],
		 "l26w" => [ "26:week", "Last 26 Weeks" ],
		 "l52w" => [ "52:week", "Last 52 Weeks" ],
	         "ad" => [ "0:day", "Daily Since Start" ],
		 "aw" => [ "0:week", "Weekly Since Start" ],
		 "am" => [ "0:month", "Monthly Since Start" ]);
    my $plot = param("plot");
    my $filter = param("filter") || '';
    my $entity = param("entity") || 'dest';
    my $upto = param("upto") || '';
    $plot = 'l96h' if (! $plot || ! exists $plots{$plot});

    print "<p><form method='GET' action='@{[&baseurl()]}'>\n",
          "<input type='hidden' name='page' value='@{[param('page')]}'>\n",
          "<input type='hidden' name='db' value='@{[param('db')]}'>\n",
          "<label for='plot'>Period</label> ",
          "<select name='plot' onchange='submit()'>";
    foreach my $p (@plotorder)
    {
	print "<option ", ($plot eq $p ? 'selected=selected' : ''),
	      " value='$p'>$plots{$p}[1]</option>";
    }
    print "</select>\n",
          "<label for='entity'>By</label> ",
    	  "<select name='entity' onchange='submit()'>",
	  " <option ", ($entity eq 'dest' ? 'selected=selected' : ''),
	  "  value='dest'>Destination</option>",
	  " <option ", ($entity eq 'src' ? 'selected=selected' : ''),
	  "  value='src'>Source</option>",
	  " <option ", ($entity eq 'link' ? 'selected=selected' : ''),
	  "  value='link'>Link</option>",
          "</select>\n",
          "<label for='filter'>Filter</label> ",
	  $cgi->textfield(-name=>'filter', -default=>$filter, -size=>15,
	  		  -title=>("Regular expression to match against node or link names. "
		  		   ."Only those matching the expression will be shown.")), "\n",
          "<label for='upto'>Up to</label> ",
	  $cgi->textfield(-name=>'upto', -default=>$upto, -size=>15,
	  		  -title=>("Time up to and including which results will be shown. "
				   ."Specify the time in format matching the selected plot type:\n"
				   ."YYYYMMDDZHHMM for hourly plots;\n"
				   ."YYYYMMDD for daily plots;\n"
				   ."YYYYMM for monthly plots;\n"
				   ."YYYYWW for weekly plots.")), "\n",
    	  "<input type='submit' value='Update'></form></p>\n";
    foreach my $kind (qw(completed_ratio attempted completed failed))
    {
	my ($last, $unit) = $plots{$plot}[0] =~ /([^:]+)/g;
	my $php = ($kind =~ /_/ ? "quality-map-23.php" : "quality-graph-23.php");
	print "<p><img width=900 height=406 src='$php?",
	      &urlencode('db' => $db, 'span' => $unit, 'kind' => $kind, by => $entity,
		         'last' => $last, 'filter' => $filter, 'upto' => $upto),
	      "' /></p>";
    }
}

######################################################################
# Nicked IO::Capture::Stdout from CPAN.
#
# Mark Reynolds <reynolds@sgi.com>; Jon Morgan <jmorgan@sgi.com>.
# Copyright (c) 2003, Mark Reynolds. All Rights Reserved. This module
# is free software. It may be used, redistributed and/or modified under
# the same terms as Perl itself.
package IO::Capture::Tie_STDx;
sub TIEHANDLE { my $class = shift; bless [], $class; }
sub PRINTF { my $self   = shift; my $format = shift; $self->PRINT( sprintf( $format, @_ ) ); }
sub PRINT { my $self = shift; push @$self, join '',@_; }
sub READLINE { my $self = shift; return wantarray ? @$self : shift @$self; }
sub CLOSE { my $self = shift; return close $self; }
1;

package IO::Capture;
use strict;
use Carp;

sub new {
    my $class = shift;
    if (ref $class) {
	carp "WARNING: " . __PACKAGE__ . "::new cannot be called from existing object. (cloned)";
	return;
    }
    my $object = shift || {};
    bless $object, $class;
    $object->_initialize; 
}

sub _check_pre_conditions {
    my $self = shift;

    if( $self->{'IO::Capture::status'} ne "Ready") {
	carp "Start issued on an in progress capture ". ref($self);
	return;
    }

    return 1;
}

sub _initialize {
    my $self = shift;
    if (!ref $self) {
	carp "WARNING: _initialize was called, but not called from a valid object";
	return;
    }

    $self->{'IO::Capture::messages'} = [];
    $self->{'IO::Capture::line_pointer'} = 1;
    $self->{'IO::Capture::status'} = "Ready";
    return $self;
}

sub start {
    my $self = shift;

    if (! $self->_check_pre_conditions) {
	carp "Error: failed _check_pre_confitions in ". ref($self);
	return;
    }

    if (! $self->_save_current_configuration ) { 
	carp "Error saving configuration in " . ref($self);
	return;
    }

    $self->{'IO::Capture::status'} = "Busy";

    if (! $self->_start(@_)) {
	carp "Error starting capture in " . ref($self);
	return;
    }
    return 1;
}

sub stop {
    my $self = shift;

    if( $self->{'IO::Capture::status'} ne "Busy") {
	carp "Stop issued on an unstarted capture ". ref($self);
	return;
    }

    if (! $self->_retrieve_captured_text() ) {
        carp "Error retreaving captured text in " . ref($self);
	return;
    }

    if (!$self->_stop() ) {
	carp "Error return from _stop() " . ref($self) . "\n";
	return;
    }

    $self->{'IO::Capture::status'} = "Ready";
    return 1;
}

sub read {
    my $self = shift;
    $self->_read;
}

#
#  Internal start routine.  This needs to be overriden with instance
#  method
#
sub _start {
    my $self = shift;
    return 1;
}

sub _read {
    my $self = shift;
    my $messages = \@{$self->{'IO::Capture::messages'}};
    my $line_pointer = \$self->{'IO::Capture::line_pointer'};

    if ($self->{'IO::Capture::status'} ne "Ready") {
	carp "Read cannot be done while capture is in progress". ref($self);
	return;
    }

    return if $$line_pointer > @$messages;
    return wantarray ? @$messages :  $messages->[($$line_pointer++)-1];
}

sub _retrieve_captured_text {
    return 1;
    
}

sub _save_current_configuration {
    my $self = shift;
    $self->{'IO::Capture::handler_save'} = $SIG{__WARN__};
    open STDOUT_SAVE, ">&STDOUT";
    $self->{'IO::Capture::stdout_save'} = *STDOUT_SAVE;
    open STDERR_SAVE, ">&STDOUT";
    $self->{'IO::Capture::stderr_save'} = *STDERR_SAVE;
    return $self; 
}

sub _stop {
    my $self = shift;
    return 1;
}

sub line_pointer {
    my $self = shift;
    my $new_number = shift;

    $self->{'IO::Capture::line_pointer'} = $new_number if $new_number;
    return $self->{'IO::Capture::line_pointer'};
}
1;

package IO::Capture::Stdout;
use Carp; use base qw/IO::Capture/;

sub _start {
    my $self = shift;
    $self->line_pointer(1);
    tie *STDOUT, "IO::Capture::Tie_STDx";
}

sub _retrieve_captured_text {
    my $self = shift;
    my $messages = \@{$self->{'IO::Capture::messages'}};
    @$messages = <STDOUT>;
    #$self->line_pointer(1);
    return 1;
}

sub _check_pre_conditions {
    my $self = shift;
    return unless $self->SUPER::_check_pre_conditions;
    if (tied *STDOUT) {
	carp "WARNING: STDOUT already tied, unable to capture";
	return;
    }
    return 1;
}

sub _stop { untie *STDOUT; }
1;
######################################################################
__END__
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, monitoring, status" />
  <link rel="stylesheet" href="../style.css" type="text/css" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <script type="text/javascript" src="../stripe.js"></script>

  <title>@DBID@ @PAGETITLE@: PhEDEx Status</title>
</head>

<body onload='stripe("#fff", "#edf3fe")'>
<div id="page">
<div id="header">
  <!-- Logo and page title -->
  <div id="logo">
    <a href="http://cern.ch/cms-project-phedex/" title="PhEDEx Home Page"
      ><img src="../phedex-logo.gif" alt="PhEDEx" height="120" /></a>
  </div>

  <div id="heading">
    <h1 class="title">PhEDEx @DBID@ Status</h1>
    <h2>@PAGETITLE@</h2>
    <h4>@TIME@</h4>
  </div>

  <!-- Main navigation bar: public/developers/other -->
  @DBSELECTOR@
</div> <!-- /header -->

<!-- side navigation bar -->
<div id="sidebar">
  <div class="sidetopic"><h2>Monitor Options</h2>
    <p>@PAGESELECTOR@</p>
  </div>
</div> <!-- /sidebar -->

<!-- main content -->
<div id="content">
<center>
@CONTENT@
<hr />
</center>
</div>
</div>
</body>
</html>
