#!/usr/bin/env perl

######################################################################
package Web::Common; use strict; use warnings; use base "Exporter";
use CGI qw(:standard unescape);
use Net::hostent;
require Socket;
use POSIX qw(strftime mktime);

our @EXPORT = qw(urlencode dblink toclink pagelink
		 alert warning breakAtSlash note
		 age format_num format_size format_timespan
		 badcolor warncolor pendcolor goodcolor altcolor
		 dbexec dbprep dbbindexec makeObjWithAttrs
		 timeSeries formatTime timegm sizeValue);

# Various useful colours
our $badcolor = '#ff9e9e';
our $warncolor = '#ffd89e';
our $pendcolor = '#ccccff'; # ececff
our $goodcolor = '#ccffcc';
our $altcolor = '#f0f0f0';

# Encode arguments into a URL query string.
sub urlencode
{
  eval "use CGI '-oldstyle_urls'";
  my %args = @_; return new CGI (\%args)->query_string();
}

# Generate a HTML <a> link for a database instance.
sub dblink
{
  my ($self, $dbname, $db) = @_;
  return "<a href='" . $self->myurl('db' => $$db{ID})
    . "' title='$$db{TITLE} database instance'>$$db{TITLE}</a>";
}

# Generate a HTML <a> link for a category.  For now this is just a
# link to the first page of the category.
sub toclink
{
  my ($self, $category) = @_;

  # Scan pages for this category
  no strict "refs";
  my @pages = ();
  my $scope = \%{*{$category}{PACKAGE} . "::"};
  foreach (keys %$scope)
  {
    next if ! /::$/;
    next if ! exists ${$$scope{$_}}{INDEX};
    push(@pages, ${$$scope{$_}}{INDEX});
  }

  @pages = sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @pages;
  return &pagelink($self, $pages[0], ${$$category}{TITLE});
}

# Generate a HTML <a> link for a page.
sub pagelink
{
  my ($self, $page, $label) = @_;
  my $title = "";
  my $url = ${$$page}{LINK};
  my $name = *{$page}{PACKAGE}; $name =~ s/Web:://;
  $label = ${$$page}{TITLE} if ! defined $label;

  # If the page has a title, stuff into a link attribute.
  if (${$$page}{LINK_TITLE})
  {
    $title = " title='@{[&escapeHTML(${$$page}{LINK_TITLE})]}'";
  }

  # If the page has a URL, convert relative one; otherwise generate a URL.
  if ($url && $url !~ /^[a-z]+:/ && substr($url,0,1) ne '/') 
  {
    $url = "$$self{CONFIG}{SERVICE_PATH}/$url";
  }
  elsif (! $url)
  {
    $url = $self->myurl("page" => $name);
  }

  # Return final link.
  return "<a href='$url'$title>" .  &escapeHTML($label) . "</a>";
}

# Convert a time difference into human-friendly short age string.
sub age
{
  my ($diff) = @_;
  my $str = "";
  my $full = 0;
  if ($diff >= 86400)
  {
    $str .= sprintf("%dd", $diff / 86400);
    $diff %= 86400;
    $full = 1;
  }
  $str .= sprintf("%dh", $diff / 3600);
  $diff %= 3600;
  $str .= sprintf("%02d", $diff / 60);
  return $str;
}

# Convert a time span into human-friendly long string.
sub format_timespan
{
  my $span = shift;
  if ($span >= 86400)
  {
    $span /= 86400;
    return $span == 1 ? "day" : "$span days";
  }
  elsif ($span >= 3600)
  {
    $span /= 3600;
    return $span == 1 ? "hour" : "$span hours";
  } elsif ($span >= 60) {
    $span /= 60;
    return $span == 1 ? "minute" : "$span minutes";
  } else {
    return $span == 1 ? "second" : "$span seconds";
  }
}

sub breakAtSlash
{
  my ($val) = @_;
  my $agent = $ENV{HTTP_USER_AGENT} || "";
  $val =~ s,/,/&#8203;,g if ($agent =~ /Mozilla/ && $agent !~ /MSIE/);
  return $val;
}

# Generate an alert into the output.
sub alert
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='alert'>",
    "<p><b>Error:</b> ", @_, "</p></div></center>\n";
}

# Generate a warning into the output.
sub warning
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='warning'>",
    "<p><b>Warning:</b> ", @_, "</p></div></center>\n";
}

# Generate a note into the output.
sub note
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='note'>",
    "<p>", @_, "</p></div></center>\n";
}

# Format a number as a string.  Zero is converted into a dash.
sub format_num
{
  my ($n) = @_;
  return $n ? "$n" : '&#8211;';
}

# Format a file size as a string.  The value is automatically
# abbreviated with a k/M/G/T/P/E suffix, either the first that
# applies or a minimum scale requested by the caller.  The default
# precision is one decimal point, but the caller can change this.
sub format_size {
  my ($bytes, $nodash, $precision, $minscale) = @_;
  my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		[ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
  my ($val, $unit, $minus) = ($bytes, '', $bytes < 0 ? "-" : "");
  do { $val = -$val; $bytes = -$bytes; } if $minus;
  while (@bounds && ($bytes >= $bounds [0][0] || defined $minscale))
  {
    $val = $bytes / $bounds[0][0];
    $unit = $bounds[0][1];
    undef $minscale if (defined $minscale && $minscale eq $unit);
    shift (@bounds);
  }

  $precision = "1" if ! defined $precision;
  return $bytes || $nodash
    ? sprintf("%s%.${precision}f&nbsp;%sB", $minus, $val, $unit)
    : '&#8211;';
}

# Tidy up SQL statement
sub dbsql
{
  my ($sql) = @_;
  $sql =~ s/--.*//mg;
  $sql =~ s/^\s+//mg;
  $sql =~ s/\s+$//mg;
  $sql =~ s/\n/ /g;
  return $sql;
}

# Simple utility to prepare a SQL statement
sub dbprep
{
  my ($dbh, $sql) = @_;
  return $dbh->prepare (&dbsql ($sql));
}

# Simple utility to prepare, bind and execute a SQL statement.
sub dbexec
{
  my ($dbh, $sql, %params) = @_;
  my $stmt = &dbprep ($dbh, $sql);
  my $rv = &dbbindexec ($stmt, %params);
  return wantarray ? ($stmt, $rv) : $stmt;
}

# Simple bind and execute a SQL statement.
sub dbbindexec
{
  my ($stmt, %params) = @_;
  my $isarray = 0;
  while (my ($param, $val) = each %params)
  {
    if (ref $val eq 'ARRAY')
    {
      $stmt->bind_param_array ($param, $val);
      $isarray++;
    }
    elsif (ref $val)
    {
      $stmt->bind_param_inout ($param, $val, 4096);
    }
    else
    {
      $stmt->bind_param ($param, $val);
    }
  }

  return $isarray
    ? $stmt->execute_array({ ArrayTupleResult => [] })
    : $stmt->execute();
}

# Convenience wrapper for automatically constructing an object
# with requested set of attributes.
sub makeObjWithAttrs
{
  my ($dbh, $kind, $link, $obj, @attrs) = @_;
  my ($tname, $sname) = ("t_$kind", "seq_$kind");
  my @objfields = keys %$obj;
  my %objattrs = map { (":attr_$_" => $$obj{$_}) } @objfields;
  my $objsql =
    "insert into $tname ("
    . join(", ", "id", @objfields)
    . ")\n values ("
    . join(", ", "$sname.nextval", map { ":attr_$_" } @objfields)
    . ")\n returning id into :id";
  my $id = undef;
  &dbexec($dbh, $objsql, ":id" => \$id, %objattrs);

  $tname .= "_attr"; $sname .= "_attr";
  while (@attrs)
  {
    my ($name, $value) = splice(@attrs, 0, 2);
    &dbexec($dbh, qq{
      insert into $tname (id, $link, name, value)
      values ($sname.nextval, :id, :name, :value)},
      ":id" => $id, ":name" => $name, ":value" => $value);
  }

  return $id;
}

# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
  my ($first, $range, $now) = @_;
  $now ||= time();
  my @series = ();
  $first = int($first);

  if ($range eq 'hour') {
    # Convert first time to UTC hour in units of half a day.  Then
    # make a time series of hours until end of current 4 hours.
    my $low = int($first / 3600);
    my $high = int($now / 3600) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
    }
  } elsif ($range eq 'day') {
    # Convert first time to UTC day at 00:00.  Then make a
    # time series of days until end of today.
    my $low = int($first / 86400);
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
    }
  } elsif ($range eq 'week') {
    # Convert first time to previous Monday.  Then make a
    # time series of weeks until we pass today.
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $low = int($first/86400) - $diff{$wday};
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; $low += 7) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
    }
  } elsif ($range eq 'month') {
    # Convert first time to first of the month.  Then convert
    # into a time-series of months.  This is a bit dodgy, we
    # go by day so we don't need to worry about month dates.
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $start = int(($first - ($mday-1)*86400)/86400);
    my $limit = int($now / 86400) + 1;
    while ($start < $limit)
    {
      my $low = $start;
      my ($prevyear, $prevmon) = ($year, $mon);
      while ($year == $prevyear && $mon == $prevmon)
      {
	($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
	  = gmtime ((++$start) * 86400);
      }
      push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
    }
  }

  return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
  my ($time, $range) = @_;
  if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
  elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
  elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
  elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
  my @args = @_;
  my $t1 = mktime (@args);
  my @gmt = gmtime ($t1);
  my $t2 = mktime (@gmt);
  return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
  my ($value) = @_;
  if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
  {
    my %scale = ('k' => 2**10, 'M' => 2**20, 'G' => 2**30,
		 'T' => 2**40, 'P' => 2**50, 'E' => 2**60);
    $value = $1 * $scale{$2};
  }
  return $value * 1.0;
}

1;

######################################################################
package Web::Page;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web::Common;

our $TEMPLATE = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }
   --></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
'>
<div id="page">
<div id="header">
 <!-- Logo and page title -->
 <div id="logo">
  <a href="http://cern.ch/cms-project-phedex/" title="PhEDEx Home Page"
    ><img src="@ROOTURL@phedex-logo-small.gif" alt="PhEDEx" height="80" /></a>
 </div> <!-- /logo -->

 <div id="heading">
  <h1 class="title">PhEDEx &#8211; CMS Data Transfers</h1>
  <div class="pagenav">
   @TOCSELECTOR@
   @PAGESELECTOR@
  </div> <!-- /pagenav -->
 </div> <!-- /heading -->
</div> <!-- /header -->

<!-- main content -->
<div id="content">
@THIS_IS_A_TEST@
@CONTENT@
</div>
</div>

<!-- side navigation panel -->
<div class="viewnav">
@DBSELECTOR@
@IDENTITY@
@MYPAGE@
@SIDEBAR@
</div>

</body>
</html>
END_OF_TEMPLATE

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};
  bless $self, $class;
  return $self;
}

sub toc
{
  my ($self) = @_;
  my @result = ();
  foreach (keys %{Web::})
  {
    next if ! /::$/;
    next if ! exists ${$Web::{$_}}{TOC};
    push (@result, ${$Web::{$_}}{TOC});
  }
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

sub index
{
  my ($self) = @_;
  my @result = ();

  # Get the type of dynamic type of this page and navigate to
  # the namespace scope just above it (e.g. Web::Request::).
  no strict "refs";
  my $scope = ref $self;
  $scope =~ s/[^:]+$//;

  # Search the scope for sub-types with $INDEX.  These are
  # web pages we'll offer to make visible.
  foreach (keys %$scope)
  {
    push (@result, ${$$scope{$_}}{INDEX})
      if /::$/ && exists ${$$scope{$_}}{INDEX};
  }

  # Sort the pages by order tag.
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

# Return a hash of existing valid parameters
sub urlparams
{
  my ($self, @names) = @_;
  my %known = map { $_ => 1 } param();
  my %result = ();

  foreach my $name (@names)
  {
    $result{$name} = [ param($name) ]
      if exists $known{$name};
  }
  return %result;
}

# Return a URL to this page, i.e. a URL which would come back to this
# page, plus additional query parameters.  The page can be changed
# with "page" parametre and database instance with "db" parametre;
# these are automatically converted into script path components such
# that the final URL is "/path/to/script[/DB[/PAGE]][?QUERY]".
sub myurl
{
  my $self = shift(@_);
  my $curpage = param('page');
  my $curview = param('view');
  my $cursecure = (($ENV{HTTPS} || 'nope') eq 'on' ? 1 : 0);
  my %args = ('db' => $$self{DBID},
	      ($cursecure ? ('secure' => 1) : ()),
	      ($curview ? ('view' => $curview) : ()),
	      ($curpage ? ('page' => $curpage) : ()),
	      @_);
  my $page = $args{'page'}; delete $args{'page'};
  my $db = $args{'db'}; delete $args{'db'};
  my $secure = $args{'secure'}; delete $args{'secure'};

  my $newcgi = new CGI ("");
  $newcgi->param ($_, ref $args{$_} ? @{$args{$_}} : $args{$_}) for keys %args;
  my $url = $$self{CONFIG}{SERVICE_PATH};
  my $q = $newcgi->query_string();
  $url = $$self{CONFIG}{$secure ? "SSL_SERVER_ROOT" : "SERVER_ROOT"} . $url
    if ($cursecure || 0) != ($secure || 0);
  $url .= "/$db";
  $url .= "/$page" if $page;
  $url .= "?$q" if $q;
  return $url;
}

sub generate
{
  my ($self, $config, $db) = @_;
  $$self{CONFIG} = $config;
  $$self{DBID} = $db;

  # Find the class cope index of this page instance.
  my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

  # Do we have SSL login information from a secure proxy, but none
  # direcly?  If so, grab the headers from the proxy and use them
  # here.  *WARNING* This can potentially open up a security hole
  # the size of an elephant!  We are taking "trusted" values from
  # the HTTP headers, and need to be aboslutely sure nobody does
  # e.g. "wget" with faked header values.  It's paramount to trust
  # the proxy source.

  if (! $ENV{SSL_CLIENT_VERIFY} && ! $ENV{HTTPS}
      && grep($ENV{REMOTE_HOST} eq $_, qw(cms.cern.ch cmslcgse02.cern.ch))
      && ($ENV{HTTP_HTTPS} || 'nope') eq 'on'
      && $ENV{HTTP_SSL_CLIENT_VERIFY})
  {
    my ($pre, $data, $post);
    $ENV{HTTPS} = "on";
    $ENV{SSL_CLIENT_VERIFY} = $ENV{HTTP_SSL_CLIENT_VERIFY};
    if ($ENV{HTTP_SSL_CLIENT_S_DN})
    {
      $ENV{SSL_CLIENT_S_DN} = $ENV{HTTP_SSL_CLIENT_S_DN};
    }
    if ($ENV{HTTP_SSL_CLIENT_CERT})
    {
      my ($pre, $data, $post)
        = ($ENV{HTTP_SSL_CLIENT_CERT} =~ /^(-+[A-Z ]+-+) (.*) (-+[A-Z ]+-+)$/);
      $ENV{SSL_CLIENT_CERT} = "$pre\n" . join("\n", split(" ", $data)) . "\n$post\n";
    }
  }

  # Force redirect to https if using http
  if ($$index{SECURE} && ($ENV{HTTPS} || 'nope') ne 'on')
  {
    print redirect(-url => $self->myurl("secure" => 1));
    return;
  }

  # Check if the client's identity was verified
  my $idurl = $self->myurl('page' => 'Configuration::Identities');
  if ($ENV{SSL_CLIENT_S_DN} && ($ENV{SSL_CLIENT_VERIFY} || '') eq 'SUCCESS')
  {
    $$self{SSL_VERIFIED} = 1;
    $$self{SSL_IDENTITY} = $ENV{SSL_CLIENT_S_DN};
    $$self{SSL_CERT} = $ENV{SSL_CLIENT_CERT};
    my ($login) = ($$self{SSL_IDENTITY} =~ m,/CN=([^/]+?)[\s\d]*(/|$),); #/
    $$self{SSL_MSG_STATUS} =
      "<p><a href='$idurl'>" . &escapeHTML($login) . "</a>";
    $$self{SSL_MSG_CHANGE} =
      " | <a href='" . $self->myurl("secure" => 0) . "'>Sign out</a></p>";
  }
  else
  {
    $$self{SSL_VERIFIED} = 0;
    $$self{SSL_IDENTITY} = undef;
    $$self{SSL_CERT} = undef;
    if (($ENV{HTTPS} || "nope") eq 'on')
    {
      $$self{SSL_MSG_STATUS} =
       "<p><span style='color:#666'>Sign in <a href='$idurl'>failed</a>";
      $$self{SSL_MSG_CHANGE} =
       " | <a href='" . $self->myurl("secure" => 0) . "'>Sign out</a></p>";
    }
    else
    {
      $$self{SSL_MSG_STATUS} =
        "<p><span style='color:#666'>Not signed in</span>";
      $$self{SSL_MSG_CHANGE} =
        " | <a href='" . $self->myurl("secure" => 1) . "'>Sign in</a></p>";
    }
  }

  # Check whether we are looking at our vs. global view
  if (! $$self{SSL_VERIFIED})
  {
    param('view', $$self{MY_VIEW} = 'global');
    $$self{VIEW_MESSAGE} = "<h3 style='color:#666'>Global view</h3><p style='color:#666'>(Sign in to change)</p>";
  }
  elsif ($$self{MY_VIEW} = ((param('view') || 'none') eq 'my'))
  {
    my $otherurl = $self->myurl('view' => 'global');
    $$self{VIEW_MESSAGE} = "<h3>Your view</h3><p>Switch to <a href='$otherurl'>global view</a></p>";
  }
  else
  {
    my $otherurl = $self->myurl('view' => 'my');
    $$self{VIEW_MESSAGE} = "<h3>Global view</h3><p>Switch to <a href='$otherurl'>your view</a></p>";
  }

  # Select page we are visiting
  my %pagemap;
  my @pages = grep(${$$_}{LIST}, $self->index());
  foreach (@pages)
  {
    my ($name) = (*{$_}{PACKAGE} =~ /Web::(.*)/);
    $pagemap{$_} = $name;
  }

  my $page = param('page');
  my @toc = $self->toc();
  my $cat = do {
    no strict "refs";
    my $scope = ref $self;
    $scope =~ s/[^:]+$//;
    exists $$scope{TOC} ? ${"${scope}TOC"} : undef
  };

  # Check if this is running against a test location and warn if so
  my $testwarn = "";
  if ($ENV{SCRIPT_NAME} =~ m!/test/!)
  {
    my $prod = $self->myurl();
    $prod =~ s!/test/!/!;
    $testwarn =
      "<center><div class='warning'>"
      . "Hoy!  The production server is <a href='$prod'>over this way</a>."
      . " This is a test server for the developers. You might wish to update"
      . " your bookmarks."
      . "</div></center>";
  }

  # Initialise page template
  my $ndb = 0;
  my $replacements = {
    'THIS_IS_A_TEST' => $testwarn,
    'CONTENT' => '',
    'PAGETITLE' =>
      ($cat ? $$cat{TITLE} . " &#8211; " . $$index{TITLE} : $$index{TITLE}),
    'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
    'DBTITLE' => $$config{INSTANCES}{$db}{TITLE},
    'ROOTURL' => "$$self{CONFIG}{SERVICE_PATH}/",
    'REFRESH' => (param('refresh') ? "<meta http-equiv='refresh' content='600'>" : ""),
    'DBSELECTOR' =>
      (" <div class='dbopt'>\n" .
       "  <h3 style='margin-top:0'>Instance</h3>\n" .
       "  <i>$$config{INSTANCES}{$db}{TITLE}</i>&nbsp;" .
       "<a href='@{[$self->myurl('page'=>'DB')]}'" .
       " onclick='return hideshow(this,\"dbopts\",0)'>&#187;&#187;</a>\n" .
       "  <div id='dbopts' style='display:none'>\n" .
       "   <a href='#' onclick='return hideshow(this,\"dbopts\",0)'><img" .
       " border='0' src='$$self{CONFIG}{SERVICE_PATH}/x.gif'" .
       " width='13' height='13' alt='Close menu' align='right'" .
       " style='position:relative;margin:.5ex -.5ex .1ex 1ex' /></a>\n" .
       join ("",
             map { "   " . &dblink ($self, $db, $_) . "<br />\n" }
	     sort { $$a{RANK} <=> $$b{RANK} }
	     grep($$_{ID} ne $db, values %{$$config{INSTANCES}})) .
       "  </div>\n" .
       " </div>"),
    'TOCSELECTOR' =>
      (@toc ?
       "<div class='catopt'>\n" .
       " <ul>\n" .
       join("", map { "  <li"
		      . ($$_ == $cat
			 ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
			 : (">" . &toclink($self, $_)))
		      . "</li>\n" } @toc) .
       " </ul>\n" .
       "</div>" : ""),
    'PAGESELECTOR' =>
      (@pages ?
       "<div class='menuopt'>\n" .
       " <ul>\n" .
       join("",
	    map { "  <li" .
		  ("Web::$page" eq *{$_}{PACKAGE}
		   ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
		   : (">" . &pagelink($self, $_)))
		  . "</li>\n" }
	    @pages) .
       " </ul>\n" .
       "</div>" : ""),
    'IDENTITY' =>
      (" <div>\n" .
       # "  <h3>Identity</h3>\n" .
       "  $$self{SSL_MSG_STATUS}$$self{SSL_MSG_CHANGE}\n" .
       " </div>"),
    'MYPAGE' => "<div>$$self{VIEW_MESSAGE}</div>",
  };

  # Execute the desired page.  We save old STDOUT to print to it
  # later, then redirect the page routine's output to CONTENT.
  my ($output, $sidebar) = ("", "");
  open ($$self{CONTENT}, ">", \$output);
  open ($$self{SIDEBAR}, ">", \$sidebar);
  eval
  {
    # Connect to the database, do the page, the disconnect
    if (! $$index{NOLOGIN})
    {
      eval
      {
	my $dbtns = $$config{INSTANCES}{$db}{DATABASE_NAME};
        my $dbuser = $$config{INSTANCES}{$db}{USER_NAME};
        my $dbpass = $$config{INSTANCES}{$db}{PASSWORD};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>1 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;
      };
      if ($@)
      {
	my $feedbackurl =
	  "mailto:cms-phedex-admins\@cern.ch?subject="
	  . "PhEDEx%20web%20is%20inaccessible";

	print { $$self{CONTENT} }
	  "<center><div class='alert'>\n",
	  " <p>This PhEDEx instance is not available at this time.",
	  " Please try again at another time, or if the problem",
	  " persists and this is an instance you should be using,",
	  " please <a href='$feedbackurl'>notify the administrators</a>.",
	  "</p>",
          # "<p>The database error was: <i>", &escapeHTML($@), "</i></p>",
          "</div></center>\n";
	return;
      }
    }
    $self->output();
    if ($$self{DBH})
    {
      $$self{DBH}->disconnect() if $$self{DBH};
      delete $$self{DBH};
    }
  };
  if ($@)
  {
    my $message = $@;
    $message = &escapeHTML($message);

    my $feedbackurl =
      "mailto:cms-phedex-admins\@cern.ch?subject="
      . "PhEDEx%20web%20server%20trouble";

    if ($message =~ /ORA-00942/) # table or view doesn't exist
    {
      print { $$self{CONTENT} }
        "<center><div class='warning'>\n",
        " <p>This PhEDEx instance is not capable of providing",
        " this feature.  Perhaps you meant to select another PhEDEx",
        " instance in the instance menu above?</p></div></center>\n";
    }
    else
    {
      print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Apologies, looks like we have an internal server error,",
        " details of which below.  If the problem persists, please",
        " <a href='$feedbackurl'>notify the administrators</a>.</p>\n",
        " <p><i>$message</i></p>\n",
        "</div></center>\n";
    }
  }
  close($$self{CONTENT});
  close($$self{SIDEBAR});
  $$replacements{CONTENT} = join("\n", $output);
  $$replacements{SIDEBAR} = join("\n", $sidebar);

  # Instantiate the template and spit it out
  my $result = $TEMPLATE;
  while (my ($key, $value) = each %$replacements)
  {
    $result =~ s/\@$key\@/$value/g;
  }

  print header(-type => 'text/html'), $result;
}

1;

######################################################################
package Web::Info::Main;
use strict; use warnings;
use base "Web::Page";
use CGI qw(:standard);
import Web::Common;
our $INDEX = { LIST => 1, ORDER => 0, NOLOGIN => 1, TITLE => "Overview" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  no strict "refs";
  foreach my $toc ($self->toc())
  {
    next if ! ${$$toc}{LIST};
    my $type = *{$toc}{PACKAGE};
    print { $$self{CONTENT} }
      (${$$toc}{ORDER} % 4 ? "" : "<p style='clear: left'></p>\n"),
      "<div class='toc'>\n",
      " <h2>", &escapeHTML(${$$toc}{TITLE}), "</h2>\n",
      " <ul>\n";

    my @pages = ();
    my $scope = "${type}::";
    foreach (keys %$scope)
    {
      next if ! /::$/;
      next if ! exists ${$$scope{$_}}{INDEX};
      push(@pages, ${$$scope{$_}}{INDEX});
    }

    print { $$self{CONTENT} }
      map { "  <li>" . &pagelink($self, $_) . "</li>\n" }
      sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} }
      grep (${$$_}{LIST}, @pages);

    print { $$self{CONTENT} } " </ul>\n</div>";
  }
}

1;

######################################################################
package Web::Info; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 0, TITLE => "Info" }; 1;

package Web::Activity; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 1, TITLE => "Activity" }; 1;

package Web::Data; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 2, TITLE => "Data" }; 1;

package Web::Request; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 3, TITLE => "Requests" }; 1;

package Web::Configuration; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 4, TITLE => "Configuration" }; 1;

# package Web::Admin; use strict; use warnings; use base "Exporter";
# our $TOC = { LIST => 1, ORDER => 6, TITLE => "Administration" }; 1;

package Web::Components; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 5, TITLE => "Components" }; 1;

package Web::Reports; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 6, TITLE => "Reports" }; 1;

######################################################################
package Web::Info::About; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "About",
	       LINK => "about.html",
	       LINK_TITLE => "General Information" };
1;

package Web::Info::Documentation; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Documentation",
	       LINK => "documents.html",
	       LINK_TITLE => "READMEs and Other Documentation" };
1;

package Web::Info::Presentations; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Presentations",
	       LINK => "presentations.html",
	       LINK_TITLE => "PhEDEx Presentations" };
1;

package Web::Info::HyperNews; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "HyperNews Forum",
	       LINK => "https://hypernews.cern.ch/HyperNews/CMS/get/phedex.html",
	       LINK_TITLE => "Mailing List and HyperNews Forum" };
1;

package Web::Info::Developers; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Developers",
	       LINK => "developers.html",
	       LINK_TITLE => "Developer info" };
1;

######################################################################
package Web::Request::Page;
use strict; use warnings;
use base "Web::Page";
use CGI qw(:standard);
use POSIX qw(strftime);
import Web::Common;

our @reqstates = (
    { STATE => 0, RANK => 0, LABEL => "In preparation" },
    { STATE => 1, RANK => 2, LABEL => "Pending approval" },
    { STATE => 2, RANK => 1, LABEL => "Pending feedback" },
    { STATE => 3, RANK => 3, LABEL => "Approved" },
    { STATE => 4, RANK => 9, LABEL => "Disapproved" },
    { STATE => 5, RANK => 5, LABEL => "Active" },
    { STATE => 6, RANK => 6, LABEL => "Suspended" },
    { STATE => 7, RANK => 7, LABEL => "Completed" },
    { STATE => 8, RANK => 8, LABEL => "Disabled" } );

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

1;

######################################################################
package Web::Request::Main;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 0, TITLE => "Overview",
	       LINK_TITLE => "Quick overview of transfer requests",
	       SECURE => 1 };
use CGI qw(:standard);
import Web::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my ($qtask, $qreq, $qsite);
  if ($$self{MY_VIEW})
  {
    $qtask = &dbexec($$self{DBH}, qq{
      select count(t.id)
      from t_adm_identity_attr ia
        join t_req_task t
          on t.person = ia.identity
      where ia.name = 'Distinguished name'
        and ia.value = :client_dn},
      ":client_dn" => $$self{SSL_IDENTITY});

    $qreq = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_adm_identity_attr ia
        join t_adm_client c
          on c.identity = ia.identity
        join t_req_request req
          on req.creator = c.id
      where ia.name = 'Distinguished name'
        and ia.value = :client_dn
      group by req.state},
      ":client_dn" => $$self{SSL_IDENTITY});

    $qsite = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      where exists
        (select 1
         from t_req_action ra
	   join t_req_action_attr raa on raa.action = ra.id
	   join t_node n on n.name = raa.value
	   join t_adm_site_node sn on sn.node = n.id
	   join t_adm_site_admin sa on sa.site = sn.site
	   join t_adm_identity_attr ia on ia.identity = sa.identity
	 where ra.request = req.id
	   and raa.name = 'Destination'
	   and ia.name = 'Distinguished name'
	   and ia.value = :client_dn)
	 group by req.state},
	 ":client_dn" => $$self{SSL_IDENTITY});
  }
  else
  {
    $qtask = &dbexec($$self{DBH}, qq{
      select count(t.id) from t_req_task t});

    $qreq = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      group by req.state});

    $qsite = &dbexec($$self{DBH}, qq{
      select req.state, count(req.id)
      from t_req_request req
      group by req.state});
  }

  my ($tasks) = $qtask->fetchrow();
  my $your = $$self{MY_VIEW} ? "Your" : "All";
  print { $$self{CONTENT} }
    "<div align='left'>",
    "<p><a href='@{[$self->myurl('page' => 'Tasks')]}'>$your pending tasks</a></p>\n",
    "<ul>\n",
    " <li> ", ($tasks ? "$tasks Tasks" : "None"), "</li>\n",
    "</ul>\n",
    "<p><a href='@{[$self->myurl('page' => 'Requests')]}'>$your transfer requests</a></p>\n",
    "<ul>\n";

  my $n = 0;
  my %status = ();
  while (my ($state, $count) = $qreq->fetchrow())
  {
    $status{$state} = $count;
  }

  foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
  {
    my $s = $$state{STATE};
    next if ! $status{$s};
    print { $$self{CONTENT} } " <li> $status{$s} $$state{LABEL}</li>\n";
    $n += $status{$s};
  }

  print { $$self{CONTENT} }
    " <li> ", ($n ? "$n Total" : "None"), "</li>\n",
    "</ul>\n",
    "<p><a href='@{[$self->myurl('page' => 'Site')]}'>Site activity for @{[lc($your)]} sites</a></p>\n",
    "<ul>\n";

  $n = 0;
  %status = ();
  while (my ($state, $count) = $qsite->fetchrow())
  {
    $status{$state} = $count;
  }

  foreach my $state (sort { $$a{RANK} <=> $$b{RANK} } @reqstates)
  {
    my $s = $$state{STATE};
    next if ! $status{$s};
    print { $$self{CONTENT} } " <li> $status{$s} $$state{LABEL}</li>\n";
    $n += $status{$s};
  }

  print { $$self{CONTENT} }
    " <li> ", ($n ? "$n Total" : "None"), "</li>\n",
    "</ul>\n",
    "</div>\n";
}

1;

######################################################################
package Web::Request::Tasks;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Tasks",
	       LINK_TITLE => "Browse and carry out pending tasks",
	       SECURE => 1 };
use CGI qw(:standard);
import Web::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $qtask;
  if ($$self{MY_VIEW})
  {
    $qtask = &dbexec($$self{DBH}, qq{
      select t.id, t.time_create, r.id, r.state, a.action
      from t_adm_identity_attr ia
	join t_req_task t on t.person = ia.identity
	join t_req_action a on a.id = t.action
	join t_req_request r on r.id = a.request
      where ia.name = 'Distinguished name'
	and ia.value = :client_dn
      order by a.action, t.time_create asc, r.id asc},
      ":client_dn" => $$self{SSL_IDENTITY});
  }
  else
  {
    $qtask = &dbexec($$self{DBH}, qq{
      select t.id, t.time_create, r.id, r.state, a.action
      from t_req_task t
	join t_req_action a on a.id = t.action
	join t_req_request r on r.id = a.request
      order by a.action, t.time_create asc, r.id asc});
  }

  my $n = 0;
  while (my ($tid, $tcreate, $rid, $rstate, $action) = $qtask->fetchrow())
  {
    print { $$self{CONTENT} } "<pre>$action #$rid ($tid $tcreate $rstate)</pre>";
    ++$n;
  }

  if (! $n)
  {
    print { $$self{CONTENT} } "<p>No pending tasks to show.</p>";
  }
}

1;

######################################################################
package Web::Request::Site;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Site Status",
	       LINK_TITLE => "Browse request status by site",
	       SECURE => 1 };
use CGI qw(:standard);
import Web::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
}

1;

######################################################################
package Web::Request::Requests;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Requests",
	       LINK_TITLE => "Browse requests",
	       SECURE => 1 };
use CGI qw(:standard);
import Web::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $rquery;
  my $dquery = &dbprep($$self{DBH}, qq{
    select
      ri.time_update, n.name,

      count(rid.dataset),
      sum(case when rid.dbs_isknown = 'y' then 1 else 0 end),
      sum(case when rid.dps_isknown = 'y' then 1 else 0 end),

      count(rib.block),
      sum(case when rib.dbs_isknown = 'y' then 1 else 0 end),
      sum(rib.dbs_files), sum(rib.dbs_bytes),
      sum(rib.dbs_only_files), sum(rib.dbs_only_bytes),
      sum(case when rib.dps_isknown = 'y' then 1 else 0 end),
      sum(rib.dps_files), sum(rib.dps_bytes),
      sum(rib.dps_only_files), sum(rib.dps_only_bytes),

      sum(dbr.node_files), sum(dbr.node_bytes)
    from t_req_info ri
      left join t_req_info_dest rin
        on rin.request = ri.request
      left join t_node n
        on n.id = rin.destination
      left join t_req_info_dataset rid
        on rid.request = ri.request
      left join t_req_info_block rib
        on rib.request = ri.request
        and rib.dbs = rid.dbs
        and rib.dataset = rid.dataset
      left join t_dps_dbs ddbs
        on ddbs.name = rid.dbs
      left join t_dps_dataset dds
        on dds.dbs = ddbs.id
        and dds.name = rid.dataset
      left join t_dps_block db
        on db.dataset = dds.id
        and db.name = rib.block
      left join t_dps_block_replica dbr
        on dbr.block = db.id
        and dbr.node = rin.destination
    where ri.request = :request
    group by ri.time_update, n.name});

  if ($$self{MY_VIEW})
  {
    $rquery = &dbexec($$self{DBH}, qq{
      select req.id, req.state, ranew.time_apply
      from t_adm_identity_attr aia
        join t_adm_client acl
          on acl.identity = aia.identity
        join t_req_request req
          on req.creator = acl.id
        left join t_req_action ranew
          on ranew.request = req.id
          and ranew.action = 'Create'
      where aia.name = 'Distinguished name'
        and aia.value = :client_dn},
      ":client_dn" => $$self{SSL_IDENTITY});
  }
  else
  {
    $rquery = &dbexec($$self{DBH}, qq{
      select req.id, req.status, ranew.time_apply
      from t_req_request req
        left join t_req_action ranew
          on ranew.request = req.id
          and ranew.action = 'Create'});
  }

  my %status = ();
  while (my ($req, $state, $created) = $rquery->fetchrow())
  {
    $status{$req} = {
      ID => $req,
      NAME => undef,
      STATE => $state,
      CREATED => $created
    };

    
    &dbbindexec($dquery, ":request" => $req);
    while (my @row = $dquery->fetchrow())
    {
      $status{$req}{STATS}{$row[1]} = [ @row ];
    }
  }

  use Data::Dumper;
  print { $$self{CONTENT} } "<pre>\n",
    &escapeHTML(Dumper(\%status)),
    "</pre>\n";
  return;

  print { $$self{CONTENT} }
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='8'>Transfer request status</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Request</th>\n",
    " <th rowspan='2'>Destination</th>\n",
    " <th colspan='2'>Known Files</th>\n",
    " <th colspan='2'>Destination</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Size</th>\n",
    " <th>Files</th>\n",
    " <th>Size</th>\n",
    "</tr>\n";

  foreach my $req (sort { $b cmp $a } keys %status)
  {
    my @dest = sort keys %{$status{$req}};
    for (my $i = 0; $i <= $#dest; ++$i)
    {
      my $dest = $dest[$i];
      my $x = $status{$req}{$dest};
      my $tmdb_color = ($x->{TMDB_FILES} == $x->{DBS_FILES} ? "" : " bgcolor='$pendcolor'");
      my $node_color = ($x->{NODE_FILES} == $x->{TMDB_FILES} ? "" : " bgcolor='$pendcolor'");
      print { $$self{CONTENT} } "<tr>\n",
	($i != 0 ? "" :
	(" <td rowspan='@{[scalar @dest]}'><a href='" .
	$self->myurl('page' => 'Detail', 'request' => quotemeta($req)) .
	"'>$req</a></td>\n")),
	" <td>$dest</td>\n",
	" <td align='right'$tmdb_color>", &format_num ($x->{TMDB_FILES}), "</td>\n",
	" <td align='right'$tmdb_color>", &format_size ($x->{TMDB_BYTES}), "</td>\n",
	" <td align='right'$node_color>", &format_num ($x->{NODE_FILES}), "</td>\n",
	" <td align='right'$node_color>", &format_size ($x->{NODE_BYTES}), "</td>\n",
	"</tr>\n";
    }
  }

  print { $$self{CONTENT} } "</tbody>\n",
    "</table>\n",
    "</p>\n";
}

1;

######################################################################
package Web::Request::Detail;
use strict; use warnings;
use base "Web::Request::Page";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Request Details",
	       LINK_TITLE => "Explore request details",
	       SECURE => 1 };
use CGI qw(:standard);
import Web::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my %status = ();
  my $reqparam = param('request') || '';
  my $rquery = &dbexec($$self{DBH}, qq{
    select
      r.name, s.block,
      min(s.dbs_files), min(s.dbs_bytes),
      min(s.tmdb_files), min(s.tmdb_bytes),
      min(s.common_files), min(s.dbs_only_files), min(s.tmdb_only_files)
    from t_request r join t_request_status s on s.request = r.id
    group by r.name, s.block});
  while (my ($req, $block,
             $dbs_files, $dbs_bytes,
             $tmdb_files, $tmdb_bytes,
             $common, $dbs_only, $tmdb_only) = $rquery->fetchrow())
  {
    $status{$req}{$block} = {
      DBS_FILES => $dbs_files, DBS_BYTES => $dbs_bytes,
      TMDB_FILES => $tmdb_files, TMDB_BYTES => $tmdb_bytes,
      COMMON => $common, DBS_ONLY => $dbs_only, TMDB_ONLY => $tmdb_only
    };
  }

  print { $$self{CONTENT} } "<p>",
    "<form method='GET' action='@{[$self->myurl()]}'>\n",
    "Filter Request: ",
    textfield(-name=>'request', -default=>$reqparam, -size=>30),
    " <input type='submit' value='Update'></form></p>\n",

    "<p>\n",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='8'>Transfer request status</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Block</th>\n",
    " <th colspan='2'>DBS</th>\n",
    " <th colspan='2'>TMDB</th>\n",
    " <th colspan='3'>Difference</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Size</th>\n",
    " <th>Files</th>\n",
    " <th>Size</th>\n",
    " <th>Common</th>\n",
    " <th>DBS</th>\n",
    " <th>TMDB</th>\n",
    "</tr>\n";

  foreach my $req (sort { $b cmp $a } keys %status)
  {
    next if $reqparam && $req !~ /$reqparam/;

    my @blocks = sort keys %{$status{$req}};
    for (my $i = 0; $i <= $#blocks; ++$i)
    {
      my $block = $blocks[$i];
      my $x = $status{$req}{$block};
      my $tmdb_color = ($x->{TMDB_FILES} == $x->{DBS_FILES} ? "" : " bgcolor='$pendcolor'");
      my $common_color = ($x->{COMMON} == $x->{DBS_FILES} ? "" : " bgcolor='$warncolor'");
      my $dbs_only_color = (!$x->{DBS_ONLY} ? "" : " bgcolor='$warncolor'");
      my $tmdb_only_color = (!$x->{TMDB_ONLY} ? "" : " bgcolor='$warncolor'");
      print { $$self{CONTENT} } "<tr class='selected'>\n",
        " <td colspan='8'>$req</td>\n",
        "</tr>\n"
        if $i == 0;
      print { $$self{CONTENT} } "<tr>\n",
        " <td>$block</td>\n",
        " <td align='right'>", &format_num ($x->{DBS_FILES}), "</td>\n",
        " <td align='right'>", &format_size ($x->{DBS_BYTES}), "</td>\n",
        " <td align='right'$tmdb_color>", &format_num ($x->{TMDB_FILES}), "</td>\n",
        " <td align='right'$tmdb_color>", &format_size ($x->{TMDB_BYTES}), "</td>\n",
        " <td align='right'$common_color>", &format_num ($x->{COMMON}), "</td>\n",
        " <td align='right'$dbs_only_color>", &format_num ($x->{DBS_ONLY}), "</td>\n",
        " <td align='right'$tmdb_only_color>", &format_num ($x->{TMDB_ONLY}), "</td>\n",
        "</tr>\n";
    }
  }

  print { $$self{CONTENT} } "</tbody>\n",
    "</table>\n",
    "</p>\n";
}

1;

######################################################################
package Web::Request::CreateTools;
use strict; use warnings;
use base "Exporter";
import Web::Common;
use CGI qw(:standard);
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} || "./"; $__scriptdir =~ s,[^/]+$,,; unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;

our @EXPORT = qw(getdbslist getnodelist
		 create_default_email
		 create_check_access
		 create_check_identity
		 create_check_email
		 create_check_comment
		 create_check_dbs
		 create_check_deps
		 create_check_data
		 create_check_dest
		 create_check_bad);

sub getdbslist
{
  my ($dbh) = @_;
  my %list = ();
  my $q = &dbexec($dbh, qq{select id, name from t_dps_dbs});
  while (my ($id, $name) = $q->fetchrow()) {
    $list{$name} = $id;
  }
  return %list;
}

sub getnodelist
{
  my ($dbh) = @_;
  my %nodes = ();
  my $qnodes = &dbexec($dbh, qq{select name from t_node});
  while (my ($node) = $qnodes->fetchrow()) {
    $nodes{$node} = 1;
  }
  foreach my $node (keys %nodes) {
    delete $nodes{$node} if ($node =~ /(.*)_(Buffer|Stage)$/ && exists $nodes{"$1_MSS"});
  }

  return sort keys %nodes;
}

sub create_default_email
{
  my ($self) = @_;
  return undef if ! $ENV{SSL_CLIENT_CERT};
  my $email = "";

  use File::Temp ':mktemp';
  if (my ($fh, $file) = mkstemp ('/tmp/certXXXXXXXXXX'))
  {
    if ((print $fh $ENV{SSL_CLIENT_CERT}) && close($fh))
    {
      chomp($email = qx(openssl x509 -in $file -noout -email));
    }
    unlink ($file);
  }
  return $email;
}

sub create_check_access
{
  my ($self, $bad) = @_;
  return if $$bad;

  if (request_method() ne 'POST')
  {
    alert($self, "This form can only be accessed with 'POST' method.");
    $$bad = 1;
  }
}

sub create_check_identity
{
  my ($self, $bad) = @_;
  return if $$bad;
  return;

  # Make sure this page can be used
  if (! $$self{SSL_IDENTITY})
  {
    alert($self,
	  "You have not been authenticated and cannot create requests.</p>",
	  "<p>Please make sure you are accessing this service using",
	  " https protocol signed with your grid certificate.  You",
	  " may need to load your grid certificate into your browser",
	  " to achieve that.  The little box on the left will automatically",
	  " indicate when your identity has been successfully verified.");
    $$bad = 1;
    return;
  }

  if (! $$self{SSL_VERIFIED})
  {
    warning($self,
	    "Your identity has not been verified.  The certificate",
	    " presented by your web browser is not a recognised grid",
	    " certificate.  For now you are still allowed to create",
	    " a transfer request.");
  }
}

sub create_check_email
{
  my ($self, $bad, $email, $email_list) = @_;
  return undef if $$bad;

  if (! $email)
  {
    alert($self, "No requestor e-mail, please supply one.");
    $$bad = 1;
    return undef;
  }

  my ($nrvalidmails, @emails) = validlist ($email);
  if ($email ne '' && ! $nrvalidmails)
  {
    alert($self, "Requestor e-mail &ldquo;@{[&escapeHTML($email)]}&rdquo; is",
	  " not a valid RFC822 e-mail address or address list.");
    $$bad = 1;
  }

  @$email_list = @emails if $email_list && ! $$bad;
  return $$bad ? undef : $email;
}

sub create_check_comment
{
  my ($self, $bad, $comment) = @_;
  return undef if $$bad;
  return $comment;
}

sub create_check_dbs
{
  my ($self, $bad, $dbs) = @_;
  return undef if $$bad;
  if (! $dbs)
  {
    alert($self, "No DBS selected, please choose a value.");
    $$bad = 1;
    return undef;
  }

  if ($dbs !~ m|^[-=+_:/?&;.a-zA-Z0-9]+$|)
  {
    alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	  " contains unsafe characters.");
    $$bad = 1;
  }

  my $SAFE_HOST = "[-A-Za-z0-9_+.]+";
  my $SAFE_PATH = "[-A-Za-z0-9_+.:/&%;]*";
  if ($dbs !~ m,^https?://($SAFE_HOST)(:\d+)?/($SAFE_PATH)\?.*instance=$SAFE_PATH$,)
  {
    my %dbses = &getdbslist($$self{DBH});
    if (! grep($_ eq $dbs, keys %dbses))
    {
      alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " is not a URL for a DBS service.  Please use a URL of",
	    " the form http://server/path?instance=name.");
      $$bad = 1;
    }
  }
  else
  {
    my $hostname = $1;
    my ($name,$aliases,$addrtype,$length,@addrs)
      = CORE::gethostbyname($hostname);
    if (! $name)
    {
      alert($self, "The host name of the DBS service, &ldquo;",
	    &escapeHTML($hostname), "&rdquo;, did not resolve.",
	    " Please make sure the host is accessible.");
      $$bad = 1;
    }

    my $info = qx(wget -qO- '$dbs;api=listPrimaryDatasets;pattern=/zilch');
    if (! $info || $info !~ /<dbs>/s)
    {
      alert($self, "The DBS contact, &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " does not respond to aliveness check.  Please make sure",
	    " the contact URL points to a correct service.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : $dbs;
}

sub create_check_deps
{
  my ($self, $bad, $deps) = @_;
  return undef if $$bad;

  if (! $deps)
  {
    alert($self, "No selection made for dependencies, please supply one.");
    $$bad = 1;
    return undef;
  }

  if (! grep ($deps eq $_, qw(Yes No)))
  {
    alert($self, "&ldquo;@{[&escapeHTML($deps)]}&rdquo;",
	  " is not a valid dependencies selection.");
    $$bad = 1;
  }

  return $$bad ? undef : $deps;
}

sub create_check_data
{
  my ($self, $bad, $data) = @_;
  return undef if $$bad;

  my @data = split(/\s+/, $data);
  if (! @data)
  {
    alert($self, "No data specified.");
    $$bad = 1;
    return undef;
  }

  foreach my $data (@data)
  {
    if ($data !~ m|^/[^/]+/[^/]+/[^/]+$|)
    {
      warning($self, "The data pattern is &ldquo;@{[&escapeHTML($data)]}&rdquo;",
	      " does not match pattern of type /PRIMARY/TIER/DATASET.");
    }
  }

  return $$bad ? undef : @data;
}

sub create_check_dest
{
  my ($self, $bad, @dests) = @_;
  return undef if $$bad;

  if (! @dests)
  {
    alert($self, "No destination selected, please select some.");
    $$bad = 1;
    return undef;
  }

  my @nodes = &getnodelist($$self{DBH});
  foreach my $node (@dests)
  {
    if (! grep ($_ eq $node, @nodes))
    {
      alert($self, "Node name &ldquo;@{[&escapeHTML($node)]}&rdquo;",
	    " is not known to PhEDEx.");
      $$bad = 1;
    }
  }

  my %destreqs = (T2_Caltech_Buffer	=> 'T1_FNAL_MSS',
	    	  T2_Florida_Buffer	=> 'T1_FNAL_MSS',
		  T2_Nebraska_Buffer	=> 'T1_FNAL_MSS',
		  T2_Purdue_Buffer	=> 'T1_FNAL_MSS',
		  T2_UCSD_Buffer	=> 'T1_FNAL_MSS',
		  T2_Wisconsin_Buffer	=> 'T1_FNAL_MSS',
		  T3_UIowa_Buffer	=> 'T1_FNAL_MSS');


  foreach my $node (@dests)
  {
    next if ! exists $destreqs{$node};
    push (@dests, $destreqs{$node})
    if (! grep ($_ eq $destreqs{$node}, @dests));
  }

  return $$bad ? undef : sort @dests;
}

sub create_check_bad
{
  my ($self, $bad) = @_;
  print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n" if $bad;
  return $bad;
}

1;

######################################################################
package Web::Request::Create;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Create Request",
	       LINK_TITLE => "Create a new transfer request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  return if $bad;

  # Get the client's e-mail address.  By default, use an e-mail
  # from the database if we have one.  Failing that, use the
  # address from the certificate itself.  This order allows the
  # users to change their preferred e-mail address and make the
  # choice sticky.
  my ($email_contact) = &dbexec($$self{DBH}, qq{
    select email.value
    from t_adm_identity_attr dn
      join t_adm_identity_attr email
        on email.identity = dn.identity
        and email.name = 'E-mail'
    where dn.name = 'Distinguished name'
    and dn.value = :client_dn},
    ':client_dn' => $$self{SSL_IDENTITY})->fetchrow();
  $email_contact = &create_default_email() if ! $email_contact;

  print { $$self{CONTENT} }
    "<p>",
    "<form method='POST' action='@{[$self->myurl('page' => 'Request::CreateDBS')]}'>\n",
    "<table class='striped'>\n",
    " <tr class='selected'><th colspan='2'>Create a new request</th></tr>\n",
    " <tr valign='top'>\n",
    "  <td>Requestor e-mail</td>\n",
    "  <td>", textfield(-name=>'email', -default=>$email_contact, -size=>50), "</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td>Describe this request</td>\n",
    "  <td>", textarea('comment', '', 10, 50), "</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td colspan='2' align='center'>", submit('submit', 'Next'), "</td>\n",
    " </tr>\n",
    "</table>\n",
    "</p>\n";
}

1;

######################################################################
package Web::Request::CreateDBS;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 6, TITLE => "Select DBS for Request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  my $email = &create_check_email($self, \$bad, param('email'));
  my $comment = &create_check_comment($self, \$bad, param('comment'));
  return if &create_check_bad($self, $bad);

  my %dbses = &getdbslist($$self{DBH});
  my @dbsnames = sort keys %dbses;
  print { $$self{CONTENT} }
    "<p>",
    "<form method='POST' action='@{[$self->myurl('page' => 'Request::CreateData')]}'>\n",
    "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
    "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
    "<table class='striped'>\n",
    " <tr class='selected'><th colspan='2'>Create a new request</th></tr>\n",
    " <tr valign='top'>\n",
    "  <td>DBS instance</td>\n",
    "  <td>",
    (map { "   <input type='radio' name='dbs' value='@{[&escapeHTML($_)]}' />&nbsp;" .
           &escapeHTML($_) . "<br />\n" } @dbsnames),
    "   <input type='radio' name='dbs' value='NEW' />&nbsp;Other:&nbsp;",
    textfield(-name=>'newdbs', -default=>'http://path?instance=value', -size=>50),
    "  </td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td colspan='2' align='center'>", submit('submit', 'Next'), "</td>\n",
    " </tr>\n",
    "</table>\n",
    "</form>\n",
    "</p>\n";
}

1;

######################################################################
package Web::Request::CreateData;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 7, TITLE => "Select Datasets for Request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  my $email = &create_check_email($self, \$bad, param('email'));
  my $comment = &create_check_comment($self, \$bad, param('comment'));
  my $dbs = param('dbs');
  $dbs = param('newdbs') if $dbs && $dbs eq 'NEW';
  $dbs = &create_check_dbs($self, \$bad, $dbs);
  return if &create_check_bad($self, $bad);

  print { $$self{CONTENT} }
    "<p>",
    "<form method='POST' action='@{[$self->myurl('page' => 'Request::CreateDest')]}'>\n",
    "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
    "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
    "<input type='hidden' name='dbs' value='@{[&escapeHTML($dbs)]}' />\n",
    "<table class='striped'>\n",
    " <tr class='selected'><th colspan='2'>Create a new request</th></tr>\n",
    " <tr valign='top'>\n",
    "  <td>Include dependencies</td>\n",
    "  <td>",
    "<input type='radio' name='dependencies' value='No' />&nbsp;",
    "No, only the requested datasets<br />\n",
    "<input type='radio' name='dependencies' value='Yes' />&nbsp;",
    "Yes, selected datasets and their dependencies</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td>/Primary/Tier/Dataset names<br />(glob patterns)</td>\n",
    "  <td>", textarea('data', '', 10, 50), "</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td colspan='2' align='center'>", submit('submit', 'Next'), "</td>\n",
    " </tr>\n",
    "</table>\n",
    "</form>\n",
    "</p>\n";
}

1;

######################################################################
package Web::Request::CreateDest;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 8, TITLE => "Select Destinations for Request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  my $email = &create_check_email($self, \$bad, param('email'));
  my $comment = &create_check_comment($self, \$bad, param('comment'));
  my $dbs = &create_check_dbs($self, \$bad, param('dbs'));
  my $deps = &create_check_deps($self, \$bad, param('dependencies'));
  my @data = &create_check_data($self, \$bad, param('data'));
  return if &create_check_bad($self, $bad);

  # Get list of nodes, but suppress Buffer nodes where MSS exists
  my @nodes = &getnodelist($$self{DBH});
  print { $$self{CONTENT} }
    "<p>",
    "<form method='POST' action='@{[$self->myurl('page' => 'Request::CreateConfirm')]}'>\n",
    "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
    "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
    "<input type='hidden' name='dbs' value='@{[&escapeHTML($dbs)]}' />\n",
    "<input type='hidden' name='dependencies' value='@{[&escapeHTML($deps)]}' />\n",
    "<input type='hidden' name='data' value='@{[&escapeHTML(join(' ', @data))]}' />\n",
    "<table class='striped'>\n",
    " <tr class='selected'><th colspan='4'>Create a new request</th></tr>\n",
    " <tr valign='top'>\n",
    "  <td>Destinations</td>\n",
    "  <td>\n",
    (map { "<input type='checkbox' name='dest' value='$_' />&nbsp;$_<br />" }
     grep (/^T1_/, @nodes)),
    "  </td>\n",
    "  <td>\n",
    (map { "<input type='checkbox' name='dest' value='$_' />&nbsp;$_<br />" }
     grep (/^T2_/, @nodes)),
    "  </td>\n",
    "  <td>\n",
    (map { "<input type='checkbox' name='dest' value='$_' />&nbsp;$_<br />" }
     grep (! /^T[12]_/, @nodes)),
    "  </td>\n",
    " </tr>\n",
    " <tr>\n",
    "  <td colspan='4' align='center'>", submit('submit', 'Next'), "</td>\n",
    " </tr>\n",
    "</table>\n",
    "</form>\n",
    "</p>\n";
}

1;

######################################################################
package Web::Request::CreateConfirm;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 9, TITLE => "Confirm Request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my @emails;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  my $email = &create_check_email($self, \$bad, param('email'), \@emails);
  my $comment = &create_check_comment($self, \$bad, param('comment'));
  my $dbs = &create_check_dbs($self, \$bad, param('dbs'));
  my $deps = &create_check_deps($self, \$bad, param('dependencies'));
  my @data = &create_check_data($self, \$bad, param('data'));
  my @dest = &create_check_dest($self, \$bad, param('dest'));
  return if &create_check_bad($self, $bad);

  print { $$self{CONTENT} }
    "<p>",
    "<form method='POST' action='@{[$self->myurl('page' => 'Request::CreateCheck')]}'>\n",
    "<input type='hidden' name='email' value='@{[&escapeHTML($email)]}' />\n",
    "<input type='hidden' name='comment' value='@{[&escapeHTML($comment)]}' />\n",
    "<input type='hidden' name='dbs' value='@{[&escapeHTML($dbs)]}' />\n",
    "<input type='hidden' name='dependencies' value='@{[&escapeHTML($deps)]}' />\n",
    "<input type='hidden' name='data' value='@{[&escapeHTML(join(' ', @data))]}' />\n",
    (map { "<input type='hidden' name='dest' value='@{[&escapeHTML($_)]}' />\n" } @dest),
    "<table class='striped'>\n",
    " <tr valign='top'>\n",
    "  <td>Requestor e-mail</td>\n",
    "  <td>", (map { &escapeHTML($_) . "<br />" } @emails), "</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td>Comments</td>\n",
    "  <td>@{[&escapeHTML($comment)]}</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td>DBS instance</td>\n",
    "  <td>@{[&escapeHTML($dbs)]}</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td>Include dependencies</td>\n",
    "  <td>@{[&escapeHTML($deps)]}</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td>/Primary/Tier/Dataset names</td>\n",
    "  <td>", (map { &escapeHTML($_) . "<br />" } @data), "</td>\n",
    " </tr>\n",
    " <tr valign='top'>\n",
    "  <td>Destinations</td>\n",
    "  <td>", (map { &escapeHTML($_) . "<br />" } @dest), "</td>\n",
    " </tr>\n",
    " <tr>\n",
    "  <td colspan='2' align='center'>", submit('submit', 'Confirm'), "</td>\n",
    " </tr>\n",
    "</table>\n",
    "</form>\n",
    "</p>\n";
}

1;

######################################################################
package Web::Request::CreateCheck;
use strict; use warnings;
use base "Web::Request::Page";
import Web::Request::CreateTools;
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 10, TITLE => "Submit Request",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my @emails;
  my $bad = 0;
  &create_check_identity($self, \$bad);
  &create_check_access($self, \$bad);
  my $email = &create_check_email($self, \$bad, param('email'), \@emails);
  my $comment = &create_check_comment($self, \$bad, param('comment'));
  my $dbs = &create_check_dbs($self, \$bad, param('dbs'));
  my $deps = &create_check_deps($self, \$bad, param('dependencies'));
  my @data = &create_check_data($self, \$bad, param('data'));
  my @dest = &create_check_dest($self, \$bad, param('dest'));
  if ($bad)
  {
    print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n";
    return;
  }

  (open (MAIL, "| /usr/sbin/sendmail -t")
   && (print MAIL
         "Subject: PhEDEx request\n",
         "From: PhEDEx Request Form <cms-phedex-admins\@cern.ch>\n",
         # "To: cms-phedex-admins\@cern.ch\n",
         # "Cc:", join(", ", @emails), "\n",
        "To: lassi.tuura\@cern.ch\n",
	"\n",
	"Greetings.  You may wish to take note of the following new\n",
	"transfer request which is now being processed.  At this time\n",
	"you need not take any action.  Have a nice day!\n",
	"\n",
	"* Requestor:\n",
	"   Identity: $$self{SSL_IDENTITY}\n",
	"   Host: @{[remote_host()]}\n",
	"   Agent: @{[user_agent()]}\n",
	"\n",
	"* Request:\n",
	"   Database:\n",
	"     $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}\n",
	"   Contacts:\n",
	(map { "     $_\n" } @emails),
	"   DBS:\n",
	"     $dbs\n",
	"   Dependencies:\n",
	"     $deps\n",
	"   Data:\n",
	(map { "     $_\n" } @data),
	"   Destinations:\n",
	(map { "     $_\n" } @dest),
	"\n",
	"Yours truly,\n",
	"  PhEDEx transfer request web form\n")
   && close(MAIL))
    or do { alert($self, "Cannot send mail: $!."); return };

  my $now = time();
  my $id = &makeObjWithAttrs
    ($$self{DBH}, "adm_identity", "identity", {},
     "Distinguished name" => $$self{SSL_IDENTITY},
     "E-mail" => &create_default_email(),
     "Certificate" => $$self{SSL_CERT});

  my $cid = &makeObjWithAttrs
    ($$self{DBH}, "adm_contact", "contact", {},
     "Remote host" => remote_host(),
     "User agent" => user_agent(),
     "Server" => new CGI ('')->self_url(-full=>1));

  my $client = &makeObjWithAttrs
    ($$self{DBH}, "adm_client", undef,
     { "identity" => $id, "contact" => $cid });

  my $rid = &makeObjWithAttrs
    ($$self{DBH}, "req_request", undef,
     { "creator" => $client, "state" => 0 });

  &makeObjWithAttrs
    ($$self{DBH}, "req_action", "action",
     { "request" => $rid,
       "action" => "Create",
       "client" => $client,
       "time_apply" => $now },
     "Comment" => $comment);
  &makeObjWithAttrs
    ($$self{DBH}, "req_action", "action",
     { "request" => $rid,
       "action" => "Contact",
       "client" => $client,
       "time_apply" => $now },
     map { ("E-mail" => $_) } @emails);
  &makeObjWithAttrs
    ($$self{DBH}, "req_action", "action",
     { "request" => $rid,
       "action" => "DBS",
       "client" => $client,
       "time_apply" => $now },
     "URL" => $dbs);
  &makeObjWithAttrs
    ($$self{DBH}, "req_action", "action",
     { "request" => $rid,
       "action" => "Destination",
       "client" => $client,
       "time_apply" => $now },
     map { ("Node" => $_) } @dest);
  &makeObjWithAttrs
    ($$self{DBH}, "req_action", "action",
     { "request" => $rid,
       "action" => "Data",
       "client" => $client,
       "time_apply" => $now },
     "Dependencies" => $deps,
     map { ("Pattern" => $_) } @data);

  note($self, "Request confirmed!");
}

1;

######################################################################
package Web::Components::Status;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Status",
	       LINK_TITLE => "View recently active PhEDEx components" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $active = 60*5;
  my $offline = 60*15;
  my $now = time ();
  my $query = &dbexec($$self{DBH}, qq{
    select n.name, a.name, ast.time_update
    from t_agent_status ast
      join t_node n on n.id = ast.node
      join t_agent a on a.id = ast.agent});

  my (%agents, %status);
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($node, $agent, $contact) = @$row;
    $status{$node}{$agent} = $contact;
    $agents{$agent} = 1;
  }

  my @standard = grep (!/^(Block|Info(?!Drop)|Perf|Table)/, sort keys %agents);
  my @admin = grep (/^Block/, sort keys %agents);
  my @support = grep (/^(?!File|Block|InfoDrop)/, sort keys %agents);

  foreach my $item ([ "Common", @standard ], [ "Administrative", @admin ], [ "Support", @support ])
  {
    my ($type, @agents) = @{$item};
    print { $$self{CONTENT} }
      "<p><table class='striped'>\n",
      "<tbody>\n",
      "<tr class='selected'>\n",
      " <td align='center' colspan='" . (scalar @agents + 1) . "'>$type Agents</td>\n",
      "</tr>\n",
      "<tr class='selected'>\n",
      " <th>Node</th>\n",
      (map { " <th>$_</th>\n" } @agents),
      "</tr>\n";

    foreach my $node (sort keys %status)
    {
      next if ! grep (defined $status{$node}{$_}, @agents);

      print { $$self{CONTENT} } "<tr>\n", " <td>$node</td>\n";
      foreach my $agent (@agents)
      {
	my $contact = $status{$node}{$agent};
	if (! defined $contact)
	{
	  print { $$self{CONTENT} } " <td>&nbsp;</td>\n";
	  next;
	}

	my $ago = &age ($now - $contact);
	if (($now - $contact) < $active) {
	  print { $$self{CONTENT} } "<td align='center' bgcolor='$goodcolor'>UP</td>\n";
	} elsif (($now - $contact) < $offline) {
	  print { $$self{CONTENT} } "<td align='center' bgcolor='$goodcolor'>UP ($ago ago)</td>\n";
	} else {
	  print { $$self{CONTENT} } "<td align='center' bgcolor='$badcolor'>DOWN ($ago ago)</td>\n";
	}
      }
      print { $$self{CONTENT} } "</tr>\n";
    }
    print { $$self{CONTENT} } "</tbody>\n", "</table>\n";
  }
}

1;

######################################################################
package Web::Components::Agents;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Processes",
	       LINK_TITLE => "View details about PhEDEx processes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my %info = ();
  my @states = qw(pending received work completed bad outgoing);
  my %states = ();
  my %age = ();
  my %live = ();
  foreach my $row (@{$$self{DBH}->selectall_arrayref(qq{
		     select time_update, site, host, path, agent, worker,
			    pid, live, state, value
		     from t_info_agent_status})})
  {
    my ($stamp, $site, $host, $path, $agent, $worker, $pid, $live, $state, $value) = @$row;
    $age{$site}{$host}{$path} = $stamp;
    $live{$site}{$host}{$path}{$agent}{$worker} = { PID => $pid, LIVE => $live };
    $info{$site}{$host}{$path}{$agent}{$worker}{$state} = $value;
    $states{$state} = 1 if ! grep ($_ eq $state, @states);
  }

  print { $$self{CONTENT} }
    "<p><table class='striped'><tbody>\n",
    "<tr class='selected'>",
    " <th>Age</th>",
    " <th>Site</th>",
    " <th>Agent</th>",
    " <th>Process</th>",
    " <th>Host</th>",
    " <th>Worker</th>",
    (map { " <th>$_</th>\n" } @states, sort keys %states),
    " <th>Path</th>",
    "</tr>\n";

  foreach my $site (sort keys %info)
  {
    foreach my $host (sort keys %{$info{$site}})
    {
      foreach my $path (sort keys %{$info{$site}{$host}})
      {
        foreach my $agent (sort keys %{$info{$site}{$host}{$path}})
        {
	  foreach my $worker (sort keys %{$info{$site}{$host}{$path}{$agent}})
	  {
	    my $pid = $live{$site}{$host}{$path}{$agent}{$worker}{PID};
	    my $live = $live{$site}{$host}{$path}{$agent}{$worker}{LIVE};
	    my $agecolor = $now - $age{$site}{$host}{$path} <= 120 ? "" : " bgcolor='$warncolor'";
	    my $pidcolor = $live ? "" : " bgcolor='$warncolor'";
	    my $agentname = $agent;
	    $agentname =~ s/-/&#8209;/g;
	    print { $$self{CONTENT} }
	      "<tr>\n",
	      " <td$agecolor>", &age($now - $age{$site}{$host}{$path}), "</td>\n",
	      " <td>$site</td>\n",
	      " <td>$agentname</td>\n",
	      " <td$pidcolor>$pid</td>\n",
	      " <td>$host</td>\n",
	      " <td>$worker</td>\n";
	    foreach my $state (@states, sort keys %states)
	    {
	      my $value = $info{$site}{$host}{$path}{$agent}{$worker}{$state};
	      my $color = $value ? " bgcolor='$pendcolor'" : '';
	      print { $$self{CONTENT} } " <td$color>$value</td>\n";
	    }
	    print { $$self{CONTENT} } " <td>$path</td>\n", "</tr>\n";
	  }
	}
      }
    }
  }
  print { $$self{CONTENT} } "</tbody></table></p>\n";
}

1;

######################################################################
package Web::Activity::Rate;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Rate",
	       LINK_TITLE => "Show recent transfer rates in tabular form" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(span errors tofilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::Rate");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my %stats = ();
  my @spans = qw(h 2h d w m);
  my %spans = (h => [ 'Last hour', $now, 3600 ],
	       '2h' => [ 'Last 2 hours', $now, 3600*2 ],
	       d => [ 'Last day', $now, 86400 ],
	       w => [ 'Last 7 days', int($now/86400)*86400, 7*86400 ],
	       m => [ 'Last 30 days', int($now/86400)*86400, 30*86400 ]);
  my $span = param('span') || $spans[0];
  $span = $spans[0] if ! grep($span eq $_, @spans);
  my $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(sum(h.done_files),0) done_files,
      nvl(sum(h.done_bytes),0) done_bytes,
      nvl(sum(h.fail_files),0) fail_files,
      nvl(sum(h.expire_files),0) expire_files,
      nvl(avg(h.param_rate),0) param_rate,
      nvl(avg(h.param_latency),0) param_latency
    from t_link_histogram h
      join t_node f on f.id = h.from_node
      join t_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    $stats{$span}{N}{$key} = $row;
  }

  $stats{$span}{T}{1} = { DONE_FILES => 0, DONE_BYTES => 0, FAIL_FILES => 0, EXPIRE_FILES => 0 };
  my $errors = param('errors') ? "checked='checked'" : "";
  my $tofilter = param('tofilter') || "";
  my $fromfilter = param('fromfilter') || "";
  my $andor = param('andor') || 'or';
  print { $$self{CONTENT} }
    "<form method='GET' action='@{[$self->myurl()]}'><p>\n",
    "<label for='span'>Time span</label>\n",
    "<select name='span' onchange='submit()'>",
    (map { (" <option", ($span eq $_ ? " selected='selected'" : ""),
	    "  value='$_'>$spans{$_}[0]</option>") } @spans),
    "</select>\n",
    "&nbsp;<input type='checkbox' name='errors' $errors>\n",
    "<label for='errors'>Include links with nothing but errors</label> ",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'><tbody>\n",

    "<tr class='selected'>\n",
    " <th colspan='10'>",
    "Last @{[&format_timespan($spans{$span}[2])]}",
    "</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>To</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From</th>\n",
    " <th rowspan='2'>Files</th>\n",
    " <th rowspan='2'>Total Size</th>\n",
    " <th rowspan='2'>Rate</th>\n",
    " <th rowspan='2'>Errors</th>\n",
    " <th rowspan='2'>Expired</th>\n",
    " <th rowspan='2'>Avg. Est. Rate</th>\n",
    " <th rowspan='2'>Avg. Est. Latency</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "<th>",
    "<select name='andor' onchange='submit()'>",
    " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
    "  value='and'>and</option>",
    " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
    "  value='or'>or</option>",
    "</select>",
    "</th>",
    " <th>",
    textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
		       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "</tr>\n";

  foreach my $kind (qw(N T))
  {
    foreach my $row (sort { $$b{DONE_BYTES} <=> $$a{DONE_BYTES}
			    || $$b{FAIL_FILES} <=> $$a{FAIL_FILES}
			    || $$b{EXPIRE_FILES} <=> $$a{EXPIRE_FILES}
			    || $$a{TO_NODE} cmp $$b{TO_NODE}
			    || $$a{FROM_NODE} cmp $$b{FROM_NODE} }
		     values %{$stats{$span}{$kind}})
    {
      next if ($kind eq 'N'
	       && ($fromfilter || $tofilter)
	       && ($andor eq 'or'
		   ? ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			|| ($tofilter && $$row{TO_NODE} =~ /$tofilter/))
		   : ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			&& ($tofilter && $$row{TO_NODE} =~ /$tofilter/))));
      next if $kind eq 'N' && ! $errors && ! $$row{DONE_FILES};
      next if $kind eq 'N' && ! $$row{DONE_FILES} && ! $$row{FAIL_FILES} && ! $$row{EXPIRE_FILES};
      my $bps = $$row{DONE_BYTES} / $spans{$span}[2];
      print { $$self{CONTENT} }
	"<tr>",
	($$row{FROM_NODE}
	 ? "<td>$$row{TO_NODE}</td><td>&nbsp;</td><td>$$row{FROM_NODE}</td>"
	 : "<td colspan='3'>Total</td>"),
	"<td align='right'>@{[&format_num($$row{DONE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{DONE_BYTES})]}</td>",
	"<td align='right'>", ($bps >= 0 ? &format_size($bps) . '/s' : &format_num(0)), "</td>",
	"<td align='right'>@{[&format_num($$row{FAIL_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_num($$row{EXPIRE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{PARAM_RATE} || 0)]}/s</td>",
	"<td align='right'>@{[&age($$row{PARAM_LATENCY} || 0)]}</td>",
	"</tr>\n";

      if ($kind eq 'N')
      {
	$stats{$span}{T}{1}{DONE_FILES} += $$row{DONE_FILES};
	$stats{$span}{T}{1}{DONE_BYTES} += $$row{DONE_BYTES};
	$stats{$span}{T}{1}{FAIL_FILES} += $$row{FAIL_FILES};
	$stats{$span}{T}{1}{EXPIRE_FILES} += $$row{EXPIRE_FILES};
      }
    }
  }
  print { $$self{CONTENT} } "</tbody></table></p></form>\n";
}

1;

######################################################################
package Web::Activity::PlotPage;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);
use File::Temp ':mktemp';

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{PLOT_ORDER} = [ qw(l24h l48h l72h l96h l132h l7d l14d l30d l45d l90d l120d
			    l6w l26w l52w ad aw am) ];
  $$self{PLOTS} = { "l24h" => [ "24:hour", "Last 24 Hours" ],
		    "l48h" => [ "48:hour", "Last 48 Hours" ],
	            "l72h" => [ "72:hour", "Last 72 Hours" ],
	            "l96h" => [ "96:hour", "Last 96 Hours" ],
	            "l132h" => [ "132:hour", "Last 132 Hours" ],
	            "l7d" => [ "7:day", "Last 7 Days" ],
	            "l14d" => [ "14:day", "Last 14 Days" ],
	            "l30d" => [ "30:day", "Last 30 Days" ],
	            "l45d" => [ "45:day", "Last 45 Days" ],
	            "l90d" => [ "90:day", "Last 90 Days" ],
	            "l120d" => [ "120:day", "Last 120 Days" ],
	            "l6w" => [ "6:week", "Last 6 Weeks" ],
	            "l26w" => [ "26:week", "Last 26 Weeks" ],
	            "l52w" => [ "52:week", "Last 52 Weeks" ],
	            "ad" => [ "0:day", "Daily Since Start" ],
	            "aw" => [ "0:week", "Weekly Since Start" ],
	            "am" => [ "0:month", "Monthly Since Start" ] };
  $$self{DEFAULT_PLOT} = 'l96h';
  $$self{DEFAULT_GRAPH} = undef;
  $$self{GRAPH_ORDER} = [];
  $$self{GRAPHS} = {};
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(plot graph entity filter upto);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Activity::RatePlots"
        && $args{"page"} ne "Activity::QueuePlots"
        && $args{"page"} ne "Activity::QualityPlots");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub save_data
{
  my ($self, $start, $end, $unit, $span, $entity) = @_;
  my $TERABYTE = &sizeValue ("1T");
  my $MEGABYTE = &sizeValue ("1M");

  # Generate actual data file
  my $tmpdir = mkdtemp("/tmp/perf.graph.XXXXXX");
  open(TOT, "> $tmpdir/total") or die "Failed to save performance data: $!\n";
  open(DST, "> $tmpdir/destined") or die "Failed to save performance data: $!\n";
  open(RES, "> $tmpdir/resident") or die "Failed to save performance data: $!\n";
  open(PER, "> $tmpdir/pending") or die "Failed to save performance data: $!\n";
  open(ERR, "> $tmpdir/error") or die "Failed to save performance data: $!\n";
  open(ROU, "> $tmpdir/routed") or die "Failed to save performance data: $!\n";
  open(COO, "> $tmpdir/cooloff") or die "Failed to save performance data: $!\n";
  open(QUA, "> $tmpdir/quality") or die "Failed to save performance data: $!\n";

  # Read data from the database
  my $sqlentity = ($entity eq 'src' ? "f.name"
		   : $entity eq 'link' ? "t.name || ' < ' || f.name"
		   : "t.name");
  my $q = &dbexec($$self{DBH}, qq{
    select
      trunc(h.timebin/:span)*:span,
      $sqlentity,
      nvl(sum(h.done_bytes),0),
      nvl(sum(pend_bytes) keep (dense_rank last order by timebin asc),0),
      nvl(sum(cool_bytes) keep (dense_rank last order by timebin asc),0),
      nvl(sum(h.try_files),0),
      nvl(sum(h.fail_files),0),
      nvl(sum(h.done_files),0)
    from t_link_histogram h
      join t_node f on f.id = h.from_node
      join t_node t on t.id = h.to_node
    where timebin >= :starttime
      and timebin < :endtime
    group by trunc(h.timebin/:span)*:span, $sqlentity
    order by 1 asc},
    ":starttime" => $start,
    ":endtime" => $end,
    ":span" => $span);

  my ($first, %items, %xferred, %pending, %error, %quality);
  while (my ($bin, $item, $bdone, $bpend, $berr, $tfiles, $ffiles, $dfiles) = $q->fetchrow())
  {
    $bin = (&timeSeries($bin, $unit, $bin))[0]->{LOW};
    $first = $bin if (! $first || $first > $bin);
    if ($bdone)
    {
      $xferred{$bin}{$item} ||= 0;
      $xferred{$bin}{$item} += $bdone / $TERABYTE;
    }
    $pending{$bin}{$item} = $bpend / $TERABYTE if $bpend;
    $error{$bin}{$item} = $berr / $TERABYTE if $berr;
    if ($tfiles || $ffiles || $dfiles)
    {
      $quality{$bin}{$item} ||= { STARTED => 0, FAILED => 0, COMPLETED => 0 };
      $quality{$bin}{$item}{STARTED} += $tfiles || 0;
      $quality{$bin}{$item}{FAILED} += $ffiles || 0;
      $quality{$bin}{$item}{COMPLETED} += $dfiles || 0;
    }
    $items{$item} = 1;
  }

  my (%destined, %resident, %routed, %cool);
  my $sqlentity = ($entity eq 'src' ? "'Source unavailable'"
		   : $entity eq 'link' ? "n.name"
		   : "n.name");
  $q = &dbexec($$self{DBH}, qq{
    select
      trunc(h.timebin/:span)*:span,
      $sqlentity,
      nvl(sum(dest_bytes) keep (dense_rank last order by timebin asc),0),
      nvl(sum(node_bytes) keep (dense_rank last order by timebin asc),0),
      nvl(sum(request_bytes) keep (dense_rank last order by timebin asc),0),
      nvl(sum(idle_bytes) keep (dense_rank last order by timebin asc),0)
    from t_dest_histogram h
      join t_node n on n.id = h.node
    where timebin >= :starttime
      and timebin < :endtime
    group by trunc(h.timebin/:span)*:span, $sqlentity
    order by 1 asc},
    ":starttime" => $start,
    ":endtime" => $end,
    ":span" => $span);
  while (my ($bin, $item, $bdest, $bnode, $breq, $bidle) = $q->fetchrow())
  {
    $bin = (&timeSeries($bin, $unit, $bin))[0]->{LOW};
    $first = $bin if (! $first || $first > $bin);
    $destined{$bin}{$item} = $bdest / $TERABYTE if $bdest;
    $resident{$bin}{$item} = $bnode / $TERABYTE if $bnode;
    $routed{$bin}{$item} = $breq / $TERABYTE if $breq;
    $cool{$bin}{$item} = $bidle / $TERABYTE if $bidle;
    $items{$item} = 1;
  }

  # Print the statistics for all nodes.  Generate a continuous time
  # series so we print out values even for time spans when there
  # were no transfers to report.  This allows for correct histograms
  # without having to understands time as real time values.
  my @itemnames = sort keys %items;
  print TOT "Time,Span,Item,Value\n";
  print DST "Time,Span,Item,Value\n";
  print PER "Time,Span,Item,Value\n";
  print ERR "Time,Span,Item,Value\n";
  print ROU "Time,Span,Item,Value\n";
  print COO "Time,Span,Item,Value\n";
  print QUA "Time,Span,Item,Value\n";

  $first ||= int(time()/86400)*86400;
  foreach my $time (&timeSeries ($first, $unit, $end-1))
  {
    my $bin = $$time{LOW};
    my $binfmt = &formatTime ($bin, $unit);
    my $x = $xferred{$bin};
    my $d = $destined{$bin};
    my $n = $resident{$bin};
    my $p = $pending{$bin};
    my $e = $error{$bin};
    my $r = $routed{$bin};
    my $c = $cool{$bin};
    my $q = $quality{$bin};
    my %dests = map { $_ => 1 } map { keys %$_ } $x, $d, $n, $p, $e, $r, $c, $q;
    $dests{$itemnames[0]} = 1 if @itemnames && ! keys %dests;
    foreach my $dest (sort keys %dests)
    {
      print TOT join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest, $$x{$dest}||0), "\n";
      print DST join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest, $$d{$dest}||0), "\n";
      print RES join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest, $$n{$dest}||0), "\n";
      print PER join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest, $$p{$dest}||0), "\n";
      print ERR join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest, $$e{$dest}||0), "\n";
      print ROU join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest, $$r{$dest}||0), "\n";
      print COO join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest, $$c{$dest}||0), "\n";
      print QUA join(",", $binfmt, $$time{HIGH}-$$time{LOW}, $dest,
		     ($$q{$dest}{STARTED}||0) . "/" .
      		     ($$q{$dest}{FAILED}||0) . "/" .
      		     ($$q{$dest}{COMPLETED}||0)), "\n";
    }
  }

  close (TOT);
  close (DST);
  close (RES);
  close (PER);
  close (ERR);
  close (ROU);
  close (COO);
  close (QUA);

  $tmpdir =~ s,^/tmp/,,;
  return $tmpdir;
}

# Done.
sub output
{
  my ($self) = @_;
  my $page = param("page");
  my $plot = param("plot");
  my $graph = param("graph");
  my $entity = param("entity");
  my $filter = param("filter") || '';
  my $upto = param("upto") || '';
  $plot = $$self{DEFAULT_PLOT} if (! $plot || ! exists $$self{PLOTS}{$plot});
  $graph = $$self{DEFAULT_GRAPH} if (! $graph || ! exists $$self{GRAPHS}{$graph});
  $entity = 'dest' if (! $entity || ! grep($_ eq $entity, qw(dest src link)));

  print { $$self{CONTENT} } "<p><form method='GET' action='@{[$self->myurl()]}'>\n",
    "<label for='graph'>Graph</label>\n",
    "<select name='graph' onchange='submit()'>\n",
    (map { (" <option", ($graph eq $_ ? " selected='selected'" : ""),
	    " value='$_'>$$self{GRAPHS}{$_}</option>\n") }
     @{$$self{GRAPH_ORDER}}),
    "</select>\n",
    "<label for='plot'>Period</label>\n",
    "<select name='plot' onchange='submit()'>\n",
    (map { (" <option", ($plot eq $_ ? " selected='selected'" : ""),
            " value='$_'>$$self{PLOTS}{$_}[1]</option>\n") }
     @{$$self{PLOT_ORDER}}),
    "</select>\n",
    "<label for='entity'>By</label> ",
    "<select name='entity' onchange='submit()'>",
    " <option ", ($entity eq 'dest' ? "selected='selected'" : ''),
    "  value='dest'>Destination</option>",
    " <option ", ($entity eq 'src' ? "selected='selected'" : ''),
    "  value='src'>Source</option>",
    " <option ", ($entity eq 'link' ? "selected='selected'" : ''),
    "  value='link'>Link</option>",
    "</select>\n",
    "<label for='filter'>Filter</label> ",
    textfield(-name=>'filter', -default=>$filter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")), "\n",
    "<label for='upto'>Up to</label> ",
    textfield(-name=>'upto', -default=>$upto, -size=>15,
	      -title=>("Time up to and including which results will be shown. "
		       ."Specify the time in format matching the selected plot type:\n"
		       ."YYYYMMDDZHHMM for hourly plots;\n"
		       ."YYYYMMDD for daily plots;\n"
		       ."YYYYMM for monthly plots;\n"
		       ."YYYYWW for weekly plots.")), "\n",
    "<input type='submit' value='Update'></form></p>\n";

  my ($last, $unit) = $$self{PLOTS}{$plot}[0] =~ /([^:]+)/g;
  my %args = ('span' => $unit, 'by' => $entity, 'last' => $last,
              'filter' => $filter, 'upto' => $upto);
  my %span = ("hour" => 3600, "day" => 86400, "week" => 7*86400, "month" => 86400);
  my %round = (%span, 'week' => 86400);
  my $now = time();
  my $end = (int($now/$round{$unit})+1)*$round{$unit};
  if ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)Z(\d\d)\d\d$/)
  {
    $end = timegm(0, 0, $4, $3, $2-1, $1-1900) + 3600;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, $3, $2-1, $1-1900) + 86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/ && $unit eq 'week')
  {
    # January 4th is always in (ISO) week one, so find out what
    # day of week that is, then go back to Monday of that week,
    # and advance specified number of weeks plus one.
    my $jan4 = timegm(0, 0, 0, 4, 0, $1-1900);
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($jan4);
    $end = $jan4 + (-$diff{$wday} + 7*$2)*86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, 1, $2, $1-1900);
  }

  my $start = ($last ? $end - $last*$span{$unit} : 0);
  my $datadir = $self->save_data($start, $end, $unit, $round{$unit}, $entity);
  $self->output_plot($graph, $datadir, %args);
  # FIXME: Clean up old directories (older than a day)
  # &rmtree([ grep((stat($_))[9] < $now-86400, </tmp/perf.graph.*>) ]);
}

1;

######################################################################
package Web::Activity::RatePlots;
use strict; use warnings;
use base "Web::Activity::PlotPage";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Rate Plots",
	       LINK_TITLE => "Show recent transfer rate as plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'rate';
  $$self{GRAPH_ORDER} = [ 'rate', 'volume', 'cumulative' ];
  $$self{GRAPHS} = { 'rate' => "Rate", 'volume' => "Volume", 'cumulative' => "Cumulative" };
  bless $self, $class;
  return $self;
}

sub output_plot
{
  my ($self, $graph, $datadir, %args) = @_;
  my $suffix = ($graph eq 'cumulative' ? '-line' : '');
  my $home = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/"; #"http://cmsdoc.cern.ch/cms/aprom/phedex/cgi-bin/";
  my $kind = ($graph eq 'rate' ? 'rate'
              : $graph eq 'volume' ? 'total'
              : $graph eq 'cumulative' ? 'total'
              : 'rate');

  print { $$self{CONTENT} } "<p><img width=800 height=500 src='${home}perf-graph$suffix-23.php?",
    &urlencode('db' => $$self{DBID}, 'data' => $datadir, 'kind' => $kind, %args),
    "' /></p>";
}

1;

######################################################################
package Web::Activity::QueuePlots;
use strict; use warnings;
use base "Web::Activity::PlotPage";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Queue Plots",
	       LINK_TITLE => "Show pending transfer queue plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'destined';
  $$self{GRAPH_ORDER} = [ 'destined', 'resident', 'pending', 'error', 'routed', 'cooloff' ];
  $$self{GRAPHS} = { 'destined' => "Allocated volume",
		     'resident' => "Resident volume",
		     'pending' => "Transferable volume",
		     'error' => "Transfer cool-off",
		     'routed' => "Currently routed",
		     'cooloff' => "Routing cool-off" };
  bless $self, $class;
  return $self;
}

sub output_plot
{
  my ($self, $graph, $datadir, %args) = @_;
  my $home = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/";
  print { $$self{CONTENT} } "<p><img width=800 height=500 src='${home}perf-graph-23.php?",
    &urlencode('db' => $$self{DBID}, 'data' => $datadir, 'kind' => $graph, %args),
    "' /></p>";
}

1;

######################################################################
package Web::Activity::QualityPlots;
use strict; use warnings;
use base "Web::Activity::PlotPage";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Quality Plots",
	       LINK_TITLE => "Show transfer quality plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{GRAPH_ORDER} = [ 'map', 'attempts', 'successes', 'failures' ];
  $$self{GRAPHS} = { 'map' => "Quality map",
		     'attempts' => "Attempts",
		     'successes' => "Successes",
		     'failures' => "Failures" };
  bless $self, $class;
  return $self;
}

sub output_plot
{
  my ($self, $graph, $datadir, %args) = @_;
  my $kind = ($graph eq 'map' ? 'completed_ratio'
	      : $graph eq 'attempts' ? 'attempted'
	      : $graph eq 'successes' ? 'completed'
	      : $graph eq 'failures' ? 'failed'
	      : 'completed_ratio');
  my $home = "$$self{CONFIG}{SERVICE_PATH}/cgi-bin/"; # "http://cmsdoc.cern.ch/cms/aprom/phedex/cgi-bin/";
  my $php = ($kind =~ /_/ ? "quality-map-23.php" : "quality-graph-23.php");
  print { $$self{CONTENT} } "<p><img width=800 height=500 src='${home}$php?",
    &urlencode('db' => $$self{DBID}, 'data' => $datadir, 'kind' => $kind, %args),
    "' /></p>";
}

1;

######################################################################
package Web::Activity::TransferState;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Transfer State",
	       LINK_TITLE => "Show overview of the transfer situation" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $rows = 0;
  my $now = time();
  my $query = &dbexec($$self{DBH}, qq{
    select
      n.name, max(br.time_update),
      sum(br.dest_files), sum(br.dest_bytes),
      sum(br.node_files), sum(br.node_bytes),
      sum(br.xfer_files), sum(br.xfer_bytes)
     from t_dps_block_replica br join t_node n on n.id = br.node
     group by n.name order by n.name});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Last<br>Change</th>\n",
    " <th rowspan='2'>Node</th>\n",
    " <th colspan='2'>Destined</th>\n",
    " <th colspan='2'>On Site</th>\n",
    " <th colspan='2'>In Transfer</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    "</tr>\n";

 my ($tdest_files, $tdest_size,
     $tnode_files, $tnode_size,
     $txfer_files, $txfer_size) = (0) x 6;

  while (my $row = $query->fetchrow_arrayref)
  {
    my ($n, $stamp,
	$dest_files, $dest_size,
	$node_files, $node_size,
	$xfer_files, $xfer_size) = @$row;

    $tdest_files += $dest_files; $tdest_size += $dest_size;
    $tnode_files += $node_files; $tnode_size += $node_size;
    $txfer_files += $xfer_files; $txfer_size += $xfer_size;

    my $node_color = (($dest_files && $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : $xfer_files ? " bgcolor='$pendcolor'" : "");
    my $xfer_color = (($xfer_files) ? " bgcolor='$goodcolor'"
		      : ($xfer_files + $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : "");

    print { $$self{CONTENT} }
      "<tr>\n",
      " <td>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$n</td>\n",
      " <td align='right'>@{[&format_num($dest_files)]}</td>\n",
      " <td align='right'>@{[&format_size($dest_size)]}</td>\n",
      " <td align='right'$node_color>@{[&format_num($node_files)]}</td>\n",
      " <td align='right'$node_color>@{[&format_size($node_size)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_num($xfer_files)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_size($xfer_size)]}</td>\n",
      "</tr>\n";
  }
  my $node_color = (($tdest_files && $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : ($txfer_files) ? " bgcolor='$pendcolor'" : "");
  my $xfer_color = (($txfer_files) ? " bgcolor='$goodcolor'"
		    : ($txfer_files + $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : "");

  print { $$self{CONTENT} }
    "<tr>\n",
    " <th>&nbsp;</th>\n",
    " <th align='left'>Total</th>\n",
    " <th align='right'>@{[&format_num($tdest_files)]}</th>\n",
    " <th align='right'>@{[&format_size($tdest_size)]}</th>\n",
    " <th align='right'$node_color>@{[&format_num($tnode_files)]}</th>\n",
    " <th align='right'$node_color>@{[&format_size($tnode_size)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_num($txfer_files)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_size($txfer_size)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n";
}

1;

######################################################################
package Web::Activity::TransferStates;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Transfer Details",
	       LINK_TITLE => "Browse transfer state details" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::TransferStates");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $rows = 0;
  my $now = time();
  my %total = ();
  my $tofilter = param('tofilter') || "";
  my $fromfilter = param('fromfilter') || "";
  my $andor = param('andor') || 'or';
  my $query = &dbexec($$self{DBH}, qq{
    select
      time_update,
      nd.name, ns.name,
      to_state, from_state,
      files, bytes
    from t_info_xfer_states xs
      join t_node ns on ns.id = xs.from_node
      join t_node nd on nd.id = xs.to_node
    order by nd.name, ns.name, to_state, from_state});

  print { $$self{CONTENT} }
    "<form method='GET' action='@{[$self->myurl()]}'><p>\n",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='9' align='center'>Transfer State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='3'>Age</th>\n",
    " <th colspan='2'>To</th>\n",
    " <th rowspan='2'>&nbsp;</th>\n",
    " <th colspan='2'>From</th>\n",
    " <th colspan='2'>Files</th>\n",
    " <th rowspan='3'>Detail</th>",
    "</tr>\n",
    "<tr class='selected'>",
    " <th>Node</th>\n",
    " <th rowspan='2'>State</th>\n",
    " <th>Node</th>\n",
    " <th rowspan='2'>State</th>\n",
    " <th rowspan='2'>N</th>\n",
    " <th rowspan='2'>Size</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th>",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>",
    "<th>",
    "<select name='andor' onchange='submit()'>",
    " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
    "  value='and'>and</option>",
    " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
    "  value='or'>or</option>",
    "</select>",
    "</th>",
    "<th>",
    textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>",
    "</tr>\n";

  while (my $row = $query->fetchrow_arrayref)
  {
    my ($stamp,
	$to_node, $from_node,
	$to_state, $from_state,
	$files, $bytes) = @$row;

    next if (($fromfilter || $tofilter)
	     && ($andor eq 'or'
		 ? ! (($fromfilter && $from_node =~ /$fromfilter/)
		      || ($tofilter && $to_node =~ /$tofilter/))
		 : ! (($fromfilter && $from_node =~ /$fromfilter/)
		      && ($tofilter && $to_node =~ /$tofilter/))));
    $total{$to_state}{$from_state} ||= { FILES => 0, BYTES => 0 };
    $total{$to_state}{$from_state}{FILES} += $files;
    $total{$to_state}{$from_state}{BYTES} += $bytes;
    my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
    my $to_state_name = ($to_state == 0 ? "pending"
			 : $to_state == 1 ? "requested"
			 : $to_state == 2 ? "transferring"
			 : $to_state == 3 ? "transferred"
			 : ($to_state >= 100 && $to_state < 999) ? "error"
			 : "unknown");
    my $from_state_name = ($from_state == 0 ? "pending"
			   : $from_state == 1 ? "ready"
			   : "unknown");
    my $to_color = (($to_state == 2) ? " bgcolor='$goodcolor'"
		    : ($to_state == 1) ? " bgcolor='$pendcolor'"
		    : ($to_state >= 100) ? " bgcolor='$warncolor'"
		    : "");
    my $from_color = ($from_state == 1 ? " bgcolor='$goodcolor'" : "");
    my $url = $self->myurl("page" => "Activity::FileInfo",
			   "to_node" => $to_node,
			   "to_state" => $to_state,
			   "from_node" => $from_node,
			   "from_state" => $from_state);
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$to_node</td>\n",
      " <td align='left'$to_color>$to_state_name</td>\n", # ($to_state_name)
      " <td align='right'>&nbsp;</td>\n",
      " <td>$from_node</td>\n",
      " <td align='left'$from_color>$from_state_name</td>\n", # ($from_state_name)
      " <td align='right'>@{[&format_num($files)]}</td>\n",
      " <td align='right'>@{[&format_size($bytes)]}</td>\n",
      " <td align='center'><a href='$url'>(Files)</a></td>\n",
      "</tr>\n";
  }

  my $first_total = 1;
  my ($tfiles, $tbytes) = (0, 0);
  foreach my $to_state (sort keys %total)
  {
    foreach my $from_state (sort keys %{$total{$to_state}})
    {
      $tfiles += $total{$to_state}{$from_state}{FILES};
      $tbytes += $total{$to_state}{$from_state}{BYTES};
      my $to_state_name = ($to_state == 0 ? "pending"
			   : $to_state == 1 ? "requested"
			   : $to_state == 2 ? "transferring"
			   : $to_state == 3 ? "transferred"
			   : ($to_state >= 100 && $to_state < 999) ? "error"
			   : "unknown");
      my $from_state_name = ($from_state == 0 ? "pending"
			     : $from_state == 1 ? "ready"
			     : "unknown");
      print { $$self{CONTENT} }
        "<tr>\n",
        " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
        " <th align='right'>$to_state_name</td>\n",
        " <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>$from_state_name</td>\n",
	" <th align='right'>@{[&format_num($total{$to_state}{$from_state}{FILES})]}</th>\n",
	" <th align='right'>@{[&format_size($total{$to_state}{$from_state}{BYTES})]}</th>\n",
	" <th align='right'>&nbsp;</th>\n",
	"</tr>\n";
      $first_total = 0;
    }
  }
  print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    " <th align='right'>&nbsp;</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n";

  $query = &dbexec($$self{DBH}, qq{
    select xr.time_update, n.name, xr.state, xr.files, xr.bytes
    from t_info_xfer_replicas xr join t_node n on n.id = xr.node
    order by n.name, state});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='5' align='center'>Replica State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Age</th>",
    " <th rowspan='2'>Node</th>",
    " <th rowspan='2'>State</th>",
    " <th colspan='2'>Files</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>N</th>\n",
    " <th>Size</th>\n",
    "</tr>\n";

  %total = ();
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($stamp, $node, $state, $files, $bytes) = @$row;
    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $node =~ /$fromfilter/)
		   || ($tofilter && $node =~ /$tofilter/)));
    $total{$state} ||= { FILES => 0, BYTES => 0 };
    $total{$state}{FILES} += $files;
    $total{$state}{BYTES} += $bytes;
    my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    my $color = (($state == 1) ? " bgcolor='$goodcolor'" : "");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$node</td>\n",
      " <td$color align='right'>$state_name</td>\n",
      " <td$color align='right'>@{[&format_num($files)]}</td>\n",
      " <td$color align='right'>@{[&format_size($bytes)]}</td>\n",
      "</tr>\n";
  }

  $first_total = 1;
  ($tfiles, $tbytes) = (0, 0);
  foreach my $state (sort keys %total)
  {
    $tfiles += $total{$state}{FILES};
    $tbytes += $total{$state}{BYTES};
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
      " <th align='right'>$state_name</td>\n",
      " <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
      " <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
      "</tr>\n";
    $first_total = 0;
  }
  print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n",
    "</form>\n";
}

1;

######################################################################
package Web::Activity::FileInfo;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 0, ORDER => 7, TITLE => "Transfer Details" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(to_node from_node to_state from_state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::FileInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $to_node = param('to_node');
  my $from_node = param('from_node');
  my $to_state = param('to_state');
  my $from_state = param('from_state');
  if (! defined $to_node || $to_node eq ''
      || ! defined $from_node || $from_node eq ''
      || ! defined $to_state || $to_state !~ /^\d+$/
      || ! defined $from_state || $from_state !~ /^\d+$/)
  {
    print { $$self{CONTENT} }
      "<div class='alert'><p><b>Error:</b>",
      " Missing arguments</p></div>\n";
  }

  my $query = &dbexec($$self{DBH}, qq{
    select f.logical_name, f.filesize, xs.from_pfn, xs.to_pfn,
	   xs.errors, xs.last_error, xs.time_xfer_start
    from t_xfer_state xs
      join t_xfer_file f on f.id = xs.fileid
      join t_node ns on ns.id = xs.from_node
      join t_node nd on nd.id = xs.to_node
    where ns.name = :from_node
      and nd.name = :to_node
      and xs.from_state = :from_state
      and xs.to_state = :to_state
    order by xs.time_xfer_start, f.logical_name},
    ":from_node" => $from_node,
    ":to_node" => $to_node,
    ":from_state" => $from_state,
    ":to_state" => $to_state);
  print { $$self{CONTENT} }
    "<p>Files from $from_node, state $from_state to $to_node, state $to_state.</p>\n",
    "<ol align='left'>\n";
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($lfn, $size, $from_pfn, $to_pfn, $errors, $errmsg, $start) = @$row;
    print { $$self{CONTENT} }
      "<li><b>lfn</b>=@{[&escapeHTML($lfn)]}<br />",
      "<b>size</b>=$size<br />",
      "<b>errors</b>=$errors<br />",
      ($from_pfn ? "<b>from_pfn</b>=@{[&escapeHTML($from_pfn)]}<br />" : ""),
      ($to_pfn ? "<b>to_pfn</b>=@{[&escapeHTML($to_pfn)]}<br />" : ""),
      ($errmsg ? "<b>last_error</b>=<i>@{[&escapeHTML($errmsg)]}</i><br />" : ""),
      ($start ? "<b>time_xfer_start</b>=@{[strftime('%Y-%m-%d %H:%M:%S', gmtime($start))]} UTC<br />" : ""),
      "<br /></li>\n";
  }
  print { $$self{CONTENT} } "</ol></p>\n";
}

1;

######################################################################
package Web::Data::ExplorePage;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);
use Sort::Key::Natural;
use Sort::Key::Maker sort_dbs =>
  sub { $$_{LABEL}, ($$_{BASE} || ''), $$_{ID} }, qw(nat nat int);
use Sort::Key::Maker sort_dataset_dbs =>
  sub { $$_{DBS}{LABEL}, ($$_{DBS}{BASE}||''), $$_{DBS}{ID}, $$_{NAME}, $$_{ID} },
  qw(nat nat int nat int);
use Sort::Key::Maker sort_name_id =>
  sub { $$_{NAME}, $$_{ID} }, qw(nat int);
use Sort::Key::Maker sort_name =>
  sub { $$_{NAME} }, qw(nat);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{SAVE_DB}   = [ qw(filter dcolumn rcolumn nvalue scolumn rows) ];
  $$self{SAVE_PAGE} = [ @{$$self{SAVE_DB}}, qw(dbs node dexp bexp) ];
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Data::Datasets"
        && $args{"page"} ne "Data::Replicas"
        && $args{"page"} ne "Data::Subscriptions");

  # If we stay in the same database, keep all, otherwise stripp off db-specific
  my @save = $args{"db"} && $args{"db"} ne $$self{DBID}
    ? @{$$self{SAVE_DB}} : @{$$self{SAVE_PAGE}};

  # Return a URL with thave saved parameters
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub saveform
{
  my ($self, @omit) = @_;
  my $result = "";
  foreach my $option ('view', @{$$self{SAVE_PAGE}})
  {
    next if grep($option eq $_, @omit);
    if ($option eq 'nvalue')
    {
      $result .= "<input type='hidden' name='$option' value='$$self{NVALUE}' />";
    }
    elsif (grep($option eq $_, qw(dcolumn rcolumn scolumn)))
    {
      $result .= "<input type='hidden' name='$option' value='$_' />"
	for grep($$self{uc($option)}{$_}, param($option));
    }
    elsif (grep($option eq $_, qw(dbs node dexp bexp)))
    {
      $result .= "<input type='hidden' name='$option'"
		 . " value='@{[&escapeHTML($_)]}' />"
	for param($option);
    }
    else
    {
      $result .= "<input type='hidden' name='$option'"
		 . " value='@{[&escapeHTML(param($option))]}' />"
    }
  }

  return $result;
}

sub dbs_list
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select id, name, dls from t_dps_dbs
    order by name asc});

  my (%bases, @result);
  while (my ($id, $name, $dls) = $q->fetchrow())
  {
    # Build DBS object
    my $dbs = { ID => $id, URL => $name, DLS => $dls,
		BASE => undef, LABEL => $name };
    if ($name =~ /^(http.*)\?instance=(.*)/)
    {
      $$dbs{BASE} = $1;
      $$dbs{LABEL} = $2;
      $$dbs{LABEL} =~ s,/Writer$,,;
    }

    # Add HTML-formatted data
    my $htmllabel = &escapeHTML($$dbs{LABEL});
    my $htmldls = &breakAtSlash(&escapeHTML($$dbs{DLS}));
    my $suplink = "";
    if ($$dbs{BASE})
    {
      $bases{$$dbs{BASE}} = scalar(keys %bases) + 1
	if ! exists $bases{$$dbs{BASE}};
  
      $$dbs{BASE_ID} = $bases{$$dbs{BASE}};
      $suplink = "<sup><small>$$dbs{BASE_ID}</small></sup>";
    }
    $$dbs{HTML_DBS} = "$htmllabel$suplink";
    $$dbs{HTML_DLS} = $htmldls || '&nbsp;';

    # Add to the result
    push(@result, $dbs);
  }

  $q->finish();
  return @result;
}

sub dataset_list
{
  my ($self, @dbses) = @_;
  my $q = &dbprep($$self{DBH}, qq{
    select ds.id, ds.name, ds.is_open, ds.is_transient,
           nvl(count(b.id),0), nvl(sum(b.files),0), nvl(sum(b.bytes),0)
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
    where dbs = :dbsid
    group by ds.id, ds.name, ds.is_open, ds.is_transient
    order by ds.name asc});

  my @result = ();
  foreach my $dbs (@dbses)
  {
    &dbbindexec($q, ":dbsid" => $$dbs{ID});
    while (my ($id, $name, $open, $transient, $nblocks, $nfiles, $nbytes) = $q->fetchrow())
    {
      push(@result, {
	DBS => $dbs,
	ID => $id,
	NAME => $name,
	IS_OPEN => $open,
	IS_TRANSIENT => $transient,
	BLOCKS => $nblocks,
	FILES => $nfiles,
	BYTES => $nbytes });
    }
    $q->finish();
  }

  return @result;
}

sub dataset_replicas
{
  my ($self, @datasets) = @_;
  my $list = join(" or ", map { "ds.id = $$_{ID}" } @datasets);
  my $q = &dbexec($$self{DBH}, qq{
    select ds.id dataset, n.id node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
      join t_dps_block_replica br on br.block = b.id
      join t_node n on n.id = br.node
    where $list
    group by ds.id, n.id});

  my %byid = map { $$_{ID} => $_ } @datasets;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{DATASET}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_list
{
  my ($self, $dataset) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, b.name, b.is_open, b.files, b.bytes
    from t_dps_block b where b.dataset = :dsid},
    ":dsid" => $$dataset{ID});

  my @result = ();
  while (my ($id, $name, $open, $nfiles, $nbytes) = $q->fetchrow())
  {
    push(@result, {
      DATASET => $dataset,
      ID => $id,
      NAME => $name,
      IS_OPEN => $open,
      BLOCKS => 1,
      FILES => $nfiles,
      BYTES => $nbytes });
  }

  $q->finish();
  return @result;
}

sub file_list
{
  my ($self, $block) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select f.id, f.logical_name, f.filesize, n.name
    from t_dps_file f join t_node n on n.id = f.node
    where inblock = :bid},
    ":bid" => $$block{ID});

  my @result = ();
  while (my ($id, $name, $size, $source) = $q->fetchrow())
  {
    push(@result, {
      BLOCK => $block,
      SOURCE => $source,
      ID => $id,
      NAME => $name,
      SIZE => $size });
  }

  $q->finish();
  return @result;
}

sub block_replicas
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, br.node node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
    from t_dps_block b
      join t_dps_block_replica br on br.block = b.id
    where $list
    group by b.id, br.node});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{BLOCK}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_sources
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, f.node, n.name
    from t_dps_block b
      join t_dps_file f on f.inblock = b.id
      join t_node n on n.id = f.node
    where $list
    group by b.id, f.node, n.name});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $node, $name) = $q->fetchrow())
  {
    $byid{$block}{SOURCES}{$node} = $name;
    $byid{$block}{DATASET}{SOURCES}{$node} = $name;
  }

  $q->finish ();
}

sub file_replicas
{
  my ($self, @blocks) = @_;
  my $list = join(" or ", map { "b.id = $$_{ID}" } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, f.id, xr.node
    from t_dps_block b
      join t_xfer_file f on f.inblock = b.id
      join t_xfer_replica xr on xr.fileid = f.id
    where $list});

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $file, $node) = $q->fetchrow())
  {
    $byid{$block}{FILE_REPLICAS}{$file}{$node} = 1;
  }

  $q->finish ();
}

sub node_list
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{select id, name from t_node});
  my @result = ();
  while (my ($id, $name) = $q->fetchrow()) {
    push(@result, { ID => $id, NAME => $name });
  }

  $q->finish();
  return @result;
}

sub apply_options
{
  my ($self) = @_;

  # Determine which dataset options we are showing (in dataset mode)
  $$self{DCOLUMN_NAMES} = [ qw(DBS Name Blocks Files Bytes Open Transient Id) ];
  $$self{DCOLUMN} = { "DBS" => 0, "Name" => 1, "Blocks" => 1, "Files" => 1,
                      "Bytes" => 1, "Open" => 0, "Transient" => 0, "Id" => 0 };
  if (defined param('dcolumn'))
  {
    $$self{DOCLUMN}{$_} = 0 for keys %{$$self{DCOLUMN}};
    $$self{DCOLUMN}{$_} = 1 for grep(exists $$self{DCOLUMN}{$_}, param('dcolumn'));
  }

  # Determine which replica options we are showing (in replica mode)
  $$self{RCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{RCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
  if (defined param('rcolumn'))
  {
    $$self{ROCLUMN}{$_} = 0 for keys %{$$self{RCOLUMN}};
    $$self{RCOLUMN}{$_} = 1 for grep(exists $$self{RCOLUMN}{$_}, param('rcolumn'));
  }

  # Determine which replica options we are showing (in subscription mode)
  $$self{SCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{SCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
  if (defined param('scolumn'))
  {
    $$self{SOCLUMN}{$_} = 0 for keys %{$$self{SCOLUMN}};
    $$self{SCOLUMN}{$_} = 1 for grep(exists $$self{SCOLUMN}{$_}, param('scolumn'));
  }

  # Determine which replica value we show (in replica mode)
  $$self{NVALUES} = [ "Node blocks", "Node files", "Node bytes",
		      "Destined blocks", "Destined files", "Destined bytes",
		      "Missing blocks", "Missing files", "Missing bytes" ];
  $$self{NVALUE} = param('nvalue') || "Node files";
  $$self{NVALUE} = "Node files" if !grep($$self{NVALUE} eq $_, @{$$self{NVALUES}});

  # Determine if we are showing all or interesting rows
  $$self{ROWS} = param('rows') || 'all';
  $$self{ROWS} = 'all' if !grep($$self{ROWS} eq $_, qw(all interesting));
}

sub fetch_data
{
  my ($self) = @_;

  # Obtain the list of DBSes, sort them and pick the ones we show.
  my %shown = map { $_ => 1 } param('dbs');
  $$self{DBS_LIST} = [ sort_dbs $self->dbs_list() ];

  if (keys %shown)
  {
    $$self{DBS_SHOWN} = [ grep(exists $shown{$$_{ID}}, @{$$self{DBS_LIST}}) ];
  }
  else
  {
    $$self{DBS_SHOWN} = $$self{DBS_LIST};
  }

  $$_{IS_SHOWN} = 1 for @{$$self{DBS_SHOWN}};

  # Now get a sorted list of the datasets we are interested in
  my $filter = param('filter');
  $filter = "." if ! defined $filter || $filter eq '';
  my @datasets = grep($$_{NAME} =~ /$filter/,
		      $self->dataset_list(@{$$self{DBS_SHOWN}}));
  if ($$self{DCOLUMN}{"DBS"})
  {
    $$self{DATASET_LIST} = [ sort_dataset_dbs @datasets ];
  }
  else
  {
    $$self{DATASET_LIST} = [ sort_name_id @datasets ];
  }

  # Fetch blocks and block replicas
  my %dexpand = map { $_ => 1 } param('dexp');
  my %bexpand = map { $_ => 1 } param('bexp');
  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    if (! $dexpand{$$ds{ID}})
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ $$ds{ID}, param('dexp') ]) .
        "#d$$ds{ID}'>&#187;</a>";
    }
    else
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ grep($_ != $$ds{ID}, param('dexp')) ]) .
        "#d$$ds{ID}'>&#171;&#171;</a>";
    }

    # Pass if not expanded
    next if ! $dexpand{$$ds{ID}};

    # Expanded, obtain block list
    $$ds{BLOCK_LIST} = [ sort_name $self->block_list($ds) ];
    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      if (! $bexpand{$$block{ID}})
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ $$block{ID}, param('bexp') ]) .
          "#b$$block{ID}'>&#187;</a>";
      }
      else
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ grep($_ != $$block{ID}, param('bexp')) ]) .
          "#b$$block{ID}'>&#171;&#171;</a>";
      }

      # Pass if not expanded
      next if ! $bexpand{$$block{ID}};

      # Expanded, obtain file list
      $$block{FILE_LIST} = [ sort_name $self->file_list($block) ];
    }
  }

  # Fetch per-node replicas for datasets, blocks and files in expanded view
  if (ref ($self) !~ /Datasets/)
  {
    $$self{NODE_LIST} = [ sort_name $self->node_list() ];
    my %nodesel = defined param('node')
      ? (map { $_ => 1 } param('node'))
      : (map { $$_{ID} => 1 } grep($$_{NAME} =~ /CERN_MSS/, @{$$self{NODE_LIST}}));
    $$self{NODE_SHOWN} = [ grep($nodesel{$$_{ID}}, @{$$self{NODE_LIST}}) ];
    $$_{IS_SHOWN} = 1 for @{$$self{NODE_SHOWN}};
      
    $self->dataset_replicas(@{$$self{DATASET_LIST}})
      if @{$$self{DATASET_LIST}};

    my @allblocks = map { @{$$_{BLOCK_LIST}} } grep($$_{BLOCK_LIST}, @{$$self{DATASET_LIST}});

    $self->block_replicas(@allblocks)
      if @allblocks;

    $self->block_sources(@allblocks)
      if (@allblocks
	  && ((ref ($self) =~ /::Replicas/ && $$self{RCOLUMN}{"Source"})
	      || (ref ($self) =~ /::Subs/ && $$self{SCOLUMN}{"Source"})));

    my @expblock = grep($bexpand{$$_{ID}}, @allblocks);
    $self->file_replicas(@expblock) if @expblock;
  }
}

# Dump the list of DBSes.  This is either a compact list (default),
# or a form / table where user can select the DBSes (toggle).
sub output_dbses
{
  my ($self) = @_;

  print { $$self{CONTENT} }
    "<div id='dbschoice'>\n";

  if ((param('dbsmenu') || 'no') eq 'yes')
  {
    print { $$self{CONTENT} }
      "  <div id='dbsmenu' style='width:100%;font-size:0.9em'>\n",
      "   <form method='GET' href='@{[$self->myurl()]}'>\n",
      "    ", $self->saveform('dbs'),
      "    <table>\n",
      "     <thead>\n",
      "      <tr>\n",
      "       <th width='4%' align='center'>Show</th>\n",
      "       <th width='20%' align='left'>DBS</th>\n",
      "       <th width='100%' align='left'>DLS contact</th>\n",
      "       <th width='4%' align='right'>Id</th>\n",
      "      </tr>\n",
      "     </thead>\n",
      "     <tbody>\n";

    my $n = 0;
    foreach my $dbs (@{$$self{DBS_LIST}})
    {
      my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
      print { $$self{CONTENT} }
        "      <tr$rowcolor>\n",
        "       <td align='center'><input type='checkbox' name='dbs' value='$$dbs{ID}'",
        ($$dbs{IS_SHOWN} ? " checked='checked'" : ''), " /></td>\n",
        "       <td align='left'>$$dbs{HTML_DBS}</td>\n",
        "       <td align='left'>$$dbs{HTML_DLS}</td>\n",
        "       <td align='right' style='color:#666'>$$dbs{ID}</td>\n",
        "      </tr>\n";
    }

    print { $$self{CONTENT} }
      "      <tr>\n",
      "       <td colspan='4' align='center'><input type='submit' value='Update' /></td>\n",
      "      </tr>\n",
      "     </tbody>\n",
      "    </table>\n",
      "   </form>\n",
      "  </div>\n";
  }
  else
  {
    print { $$self{CONTENT} }
      " <p style='font-size:0.95em;margin:1em 0 0 1em'>Sources:&nbsp;&nbsp;",
      (! @{$$self{DBS_SHOWN}} ? "(None)"
       : join(" &nbsp;|&nbsp;&nbsp;",
              map { ($$_{IS_SHOWN} ? $$_{HTML_DBS}
		     : "<span style='color:#666;text-decoration:line-through;'>$$_{HTML_DBS}</span>") }
	      @{$$self{DBS_SHOWN}})),
      "&nbsp;&nbsp;<a href='@{[$self->myurl('dbsmenu' => 'yes')]}'>&#187; other</a></p>\n";
  }

  print { $$self{CONTENT} }
    "</div>\n", # dbschoice
    "\n";
}

sub output_nodes
{
  my ($self) = @_;

  print { $$self{CONTENT} }
    "<div id='nodechoice'>\n";

  if ((param('nodemenu') || 'no') eq 'yes')
  {
    my (@all, @columns) = @{$$self{NODE_LIST}};
    my $percolumn = int(scalar(@all)/4 + 0.5);
    $percolumn = 4 if ! $percolumn;
    push (@columns, [ splice(@all, 0, $percolumn) ]) while @all;

    print { $$self{CONTENT} }
      "  <div id='nodemenu' style='font-size:0.9em'>\n",
      "   <form method='GET' href='@{[$self->myurl()]}#replicas'>\n",
      "    ", $self->saveform('node'),
      "    <table>\n",
      "     <tbody>\n",
      "      <tr>\n";

    foreach my $col (@columns)
    {
      print { $$self{CONTENT} }
        "       <td>\n",
        (map { "        <input type='checkbox' name='node' value='$$_{ID}'" .
	       ($$_{IS_SHOWN} ? " checked='checked'" : "") .
               " />&nbsp;" . &escapeHTML($$_{NAME}) . "<br />" }
	 @$col),
        "       </td>\n";
    }

    print { $$self{CONTENT} }
      "      </tr>\n",
      "      <tr>\n",
      "       <td colspan='4' align='center'><input type='submit' value='Update' /></td>\n",
      "      </tr>\n",
      "     </tbody>\n",
      "    </table>\n",
      "   </form>\n",
      "  </div>\n";
  }
  else
  {
    print { $$self{CONTENT} }
      " <p style='font-size:0.95em;margin:0 0 1em 1em'>Nodes:&nbsp;&nbsp;",
      (! @{$$self{NODE_SHOWN}} ? "(None)"
       : join(" &nbsp;|&nbsp;&nbsp;", map { &escapeHTML($$_{NAME}) } @{$$self{NODE_SHOWN}})),
      "&nbsp;&nbsp;<a href='@{[$self->myurl('nodemenu' => 'yes')]}'>&#187; other</a></p>\n";
  }

  print { $$self{CONTENT} }
    "</div>\n", # nodechoice
    "\n";
}

sub output_filter
{
  my ($self) = @_;
  my $filter = param('filter');
  my $filterform = "" .
    "<form style='display:inline' method='GET' href='@{[$self->myurl()]}'>" .
    $self->saveform('filter') .
    textfield(-name=>'filter', -default=>$filter, -size=>15,
	      -title=>("Regular expression to match against the name column. "
		       ."Only those matching the expression will be shown.")) .
    " <input type='submit' value='Filter' />" .
    "</form>";

  return ($filter, $filterform);
}

sub output
{
  my ($self) = @_;

  # Apply form options and fetch the data we show on this form
  $self->apply_options();
  $self->fetch_data();
  $self->output_page();

  # Produce "footnotes" for the DBS URL base strings
  my %bases = map { $$_{BASE_ID} => $$_{BASE} } grep($$_{BASE}, @{$$self{DBS_LIST}});
  if (keys %bases)
  {
    print { $$self{CONTENT} }
      "<div style='font-size: 0.9em;margin-top:1em'>\n<hr>\n",
      (map { ("<sup><small>$_</small></sup>",
	      "&nbsp;", &breakAtSlash(&escapeHTML($bases{$_})), "<br />\n") }
       sort keys %bases),
      "</div>";
  }

  $self->output_sidebar();
}

1;

######################################################################
package Web::Data::Datasets;
use strict; use warnings;
use base "Web::Data::ExplorePage";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Datasets",
	       LINK_TITLE => "Explore datasets" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  my ($filter, $filterform) = $self->output_filter();
  $self->output_dbses();

  print { $$self{CONTENT} }
    "<div style='width:100%;overflow:auto'>\n",
    "<table id='dataset_tbl'>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{DCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{DCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{DCOLUMN}{"Blocks"}    ? "   <th width='6%' align='right'>Blocks</th>\n" : ()),
    ($$self{DCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{DCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{DCOLUMN}{"Open"}      ? "   <th width='4%' align='center'>Open</th>\n" : ()),
    ($$self{DCOLUMN}{"Transient"} ? "   <th width='4%' align='center'>Transient</th>\n" : ()),
    ($$self{DCOLUMN}{"Id"}        ? "   <th width='4%' align='right'>Id</th>\n" : ()),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody>\n";

  my $n = 0;
  my %total = (BLOCKS => 0, FILES => 0, BYTES => 0);
  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{DCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{DCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>@{[&format_num($$ds{BLOCKS})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$ds{IS_OPEN}</td>\n" : ()),
      ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>$$ds{IS_TRANSIENT}</td>\n" : ()),
      ($$self{DCOLUMN}{"Id"}        ? "   <td align='right' style='color:#666'>$$ds{ID}</td>\n" : ()),
      "  </tr>\n";

    $total{BLOCKS} += $$ds{BLOCKS};
    $total{FILES} += $$ds{FILES};
    $total{BYTES} += $$ds{BYTES};

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{DCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{DCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>&nbsp;</td>\n" : ()),
        ($$self{DCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$block{IS_OPEN}</td>\n" : ()),
        ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
        ($$self{DCOLUMN}{"Id"}        ? "   <td align='right' style='color:#666'>$$block{ID}</td>\n" : ()),
        "  </tr>\n";

      foreach my $file (@{$$block{FILE_LIST}})
      {
        my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
        my $span = 1;
        $span++ if $$self{DCOLUMN}{"Blocks"};
        $span++ if $$self{DCOLUMN}{"Files"};

        print { $$self{CONTENT} }
          "  <tr$rowcolor>\n",
          "   <td>&nbsp;</td>\n",
          ($$self{DCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
          ($$self{DCOLUMN}{"Name"}      ? "   <td style='padding-left:3em' colspan='$span'>@{[&escapeHTML($$file{NAME})]}</td>\n" : ()),
          ($$self{DCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$file{SIZE})]}</td>\n" : ()),
          ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Id"}        ? "   <td align='right' style='color:#666'>$$file{ID}</td>\n" : ()),
          "  </tr>\n";
      }
    }
  }

  print { $$self{CONTENT} }
    " </tbody>\n",
    " <tfoot>\n",
    "   <tr bgcolor='#f8f8f8'>\n",
    "    <th>&nbsp;</th>\n",
    ($$self{DCOLUMN}{"DBS"} && $$self{DCOLUMN}{"Name"}
     ? "   <th colspan='2' align='left'>Total</th>\n"
     : $$self{DCOLUMN}{"DBS"} || $$self{DCOLUMN}{"Name"}
     ? "   <th align='left'>Total</th>\n"
     : ()),
    ($$self{DCOLUMN}{"Blocks"}    ? "   <th align='right'>@{[&format_num($total{BLOCKS})]}</th>\n" : ()),
    ($$self{DCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
    ($$self{DCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
    ($$self{DCOLUMN}{"Open"}      ? "   <th align='center style='color:#666'>&#8211;</th>\n" : ()),
    ($$self{DCOLUMN}{"Transient"} ? "   <th align='center' style='color:#666'>&#8211;</th>\n" : ()),
    ($$self{DCOLUMN}{"Id"}        ? "   <th align='right' style='color:#666'>&#8211;</th>\n" : ()),
    "   </tr>\n",
    " </tfoot>\n",
    "</table>\n",
    "</div>\n";
}

# Produce content to the sidebar: dataset field selector
sub output_sidebar
{
  my ($self) = @_;
  print { $$self{SIDEBAR} }
    " <div>\n",
    "  <h3>Options</h3>\n",
    "  <form method='GET' href='@{[$self->myurl('dcolumn' => [])]}'>\n",
    "   ", $self->saveform('dcolumn'), "\n",
    "   <p><i>Show columns</i></p>\n";

  foreach my $opt (@{$$self{DCOLUMN_NAMES}})
  {
    print { $$self{SIDEBAR} }
      "   <p><input type='checkbox' name='dcolumn' value='$opt'",
      ($$self{DCOLUMN}{$opt} ? " checked='checked'" : ""),
      " />&nbsp;$opt</p>\n";
  }

  print { $$self{SIDEBAR} }
    "   <p style='margin-top:1ex'><input type='submit' value='Update' /></p>\n",
    "  </form>\n",
    " </div><!-- options -->\n";
}

1;

######################################################################
package Web::Data::Replicas;
use strict; use warnings;
use base "Web::Data::ExplorePage";
import Web::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Replicas",
	       LINK_TITLE => "Explore replicas" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  my ($filter, $filterform) = $self->output_filter();
  $self->output_dbses();
  $self->output_nodes();

  print { $$self{CONTENT} }
    "<div style='width:100%;overflow:auto'>\n",
    "<table id='dataset_tbl'>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{RCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{RCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{RCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{RCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{RCOLUMN}{"Source"}    ? "   <th width='6%' align='left'>Source</th>\n" : ()),
    (map { "   <th width='4%' align='center'>@{[&escapeHTML($$_{NAME})]}</th>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody>\n";

  my $n = 0;
  my %total = (BYTES => 0, FILES => 0);
  $total{$$_{ID}} = { VALUE => 0, ATTR => "" } for @{$$self{NODE_SHOWN}};
  my ($quantity, $formatter) = ("", sub { return -1, 0 }, sub { return @_ });
  if ($$self{NVALUE} eq "Node blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{NODE_BLOCKS} || 0, $$ref{BLOCKS}; };
  }
  elsif ($$self{NVALUE} eq "Destined blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{DEST_BLOCKS} || 0, $$ref{BLOCKS}; };
  }
  elsif ($$self{NVALUE} eq "Missing blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return max(0, ($$obj{DEST_BLOCKS} || 0) - ($$obj{NODE_BLOCKS} || 0)), 0; };
  }
  elsif ($$self{NVALUE} eq "Node files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{NODE_FILES} || 0, $$ref{FILES}; };
  }
  elsif ($$self{NVALUE} eq "Destined files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{DEST_FILES} || 0, $$ref{FILES}; };
  }
  elsif ($$self{NVALUE} eq "Missing files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return max(0, ($$obj{DEST_FILES} || 0) - ($$obj{NODE_FILES} || 0)), 0; };
  }
  elsif ($$self{NVALUE} eq "Node bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{NODE_BYTES} || 0, $$ref{BYTES}; };
  }
  elsif ($$self{NVALUE} eq "Destined bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{DEST_BYTES} || 0, $$ref{BLOCKS}; };
  }
  elsif ($$self{NVALUE} eq "Missing bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      return max(0, ($$obj{DEST_BYTES} || 0) - ($$obj{NODE_BYTES} || 0)), 0; };
  }

  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my %values = ();
    my $interesting = 0;
    foreach my $node (@{$$self{NODE_SHOWN}})
    {
      my ($value, $refvalue) = &$quantity($ds, $$ds{REPLICAS}{$$node{ID}});
      my $attr = $value == $refvalue ? "" : " style='color:#d00'";
      $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
      $interesting ||= ($refvalue || $value);
    }

    next if $$self{ROWS} eq 'interesting' && ! $interesting;

    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    my @sources = ($$ds{SOURCES} ? values %{$$ds{SOURCES}}
		   : "<span style='color:#666'>(Expand)</span>");
    my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		  ? "<span style='color:#666'>(Multiple)</span>"
		  : $sources[0]);
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{RCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
      (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
      "  </tr>\n";

    $total{BYTES} += $$ds{BYTES};
    $total{FILES} += $$ds{FILES};
    for (@{$$self{NODE_SHOWN}})
    {
      $total{$$_{ID}}{VALUE} += $values{$$_{ID}}{VALUE};
      $total{$$_{ID}}{ATTR} ||= $values{$$_{ID}}{ATTR};
    }

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      %values = ();
      $interesting = 0;
      foreach my $node (@{$$self{NODE_SHOWN}})
      {
        my ($value, $refvalue) = &$quantity($block, $$block{REPLICAS}{$$node{ID}});
        my $attr = $value == $refvalue ? "" : " style='color:#d00'";
        $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
        $interesting ||= ($refvalue || $value);
      }

      next if $$self{ROWS} eq 'interesting' && ! $interesting;

      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      my @sources = ($$block{SOURCES} ? values %{$$block{SOURCES}}
		     : "<span style='color:#666'>(Expand)</span>");
      my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		    ? "<span style='color:#666'>(Multiple)</span>"
		    : &escapeHTML($sources[0]));
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
        (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
        "  </tr>\n";

      foreach my $file (@{$$block{FILE_LIST}})
      {
        my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
        my $span = 1; $span++ if $$self{RCOLUMN}{"Files"};
        my $have = "<span style='color:#666'>y</span>";
        my $havenot = "<span style='color:#d00'>N</span>";
        my $goal = ($$self{NVALUE} =~ /Missing/ ? $havenot : $have);
	my %nodeattr = map { $$_{ID} => ($$block{FILE_REPLICAS}{$$file{ID}}{$$_{ID}}
			                 ? $have : $havenot) }
		      @{$$self{NODE_SHOWN}};
	$interesting = scalar(grep($_ eq $goal, values %nodeattr));
	next if $$self{ROWS} eq 'interesting' && ! $interesting;

        print { $$self{CONTENT} }
          "  <tr$rowcolor>\n",
          "   <td>&nbsp;</td>\n",
          ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
          ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:3em' colspan='$span'>@{[&escapeHTML($$file{NAME})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$file{SIZE})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>@{[&escapeHTML($$file{SOURCE})]}</td>\n" : ()),
          (map { "   <td align='right'>$nodeattr{$$_{ID}}</td>\n" } @{$$self{NODE_SHOWN}}),
          "  </tr>\n";
      }
    }
  }

  print { $$self{CONTENT} }
    " </tbody>\n",
    " <tfoot>\n",
    "   <tr bgcolor='#f8f8f8'>\n",
    "    <th>&nbsp;</th>\n",
    ($$self{RCOLUMN}{"DBS"} && $$self{RCOLUMN}{"Name"}
     ? "   <th colspan='2' align='left'>Total</th>\n"
     : $$self{RCOLUMN}{"DBS"} || $$self{RCOLUMN}{"Name"}
     ? "   <th align='left'>Total</th>\n"
     : ()),
    ($$self{RCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
    ($$self{RCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
    ($$self{RCOLUMN}{"Source"}    ? "   <th align='right'>&nbsp;</th>\n" : ()),
    (map { "   <td align='right'$total{$$_{ID}}{ATTR}>@{[&$formatter($total{$$_{ID}}{VALUE})]}</td>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    " </tfoot>\n",
    "</table>\n",
    "</div>\n";
}

# Produce content to the sidebar: dataset field selector
sub output_sidebar
{
  my ($self) = @_;
  print { $$self{SIDEBAR} }
    " <div>\n",
    "  <h3>Options</h3>\n",
    "  <form method='GET' href='@{[$self->myurl('rcolumn' => [], 'nvalue' => undef)]}'>\n",
    "   ", $self->saveform('rcolumn', 'nvalue', 'rows'), "\n",
    "   <p><i>Show columns</i></p>\n";

  foreach my $opt (@{$$self{RCOLUMN_NAMES}})
  {
    print { $$self{SIDEBAR} }
      "   <p><input type='checkbox' name='rcolumn' value='$opt'",
      ($$self{RCOLUMN}{$opt} ? " checked='checked'" : ""),
      " />&nbsp;$opt</p>\n";
  }

  print { $$self{SIDEBAR} }
    "   <p style='margin-top:1ex'><i>Node value</i></p>\n";

  foreach my $opt (@{$$self{NVALUES}})
  {
    print { $$self{SIDEBAR} }
      "  <p><input type='radio' name='nvalue' value='$opt'",
      ($$self{NVALUE} eq $opt ? " checked='checked'" : ""),
      " />&nbsp;$opt</p>\n";
  }

  print { $$self{SIDEBAR} }
    "   <p style='margin-top:1ex'><i>Filter rows</i></p>\n",
    "   <p><input type='radio' name='rows' value='all'",
    ($$self{ROWS} eq 'all' ? " checked='checked'" : ""),
    " />&nbsp;Show all rows</p>\n",
    "   <p><input type='radio' name='rows' value='interesting'",
    ($$self{ROWS} eq 'interesting' ? " checked='checked'" : ""),
    " />&nbsp;Show interesting rows</p>\n";

  print { $$self{SIDEBAR} }
    "   <p style='margin-top:1ex'><input type='submit' value='Update' /></p>\n",
    "  </form>\n",
    " </div><!-- options -->\n";
}

1;

######################################################################
package Web::Data::Subscriptions;
use strict; use warnings;
use base "Web::Data::ExplorePage";
import Web::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Subscriptions",
	       LINK_TITLE => "Explore subscriptions" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  my ($filter, $filterform) = $self->output_filter();
  $self->output_dbses();
  $self->output_nodes();

  print { $$self{CONTENT} }
    "<div style='width:100%;overflow:auto'>\n",
    "<table id='dataset_tbl'>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{SCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{SCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{SCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{SCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{SCOLUMN}{"Source"}    ? "   <th width='6%' align='right'>Source</th>\n" : ()),
    (map { "   <th width='4%' align='center'>@{[&escapeHTML($$_{NAME})]}</th>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody>\n";

  my $n = 0;
  my %total = (BYTES => 0, FILES => 0);
  $total{$$_{ID}} = { VALUE => 0, ATTR => "" } for @{$$self{NODE_SHOWN}};
  my ($quantity, $formatter) = ("", sub { return -1, 0 }, sub { return @_ });
  if ($$self{NVALUE} eq "Node blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{NODE_BLOCKS} || 0, $$ref{BLOCKS}; };
  }
  elsif ($$self{NVALUE} eq "Destined blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{DEST_BLOCKS} || 0, $$ref{BLOCKS}; };
  }
  elsif ($$self{NVALUE} eq "Missing blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return max(0, ($$obj{DEST_BLOCKS} || 0) - ($$obj{NODE_BLOCKS} || 0)), 0; };
  }
  elsif ($$self{NVALUE} eq "Node files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{NODE_FILES} || 0, $$ref{FILES}; };
  }
  elsif ($$self{NVALUE} eq "Destined files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{DEST_FILES} || 0, $$ref{BLOCKS}; };
  }
  elsif ($$self{NVALUE} eq "Missing files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      return max(0, ($$obj{DEST_FILES} || 0) - ($$obj{NODE_FILES} || 0)), 0; };
  }
  elsif ($$self{NVALUE} eq "Node bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{NODE_BYTES} || 0, $$ref{BYTES}; };
  }
  elsif ($$self{NVALUE} eq "Destined bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      return $$obj{DEST_BYTES} || 0, $$ref{BLOCKS}; };
  }
  elsif ($$self{NVALUE} eq "Missing bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      return max(0, ($$obj{DEST_BYTES} || 0) - ($$obj{NODE_BYTES} || 0)), 0; };
  }

  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my %values = ();
    foreach my $node (@{$$self{NODE_SHOWN}})
    {
      my ($value, $refvalue) = &$quantity($ds, $$ds{REPLICAS}{$$node{ID}});
      my $attr = $value == $refvalue ? "" : " style='color:#d00'";
      $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
    }

    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{SCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{SCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{SCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{SCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{SCOLUMN}{"Source"}    ? "   <td align='right'>(FIXME)</td>\n" : ()),
      (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
      "  </tr>\n";

    $total{BYTES} += $$ds{BYTES};
    $total{FILES} += $$ds{FILES};
    for (@{$$self{NODE_SHOWN}})
    {
      $total{$$_{ID}}{VALUE} += $values{$$_{ID}}{VALUE};
      $total{$$_{ID}}{ATTR} ||= $values{$$_{ID}}{ATTR};
    }

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      %values = ();
      foreach my $node (@{$$self{NODE_SHOWN}})
      {
        my ($value, $refvalue) = &$quantity($block, $$block{REPLICAS}{$$node{ID}});
        my $attr = $value == $refvalue ? "" : " style='color:#d00'";
        $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
      }

      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{SCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{SCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{SCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{SCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{SCOLUMN}{"Source"}    ? "   <td align='right'>(FIXME)</td>\n" : ()),
        (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
        "  </tr>\n";
    }
  }

  print { $$self{CONTENT} }
    " </tbody>\n",
    " <tfoot>\n",
    "   <tr bgcolor='#f8f8f8'>\n",
    "    <th>&nbsp;</th>\n",
    ($$self{SCOLUMN}{"DBS"} && $$self{SCOLUMN}{"Name"}
     ? "   <th colspan='2' align='left'>Total</th>\n"
     : $$self{SCOLUMN}{"DBS"} || $$self{SCOLUMN}{"Name"}
     ? "   <th align='left'>Total</th>\n"
     : ()),
    ($$self{SCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
    ($$self{SCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
    ($$self{SCOLUMN}{"Source"}    ? "   <th align='right'>&nbsp;</th>\n" : ()),
    (map { "   <td align='right'$total{$$_{ID}}{ATTR}>@{[&$formatter($total{$$_{ID}}{VALUE})]}</td>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    " </tfoot>\n",
    "</table>\n",
    "</div>\n";
}

# Produce content to the sidebar: dataset field selector
sub output_sidebar
{
  my ($self) = @_;
  print { $$self{SIDEBAR} }
    " <div>\n",
    "  <h3>Options</h3>\n",
    "  <form method='GET' href='@{[$self->myurl('scolumn' => [], 'nvalue' => undef)]}'>\n",
    "   ", $self->saveform('scolumn', 'nvalue'), "\n",
    "   <p><i>Show columns</i></p>\n";

  foreach my $opt (@{$$self{SCOLUMN_NAMES}})
  {
    print { $$self{SIDEBAR} }
      "   <p><input type='checkbox' name='scolumn' value='$opt'",
      ($$self{SCOLUMN}{$opt} ? " checked='checked'" : ""),
      " />&nbsp;$opt</p>\n";
  }

  print { $$self{SIDEBAR} }
    "   <p style='margin-top:1ex'><i>Node value</i></p>\n";

  foreach my $opt (@{$$self{NVALUES}})
  {
    print { $$self{SIDEBAR} }
      "  <p><input type='radio' name='nvalue' value='$opt'",
      ($$self{NVALUE} eq $opt ? " checked='checked'" : ""),
      " />&nbsp;$opt</p>\n";
  }

  print { $$self{SIDEBAR} }
    "   <p style='margin-top:1ex'><input type='submit' value='Update' /></p>\n",
    "  </form>\n",
    " </div><!-- options -->\n";
}

sub foo
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select
     ds.name,
     n.name,
     nvl(sum(b.files),0),
     nvl(sum(b.bytes),0),
     nvl(sum(br.node_files),0),
     nvl(sum(br.node_bytes),0)
   from t_dps_dataset ds
     left join t_dps_subscription s
       on s.dataset = ds.id
     left join t_node n
       on n.id = s.destination
     left join t_dps_block b
       on b.dataset = ds.id
     left join t_dps_block_replica br
       on br.block = b.id and br.node = s.destination
   group by ds.name, n.name});
}
1;

######################################################################
package Web::Data::DatasetRemoval;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Remove Datasets",
	       LINK_TITLE => "Remove datasets from PhEDEx database",
               SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web::Data::FileRemoval;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Remove Files",
	       LINK_TITLE => "Remove files from PhEDEx database",
               SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web::Reports::DailyReports;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Daily Reports",
	       LINK_TITLE => "Browse all daily reports" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my @reports = sort <$reportdir/$dbname-*.txt*>;
  print { $$self{CONTENT} }
    "<p><table class='striped'><tbody>\n",
    "<tr class='selected'><th colspan='32'>Available reports</th></tr>\n",
    "<tr class='selected'>\n",
    " <th>Month</td>\n",
    (map { sprintf " <th>%02d</th>\n", $_ } 1 .. 31),
    "</tr>\n";
  my $prev = "";
  my $prevday = 0;
  foreach my $file (@reports)
  {
    my $basename = $file; $basename =~ s|.*/||;
    my $cleanname = $basename; $cleanname =~ s|^$dbname-||;
    my $url = $self->myurl("page" => "Reports::DailyReport", "reportfile" => $cleanname);
    my ($year, $month, $day) = ($cleanname =~ /(\d\d\d\d)(\d\d)(\d\d)\..*/);
    if ("$year-$month" ne $prev)
    {
      if ($prev)
      {
        while (++$prevday <= 31) { print { $$self{CONTENT} } "<td></td>\n"; }
        print { $$self{CONTENT} } "</tr>\n";
      }

      print { $$self{CONTENT} } "<tr>\n <td>$year&#8209;$month</td>\n";
      $prev = "$year-$month";
      $prevday = 0;
    }
    while (++$prevday < $day) { print { $$self{CONTENT} } " <td></td>\n"; }
    print { $$self{CONTENT} } "<td align='center'><a href='$url'>R</a></td>\n";
    $prevday = $day;
  }

  print { $$self{CONTENT} } "</tbody></table></p>\n";
}

1;

######################################################################
package Web::Reports::DailyReport;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Daily Report",
	       LINK_TITLE => "Show today's daily report" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(reportfile);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Reports::DailyReport");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my $report = param('reportfile') || (strftime('%Y%m%d', gmtime()) . ".txt");
  print { $$self{CONTENT} } "<pre class='wide' align='left'>\n";
  if ($report && $report =~ m|^[-A-Za-z0-9.]+$|)
  {
    my $reportfile = (<$reportdir/$dbname-$report>)[0];
    if (-f $reportfile)
    {
      local $/ = undef;
      open (REPORT, $reportfile =~ /.gz$/ ? "gzip -dc < $reportfile |" : "< $reportfile");
      my $report = <REPORT>;
      close (REPORT);
      $report =~ s/&/&amp;/gso;
      $report =~ s/</&lt;/gso;
      $report =~ s/>/&gt;/gso;
      $report =~ s/"/&quot;/gso;
      print { $$self{CONTENT} } $report;
    }
  }
  print { $$self{CONTENT} } "</pre>\n";
}

1;

######################################################################
package Web::Reports::Size;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "File Sizes",
	       LINK_TITLE => "Show file size distribution and other statistics" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my $overview = $$self{DBH}->selectrow_arrayref(qq{
    select time_update, n_files, sz_total, sz_min, sz_max, sz_mean, sz_median
    from t_info_file_size_overview});
  my $histo = $$self{DBH}->selectall_arrayref(qq{
    select time_update, bin_low, bin_width, n_total, sz_total
    from t_info_file_size_histogram order by bin_low asc});

  print { $$self{CONTENT} }
    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='6'>File size statistics ", &age($now - $overview->[0]), " ago</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    " <th>Min Size</th>\n",
    " <th>Max Size</th>\n",
    " <th>Mean Size</th>\n",
    " <th>Median Size</th>\n",
    "</tr>\n",
    "<tr>\n",
    " <td align='right'>@{[&format_num($overview->[1])]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[2], 0, 2, 'T')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[3], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[4], 0, 2, 'G')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[5], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[6], 0, 2, 'M')]}</td>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>",

    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='4'>File size breakdown</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th colspan='2'>Bin</th>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    "</tr>\n";

  foreach my $row (@$histo)
  {
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td align='right'>@{[&format_size($row->[1] * $row->[2],1,2,'G')]} ..</td>\n",
      " <td align='right'>@{[&format_size(($row->[1]+1) * $row->[2],1,2,'G')]}</td>\n",
      " <td align='right'>@{[&format_num($row->[3])]}</td>\n",
      " <td align='right'>@{[&format_size($row->[4],1,2,'T')]}</td>\n",
      "</tr>\n";
  }

  print { $$self{CONTENT} } "</tbody>\n</table>\n</p>\n";
}

1;

######################################################################
package Web::Configuration::SignUp;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Sign Up",
	       LINK_TITLE => "Sign up to be a transfer administrator",
	       SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web::Configuration::Identities;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);
import Web::Request::CreateTools;

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Identities",
	       LINK_TITLE => "Manage registered users" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  if ($$self{SSL_VERIFIED})
  {
    my ($known) = eval {
      &dbexec($$self{DBH}, qq{
        select dn.identity
        from t_adm_identity_attr dn
        where dn.name = 'Distinguished name'
        and dn.value = :client_dn},
        ':client_dn' => $$self{SSL_IDENTITY})->fetchrow() };

    my ($email_contact) = eval {
      &dbexec($$self{DBH}, qq{
        select email.value
        from t_adm_identity_attr dn
          join t_adm_identity_attr email
            on email.identity = dn.identity
            and email.name = 'E-mail'
        where dn.name = 'Distinguished name'
        and dn.value = :client_dn},
        ':client_dn' => $$self{SSL_IDENTITY})->fetchrow() };
    my $email_default = &create_default_email();

    print { $$self{CONTENT} }
      "<div class='notebox'>\n",
      " <p>Your identity has been verified as ", &escapeHTML($$self{SSL_IDENTITY}), ".</p>",
      ($known ? " <p>You are a registered PhEDEx user.</p>" : "<p>You are not a registered user.</p>");

    if ($email_contact)
    {
      print { $$self{CONTENT} }
	" <p>Your e-mail address is registered as @{[&escapeHTML($email_contact)]}.</p>";
    }
    else
    {
      print { $$self{CONTENT} }
	" <p>PhEDEx will use the default e-mail address from your certificate @{[&escapeHTML($email_default)]}.</p>";
    }

    print { $$self{CONTENT} }
      " <p>You will be able to access <i>all operations.</i></p>\n",
      "</div>\n";
  }
  elsif (($ENV{HTTPS} || "nope") eq 'on')
  {
    print { $$self{CONTENT} }
      "<div class='alertbox'>\n",
      " <p>You are accessing this web site securely, but your identity\n",
      "  could not be verified. To authenticate please <a\n",
      "   href='http://lcg.web.cern.ch/LCG/users/registration/load-cert.html'\n",
      "   >load your grid certificate into your browser</a> and authorise\n",
      "  this web site to authenticate using the certificate.</p>\n",
      " <p>You will be able to access <i>unprivileged operations.</i></p>\n",
      "</div>\n";
  }
  else
  {
    print { $$self{CONTENT} }
      "<div class='warningbox'>\n",
      " <p>You are accessing this web site insecurely and unauthenticated.</p>\n",
      " <p>You will be able to access <i>unprivileged operations.</i></p>\n",
      "</div>\n";
  }

  my $q = &dbexec($$self{DBH}, qq{
    select dn.identity, dn.value, email.value
    from t_adm_identity_attr dn
      left join t_adm_identity_attr email
        on email.identity = dn.identity
        and email.name = 'E-mail'
    where dn.name = 'Distinguished name'
    order by dn.value, dn.identity});

  print { $$self{CONTENT} }
    "<p><table>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th colspan='4'>Registered users</th>\n",
    "  </tr>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th align='left'>Name</th>\n",
    "   <th align='left'>Distinguished name</th>\n",
    "   <th align='left'>E-mail</th>\n",
    "   <th align='right'><span style='color:#666'>Id</span></th>\n",
    "  </tr>\n",
    " </thead>\n",
    " <tbody>\n";

  my $n = 0;
  while (my ($id, $dn, $email) = $q->fetchrow ())
  {
    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    my ($login) = ($dn =~ m,/CN=([^/]+?)[\s\d]*(/|$),); #/
    print { $$self{CONTENT} }
      "  <tr$rowcolor valign='top'>\n",
      "   <td align='left' style='padding-right: 1em'>", &escapeHTML($login), "</td>\n",
      "   <td align='left' style='padding-right: 1em'>", &escapeHTML($dn), "</td>\n",
      "   <td align='left' style='padding-right: 1em'>", &escapeHTML($email || ''), "</td>\n",
      "   <td align='right'><span style='color:#666'>$id</span></td>\n",
      "  </tr>\n";
  }

  print { $$self{CONTENT} }
    " </tbody>\n",
    "</table></p>\n";
}

1;

######################################################################
package Web::Configuration::Admins;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Administrators",
	       LINK_TITLE => "Manage administrator privileges" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web::Configuration::Sites;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Sites",
	       LINK_TITLE => "Manage sites" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web::Configuration::Nodes;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Nodes",
	       LINK_TITLE => "Administer nodes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package Web::Configuration::Links;
use strict; use warnings;
use base "Web::Page";
import Web::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Links",
	       LINK_TITLE => "Administer links between nodes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  print { $$self{CONTENT} } "<p>This page not yet implemented.  Help is welcome!</p>";
}

1;

######################################################################
package main;
BEGIN { use strict; use warnings; $^W=1; }
use CGI qw(:standard);

# Run the script main routine.  Determine which page we are looking
# at, instantiate it, then ask the page to generate itself.
sub runme
{
  # Read PhEDEx web server configuration
  my $config = &read_config();
  #eval "use CGI::Carp qw(fatalsToBrowser)";

  # Interpret the trailing path suffix: /DB/PAGE?QUERY
  my $path = path_info() || "/prod";
  my ($db, $cgipage) = ("prod", "Info::Main");
  $db = $1 if ($path =~ m!\G/([^/]+)!g);
  $cgipage = $1 if ($path =~ m!\G/([^/]+)!g);

  # Grab the database name from the path info
  $db = "prod" if ! $db || ! exists $$config{INSTANCES}{$db};
  
  # Get the scope object for the page.
  no strict "refs";
  my $type = "Web::Info::Main";
  $type = "Web::$cgipage"
    if ($cgipage =~ /^[A-Za-z0-9]+(::[A-Za-z0-9]+)*/
	&& exists ${"Web::$cgipage\::"}{INDEX}
	&& exists ${"Web::$cgipage\::"}{new});

  # Instantiate the page object and remember it as a CGI parameter
  # so we can use it in generating links to other pages.
  my $page = &{"$type\::new"}($type);
  $type =~ s!^Web::!!;
  param('page', $type);
  
  # Generate the page
  $page->generate($config, $db);
}

sub read_config
{
  my $config_file = $ENV{PHEDEX_SERVER_CONFIG}
    || die "No server configuration.\n";

  open (CONFIG, "< $config_file")
    || die "$config_file: cannot read server configuration: $!\n";

  my $config = {};
  my $instance_rank = 0;
  while (1)
  {
    my $line = &parse_line($config_file);
    if (! defined $line)
    {
      last;
    }
    elsif ($line =~ /^$/)
    {
      next;
    }
    elsif ($line =~ /^server-root:\s+(\S+)$/)
    {
      $$config{SERVER_ROOT} = $1;
    }
    elsif ($line =~ /^ssl-server-root:\s+(\S+)$/)
    {
      $$config{SSL_SERVER_ROOT} = $1;
    }
    elsif ($line =~ /^service-path:\s+(\S+)$/)
    {
      $$config{SERVICE_PATH} = $1;
    }
    elsif ($line =~ /^instance:\s+([\S\s]+)$/)
    {
      my $rest = $1;
      my $info = {};
      while ($rest =~ /\G([-a-z]+)\s*=\s*(\S+)\s*/g)
      {
        my $name = uc($1);
        my $value = $2;
        $name =~ s/-/_/g;
        $$info{$name} = $value;
      }

      my @required = qw(ID TITLE DATABASE_NAME USER_NAME PASSWORD);
      my @missing = map { s/_/-/g; lc; } grep(! exists $$info{$_}, @required);
      die "$config_file: instance is missing parameters '@missing'\n" if @missing;
  
      $$info{RANK} = $instance_rank++;
      $$config{INSTANCES}{$$info{ID}} = $info;
    }
    else
    {
      die "$config_file: unexpected parameters '$line'\n";
    }
  }

  close (CONFIG);
  return $config;
}

sub input_line
{
  my $line = <CONFIG>;
  return undef if ! defined $line;

  chomp($line);
  $line =~ s/#.*//;
  $line =~ s/^\s+//;
  $line =~ s/\s+$//;
  $line =~ s/\s+/ /;;
  return $line;
}

sub parse_line
{
  my ($file) = @_;
  my $line = &input_line();
  return undef if ! defined $line;

  while (substr($line,-1,1) eq '\\')
  {
    chop($line);
    my $next = &input_line();
    die "$file: file ends in '\\', expected continued line\n"
      if ! defined $next;
    $line .= " ";
    $line .= $next;
  }

  return $line;
}

&runme();
exit(0);
