-- Deploying the schema over a 3.3 schema
-- From SQLPLUS

alter table t_dps_block add constraint uq_dps_block_dataset unique (dataset, id);
@PHEDEX/Schema/OracleCoreSubscription

-- Dump request parameters in subscription parameter table
insert into t_dps_subs_param
(id, request, 
 priority, is_move, is_custodial, user_group, 
 original, time_create)
select seq_dps_subs_param.nextval, rx.request,
       rx.priority, rx.is_move, rx.is_custodial, rx.user_group,
       'y', r.time_create
  from t_req_xfer rx
  join t_req_request r on r.id = rx.request;

-- Copy over dataset subscriptions, linking to original parameters
insert into t_dps_subs_dataset
(destination, dataset, param, 
 time_create, time_fill_after, time_suspend_until,
 time_complete, time_done)
select s.destination, s.dataset, sp.id,
       s.time_create, NULL, s.time_suspend_until,
       s.time_complete, s.time_done
  from t_dps_subscription s
  join t_dps_subs_param sp on sp.request = s.request
 where s.request is not null
   and s.dataset is not null;

-- Copy over dataset subscriptions with no request
-- First create parameters (for blocks with null request too)
insert into t_dps_subs_param
(id, request, 
 priority, is_move, is_custodial, user_group, 
 original, time_create)
select seq_dps_subs_param.nextval, NULL,
       uq.*
  from (select distinct s.priority, s.is_move, s.is_custodial, s.user_group,
               'y', s.time_create
          from t_dps_subscription s
         where request is null) uq;

-- Now get the datasets
insert into t_dps_subs_dataset
(destination, dataset, param, 
 time_create, time_fill_after, time_suspend_until,
 time_complete, time_done)
select s.destination, s.dataset, sp.id,
       s.time_create, NULL, s.time_suspend_until,
       s.time_complete, s.time_done
  from t_dps_subscription s
  join t_dps_subs_param sp on sp.priority = s.priority
                          and sp.is_move = s.is_move
                          and sp.is_custodial = s.is_custodial
                          and nvl(sp.user_group,-1) = nvl(s.user_group,-1)
                          and sp.time_create = s.time_create
 where s.request is null
   and s.dataset is not null;

-- Now get the block-only subscriptions with a request
insert into t_dps_subs_block
(destination, dataset, block, param,
 time_create, time_suspend_until,
 time_complete, time_done)
select s.destination, b.dataset, s.block, sp.id,
       s.time_create, s.time_suspend_until,
       s.time_complete, s.time_done
  from t_dps_subscription s
  join t_dps_block b on b.id = s.block
  join t_dps_subs_param sp on sp.request = s.request
 where s.request is not null
   and s.block is not null;

-- And block-only subscriptions without a request
insert into t_dps_subs_block
(destination, dataset, block, param, 
 time_create, time_suspend_until,
 time_complete, time_done)
select s.destination, b.dataset, s.block, sp.id,
       s.time_create, s.time_suspend_until,
       s.time_complete, s.time_done
  from t_dps_subscription s
  join t_dps_block b on b.id = s.block
  join t_dps_subs_param sp on sp.priority = s.priority
                          and sp.is_move = s.is_move
                          and sp.is_custodial = s.is_custodial
                          and nvl(sp.user_group,-1) = nvl(s.user_group,-1)
                          and sp.time_create = s.time_create
 where s.request is null
   and s.block is not null;

-- Sanity check: count subscriptions of each level, they should be equal!
select count(*) from t_dps_subscription where dataset is not null;
select count(*) from t_dps_subs_dataset;
select count(*) from t_dps_subscription where block is not null;
select count(*) from t_dps_subs_block;

-- Now, create block-level subscriptions for all blocks in a dataset-level subscription
-- note: time_complete comes from t_dps_block_dest, if available
merge into t_dps_subs_block n using
(
select sd.destination, b.dataset, b.id block, sd.param,
       greatest(sd.time_create, b.time_create) time_create, sd.time_suspend_until,
       bd.time_complete, bd.time_complete time_done
  from t_dps_subs_dataset sd
  join t_dps_block b on b.dataset = sd.dataset
left join t_dps_block_dest bd on bd.block = b.id and bd.destination = sd.destination
) o on (n.destination = o.destination
        and n.dataset = o.dataset
        and n.block = o.block)
when not matched then insert
(destination, dataset, block, param, 
 time_create, time_suspend_until,
 time_complete, time_done)
values
(o.destination, o.dataset, o.block, o.param,
 o.time_create, o.time_suspend_until,
 o.time_complete, o.time_done);

-- Sanity check: IFF the BlockAllocator was shut down after the last subscription was created,
-- then these two queries will be equal
select count(*) from t_dps_block_dest;
select count(*) from t_dps_subs_block;

-- Finally, update t_dps_dataset.time_fill_after to the latest block creation time
update t_dps_subs_dataset sd
   set sd.time_fill_after = 
     (select max(b.time_create) 
       from t_dps_block b
      where sd.dataset = b.dataset);
