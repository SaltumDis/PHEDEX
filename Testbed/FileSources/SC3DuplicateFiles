#!/usr/bin/env perl

##H Duplicate GUIDs in TMDB and MySQL catalogue databases artificially.
##H
##H Usage:
##H   SC3DuplicateFiles -db FILE[:SECTION] -cat CONTACT
##H
##H -db        database connection configuration parameter file
##H -cat       catalogue contact (HOST:USER:PASS)

BEGIN {
  $^W = 1; use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../../Toolkit/Common";
  unshift(@INC, $home);
}
use UtilsHelp;
use UtilsDB;
use POSIX;

# Process command line arguments.
my %args = ();
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-cat' && scalar @ARGV > 1)
    { shift (@ARGV); $args{CAT} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

# Check arguments.
if (@ARGV || !$args{DBCONFIG} || !$args{CAT})
{
    die "Insufficient parameters, use -h for help.\n";
}

# Execute
my ($cathost, $catuser, $catpass) = ($args{CAT} =~ /^([^:]+):([^:]+):([^:]+)$/);
my $cat = DBI->connect ("DBI:mysql:$cathost", $catuser, $catpass, { RaiseError => 1, AutoCommit => 0 });
my $tmdb = &connectToDatabase (\%args, 0);
my @positions = (8, 13, 18, 23);
my @letters = qw(a b c d e f g h i j k l m n o p q r s t u v w x y z ! = + _ . , ^ #);
my @guids = map { @$_ } @{&dbexec($tmdb, "select guid from t_file")->fetchall_arrayref()};

foreach my $pos (@positions)
{
    foreach my $letter (@letters)
    {
        print "$pos/$letter: ";
	do { local $| = 1; print "F"; };
        &dbexec ($tmdb, qq{
	    insert into t_file
	    (timestamp, guid, node, inblock, insubblock, lfn, filetype, filesize, checksum)
	    (select timestamp, substr(guid,1,:pos) || :letter || substr(guid,:pos+2),
	     node, inblock, insubblock, lfn, filetype, filesize, checksum from t_file
	     where guid like '%-%-%-%-%')},
	    ":pos" => $pos, ":letter" => $letter);

	do { local $| = 1; print "A"; };
        &dbexec ($tmdb, qq{
	    insert into t_file_attributes (guid, attribute, value)
	    (select substr(guid,1,:pos) || :letter || substr(guid,:pos+2),
	     attribute, value from t_file_attributes where guid like '%-%-%-%-%')},
	    ":pos" => $pos, ":letter" => $letter);

	do { local $| = 1; print "R"; };
        &dbexec ($tmdb, qq{
	    insert into t_replica_state (timestamp, guid, node, state, state_timestamp)
	    (select timestamp, substr(guid,1,:pos) || :letter || substr(guid,:pos+2),
	     node, state, state_timestamp from t_replica_state where guid like '%-%-%-%-%')},
	    ":pos" => $pos, ":letter" => $letter);

	do { local $| = 1; print "/"; };
	do { local $| = 1; print "P"; };
        &dbexec ($cat, qq{
	    insert into t_pfn (guid, pfname, filetype)
	    (select substring(guid,1,$pos) || '$letter' || substring(guid,$pos+2),
	     pfname, filetype from t_pfn where guid like '%-%-%-%-%' and filetype = 'EVDZip')});

	do { local $| = 1; print "L"; };
        &dbexec ($cat, qq{
	    insert into t_lfn (guid, lfname)
	    (select substring(guid,1,$pos) || '$letter' || substring(guid,$pos+2),
	     lfname from t_lfn where guid like '%-%-%-%-%' and lfname like 'ZippedEVD%')});

	do { local $| = 1; print "M"; };
        &dbexec ($cat, qq{
	    insert into t_meta (guid, Content, DBoid, DataType, FileCateogry, Flags, dataset, jobid, owner, runid)
	    (select substring(guid,1,$pos) || '$letter' || substring(guid,$pos+2),
	     Content, DBoid, DataType, FileCateogry, Flags, dataset, jobid, owner, runid
	     from t_meta where guid like '%-%-%-%-%' and Content = 'ZippedEVD')});

        print "\n";
    }
}

# $tmdb->commit();
# $cat->commit();
$tmdb->rollback();
$cat->rollback();
exit 0;
