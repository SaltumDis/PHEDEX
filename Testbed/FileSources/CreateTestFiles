#!/usr/bin/perl

# This tool functions as a fake data source. cd to your fake SE
# directory then run 
#
# CreateTestFiles <number of files> <source node name> <db> <user> <password>
#
# It will create N files in the pwd. First each file is registered
# in the catalogue specified in $POOL_CATALOG. Each file will
# contain its own guid. The files will also be registered in the
# TMDB.

$count = $ARGV[0];
$node = $ARGV[1];
$db=$ARGV[2];
$user=$ARGV[3];
$pass=$ARGV[4];
$pwd = $ENV{PWD};
@sql = ();

print "$count files, in $pwd, registered at node $node\n";

while ($count > 0) {
    
    $guid = '';
    $file = "TestbedFile".$count;
    $full_path = $pwd."/".$file;
    

    ($exit_value, @output) = run_command( "FCregisterPFN -p $full_path" );
    if ($exit_value == 1) {
        print "Problem registering pfn\n@output\n";
        exit(1);
    } else {
        chop($guid = $output[$#output]);
    }
    
    
    ($exit_value, @output) = run_command( "echo $guid > $file" );
    if ($exit_value == 1) {
        print "Problem creating file $file\n@output\nNot rolling back catalogue registration for $guid\n";
        exit(1);
    }
    
    
    push( @sql, "insert into t_files_for_transfer values ('$guid','$node',1)" );
    push( @sql, "insert into t_replica_metadata values ('$guid','POOL_dataset','NodeTestbedSet')" );
    push( @sql, "insert into t_replica_metadata values ('$guid','POOL_owner','NodeTestbed')" );
    
    $count--;
}

do_sql( \@sql );

# =========================================================
# Subroutines
# =========================================================

sub do_sql {
    my $sql = shift;
    
    eval {
        my $dbh;
        eval "use DBI"; $dbh = DBI->connect ("DBI:$db",
    					     "$user",
    					     "$pass",
    					     { RaiseError => 1, AutoCommit => 1 });              

        foreach my $cmd (@$sql) {
            print "$cmd\n";
            $dbh->do ($cmd);
        }

    	$dbh->disconnect;
    };

    if ($@) {
    	print "database operation failed: $@";
        if ($dbh) {
            $dbh->rollback;
            $dbh->disconnect;
	   }
	   exit(1);
    }
    
    return 0;    
}

sub run_command {
    my $cmd = shift;
    
    my @output = `$cmd 2>&1`;
    my $exit_value = $? >> 8;
    
    return ($exit_value,@output);
}
