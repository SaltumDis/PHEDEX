#!/usr/bin/env perl

##H Seed test database (set up with separate SQL) with a number of
##H files.
##H
##H Use: $0 -db <DBCONFIG> -count N_FILES -blocks N_BLOCKS
##H         -nodes <amount and type of nodes>
##H
##H Parameters:
##H
##H      db:     path to DB Config file
##H      count:  amount of files you wish to make known to the DB
##H      blocks: amount of blocks you wish to make known to the DB
##H      nodes:  pairs of amount and kind of nodes separated by commas
##H              Example: 4:Buffer,2:MSS,10:Disk
##H              Buffer nodes must be grater or equal to MSS nodes !!
##H

BEGIN { use strict; use warnings; $^W=1;
	my $me = $0; $me =~ s|.*/||;
	our $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";
	unshift(@INC, "$home/../../Toolkit/Common"); }

my %args;
use Getopt::Long;
use UtilsHelp;
use UtilsDB;
use UtilsTiming;
&GetOptions ("db=s"        => \$args{DBCONFIG},
	     "blocks=i"    => \$args{BLOCKS},
	     "count=i"     => \$args{COUNT},
	     "nodes=s"     => sub { push @{$args{NODES}},
				    split m|,|, $_[1] },
    	     "help|h"      => sub { &usage() });

my %nodes = ();
foreach ( @{$args{NODES}} )
{
    my ($amount, $kind) = split m|:|, $_;
    $nodes{$kind} = $amount;
}

my $checksum = 1;
my $size = 1000000000;

if (! $args{DBCONFIG} || ! $args{COUNT} || ! $args{BLOCKS} || ! $args{NODES})
{
    die "Insufficient parameters, use -h for help.\n";
}

my $count = $args{COUNT};
my $blocks = $args{BLOCKS};
my $now = &mytimeofday();

my $dbh = &connectToDatabase (\%args, 0);

eval
{
    # Create nodes and links
    my %nodenames = ();

    foreach my $kind (keys %nodes)
    {
	my $index = 1;
	while ( $index <= $nodes{$kind} )
	{
	    push @{$nodenames{$kind}}, "TX_TEST_${index}_${kind}";
	    $index++;
	}
    }
    
    my $index = 1;
    foreach my $kind ( keys %nodenames )
    {
	foreach my $node ( @{$nodenames{$kind}} )
	{
	    my $cmd = "$home/../../Utilities/NodeNew ".
		"-db $args{DBCONFIG}:$args{DBSECTION} ".
		"-name $node ".
		"-kind $kind ".
		"-technology Other ".
		"-se-name se.testuniverse.$index";
	    my $msg = `$cmd`;
	    $index++;
	    die "Creation of nodes failed:\n$msg" if $?;
	}
    }

    # Create a list of non-MSS nodes to link to.
    my %connections;
    my @nodelist = (map @{$_}, (values %nodenames));
    map {$connections{$_} = $_ if $_ !~ m|MSS|} (map @{$_}, (values %nodenames));
    
    foreach $kind (keys %nodenames)
    {
	foreach my $node ( @{$nodenames{$kind}} )
	{
	    if ($kind =~ m|MSS|)
	    {
		my $buffer = $node;
		$buffer =~ s|MSS|Buffer|;
		$cmd = "$home/../../Utilities/LinkNew ".
		    "-db $args{DBCONFIG}:$args{DBSECTION} ".
		    "$node ".
		    "${buffer}:L";
	    }
	    else
	    {
		delete $connections{$node};
		next if !keys %connections;
		my $connectionsstring = join " ", (values %connections);
		$cmd = "$home/../../Utilities/LinkNew ".
		    "-db $args{DBCONFIG}:$args{DBSECTION} ".
		    "$node ".
		    "$connectionsstring";
	    }
	    $msg = `$cmd`;
	    die "Creation of links failed:\n$msg" if $?;
	}
    }
    
    # Prepare file and block injections into TMDB
    my $ifile = &dbprep($dbh, qq{
	insert into t_dps_file
	(id,node,inblock,logical_name,checksum,filesize,time_create)
	select seq_dps_file.nextval, n.id, ?, ?, ?, ?, ?
	from t_adm_node n where n.name = ?});

    for( my $block=1; $block<=$blocks; $block++)
    {
	print "Creating block $block";
	my $bid = undef;
        my %params;
	# We populate the t_dps_block, but don't update the number of files and total size,
	# since Oracle triggers will take care about that.
	&dbexec($dbh, qq{
	    insert into t_dps_block 
	    (id,dataset,name,files,bytes,is_open,time_create,time_update)
	    values (seq_dps_block.nextval,1,:name,:nfiles,:nbytes,'y',:now, null)
	    returning id into :id},
	    ":id" => \$bid, ":now" => $now, ":name" => "block$block",
	    ":nfiles" => 0, ":nbytes" => 0);
	print ", id=$bid\n";
	
	for( my $f = 0; $f<$count; $f++)
	{
	    my $node = $nodelist[$f % scalar @nodelist];
	    my $fid = $f + $block * $count;
	    my $n = 1;
	    push(@{$params{$n++}}, $bid);
	    push(@{$params{$n++}}, "/my/test/file$fid");
	    push(@{$params{$n++}}, "1");
	    push(@{$params{$n++}}, $size);
	    push(@{$params{$n++}}, $now);
	    push(@{$params{$n++}}, $node);
	}

        print "Executing SQL inserts\n";
        &dbbindexec($ifile, %params);
        &dbexec($dbh, qq{
	    insert into t_xfer_file (id, inblock, logical_name, checksum, filesize)
	    (select id, inblock, logical_name, checksum, filesize from t_dps_file
	     where inblock = :block)}, ":block" => $bid);
        &dbexec($dbh, qq{
	    insert into t_xfer_replica
	    (id, node, fileid, state, time_create, time_state)
	    select seq_xfer_replica.nextval, node, id, 0, time_create, time_create
	    from t_dps_file where inblock = :block}, ":block" => $bid);
        $dbh->commit();
    }

    print "Doing subscriptions\n";
    &dbexec($dbh, qq{
	insert into t_dps_subscription
	(dataset, destination, priority, is_move, is_transient, time_create)
	select ds.id, n.id, 1, 'n', 'n', 0 from t_dps_dataset ds, t_adm_node n});
    $dbh->commit();
    print "Done\n";
};
if ( $@ )
{
    chomp ($@);
    print "$@\n";
    print "Rolling back\n";
    $dbh->rollback();
}
$dbh->disconnect();
