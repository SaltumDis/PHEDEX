#!/usr/bin/env perl

##H Fill the DBS database from RefDB.
##H
##H Usage:
##H   DSBFill -db FILE[:SECTION] [PATTERN...]
##H
##H -db           database connection configuration parameter file
##H PATTERN       block match constraint (owner/dataset), such as "*/bt03_*"

BEGIN { use strict; use warnings;
  my $me = $0; $me =~ s|.*/||;
  my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";
  unshift(@INC, "$home/../Toolkit/Common"); }
use UtilsHelp;
use UtilsDBS;
use UtilsReaders;
use TextGlob 'glob_to_regex';

my %args = (ONLY_NEW => 1);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h') {
	&usage();
    } elsif ($ARGV[0] eq '-from' && scalar @ARGV > 1) {
	shift (@ARGV); $args{FROM} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1) {
        shift (@ARGV); $args{DBCONFIG} = shift(@ARGV);
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

$TextGlob::strict_wildcard_slash = 0;
$args{PATS} = [ map { &glob_to_regex($_) } @ARGV ];
if (!$args{FROM}
    || !($args{FROM} eq 'RefDB' || $args{FROM} eq 'PhEDEx')
    || !($args{FROM} ne 'PhEDEx' || $args{DBCONFIG}))
{
    die "Insufficient parameters, use -h for help.\n";
}

# Create appropriate dataset bookkeeping proxy
my $refdb       = new UtilsDBS::RefDB (%args);
my $phedex      = new UtilsDBS::PhEDEx (%args);

# Get all existing datasets
my $datasets    = $phedex->fetchPublishedData();
my $files       = &phedex->fetchKnownFiles();
my %dso2dataset = map { join("/", $_->{OWNER}, $_->{DATASET}) => $_ } @$datasets;
my %guid2file   = map { $_->{GUID} => $_ } @$files;

# Get all current datasets
my $current     = $refdb->fetchPublishedData();

foreach my $item (@$current)
{
    my $token = "$item->{OWNER}/$item->{DATASET}";
    next if (@ARGV && !grep($token =~ $_, @{$args{PATS}}));
    print "processing $token\n";

    # Match this against known datasets
    if (my $old = $dso2dataset{"$item->{OWNER}/$item->{DATASET}"})
    {
	$item->{ID} = $old->{ID};
	$old->{KNOWN} = 1;
	next if $args{ONLY_NEW};
    }

    # Get the full data
    eval { $refdb->fillDatasetInfo ($item); };
    do { &warn ($@); next; } if $@;
    my $runs = $item->{RUNS};
    my @dsfiles = map { @{$_->{FILES}} } @$runs;

    # Match files against known files
    foreach my $file (@dsfiles)
    {
	if (my $oldfile = $guid2file{$file->{GUID}})
	{
	    $file->{ID} = $oldfile->{ID};
	    $oldfile->{KNOWN} = 1;
	}
    }

    # Evaluate dataset information
    my $events = 0; map { $events += $_->{EVTS} } @$runs;
    print " Id         = @{[$item->{ID} || '(new)']}\n";
    print " Owner      = $item->{OWNER}\n";
    print " Dataset    = $item->{DATASET}\n";
    print " Datatype   = $item->{DSINFO}{InputProdStepType}\n";
    print " InputOwner = $item->{DSINFO}{InputOwnerName}\n";
    print " PUDataset  = $item->{DSINFO}{PUDatasetName}\n";
    print " PUOwner    = $item->{DSINFO}{PUOwnerName}\n";
    print " Runs       = @{[scalar @$runs]}\n";
    print " Files      = @{[scalar @dsfiles]}\n";
    print " Events     = $events\n";
    print " Filling database...\n";

    # Update the database
    $phedex->updateDataset ($item);
}

# Delete unknown datasets
foreach my $item (@$datasets)
{
    last;

    # Skip if this is still known
    next if $item->{KNOWN};
    $phedex->clearDatasetFromDB ($item);
    # FIXME: Delete transfer requests?
}

# Delete unknown files
foreach my $item (@$files)
{
    last;

    # Skip if this is still known
    next if $item->{KNOWN};
    $phedex->clearFileFromDB ($item);
}

exit 0;
