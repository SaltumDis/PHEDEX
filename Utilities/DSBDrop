#!/usr/bin/env perl

##H Generate drops from dataset bookkeeing system.
##H
##H Usage:
##H   DBSDrop -dbconfig FILE DIRECTORY [PATTERN...]
##H
##H -dbconfig  database connection configuration parameter file
##H DIRECTORY  create drops as subdirectories here, typically some inbox
##H PATTERN    block match constraint (owner/dataset), such as "*/bt03_*"

BEGIN { use strict; use warnings;
  my $me = $0; $me =~ s|.*/||;
  my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";
  unshift(@INC, "$home/../Toolkit/Common"); }
use UtilsHelp;
use UtilsDB;
use UtilsTR;
use UtilsWriters;
use UtilsCommand;
use UtilsLogging;
use TextGlob 'glob_to_regex';
use File::Path;

my %args;
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h') {
	&usage();
    } elsif ($ARGV[0] eq '-dbconfig' && scalar @ARGV > 1) {
        shift (@ARGV); $args{DBCONFIG} = shift(@ARGV);
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

$args{TODIR} = shift (@ARGV);
$TextGlob::strict_wildcard_slash = 0;
$args{PATS} = [ map { &glob_to_regex($_) } @ARGV ];
if (!$args{TODIR} || !$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

# Connect to database
my $dbh = &connectToDatabase (\%args, 0);
$dbh->{FetchHashKeyName} = "NAME_uc";
$dbh->{LongReadLen} = 4096;

# Get all existing datasets and files
my $datasets = &dbexec($dbh, qq{select id, dataset, owner from t_dsb_dataset})
	       ->fetchall_arrayref ({});

# Get all current datasets
my $stmtcache = {};
foreach my $item (@$datasets)
{
    my $token = "$item->{OWNER}/$item->{DATASET}";
    next if (@ARGV && !grep($token =~ $_, @{$args{PATS}}));
    local $| = 1;

    print "processing $token ";

    # Generate drops
    &fetchDatasetInfo ($dbh, $item, $stmtcache);
    my $runs = $item->{RUNS};
    my @dsfiles = map { @{$_->{FILES}} } @$runs;
    foreach my $run (@{$item->{RUNS}})
    {
	print ".";
	my $label = "$item->{DATASET}.$item->{OWNER}.$run->{ID}";
	my $path = "$args{TODIR}/$label";
	-d $path && &rmtree ($path);
	&mkpath ($path);

	my $frag = join("", map { $_->{XML} } @{$run->{FILES}}) . "\n";
	$frag =~ s/>(.)/>\n$1/g;
	&outputCatalog ("$path/XMLCatFragment.$label.txt", $frag);

	my $cksums = join("", map { "$_->{CHECKSUM} $_->{SIZE} $_->{LFN}\n" } @{$run->{FILES}});
	&output ("$path/Checksum.$label.txt", $cksums);

	my $locs = join(" ", map { $_ . "_MSS" } @{$item->{SITES}});
	&output ("$path/PhEDEx-Nodes.txt", "$locs\n");

	&output ("$path/go", "");
    }

    print "\n";
}

$dbh->disconnect ();
exit 0;

# Get dataset information
sub fetchDatasetInfo
{
    my ($dbh, $object, $stmtcache) = @_;

    # Prepare statements
    $stmtcache->{IGUID} ||= &dbprep ($dbh, qq{
	select guid from t_dsb_fileid where id = :fileid});
    $stmtcache->{IFILE} ||= &dbprep ($dbh, qq{
	select filesize, checksum, filename, catfragment from t_dsb_file where fileid = :fileid});
    $stmtcache->{IDR} ||= &dbprep ($dbh, qq{
	select runid from t_dsb_dataset_run where dataset = :dataset});
    $stmtcache->{IDRF} ||= &dbprep ($dbh, qq{
	select fileid from t_dsb_dataset_run_file where dataset = :dataset and runid = :runid});
    $stmtcache->{IDL} ||= &dbprep ($dbh, qq{
	select location from t_dsb_dataset_availability where dataset = :dataset});

    # Get dataset locations
    &dbbindexec ($stmtcache->{IDL}, ":dataset" => $object->{ID});
    while (my ($loc) = $stmtcache->{IDL}->fetchrow()) {
	push (@{$object->{SITES}}, $loc);
    }

    # Get runs and files
    &dbbindexec ($stmtcache->{IDR}, ":dataset" => $object->{ID});
    while (my ($runid) = $stmtcache->{IDR}->fetchrow ())
    {
	my $run = { ID => $runid, FILES => [] };
	push (@{$object->{RUNS}}, $run);
	&dbbindexec ($stmtcache->{IDRF}, ":dataset" => $object->{ID}, ":runid" => $runid);
	while (my ($fileid) = $stmtcache->{IDRF}->fetchrow ())
	{
	    &dbbindexec ($stmtcache->{IGUID}, ":fileid" => $fileid);
	    my ($guid) = $stmtcache->{IGUID}->fetchrow();

	    &dbbindexec ($stmtcache->{IFILE}, ":fileid" => $fileid);
	    my ($size, $cksum, $filename, $frag) = $stmtcache->{IFILE}->fetchrow();
	    push (@{$run->{FILES}}, { ID => $fileid,
				      GUID => $guid,
				      SIZE => $size,
				      CHECKSUM => $cksum,
				      LFN => $filename,
				      XML => $frag });
	}
    }

    $stmtcache->{IGUID}->finish ();
    $stmtcache->{IFILE}->finish ();
    $stmtcache->{IDRF}->finish ();
    $stmtcache->{IDR}->finish ();
    $stmtcache->{IDL}->finish ();
}
