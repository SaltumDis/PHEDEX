#!/usr/bin/env perl

##H Copy file catalogues the rudimentary way
##H
##H Usage: FCcopy -u SRC-CATALOGUE -d DEST-CATALOGUE
##H               [-m PFN-MATCH-RX] [-r PFN-REWRITE-SCRIPT[,ARG...]]
##H               [-n NJOBS] [-b BATCH-SIZE] [-v]
##H
##H -u SRC-CATALOGUE   The source catalogue
##H -d DEST-CATALOGUE  The destination catalogue
##H   Both of these must be of the format "proto:contact"; possible
##H   protocols are "RLSOracle", "Oracle", "mysql" and "XML", both
##H   for source and destination.  The rest of the contact is:
##H      RLSOracle:Database:User:Password
##H      Oracle:Database:User:Password
##H      mysql:Database:User:Password
##H      XML:filename
##H
##H -m PFN-MATCH-RX    SQL pattern to match PFNs to.  Only matching PFNs
##H                    will be copied to the destination catalogue.
##H                    Files with no matching PFNs are skipped.
##H -r REWRITE-SCRIPT  If defined, invoked for every PFN to rewrite the
##H                    PFN for destination catalogue.  The script is
##H                    passed the PFN on command line and must print
##H                    the new PFN to standard output.
##H -n NJOBS           Run NJOBS of PFN-REWRITE-SCRIPT concurrently.
##H -b BATCH-SIZE      Print verbosity dots when BATCH-SIZE files copied.
##H -v                 Be verbose.

BEGIN {
  use strict; use warnings; $^W=1;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments
use UtilsHelp;
my %args = (NJOBS => 50, BATCH => 1000);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-u' && scalar @ARGV > 1)
    { shift (@ARGV); $args{SRC_CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-d' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DEST_CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-r' && scalar @ARGV > 1)
    { shift (@ARGV); $args{REWRITE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-m' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MATCH} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-j' && scalar @ARGV > 1)
    { shift (@ARGV); $args{NJOBS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-b' && scalar @ARGV > 1)
    { shift (@ARGV); $args{BATCH} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-v')
    { shift (@ARGV); $args{VERBOSE} = 1; }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

if (@ARGV || !$args{SRC_CATALOGUE} || !$args{DEST_CATALOGUE})
{
    die "Insufficient parameters, use -h for help.\n";
}

my ($src, $dest, $files) = (undef, undef, {});

if ($args{SRC_CATALOGUE} =~ /^RLSOracle:/) { $src = new RLSRead; }
elsif ($args{SRC_CATALOGUE} =~ /^Oracle:/) { $src = new OracleRead; }
elsif ($args{SRC_CATALOGUE} =~ /^mysql:/) { $src = new MySQLRead; }
elsif ($args{SRC_CATALOGUE} =~ /^XML/) { $src = new XMLRead; }
else { die "Unrecognised input catalogue $args{SRC_CATALOGUE}\n"; }

if ($args{DEST_CATALOGUE} =~ /^RLSOracle:/) { $dest = new RLSWrite; }
elsif ($args{DEST_CATALOGUE} =~ /^Oracle:/) { $dest = new OracleWrite; }
elsif ($args{DEST_CATALOGUE} =~ /^mysql:/) { $dest = new MySQLWrite; }
elsif ($args{DEST_CATALOGUE} =~ /^XML:/) { $dest = new XMLWrite; }
else { die "Unrecognised output catalogue $args{DEST_CATALOGUE}\n"; }

my $ntotal = 0;
$src->init ($args{SRC_CATALOGUE}, $args{MATCH});
$dest->init ($args{DEST_CATALOGUE});
$args{MATCH} =~ s/([^a-zA-Z0-9_%])/\\$1/g;
$args{MATCH} =~ s/_/./g;
$args{MATCH} =~ s/%/.*/g;
$args{MATCH} = "^$args{MATCH}\$";
while (1)
{
    # Fetch the next lot of files
    my @files = ();
    while (my $file = $src->read())
    {
	if ($args{MATCH})
	{
	    $file->{PFN} = [ grep($_->{PFN} =~ /$args{MATCH}/o, @{$file->{PFN}}) ];
	    do { local $| = 1; print "_" if $args{VERBOSE}; next } if ! @{$file->{PFN}};
	}
	push (@files, $file);
	last if scalar @files >= $args{BATCH};
    }

    # Maintain counts
    my $nfiles = scalar @files;
    $ntotal += $nfiles;

    # Remap PFNs if requested
    &remapPFNs (\@files, %args) if $args{REWRITE};

    # Write out
    while (my $file = shift (@files))
    {
	$dest->write ($file);
    }

    # Show progress
    do { local $| = 1; print "." if $args{VERBOSE}; };
    last if $nfiles < $args{BATCH};
}
$src->finish();
$dest->finish();

print "\n$ntotal files copied\n" if $args{VERBOSE};
exit 0;

# Pick result from remapping a PFN.
use UtilsCommand;
sub collectResult
{
    my ($file, $output, $job) = @_;
    my $pfn = &input ($output);
    chomp($pfn);
    unlink $output;

    die "Remapping $job->{PFN} failed\n" if $job->{STATUS} || ! $pfn;
    $file->{PFN}[0]{PFN} = $pfn;
}

# Map GUIDs to PFNs using catalogue, running a number of queries
# in parallel.  Adds "PFN" entry to each file in $files.
sub remapPFNs
{
    my ($files, %args) = @_;
    use POSIX;
    use UtilsJobManager;

    # Create jobs to resolve guids to pfns
    my $mgr = new UtilsJobManager (NJOBS => $args{NJOBS});
    my @cmd = split(/,/, $args{REWRITE});
    foreach my $file (@$files)
    {
	my $output = qx(mktemp /tmp/tmp.XXXXXXX); chomp ($output);
	$mgr->addJob (sub { &collectResult($file, $output, @_) },
	    {}, "sh", "-c", "@cmd $file->{PFN}[0]{PFN} > $output");
    	$mgr->pumpJobs ();
    }

    # Now wait all results are collected
    while (@{$mgr->{JOBS}})
    {
	$mgr->pumpJobs();
	select (undef, undef, undef, .1);
    }
}

######################################################################
package RLSRead; use strict; use warnings; use base 'Exporter';
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact, $match) = @_;
    die "expecting RLSOracle:Database:User:Pass as contact, got $contact"
        if $contact !~ /^RLSOracle:([^:]+):([^:]+):([^:]+)$/;
    my $args = { DBITYPE => "Oracle", DBNAME => $1, DBUSER => $2, DBPASS => $3 };
    my $dbh = $self->{DBH} = &connectToDatabase ($args, 0) or die "failed to connect to $contact";
    my $more = !$match ? ""
        : qq{join lcg2_cms_lrc.pfn on pfn_gid = guid_id
	     where pfn_pfn like '$match'
	     group by guid_id, guid_guid};
    $self->{GQUERY} = &dbexec($dbh, qq{
	select guid_id, guid_guid from lcg2_cms_lrc.guid
	$more});
    $self->{PQUERY} = &dbprep($dbh, qq{
	select pfn."ATTR_pool_filetype", pfn_pfn
	from lcg2_cms_lrc.pfn
	where pfn_gid = :guid});
    $self->{LQUERY} = &dbprep($dbh, qq{
	select alias_alias
	from lcg2_cms_rmc.alias, lcg2_cms_rmc.guid
	where guid_guid = :guid and alias_gid = guid_id});
    $self->{MQUERY} = &dbprep($dbh, qq{
	select guid."ATTR_pool_Content",
	       guid."ATTR_pool_DBoid",
	       guid."ATTR_pool_DataType",
	       guid."ATTR_pool_FileCategory",
	       guid."ATTR_pool_Flags",
	       guid."ATTR_pool_dataset",
	       guid."ATTR_pool_jobid",
	       guid."ATTR_pool_owner",
	       guid."ATTR_pool_runid"
	from lcg2_cms_rmc.guid
	where guid_guid = :guid});
}

sub read
{
    my ($self) = @_;
    my ($id, $guid) = $self->{GQUERY}->fetchrow();
    return undef if ! defined $id;

    my $file = { GUID => $guid, PFN => [], LFN => [], META => {} };
    &dbbindexec ($self->{PQUERY}, ":guid" => $id);
    while (my ($type, $pfn) = $self->{PQUERY}->fetchrow()) {
	push(@{$file->{PFN}}, { PFN => $pfn, TYPE => $type });
    }

    &dbbindexec ($self->{LQUERY}, ":guid" => $guid);
    while (my ($lfn) = $self->{LQUERY}->fetchrow()) {
	push(@{$file->{LFN}}, $lfn);
    }

    &dbbindexec ($self->{MQUERY}, ":guid" => $guid);
    while (my $attrs = $self->{MQUERY}->fetchrow_hashref()) {
	foreach my $key (keys %$attrs) {
	    my $newkey = $key; $newkey =~ s/^ATTR_pool_//;
	    $file->{META}{$newkey} = $attrs->{$key};
	}
    }

    return $file;
}

sub finish
{
    my ($self) = @_;
    undef $self->{GQUERY};
    undef $self->{PQUERY};
    undef $self->{LQUERY};
    undef $self->{MQUERY};
    $self->{DBH}->disconnect();
    undef $self->{DBH};
}

######################################################################
package MySQLRead; use strict; use warnings; use base 'Exporter';
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    die "expecting mysql:Database:User:Pass as contact, got $contact"
        if $contact !~ /^mysql:([^:]+):([^:]+):([^:]+)$/;
    my $dbh = $self->{DBH} = DBI->connect ("DBI:mysql:$1", $2, $3, { RaiseError => 1, AutoCommit => 0 })
	or die "failed to connect to $contact";
    $self->{LQUERY} = &dbexec($dbh, qq{select guid, lfname from t_lfn});
    $self->{PQUERY} = &dbprep($dbh, qq{
	select filetype, pfname
	from t_pfn where guid = ?});
    $self->{MQUERY} = &dbprep($dbh, qq{
	select Content, DBoid, DataType, FileCategory, Flags,
	       dataset, jobid, owner, runid
	from t_meta where guid = ?});
}

sub read
{
    my ($self) = @_;
    my ($guid, $lfn) = $self->{LQUERY}->fetchrow();
    return undef if ! defined $guid;

    my $file = { GUID => $guid, PFN => [], LFN => [ $lfn ], META => {} };
    &dbbindexec ($self->{PQUERY}, 1 => $guid);
    while (my ($type, $pfn) = $self->{PQUERY}->fetchrow()) {
	push(@{$file->{PFN}}, { PFN => $pfn, TYPE => $type });
    }

    &dbbindexec ($self->{MQUERY}, 1 => $guid);
    my $meta = $self->{MQUERY}->fetchrow_hashref();
    $file->{META} = $meta if $meta;

    return $file;
}

sub finish
{
    my ($self) = @_;
    undef $self->{LQUERY};
    undef $self->{PQUERY};
    undef $self->{MQUERY};
    $self->{DBH}->disconnect();
    undef $self->{DBH};
}

######################################################################
package MySQLWrite; use strict; use warnings; use base 'Exporter';
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    die "expecting mysql:Database:User:Pass as contact, got $contact"
        if $contact !~ /^mysql:([^:]+):([^:]+):([^:]+)$/;
    my $dbh = $self->{DBH} = DBI->connect ("DBI:mysql:$1", $2, $3, { RaiseError => 1, AutoCommit => 0 })
	or die "failed to connect to $contact";
    $self->{LINS} = &dbprep($dbh, qq{insert into t_lfn (guid, lfname) values (?, ?)});
    $self->{PINS} = &dbprep($dbh, qq{insert into t_pfn (guid, filetype, pfname) values (?, ?, ?)});
    $self->{MINS} = &dbprep($dbh, qq{
	insert into t_meta (guid, Content, DBoid, DataType, FileCategory,
	       Flags, dataset, jobid, owner, runid)
	   values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)});
}

sub finish
{
    my ($self) = @_;
    undef $self->{LINS};
    undef $self->{PINS};
    undef $self->{MINS};
    $self->{DBH}->disconnect();
    undef $self->{DBH};
}

sub write
{
    my ($self, $file) = @_;

    foreach my $pfn (@{$file->{PFN}})
    {
        &dbbindexec ($self->{PINS},
		     1 => $file->{GUID},
		     2 => $pfn->{TYPE},
		     3 => $pfn->{PFN});
    }

    foreach my $lfn (@{$file->{LFN}})
    {
        &dbbindexec ($self->{LINS}, 1 => $file->{GUID}, 2 => $lfn);
    }

    my $meta = $file->{META};
    my %keys = ("Content" => 2, "DBoid" => 3, "DataType" => 4,
	        "FileCategory" => 5, "Flags" => 6, "dataset" => 7,
		"jobid" => 8, "owner" => 9, "runid" => 10);
    &dbbindexec ($self->{MINS}, 1 => $file->{GUID},
	         map { $keys{$_} => $meta->{$_} } keys %$meta);

    $self->{DBH}->commit();
}

######################################################################
package XMLRead; use strict; use warnings; use base 'Exporter';
use UtilsReaders;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    my ($file) = ($contact =~ m|^XML:(.*)|);
    die "expecting XML:File as contact, got $contact" if ! $file;
    $self->{NEXT} = 0;
    $self->{CATALOGUE} = eval { &readXMLCatalogue ($file) };
    if ($@ && $@ =~ /no guid mappings/) {
	$self->{CATALOGUE} = [];
    } elsif ($@) {
	die $@;
    }
}

sub read
{
    my ($self) = @_;
    return undef if $self->{NEXT} >= scalar @{$self->{CATALOGUE}};
    return $self->{CATALOGUE}[$self->{NEXT}++];
}

sub finish
{
    my ($self) = @_;
    delete $self->{CATALOGUE};
    delete $self->{NEXT};
}

######################################################################
package XMLWrite; use strict; use warnings; use base 'Exporter';

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    die "expecting XML:File as contact, got $contact"
        if $contact !~ /^XML:([^:]+)$/;
    $self->{FILE} = $1;
    open (XMLOUT, "> $self->{FILE}") or die "$self->{FILE}: cannot open: $!\n";
    print XMLOUT <<EOF;
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE POOLFILECATALOG SYSTEM "InMemory"><POOLFILECATALOG>
  <META name="Content" type="string"/>
  <META name="DBoid" type="string"/>
  <META name="DataType" type="string"/>
  <META name="FileCategory" type="string"/>
  <META name="Flags" type="string"/>
  <META name="dataset" type="string"/>
  <META name="jobid" type="string"/>
  <META name="owner" type="string"/>
  <META name="runid" type="string"/>
EOF
}

sub finish
{
    my ($self) = @_;
    print XMLOUT "\n</POOLFILECATALOG>\n";
    close (XMLOUT) or die "$self->{FILE}: cannot write: $!\n";
}

sub write
{
    my ($self, $file) = @_;

    print XMLOUT "  <File ID='$file->{GUID}'>\n";
    print XMLOUT "    <physical>\n";
    foreach my $pfn (@{$file->{PFN}}) {
	print XMLOUT "      <pfn filetype='@{[$pfn->{TYPE} || '']}' name='$pfn->{PFN}'/>\n";
    }
    print XMLOUT "    </physical>\n";

    print XMLOUT "    <logical>\n";
    foreach my $lfn (@{$file->{LFN}}) {
        print XMLOUT "      <lfn name='$lfn'/>\n";
    }
    print XMLOUT "    </logical>\n";

    my $meta = $file->{META};
    foreach my $m (sort keys %$meta) {
	print XMLOUT "    <metadata att_name='$m' att_value='@{[$meta->{$m} || '']}'/>\n";
    }
    print XMLOUT "  </File>\n";
}
