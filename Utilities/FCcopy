#!/usr/bin/env perl

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments
my %args = (NJOBS => 10);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-u' && scalar @ARGV > 1)
    { shift (@ARGV); $args{SRC_CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-d' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DEST_CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-r' && scalar @ARGV > 1)
    { shift (@ARGV); $args{REWRITE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-m' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MATCH} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-j' && scalar @ARGV > 1)
    { shift (@ARGV); $args{NJOBS} = shift(@ARGV); }
    else
    { last; }
}

if (@ARGV || !$args{SRC_CATALOGUE} || !$args{DEST_CATALOGUE})
{
    print STDERR "usage: $me -u SRC-CATALOGUE -d DEST-CATALOGUE\n",
    		 "  [-m PFN-MATCH-RX] [-r PFN-REWRITE-SCRIPT] [-n N-JOBS]\n";
    exit (1);
}

my ($src, $dest, $files) = (undef, undef, {});

if ($args{SRC_CATALOGUE} =~ /^RLSOracle:/) { $src = new RLSRead; }
elsif ($args{SRC_CATALOGUE} =~ /^Oracle:/) { $src = new OracleRead; }
elsif ($args{SRC_CATALOGUE} =~ /^mysql:/) { $src = new MySQLRead; }
else { die "Unrecognised input catalogue $args{SRC_CATALOGUE}\n"; }

if ($args{DEST_CATALOGUE} =~ /^RLSOracle:/) { $dest = new RLSWrite; }
elsif ($args{DEST_CATALOGUE} =~ /^Oracle:/) { $dest = new OracleWrite; }
elsif ($args{DEST_CATALOGUE} =~ /^mysql:/) { $dest = new MySQLWrite; }
elsif ($args{DEST_CATALOGUE} =~ /^XML:/) { $dest = new XMLWrite; }
else { die "Unrecognised output catalogue $args{DEST_CATALOGUE}\n"; }

my $ntotal = 0;
$src->init ($args{SRC_CATALOGUE});
$dest->init ($args{DEST_CATALOGUE});
while (1)
{
    # Fetch the next lot of files
    my @files = ();
    while (my $file = $src->read())
    {
	if ($args{MATCH})
	{
	    $file->{PFNS} = [ grep($_->{PFN} =~ /$args{MATCH}/o, @{$file->{PFNS}}) ];
	    do { local $| = 1; print "_"; next } if ! @{$file->{PFNS}};
	}
	push (@files, $file);
	last if scalar @files >= 100;
    }

    # Maintain counts
    my $nfiles = scalar @files;
    $ntotal += $nfiles;

    # Remap PFNs if requested
    &remapPFNs (\@files, %args) if $args{REWRITE};

    # Write out
    while (my $file = shift (@files))
    {
	$dest->write ($file);
    }

    # Show progress
    do { local $| = 1; print "."; };
    last if $nfiles < 100;
}
$src->finish();
$dest->finish();

print "\n$ntotal files copied\n";
exit 0;

# Pick result from remapping a PFN.
use UtilsCommand;
sub collectResult
{
    my ($file, $output, $job) = @_;
    my $pfn = &input ($output);
    chomp($pfn);
    unlink $output;

    die "Remapping $job->{PFN} failed\n" if $job->{STATUS} || ! $pfn;
    $file->{PFNS}[0]{PFN} = $pfn;
}

# Map GUIDs to PFNs using catalogue, running a number of queries
# in parallel.  Adds "PFN" entry to each file in $files.
sub remapPFNs
{
    my ($files, %args) = @_;
    use POSIX;
    use UtilsJobManager;

    # Create jobs to resolve guids to pfns
    my $mgr = new UtilsJobManager (NJOBS => $args{NJOBS});
    my @cmd = split(/,/, $args{REWRITE});
    foreach my $file (@$files)
    {
	my $output = qx(mktemp /tmp/tmp.XXXXXXX); chomp ($output);
	$mgr->addJob (sub { &collectResult($file, $output, @_) },
	    {}, "sh", "-c", "@cmd $file->{PFNS}[0]{PFN} > $output");
    }

    # Now wait all results are collected
    while (@{$mgr->{JOBS}})
    {
	$mgr->pumpJobs();
	select (undef, undef, undef, .1);
    }
}

######################################################################
package RLSRead; use strict; use warnings; use base 'Exporter';
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    die "expecting RLSOracle:Database:User:Pass as contact, got $contact"
        if $contact !~ /^RLSOracle:([^:]+):([^:]+):([^:]+)$/;
    my $args = { DBITYPE => "Oracle", DBNAME => $1, DBUSER => $2, DBPASS => $3 };
    my $dbh = $self->{DBH} = &connectToDatabase ($args, 0) or die "failed to connect to $contact";
    $self->{GQUERY} = &dbexec($dbh, qq{select guid_id, guid_guid from lcg2_cms_lrc.guid});
    $self->{PQUERY} = &dbprep($dbh, qq{
	select pfn."ATTR_pool_filetype", pfn_pfn
	from lcg2_cms_lrc.pfn
	where pfn_gid = :guid});
    $self->{LQUERY} = &dbprep($dbh, qq{
	select alias_alias
	from lcg2_cms_rmc.alias
	where alias_gid = :guid});
    $self->{MQUERY} = &dbprep($dbh, qq{
	select guid."ATTR_pool_Content",
	       guid."ATTR_pool_DBoid",
	       guid."ATTR_pool_DataType",
	       guid."ATTR_pool_FileCategory",
	       guid."ATTR_pool_Flags",
	       guid."ATTR_pool_dataset",
	       guid."ATTR_pool_jobid",
	       guid."ATTR_pool_owner",
	       guid."ATTR_pool_runid"
	from lcg2_cms_rmc.guid
	where guid_guid = :guid});
}

sub read
{
    my ($self) = @_;
    my ($id, $guid) = $self->{GQUERY}->fetchrow();
    return undef if ! defined $id;

    my $file = { GUID => $guid, PFNS => [], LFNS => [], META => {} };
    &dbbindexec ($self->{PQUERY}, ":guid" => $id);
    while (my ($type, $pfn) = $self->{PQUERY}->fetchrow()) {
	push(@{$file->{PFNS}}, { PFN => $pfn, TYPE => $type });
    }

    &dbbindexec ($self->{LQUERY}, ":guid" => $id);
    while (my ($lfn) = $self->{LQUERY}->fetchrow()) {
	push(@{$file->{LFNS}}, $lfn);
    }

    &dbbindexec ($self->{MQUERY}, ":guid" => $guid);
    while (my $attrs = $self->{MQUERY}->fetchrow_hashref()) {
	foreach my $key (keys %$attrs) {
	    my $newkey = $key; $newkey =~ s/^ATTR_pool_//;
	    $file->{META}{$newkey} = $attrs->{$key};
	}
    }

    return $file;
}

sub finish
{
    my ($self) = @_;
    undef $self->{GQUERY};
    undef $self->{PQUERY};
    undef $self->{LQUERY};
    undef $self->{MQUERY};
    $self->{DBH}->disconnect();
    undef $self->{DBH};
}

######################################################################
package MySQLRead; use strict; use warnings; use base 'Exporter';
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    die "expecting mysql:Database:User:Pass as contact, got $contact"
        if $contact !~ /^mysql:([^:]+):([^:]+):([^:]+)$/;
    my $args = { DBITYPE => "mysql", DBNAME => $1, DBUSER => $2, DBPASS => $3 };
    my $dbh = $self->{DBH} = &connectToDatabase ($args, 0) or die "failed to connect to $contact";
    $self->{LQUERY} = &dbexec($dbh, qq{select guid, lfname from t_lfn});
    $self->{PQUERY} = &dbprep($dbh, qq{
	select filetype, pfname
	from t_pfn where guid = ?});
    $self->{MQUERY} = &dbprep($dbh, qq{
	select Content, DBoid, DataType, FileCategory, Flags,
	       dataset, jobid, owner, runid
	from t_meta where guid = ?});
}

sub read
{
    my ($self) = @_;
    my ($guid, $lfn) = $self->{LQUERY}->fetchrow();
    return undef if ! defined $guid;

    my $file = { GUID => $guid, PFNS => [], LFNS => [ $lfn ], META => {} };
    &dbbindexec ($self->{PQUERY}, 1 => $guid);
    while (my ($type, $pfn) = $self->{PQUERY}->fetchrow()) {
	push(@{$file->{PFNS}}, { PFN => $pfn, TYPE => $type });
    }

    &dbbindexec ($self->{MQUERY}, 1 => $guid);
    my $meta = $self->{MQUERY}->fetchrow_hashref();
    $file->{META} = $meta if $meta;

    return $file;
}

sub finish
{
    my ($self) = @_;
    undef $self->{LQUERY};
    undef $self->{PQUERY};
    undef $self->{MQUERY};
    $self->{DBH}->disconnect();
    undef $self->{DBH};
}

######################################################################
package MySQLWrite; use strict; use warnings; use base 'Exporter';
use UtilsDB;

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    die "expecting mysql:Database:User:Pass as contact, got $contact"
        if $contact !~ /^mysql:([^:]+):([^:]+):([^:]+)$/;
    my $args = { DBITYPE => "mysql", DBNAME => $1, DBUSER => $2, DBPASS => $3 };
    my $dbh = $self->{DBH} = &connectToDatabase ($args, 0) or die "failed to connect to $contact";
    $self->{LINS} = &dbprep($dbh, qq{insert into t_lfn (guid, lfname) values (?, ?)});
    $self->{PINS} = &dbprep($dbh, qq{insert into t_pfn (guid, filetype, pfname) values (?, ?, ?)});
    $self->{MINS} = &dbprep($dbh, qq{
	insert into t_meta (guid, Content, DBoid, DataType, FileCategory,
	       Flags, dataset, jobid, owner, runid)
	   values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)});
}

sub finish
{
    my ($self) = @_;
    undef $self->{LINS};
    undef $self->{PINS};
    undef $self->{MINS};
    $self->{DBH}->disconnect();
    undef $self->{DBH};
}

sub write
{
    my ($self, $file) = @_;

    foreach my $pfn (@{$file->{PFNS}})
    {
        &dbbindexec ($self->{PINS},
		     1 => $file->{GUID},
		     2 => $pfn->{TYPE},
		     3 => $pfn->{PFN});
    }

    foreach my $lfn (@{$file->{LFNS}})
    {
        &dbbindexec ($self->{LINS}, 1 => $file->{GUID}, 2 => $lfn);
    }

    my $meta = $file->{META};
    my %keys = ("Content" => 2, "DBoid" => 3, "DataType" => 4,
	        "FileCategory" => 5, "Flags" => 6, "dataset" => 7,
		"jobid" => 8, "owner" => 9, "runid" => 10);
    &dbbindexec ($self->{MINS}, 1 => $file->{GUID},
	         map { $keys{$_} => $meta->{$_} } keys %$meta);

    $self->{DBH}->commit();
}

######################################################################
package XMLWrite; use strict; use warnings; use base 'Exporter';

sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = {};
    bless $self, $class;
    return $self;
}

sub init
{
    my ($self, $contact) = @_;
    die "expecting XML:File as contact, got $contact"
        if $contact !~ /^XML:([^:]+)$/;
    $self->{FILE} = $1;
    open (XMLOUT, "> $self->{FILE}") or die "$self->{FILE}: cannot open: $!\n";
    print XMLOUT <<EOF;
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE POOLFILECATALOG SYSTEM "InMemory"><POOLFILECATALOG>
  <META name="Content" type="string"/>
  <META name="DBoid" type="string"/>
  <META name="DataType" type="string"/>
  <META name="FileCategory" type="string"/>
  <META name="Flags" type="string"/>
  <META name="dataset" type="string"/>
  <META name="jobid" type="string"/>
  <META name="owner" type="string"/>
  <META name="runid" type="string"/>
EOF
}

sub finish
{
    my ($self) = @_;
    print XMLOUT "\n</POOLFILECATALOG>\n";
    close (XMLOUT) or die "$self->{FILE}: cannot write: $!\n";
}

sub write
{
    my ($self, $file) = @_;

    print XMLOUT "  <File ID='$file->{GUID}'>\n";
    print XMLOUT "    <physical>\n";
    foreach my $pfn (@{$file->{PFNS}}) {
	print XMLOUT "      <pfn filetype='@{[$pfn->{TYPE} || '']}' name='$pfn->{PFN}'/>\n";
    }
    print XMLOUT "    </physical>\n";

    print XMLOUT "    <logical>\n";
    foreach my $lfn (@{$file->{LFNS}}) {
        print XMLOUT "      <lfn name='$lfn'/>\n";
    }
    print XMLOUT "    </logical>\n";

    my $meta = $file->{META};
    foreach my $m (sort keys %$meta) {
	print XMLOUT "    <metadata att_name='$m' att_value='@{[$meta->{$m} || '']}'/>\n";
    }
    print XMLOUT "  </File>\n";
}
