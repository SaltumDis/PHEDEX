#!/usr/bin/env perl

##H Master -config FILE[,FILE...] environ
##H Master -config FILE[,FILE...] start     [AGENT... | all]
##H Master -config FILE[,FILE...] stop      [AGENT... | all]
##H Master -config FILE[,FILE...] terminate [AGENT... | all]
##H Master -config FILE[,FILE...] show      [AGENT... | all]
##H
##H Manage an agent configuration.  If more than one configuration file
##H is given, the different sections of each file are merged and the
##H operations apply to resulting merged view.
##H
##H The configuration file can contain "ENVIRON" and "AGENT" sections.
##H The former specifies, in Bourne shell syntax, the code to execute
##H to set up environment necessary for the agents to run.  It may
##H also define variables that can be referred to in the agent section.
##H
##H The -config option specified one or more configuration files to
##H process, files separated by commas ",".  More than one -config
##H option can be provided; "-config A -config B" is equivalent to
##H "-config A,B".
##H
##H The "environ" command prints out the shell commands to set up the
##H environment.  This is useful for e.g.
##H    eval $(Master -config MyConfig environ)
##H
##H The "start" and "stop" commands start and stop, respectively, a
##H set of agents.  If no AGENT names are specified, the operation
##H will apply to default agents (i.e. all those agent definitions
##H which don't have DEFAULT=off attribute).  If "all" is specified,
##H all agents, including DEFAULT=off agents, will be affected.
##H Otherwise, a list of agent labels (LABEL=xyz) names is expected.
##H
##H The "show" command behaves like "start", but prints out the
##H shell commands the master would issue instead of executing them.
##H
##H The "terminate" forcefully terminates (kills) the specified agents.

# First we need to parse the command line arguments
BEGIN { use warnings; use strict; }

while (@ARGV)
{
    if ($ARGV[0] eq "-config" && scalar @ARGV > 1) 	
    { shift (@ARGV); push (@{$args{CONFIG}}, split(/,/, shift(@ARGV))); }
    elsif ($ARGV[0] eq "-h")
    { open (ME, "< $0")
      && print(STDERR map { s/^\#\#H ?//; $_ } grep (/^\#\#H/, <ME>))
      && close(ME);
      exit(1); }
    elsif ($ARGV[0] =~ /^-/) 
    { die "Unexpected option $ARGV[0], please use -h for help\n"; }
    else
    { last; }
}

my $mode = shift(@ARGV);
if (!$args{CONFIG} || !$mode)
{ 
    die "Insufficient parameters, please use -h for help\n";
}

# Then set variables at script scope...
my @configuration = ();
my $environ = '';
my %environs = ();
my @agents = ();

sub readConfig
{
    my ($file, $fhpattern) = @_;
    -f $file || die "$file: no such file\n";
    -r $file || die "$file: not readable\n";

    $fhpattern++; # Avoid stomping over recursed files
    open($fhpattern, "< $file") || die "$file: cannot read: $!\n";
    while (<$fhpattern>)
    {
	while (/^\#\#\#\s+([A-Z]+)(\s+(.*)|$)/)
	{
	    chomp; s/\s+$//;
	    # Here we process ENVIRON sections, defined as follows:
	    # ### ENVIRON [optional label]
	    if ($1 eq "ENVIRON")
	    {
		print STDERR "$file: $.: Unlabelled ENVIRONs are",
		    	     " deprecated, treating as 'common'\n"
		    if ! $3;

		my $label = $3 || "common";
		while (<$fhpattern>)
		{
		    last if /^###/; chomp; s/#.*//; s/^\s+//; s/\s+$//;
		    $environs{$label} .= "$_\n" if ($_ ne "");
		}
	    }

	    # Here we process AGENT sections, defined as follows:
	    # ### AGENT LABEL=<label> PROGRAM=<executable> [ENVIRON=<label>
	    elsif ($1 eq "AGENT")
	    {
		my $agent = { map { m|([^=]+)=(\S+)|g } split(/\s+/, $3) };
		push(@agents, $agent);
		while (<$fhpattern>)
		{
		    last if /^###/; chomp; s/#.*//; s/^\s+//; s/\s+$//;
		    $agent->{OPTS} .= " $_" if ($_ ne "");
		}
	    }

	    # Here we process IMPORT sections, defined as follows:
	    # ### IMPORT FILE
	    elsif ($1 eq "IMPORT")
	    {
		my $dirpart = $file;
		my $newfile = $3;
		$dirpart =~ s|/[^/]+$||;
		$dirpart = "." if $dirpart eq $file;
		&readConfig ("$dirpart/$newfile", $fhpattern);
	    }
	    else
	    {
		die "unrecognised section $1\n";
	    }
	}
    }
	       
    close ($fhpattern);

}
    
# Then we need to open up each of the config files
foreach my $file (@{$args{CONFIG}})
{
    &readConfig ($file, "fh00");
}

# And finally act on all this information
if (grep ($mode eq $_, qw(start stop show terminate)))
{
    if ($mode eq 'show') {
	open (SH, ">&STDOUT") or die "cannot open output: $!\n";
    } else {
	open (SH, "| sh") or die "cannot exec sh: $!\n";
    }
    print SH $environs{"common"}, "\n";

    foreach my $agent (@agents)
    {
	next if (@ARGV && !grep($_ eq "all" || $_ eq $agent->{LABEL}, @ARGV));
	next if (! @ARGV && ($agent->{DEFAULT} || 'on') eq 'off');

	print SH "(";
	if ($agent->{ENVIRON} && ! exists $environs{$agent->{ENVIRON}})
	{
	    print STDERR "Agent $agent->{LABEL} requests non-existent",
	    		 " environment $agent->{ENVIRON}\n";
	}
	elsif ($agent->{ENVIRON})
	{
	    print SH $environs{$agent->{ENVIRON}}, "\n";
	}

	# Now actually act on the mode, and start or show agents
	if ($mode eq 'start' || $mode eq 'show') {
	    print SH "mkdir -p \${PHEDEX_STATE}/$agent->{LABEL} &&",
	    " mkdir -p \${PHEDEX_LOGS} &&",
	    ($agent->{STATELINK}
	     ? " ln -sf $agent->{LABEL} \${PHEDEX_STATE}/$agent->{STATELINK};" : " :;"),
	    " nohup \${PHEDEX_SCRIPTS}/$agent->{PROGRAM}",
	    (" -", $agent->{STATEOPT} || "state", " ", "\${PHEDEX_STATE}/$agent->{LABEL}"),
	    $agent->{OPTS},
	    " >> \${PHEDEX_LOGS}/$agent->{LABEL} 2>&1 </dev/null &";
	} elsif ($mode eq 'stop') {
	    print SH "touch \${PHEDEX_STATE}/$agent->{LABEL}/stop";
	} elsif ($mode eq 'terminate') {
	    print SH "kill \$(cat \${PHEDEX_STATE}/$agent->{LABEL}/pid)";
	}
	print SH ")\n";
    }

    close(SH);
}
elsif ($mode eq "environ")
{
    foreach my $label (@ARGV ? @ARGV : "common")
    {
	print $environs{$label}, "\n";
    }
}
else
{
    die "Unrecognised operation mode '$mode', use -h for help\n";
}
