#!/bin/sh

# Home and myself
home=$(dirname $0)
me=$(basename $0)

# Die with a message
die() { echo ${1+"$@"} 1>&2; exit 1; }

# Download utilities
download_method=
download_curl () { curl -f -q -s "$1" -o "$2.tmp" && mv "$2.tmp" "$2"; }
download_wget () { wget -q -O "$2.tmp" "$1" && mv "$2.tmp" "$2"; }
download_none () { echo "no curl or wget, cannot fetch $1" 1>&2; exit 1; }
download_getit () {
  to="$1" url="$2"
  if [ -z "$download_method" ]; then
    if [ $(curl --version 2>&1 | wc -l) != 0 ]; then
      download_method=curl
    elif [ $(wget --version 2>&1 | wc -l) != 0 ]; then
      download_method=wget
    else
      download_method=none
    fi
  fi

  download_${download_method} "$url" "$to"
}

# Locate the latest release of project ($1).  Prints
# out project name, version and path.
scram_locate() {
  scram list 2>/dev/null | tail +7 | sed 's/...//g' | perl -e '
    @lines = ();
    while (<STDIN>) {
      chomp;
      s/\s+/ /g; s/^\s*//; s/\s*$//;
      /^$/ && next;
      if (/^Projects available/) {
        next;
      } elsif (/^-->/) {
        s/^-->\s*/ /;
        @lines[$#lines] .= $_
      } elsif (/^([A-Za-z]+) ([A-Za-z]+[A-Za-z0-9_]+)$/) {
        ($name, $v) = ($1, $2);
        $v =~ s/^[A-Za-z]*[_V]*//;
        $v =~ s/_/./g;
        push(@lines, "$name $v");
      } else {
        push(@lines, $_)
      }
    }
    print join("\n", @lines), "\n";' | 
   egrep $1 |
   sort -rd |
   head -1
}

# Get the CAT project tools
cat_tools() {
  path=$(scram_locate CAT | sed 's/.* //')
  [ -z "$path" -o ! -d "$path" ] && die "Could not locate CAT project"
  eval `cd $path && scram runtime -sh`
}

# Setup CAT RefDB virtual file system, scan all datasets and owners
# and print a list of dataset.owner pairs that are known.  Only takes
# combinations that match the input ($@)
cat_collections() {
  # Create temporary directory
  vfs=$(mktemp -d /tmp/refdb.XXXXXX)

  # Get CAT tools in our environment
  cat_tools

  # Prepare directory tree
  (cd $vfs
   phishmkdir fs -t VirtualFS
   phishls fs
   phishls fs/Datasets
   phishls fs/Datasets/All_datasets
   for x in "$@"; do
     for d in fs/Datasets/All_datasets/$(echo "$x" | sed 's/\..*//'); do
       phishls $d
     done
   done) >/dev/null 2>&1

  # Now dump all dataset.owner pairs
  (cd $vfs/fs/Datasets/All_datasets
   for d in */; do
     d=$(basename $d)
     for o in $d/*/; do
       o=$(basename $o)
       for pat in "$@"; do
         case $d.$o in $pat ) echo $d.$o ;; esac
       done
     done
   done)

   # Release temporary area
   rm -fr $vfs
}
  
# Same as cat_collections, but using production web pages
prod_collections() {
  # Get all dataset/owner pairs
  tmp=$(mktemp /tmp/refdb.XXXXXX)
  download_getit $tmp \
    "http://cmsdoc.cern.ch/cms/production/www/cgi/SQL/dataset-discovery.php?DSPattern=%25&OwPattern=%25&ProducedOn=&scriptstep=1"

  # Find the matches
  perl -n -e '
    if (/INPUT.*SelDataset.*value=["'\''](.*)["'\'']>/) { $ds=$1; }
    elsif (/OPTION.*value=["'\''](.*)\(\d+\)["'\'']/) { print "$ds.$1\n"; }' $tmp |
    while read dso; do
      for pat in "$@"; do
        case $dso in $pat ) echo $dso ;; esac
      done
    done

  # Nuke temp
  rm -f $tmp
}

# Process options
patfile=
while [ $# -gt 0 ]; do
  case $1 in
    -P ) patfile=$2; shift; shift;;
    -h ) echo "usage: RefDBList [-P DATASET.OWNER-PATTERN-FILE] [dataset.owner-pattern...]"
	 exit 1;;
    -* ) echo "unrecognised option $1"; exit 1;;
    *  ) break ;;
  esac
done

[ -n "$patfile" ] && set -- ${1+"$@"} $(cat $patfile)
[ $# -eq 0 ] && set -- "*.*"
prod_collections "$@"
