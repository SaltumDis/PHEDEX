#!/usr/bin/env perl

# Manage the addition of a new node to the network. Takes user through
# interactions required to add a new node, then asks to confirm before
# commit
#
# Request node details; request routing neighbours; request new agent
# details ...

use DBI;
use Getopt::Long;

my $me = $0;
my $state = '';
my $node_name = '';
my $node_host_string = '';
my $node_cat_uri = '';
my @node_neighbours = ();
my $user = '';
my $password = '';
my $dbname = '';

# #############################
# Main loop
# #############################

parse_command_line();
act_on_state();

# #############################
# Subroutines
# #############################

sub log_array_entries {
	my $array = shift;
	
	foreach $entry ( @$array ) {
		log_entry( $entry );
	}
}

# Eventually we might want to connect to MySQL etc as well,
# so try to hide it ...
sub connect_to_db {
	my $dbh = DBI->connect(	"DBI:Oracle:$dbname",
							$user,
							$password,
							{RaiseError => 1, AutoCommit => 1})
							
							or die "Couldn't connect to database $dbname @_";
	
	# FIXME: is this ok, or will it leave outstanding
	# connections? Return ref to handle?
	log_entry( "Connected to $dbname" );
	return $dbh;
}

sub do_sql {
    my $sql = shift;
    
    eval {
	my $dbh;
	if ($dbname) { 
	    $dbh = connect_to_db(); 
	} else {
	    log_entry( "No db specified, just logging sql" );
	}
	
	foreach my $cmd (@$sql) {
	    if ($dbname) {
		$dbh->do ($cmd);
	    } else {
		log_entry ($cmd);
	    }
	}
	$dbh->disconnect if $dbh;
    };
    
    if ($@)    {
	log_entry( "database operation failed: $@" );
	if ($dbh) {	    	
	    $dbh->rollback;
	    $dbh->disconnect;
	}
	return 1;
    }
    return 0;
}

sub create_new_neighbour_route {
	my ($node1,$node2) = @_;
	my @sql;
	
	my $time = time();
	push( @sql, "insert into t_routing values ($time, '$node1','$node2','$node2',1)" );
	push( @sql, "insert into t_routing values ($time, '$node2','$node1','$node1',1)" );	
	
	return @sql;
}

sub remove_neighbour_route {
	my ($node1,$node2) = @_;
	my @sql;
	
	my $time = time();
	push( @sql, "delete from t_routing where from_node = '$node1' and gateway = '$node2'" );
	push( @sql, "delete from t_routing where from_node = '$node2' and gateway = '$node1'" );	
	
	return @sql;
}

sub new_neighbours {
	my @sql = ();

	if ( 	$node_name eq '' || ! $node_neighbours[0] ) {
		display_usage();
	}
	
	log_entry( "Adding new neighbours" );
	log_entry( "Name: $node_name" );
	log_entry( "Neighbours: @node_neighbours" );

	# Create routes to neighbours
	foreach $neighbour ( @node_neighbours ) {
		my @routes = create_new_neighbour_route( $node_name, $neighbour );
		push( @sql, @routes );
	}
	
	do_sql( \@sql );
}

sub add_node {
    my @sql = ();
    
    if ( 	$node_name eq '' ) {
	display_usage();
    }
    
    log_entry( "Adding new node" );
    log_entry( "Name: $node_name" );
    
    push( @sql, "insert into t_node (name) values ('$node_name')" );
    
    do_sql( \@sql );
    
}

sub add_import {
    my @sql = ();
    
    if ( 	$node_name eq '' || ! $node_protocol[0]) {
	display_usage();
    }
    
    @protos = map { split (',', $_) } @node_protocol;
    log_entry( "Adding new node import" );
    log_entry( "Name: $node_name" );
    log_entry( "Protocols: @protos");
    
    for ($i = 0; $i <= $#protos; ++$i) {
        push( @sql, "insert into t_node_import (node, protocol, priority) values ('$node_name', '$protos[$i]', $i)" );
    }
    
    do_sql( \@sql );
    
}

sub add_export {
    my @sql = ();
    
    if ( 	$node_name eq '' || ! $node_protocol[0]) {
	display_usage();
    }
    
    @protos = map { split (',', $_) } @node_protocol;
    log_entry( "Adding new node export" );
    log_entry( "Name: $node_name" );
    log_entry( "Protocols: @protos");
    
    for ($i = 0; $i <= $#protos; ++$i) {
        push( @sql, "insert into t_node_export (node, protocol) values ('$node_name', '$protos[$i]')" );
    }
    
    do_sql( \@sql );
    
}

sub remove_link {
	my @sql = ();

	if ( 	$node_name eq '' ||
			! $node_neighbours[0] ) {
		display_usage();
	}
	
	log_entry( "Removing links between" );
	log_entry( "Name: $node_name" );
	log_entry( "Neighbours: @node_neighbours" );
	
	# Remove routes to neighbours
	foreach $neighbour ( @node_neighbours ) {
		my @routes = remove_neighbour_route( $node_name, $neighbour );
		push( @sql, @routes );
	}	
	
	do_sql( \@sql );
}

sub remove_node {
	my @sql = ();

	if ( $node_name eq '' ) { display_usage(); }
	
	log_entry( "Removing node" );
	log_entry( "Name: $node_name" );
	
	# Disable this until further notice.  Removing a node requires
	# major surgery on the data, so it's not safe to do with just
	# a simple script.  The following data would need to be removed:
	#  - t_agent_message, t_agent_status .node = node
	#  - t_block_replica .node = node
	#  - t_subscription .destination = node
	#  - t_destination .node = node
	#  - t_replica_state, t_file .node = node
	#  - t_transfer_state .to_node/.from_node = node
	#  - t_routing .from_node/.to_node/.gateway = node
	#  - t_node_import, t_node_export .node = node
	# plus also:
	#  - t_transfer_history .to_node/.from_node = node
	#  - t_transfer_summary .to_node/.from_node = node
	#  - t_info_transfer_rate .from_node/.to_node = node
	#  - t_info_replication_details .from_node/.to_node = node
	#  - t_info_transfer_status .node = node

	print STDERR "Sorry, too scared to remove node $node_name\n";
	exit (1);
}

sub act_on_state {
	if ( $state eq "add-node" ) {
		add_node();
	} elsif ( $state eq "remove-node" ) {
		remove_node();
	} elsif ( $state eq "new-neighbours" ) {
		new_neighbours();
	} elsif ( $state eq "remove-link" ) {
		remove_link();
	} elsif ( $state eq "add-import-protocol" ) {
		add_import();
	} elsif ( $state eq "add-export-protocol" ) {
		add_export(); 
	} else {
		display_usage();
	}
}

sub log_entry {
	my $entry = shift;
	my $time = time();
	my $local = localtime( $time );
	print "$local: $entry\n";
}

sub display_usage {
	print "Usage:\n";
	print "  $me add-node -name <node_name>\n\t\t-db <dbname> -dbuser <username> -dbpass <password>\n";
	print "  $me remove-node -name <node_name>\n\t\t-db <dbname> -dbuser <username> -dbpass <password>\n";
	print "  $me new-neighbours -name <node_name> -neighbours <neighbour1>,<neighbour2>,<...\n\t\t-db <dbname> -dbuser <username> -dbpass <password>\n";
	print "  $me remove-link -name <node_name> -neighbours <neighbour1>,<neighbour2>,<...\n\t\t-db <dbname> -dbuser <username> -dbpass <password>\n";
	print "  $me add-import-protocol -name <node_name> -protocol <proto>,<proto>,<...\n\t\t-db <dbname> -dbuser <username> -dbpass <password>\n";
	print "  $me add-export-protocol -name <node_name> -protocol <proto>,<proto>,<...\n\t\t-db <dbname> -dbuser <username> -dbpass <password>\n";
	exit(1);
}

sub parse_command_line () {
	GetOptions(	'name=s' => \$node_name,
			'host=s' => \$node_host_string,
			'cat=s' => \$node_cat_uri,
			'protocol=s' => \@node_protocol,
			'neighbours=s' => \@node_neighbours,
			'dbuser=s' => \$user,
			'dbpass=s' => \$password,
			'db=s' => \$dbname,
			);
				
	@node_neighbours = split(/,/,join(',',@node_neighbours));
				
	if ( ! $ARGV[0] || $ARGV[1]) {
		display_usage();
	} else {
		$state = $ARGV[0];
	}
}
