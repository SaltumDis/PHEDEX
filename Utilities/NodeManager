#!/usr/bin/env perl

##H Manage the addition of a new node to the network.  Provides commands
##H for various steps of creating a new node and attaching it to network.
##H
##H Usage:
##H   NodeManager
##H      add-node       -dbconfig FILE -name NAME
##H      remove-node    -dbconfig FILE -name NAME
##H      new-neighbours -dbconfig FILE -name NAME -neighbours NODE[,NODE...]
##H      remove-link    -dbconfig FILE -name NAME -neighbours NODE[,NODE...]
##H      add-import     -dbconfig FILE -name NAME -protocol NAME[,NAME...]
##H      add-export     -dbconfig FILE -name NAME -protocol NAME[,NAME...]
##H
##H -dbconfig    database connection configuration parameter file
##H -name        the name of the node
##H -neighbours  comma-separated list of neighbour nodes
##H -protocol    comma-separated list of transfer protocols

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}
use Getopt::Long;
use UtilsHelp;
use UtilsDB;

my $me = $0;
my $state = '';
my $node_name = '';
my $node_host_string = '';
my $node_cat_uri = '';
my @node_neighbours = ();

# #############################
# Main loop
# #############################

parse_command_line();
act_on_state();

# #############################
# Subroutines
# #############################

sub log_array_entries {
	my $array = shift;
	
	foreach $entry ( @$array ) {
		log_entry( $entry );
	}
}

# Eventually we might want to connect to MySQL etc as well,
# so try to hide it ...
sub connect_to_db {
	my $dbh = DBI->connect(	"DBI:Oracle:$dbname",
							$user,
							$password,
							{RaiseError => 1, AutoCommit => 1})
							
							or die "Couldn't connect to database $dbname @_";
	
	# FIXME: is this ok, or will it leave outstanding
	# connections? Return ref to handle?
	log_entry( "Connected to $dbname" );
	return $dbh;
}

sub do_sql {
    my $sql = shift;
    
    eval {
	my $dbh;
	if ($dbname) { 
	    $dbh = connect_to_db(); 
	} else {
	    log_entry( "No db specified, just logging sql" );
	}
	
	foreach my $cmd (@$sql) {
	    if ($dbname) {
		$dbh->do ($cmd);
	    } else {
		log_entry ($cmd);
	    }
	}
	$dbh->disconnect if $dbh;
    };
    
    if ($@)    {
	log_entry( "database operation failed: $@" );
	if ($dbh) {	    	
	    $dbh->rollback;
	    $dbh->disconnect;
	}
	return 1;
    }
    return 0;
}

sub create_new_neighbour_route {
	my ($node1,$node2) = @_;
	my @sql;
	
	my $time = time();
	push( @sql, "insert into t_routing values ($time, '$node1','$node2','$node2',1)" );
	push( @sql, "insert into t_routing values ($time, '$node2','$node1','$node1',1)" );	
	
	return @sql;
}

sub remove_neighbour_route {
	my ($node1,$node2) = @_;
	my @sql;
	
	my $time = time();
	push( @sql, "delete from t_routing where from_node = '$node1' and gateway = '$node2'" );
	push( @sql, "delete from t_routing where from_node = '$node2' and gateway = '$node1'" );	
	
	return @sql;
}

sub new_neighbours {
	my @sql = ();

	if ( 	$node_name eq '' || ! $node_neighbours[0] ) {
		display_usage();
	}
	
	log_entry( "Adding new neighbours" );
	log_entry( "Name: $node_name" );
	log_entry( "Neighbours: @node_neighbours" );

	# Create routes to neighbours
	foreach $neighbour ( @node_neighbours ) {
		my @routes = create_new_neighbour_route( $node_name, $neighbour );
		push( @sql, @routes );
	}
	
	do_sql( \@sql );
}

sub add_node {
    my @sql = ();
    
    if ( 	$node_name eq '' ) {
	display_usage();
    }
    
    log_entry( "Adding new node" );
    log_entry( "Name: $node_name" );
    
    push( @sql, "insert into t_node (name) values ('$node_name')" );
    
    do_sql( \@sql );
    
}

sub add_import {
    my @sql = ();
    
    if ( 	$node_name eq '' || ! $node_protocol[0]) {
	display_usage();
    }
    
    @protos = map { split (',', $_) } @node_protocol;
    log_entry( "Adding new node import" );
    log_entry( "Name: $node_name" );
    log_entry( "Protocols: @protos");
    
    for ($i = 0; $i <= $#protos; ++$i) {
        push( @sql, "insert into t_node_import (node, protocol, priority) values ('$node_name', '$protos[$i]', $i)" );
    }
    
    do_sql( \@sql );
    
}

sub add_export {
    my @sql = ();
    
    if ( 	$node_name eq '' || ! $node_protocol[0]) {
	display_usage();
    }
    
    @protos = map { split (',', $_) } @node_protocol;
    log_entry( "Adding new node export" );
    log_entry( "Name: $node_name" );
    log_entry( "Protocols: @protos");
    
    for ($i = 0; $i <= $#protos; ++$i) {
        push( @sql, "insert into t_node_export (node, protocol) values ('$node_name', '$protos[$i]')" );
    }
    
    do_sql( \@sql );
    
}

sub remove_link {
	my @sql = ();

	if ( 	$node_name eq '' ||
			! $node_neighbours[0] ) {
		display_usage();
	}
	
	log_entry( "Removing links between" );
	log_entry( "Name: $node_name" );
	log_entry( "Neighbours: @node_neighbours" );
	
	# Remove routes to neighbours
	foreach $neighbour ( @node_neighbours ) {
		my @routes = remove_neighbour_route( $node_name, $neighbour );
		push( @sql, @routes );
	}	
	
	do_sql( \@sql );
}

sub remove_node {
	my @sql = ();

	if ( $node_name eq '' ) { display_usage(); }
	
	log_entry( "Removing node" );
	log_entry( "Name: $node_name" );
	
	# Disable this until further notice.  Removing a node requires
	# major surgery on the data, so it's not safe to do with just
	# a simple script.  The following data would need to be removed:
	#  - t_agent_message, t_agent_status .node = node
	#  - t_block_replica .node = node
	#  - t_subscription .destination = node
	#  - t_destination .node = node
	#  - t_replica_state, t_file .node = node
	#  - t_transfer_state .to_node/.from_node = node
	#  - t_routing .from_node/.to_node/.gateway = node
	#  - t_node_import, t_node_export .node = node
	# plus also:
	#  - t_transfer_history .to_node/.from_node = node
	#  - t_transfer_summary .to_node/.from_node = node
	#  - t_info_transfer_rate .from_node/.to_node = node
	#  - t_info_replication_details .from_node/.to_node = node
	#  - t_info_transfer_status .node = node

	print STDERR "Sorry, too scared to remove node $node_name\n";
	exit (1);
}

sub act_on_state {
	if ( $state eq "add-node" ) {
		add_node();
	} elsif ( $state eq "remove-node" ) {
		remove_node();
	} elsif ( $state eq "new-neighbours" ) {
		new_neighbours();
	} elsif ( $state eq "remove-link" ) {
		remove_link();
	} elsif ( $state eq "add-import-protocol" ) {
		add_import();
	} elsif ( $state eq "add-export-protocol" ) {
		add_export(); 
	} else {
		display_usage();
	}
}

sub log_entry {
	my $entry = shift;
	my $time = time();
	my $local = localtime( $time );
	print "$local: $entry\n";
}

sub parse_command_line () {
    GetOptions ('name=s' => \$node_name,
		'protocol=s' => \@node_protocol,
		'neighbours=s' => \@node_neighbours,
		'dbconfig=s' => \$config);
    @node_neighbours = map { split(/,/, $_) } @node_neighbours;
    @node_protocol = map { split(/,/, $_) } @node_protocol;
    die "Incorrect parameters, use -h for help\n" if @ARGV;
}
