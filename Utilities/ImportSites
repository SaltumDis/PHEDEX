#!/usr/bin/env perl

##H Fill the site and identity tables using a simple text file
##H
##H Usage:
##H   ImportSites -db DBCONFIG [file]
##H
##H The input file should contain sections of the form:
##H site:  'siteName'
##H email:  'e@mail'
##H dn:  'distinguishedName'
##H role:  'roleName'
##H nodes:  'siteNode1,siteNode2,siteNode3,...'
##H
##H A file of this form is output by the GrepSites script

BEGIN {
    $^W = 1; use strict; use warnings;
    our $me = $0; $me =~ s|.*/||;
    our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
    unshift(@INC, $home);
}

# Process command line arguments.
my %args;
use Getopt::Long;
use UtilsHelp;
use UtilsDB;
use UtilsMisc;
use UtilsTiming;
&GetOptions ("db=s"            => \$args{DBCONFIG},
	     "help|h"          => sub { &usage() });

# Check arguments.
if (!$args{DBCONFIG})
{
    die "Insufficient parameters, use -h for help.\n";
}

my $self = { DBCONFIG => $args{DBCONFIG} };
my $dbh = &connectToDatabase ($self, 0);

# Get a list of nodes and IDs from the DB
my %nodes;
my $q = &dbexec($dbh, qq{
    select id, name from t_adm_node
});

while (my ($id, $name) = $q->fetchrow_array) {
    $nodes{$name} = $id;
}

# Parse the files and build a hash
my %sites;
$currsite = '';
while (<>) {
    chomp;
    next unless /^\w/;
    if (/^site:\s*\'(\w+)\'/) { $currsite = $1; }
    if (/^email:\s*\'(.+)\'/) { $sites{$currsite}{email} = $1; }
    if (/^dn:\s*\'(.+)\'/)    { $sites{$currsite}{dn} = $1; }
    if (/^role:\s*\'(\w+)\'/) { $sites{$currsite}{role} = $1; }
    if (/^nodes:\s*\'(.+)\'/) { $sites{$currsite}{nodes} = [split(/,/, $1)]; }
}

# Go through the hash and inser the sites
foreach my $site (sort keys %sites) {
    # Check the hash
    unless ( $sites{$site}{email} &&
	     $sites{$site}{dn} &&
	     $sites{$site}{role} &&
	     $sites{$site}{nodes} && 
	     @{$sites{$site}{nodes}} ) {
	$dbh->rollback();
	die "Missing information for $site:  aborting.\n";
    }

    print "Inserting site $site...";

    # Insert the site
    &dbexec($dbh, 
	    qq{insert into t_adm_site (id, name, role_name)
		   values (seq_adm_site.nextval, :name, :role) },
	    ':name' => $site,
	    ':role' => $sites{$site}{role});
    
    foreach my $name ( @{$sites{$site}{nodes}} ) {
	&dbexec($dbh,
		qq{insert into t_adm_site_node (site, node)
		       values (seq_adm_site.currval, :node)},
		':node' => $nodes{$name});
    }

    # Insert the identity if it is not already there
    unless ( fetch_identity_id($dbh, $sites{$site}{dn}) ) {
	&dbexec($dbh,
		qq{insert into t_adm_identity (id) 
		       values (seq_adm_identity.nextval) });
    
	my %attr = ('Distinguished name' => $sites{$site}{dn}, 
		    'E-mail' => $sites{$site}{email});
	foreach my $name (keys %attr) {
	    &dbexec($dbh,
		    qq{insert into t_adm_identity_attr (id, identity, name, value)
			   values (seq_adm_identity_attr.nextval, seq_adm_identity.currval,
				   :name, :value)},
		    ':name' => $name,
		    ':value' => $attr{$name});
	}
    }

    # Make the identity a site admin
    my $identity = fetch_identity_id($dbh, $sites{$site}{dn});
    
    &dbexec($dbh,
	    qq{insert into t_adm_site_admin (site, identity)
	       values (seq_adm_site.currval, :identity) },
	    ':identity' => $identity
	    );

    print "Done.\n";
}

print "Committing...";
$dbh->commit();
print "Done.\n";

&disconnectFromDatabase($self, $dbh, 1);


# Fetches the identity id given the distinguished name
sub fetch_identity_id 
{
    my ($dbh, $dn) = @_;
    my $q = &dbexec($dbh, qq{ select identity from t_adm_identity_attr
	        	       where name = 'Distinguished name'
		                 and value = :dn },
		    ':dn' => $dn);
    return $q->fetchrow_array();
}
