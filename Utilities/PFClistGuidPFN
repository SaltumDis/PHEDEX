#!/usr/bin/env perl

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments
my $me = $0; $me =~ s|.*/||;
my %args = (JOBS => 10);
while (@ARGV)
{
    if ($ARGV[0] eq '-u' && scalar @ARGV > 1)
    { shift (@ARGV); $args{CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] =~ /^-[pgq]$/)
    { $args{MODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-m')
    { $args{MATCH} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-r')
    { shift (@ARGV); $args{READ} = 1; }
    elsif ($ARGV[0] eq '-j' && scalar @ARGV > 1)
    { shift (@ARGV); $args{JOBS} = shift(@ARGV); }
    else
    { last; }
}

if (!$args{CATALOGUE} || !$args{MODE} || !$args{JOBS})
{
    print STDERR "usage: $me -u CATALOGUE { -p | -g | -x } [-m] [-r] [-j JOBS] ITEM...\n";
    exit (1);
}

# Build list of query arguments
my @items = ();
if ($args{READ})
{
    # Command line arguments are file names, read and split by white space.
    foreach my $file (@ARGV)
    {
	open (PATS, "< $file") or die "$file: cannot open: $!\n";
	while (<PATS>) { chomp; push(@items, split(/\s+/, $_)); }
	close (PATS) or die "$file: cannot read: $!\n";
    }
}
else
{
    # Arguments are patterns themselves.
    push(@items, @ARGV);
}

exit 1 if ! &runQueries (\@items, %args);
exit 0;

# Pick result from running FClistGuidPFN.  Just replay entire output.
sub collectResult
{
    my ($mgr, $job) = @_;

    if ($job->{STATUS})
    {
	unlink $job->{OUTPUT};
	print STDERR "$job->{PATTERN} failed, re-executing\n";
	$mgr->addJob (sub { &collectResult($mgr, @_) },
	    { PATTERN => $job->{PATTERN}, OUTPUT => $job->{OUTPUT} },
	    @{$job->{CMD}});
        return;
    }

    open (PFNS, "< $job->{OUTPUT}") or die "$job->{OUTPUT}: cannot open: $!\n";
    print grep (/^[-0-9A-F]+\s+.*/, <PFNS>);
    close (PFNS) or die "$job->{OUTPUT}: cannot read: $!\n";
    unlink $job->{OUTPUT};
}

# Map GUIDs to PFNs using catalogue, running a number of queries
# in parallel.  Adds "PFN" entry to each file in $files.
sub runQueries
{
    my ($items, %args) = @_;
    use POSIX;
    use UtilsJobManager;
    local $| = 1;

    # Create jobs to resolve guids to pfns
    my $mgr = new UtilsJobManager (NJOBS => $args{JOBS});
    my $cmd = "POOL_OUTMSG_LEVEL=100"
    	      . " $home/../../Utilities/FClistGuidPFN"
	      . " -u '$args{CATALOGUE}'"
	      . " $args{MODE}"
	      . ($args{MATCH} ? " -m" : "");
    foreach my $item (@$items)
    {
	my $output = "/tmp/tmp.$$.$item";
	$mgr->addJob (sub { &collectResult($mgr, @_) },
	    { OUTPUT => $output, PATTERN => $item },
	    "sh", "-c", "$cmd '$item' > $output");
	$mgr->pumpJobs();
    }

    # Now wait all results are collected
    while (@{$mgr->{JOBS}})
    {
	$mgr->pumpJobs();
	select (undef, undef, undef, .1);
    }

    return 1;
}
