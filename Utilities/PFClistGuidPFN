#!/usr/bin/env perl

##H Parallel FClistGuidPFN.
##H
##H Works the same as FClistGuidPFN, except also takes option
##H -j JOBS for parallel number of jobs (default: 10).
##H
##H Usage:
##H   PFClistGuidPFN -u CATALOGUE { -p | -g | -x } [-m] [-r] [-j JOBS] ITEM...
##H
##H -u specifies catalogue contact string.
##H -p selects query by PFN
##H -g selects query by GUID
##H -x selects arbitrary query expressions
##H -m selects match queryies (-p / -g)
##H -r specifies that ITEMs are files to read rather than actual search terms
##H ITEM are the search terms: GUIDs, GUID patterns, PFNs, PFN patterns etc.

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments
use UtilsHelp;
my %args = (JOBS => 10);
while (@ARGV)
{
    if ($ARGV[0] eq '-u' && scalar @ARGV > 1)
    { shift (@ARGV); $args{CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] =~ /^-[pgq]$/)
    { $args{MODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-m')
    { $args{MATCH} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-r')
    { shift (@ARGV); $args{READ} = 1; }
    elsif ($ARGV[0] eq '-j' && scalar @ARGV > 1)
    { shift (@ARGV); $args{JOBS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

if (!$args{CATALOGUE} || !$args{MODE} || !$args{JOBS})
{
    die "Insufficient parameters, use -h for help.\n";
}

# Build list of query arguments
my @items = ();
if ($args{READ})
{
    # Command line arguments are file names, read and split by white space.
    foreach my $file (@ARGV)
    {
	open (PATS, "< $file") or die "$file: cannot open: $!\n";
	while (<PATS>) { chomp; push(@items, split(/\s+/, $_)); }
	close (PATS) or die "$file: cannot read: $!\n";
    }
}
else
{
    # Arguments are patterns themselves.
    push(@items, @ARGV);
}

exit 1 if ! &runQueries (\@items, %args);
exit 0;

# Pick result from running FClistGuidPFN.  Just replay entire output.
sub collectResult
{
    my ($mgr, $job) = @_;

    if ($job->{STATUS})
    {
	unlink $job->{OUTPUT};
	print STDERR "Batch $job->{LOT} failed, re-executing\n";
	$mgr->addJob (sub { &collectResult($mgr, @_) },
	    { LOT => $job->{LOT}, OUTPUT => $job->{OUTPUT} },
	    @{$job->{CMD}});
        return;
    }

    open (PFNS, "< $job->{OUTPUT}") or die "$job->{OUTPUT}: cannot open: $!\n";
    print grep (/^[-0-9A-Fa-f]+\S+\s\S+$/, <PFNS>);
    close (PFNS) or die "$job->{OUTPUT}: cannot read: $!\n";
    unlink $job->{OUTPUT};
}

# Map GUIDs to PFNs using catalogue, running a number of queries
# in parallel.  Adds "PFN" entry to each file in $files.
sub runQueries
{
    my ($items, %args) = @_;
    use POSIX;
    use UtilsJobManager;
    local $| = 1;

    # Create jobs to resolve guids to pfns
    my $mgr = new UtilsJobManager (NJOBS => $args{JOBS});
    my $cmd = "POOL_OUTMSG_LEVEL=100"
    	      . " $home/../../Utilities/FClistGuidPFN"
	      . " -u '$args{CATALOGUE}'"
	      . " $args{MODE}"
	      . ($args{MATCH} ? " -m" : "")
	      . " ";
    for (my $i = 1; @$items; ++$i)
    {
	my @item  = splice(@$items, 0, $args{MATCH} ? 1 : 100);
	my $output = qx(mktemp /tmp/PFClistGuidPFN.$<.XXXXXXX);
	chomp ($output);
	$mgr->addJob (sub { &collectResult($mgr, @_) },
	    { OUTPUT => $output, LOT => $i },
	    "sh", "-c", $cmd . join("", map { " '$_'" } @item) . " > $output");
	$mgr->pumpJobs();
    }

    # Now wait all results are collected
    while (@{$mgr->{JOBS}})
    {
	$mgr->pumpJobs();
	select (undef, undef, undef, .1);
    }

    return 1;
}
