#!/usr/bin/env perl
#
# spacemon - client side utility for CMS Space Monitoring
# 
# Intended functionality: 
#  * Parces and aggregates storage dump file 
#  * Creates a record object for space monitoring 
#  * Downloads TFC and CMS namespace conventions
#  * Maps directories to CMS data types 
#  * Uploads record to dmwmmon database, or saves to a local file for later upload
#    (default: print to stdout)
#
# See project page for details:
#            https://twiki.cern.ch/twiki/bin/view/CMSPublic/CompProjSpaceMon
#
############################################################################

use strict;
use warnings;
use Carp;
use Data::Dumper;
use File::Basename;
use Getopt::Long qw /:config pass_through /;

use DMWMMON::SpaceMon::NamespaceConfig;
use DMWMMON::SpaceMon::FormatFactory;
use DMWMMON::SpaceMon::StorageDump;
use DMWMMON::SpaceMon::Aggregate;
use DMWMMON::SpaceMon::RecordIO;
use DMWMMON::SpaceMon::Core;

my $me = basename($0);
my $argname='STORAGE_DUMP';
my ($defaults, $upload, $save, $debug, $verbose, $format, $url, $node, $configfile);
$debug = $verbose = 0; # use these to override class defaults. 

my ($input, $dumpfile, $parser, $record, $rio, $config);

sub vPrint{
    my $text = shift;
    $verbose && print "$me: " . $text . "\n"; 
}

# Check useful for packaging. Print dependencies and exit:
GetOptions("deps|d" => sub {print Dumper(%INC); exit;}); 
&DMWMMON::SpaceMon::UserAgent::auth_getoptions();
GetOptions ( 'help|h' => sub { &usage },
	     'version'=> sub { print "$me version: " . 
				   DMWMMON::SpaceMon::Core::version()."\n";
			       exit;},
	     'upload-record' => \$upload,
	     'defaults' => \$defaults,
	     'check-auth' => sub { &check_auth },
	     'save-record:s'   => \$save,
	     'format:s'   => \$format,
	     'debug!' => \$debug,  # enables --nodebug option
	     'verbose!' => \$verbose,	     
	     'url:s' => \$url,
	     'node:s' => \$node,
	     'config:s' => \$configfile,
	     );

sub usage
{ 
    my $ver = DMWMMON::SpaceMon::Core::version();
    print <<EOF;
  $me - client side utility for CMS Space Monitoring. 
  Version:  $ver    
	
Usage:
  $me [OPTIONS] $argname
  $me --help|-h
  $me --version
  $me --check-auth
  $me --defaults

Upload options: 

  --url                   overrides default data service url
  --upload-record         upload record to central data store
  --node                  node (usually a site name) to upload data for
  --save-record <file>    save record to a file instead of printing to STDOUT
  --config      <file>    read configuration rules from the file

Verbosity control options:

  --verbose|--noverbose   turn on/off printout about processing steps
  --debug|--nodebug       turn on/off lots of debugging printout
EOF
;
    #openDumpUsage($argname);
    &DMWMMON::SpaceMon::UserAgent::auth_usage();
    exit 0;
}

sub check_auth 
{
    # Check  Authentication: 
    print "$me: Checking authentication\n" if $verbose;
    my $smua = DMWMMON::SpaceMon::UserAgent->new (
	URL      => $url,
	FORMAT   => 'perl',
        DEBUG    => $debug,
        VERBOSE  => $verbose,
                                     );
    $smua->get_auth();
    exit;
}

$input = shift;

# Print out defaults :  
#   - configuration rules
#   - location of the user config file
#   - verbosity settings
#   - upload url
# 
# TODO: show configuration in different formats: a set of rules, or a resulting NamespaceConfig tree object.

if ( defined $defaults ) {
   print "$me " . DMWMMON::SpaceMon::Core::version(). " defaults:\n";
   $config = DMWMMON::SpaceMon::NamespaceConfig->new ( 
      DEBUG => $debug,
      VERBOSE => $verbose,
   );
   print Data::Dumper->Dump ([$config->{RULES}],[qw(rules)]);
   exit;
}

if ( defined $configfile ) {
  if ( -f $configfile ) {
    $config->{'USERCONF'} = $configfile;
  } else {
    if ($configfile) { 
      die "ERROR: configuration file \"$configfile\" does not exist\n";
    } else {
      die "ERROR: option --config requires an argument: file name \n";
    }
  }
}

$config = DMWMMON::SpaceMon::NamespaceConfig->new
    ( 
      DEBUG => $debug,
      VERBOSE => $verbose,
      USERCONF => $configfile,
    );

$dumpfile = DMWMMON::SpaceMon::FormatFactory->instantiate
(
 DUMPFORMAT => $format,
 DEBUG => $debug,
 VERBOSE => $verbose,
 DUMPFILE => $input,
);

print $dumpfile->dump() if $debug;
#$dumpfile->formattingHelp();

$parser = DMWMMON::SpaceMon::Aggregate->new
    (
     DEBUG   => $debug,
     VERBOSE => $verbose,
     CONFIG  => $config,
    );

print "Using parsing algorithm: \n", $parser->dump() if $debug;
$record = $parser->createRecord($config, $dumpfile);
$node && $record->setNodeName($node);
print "Dump record returned by a parser: ", $record->dump(), "\n" if $debug;

$rio = DMWMMON::SpaceMon::RecordIO->new(
    DEBUG => $debug,
    VERBOSE => $verbose,
    DATASVC => $url,
    );


if ($debug) {
# To validate the Record object write it to a file, then read back and compare
    $verbose && print "Validating Record object: write/read from the file...\n";
    my $tmp_rec_file='/tmp/record.save-in-file-test';
    $rio->writeToFile($record, $tmp_rec_file);
    my $rec_from_file = $rio->readFromFile($tmp_rec_file);
    $verbose && print $rec_from_file->dump();
    if ( ! $rec_from_file->matches($record)) {    
	$upload = 0;
	print "WARNING: the Record failed validation. Will not upload!\n";
	print "DETAILS: the Record read from the file does not match the original Record.\n";
    }
}

# The resulting Record is printed to STDOUT, unless explicitly asked to 
# save it to a file using  --save-record  option: 
if ($save) {
    $rio->writeToFile($record, $save);    
} else {
    print $record->dump();
}

if ($upload) {
    $rio->upload($record);
}

#$rio->show($record);
