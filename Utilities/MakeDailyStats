#!/usr/bin/env perl

##H Clean up active tables by moving away historical and timed-out data.
##H
##H Usage:
##H   MakeDailyStats
##H      -db FILE[:SECTION] [-unit k|G|M|T] [-time hour|day|week|month]
##H      [-add FILE] [-rate | -total]
##H
##H -db        database connection configuration parameter file
##H -unit      report in specified unit instead of bare number of bytes (default: T)
##H -time      group by the specified time span (default: day)
##H -add       add transfer deltas from a file, with lines in the format
##H               YYYYMMDD NODE SIZE-VAL [NODE SIZE-VAL]...
##H -rate      show transfer rate (MB/s, or unit)
##H -show      show total data transferred (terabytes, or unit)

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}
use UtilsHelp;
use UtilsDB;
use POSIX;

my %stats = ();
my %nodes = ();
my $first = undef;
my %args = (MODE => 'total', TIME => 'day');

# Process command line arguments.
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-unit' && scalar @ARGV > 1)
    { shift (@ARGV); $args{UNIT} = "1" . shift(@ARGV); }
    elsif ($ARGV[0] eq '-time' && scalar @ARGV > 1)
    { shift (@ARGV); $args{TIME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-add' && scalar @ARGV > 1)
    { shift (@ARGV); $args{ADDFILE} = shift (@ARGV); }
    elsif ($ARGV[0] eq '-rate')
    { shift (@ARGV); $args{MODE} = 'rate'; }
    elsif ($ARGV[0] eq '-total')
    { shift (@ARGV); $args{MODE} = 'total'; }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

# Check arguments.
$args{UNIT} = ($args{MODE} eq 'rate' ? "1M" : "1T") if ! $args{UNIT};
$args{UNIT} = &sizeValue ($args{UNIT}) if $args{UNIT};
if (@ARGV || !$args{UNIT} || !$args{TIME} || !$args{DBCONFIG} || !$args{MODE})
{
    die "Insufficient parameters, use -h for help.\n";
}

# If we were given a file of transfer stats that are no longer known
# in the database, insert them into %stats as "seed" values.  The
# file contains lines "YYYYMMDD SITE SIZE-VAL [SITE SIZE-VAL]...".
# For each day get the values, convert the date to a time value and
# then to the requested time unit, and add into %stats as if they
# were real transfers.
if ($args{ADDFILE})
{
    open (F, "< $args{ADDFILE}") or die "$args{ADDFILE}: $!\n";
    while (<F>)
    {
	my ($date, @words) = split(/\s+/, $_);
	my ($year, $month, $day) = ($date =~ m|(\d\d\d\d)(\d\d)(\d\d)|);
	while (@words)
	{
	    my $node = shift (@words);
	    my $size = &sizeValue (shift (@words));
	    foreach my $hour (8 .. 19)
	    {
		my $timeval = &timegm (0, 0, $hour, $day, $month-1, $year-1900, 0, -1);
		my $unit = &formatTime ($timeval, $args{TIME});
		$first = $timeval if (! $first || $first > $timeval);
	    	$stats{$unit}{$node} = 0 if ! exists $stats{$unit}{$node};
	    	$stats{$unit}{$node} += $size / $args{UNIT} / 12.0;
	    	$nodes{$node} = 1;
	    }
	}
    }
    close (F);
}

# Fetch all completed transfers, convert to the requested time unit
# and fill into %stats.
$dbh = &connectToDatabase (\%args, 0);
my $data = &dbexec ($dbh, qq{
    select timebin, to_node, sum(xferred_bytes)
    from t_perf_histogram
    where from_node not like '%_MSS'
      and to_node not like '%_MSS'
    group by timebin, to_node});

while (my ($time, $tonode, $size) = $data->fetchrow())
{
    my $unit = &formatTime ($time, $args{TIME});
    $first = $time if (! $first || $first > $time);
    $stats{$unit}{$tonode} = 0 if ! exists $stats{$unit}{$tonode};
    $stats{$unit}{$tonode} += $size / $args{UNIT};
    $nodes{$tonode} = 1;
}
$data->finish ();
$dbh->disconnect ();
undef $dbh;

# Print the statistics for all nodes.  Generate a continuous time
# series so we print out values even for time spans when there
# were no transfers to report.  This allows for correct histograms
# without having to understands time as real time values.
my @nodenames = sort keys %nodes;
print join(",", "Time Base", @nodenames), "\n";
foreach my $time (&timeSeries ($first, $args{TIME})) {
    my $unit = &formatTime ($time->{LOW}, $args{TIME});
    print $unit;
    foreach my $node (@nodenames)
    {
        my $amount = $stats{$unit}{$node} || 0;
        $amount /= $time->{HIGH} - $time->{LOW}
	   if $args{MODE} eq 'rate';
        print ",$amount";
    }
    print "\n";
}

# Done.
exit 0;

######################################################################
# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
    my ($first, $range) = @_;
    my $now = time();
    my @series = ();
    $first = int($first);

    if ($range eq 'hour') {
	# Convert first time to UTC hour.  Then make a
	# time series of hours until end of current hour.
	my $low = 12 * int($first / 3600 / 12);
	my $high = 12 * (int($now / 3600 / 12) + 1);
	for ( ; $low < $high; ++$low) {
	    push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
        }
    } elsif ($range eq 'day') {
	# Convert first time to UTC day at 00:00.  Then make a
	# time series of days until end of today.
	my $low = int($first / 86400);
	my $high = int($now / 86400) + 1;
	for ( ; $low < $high; ++$low) {
	    push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
        }
    } elsif ($range eq 'week') {
	# Convert first time to previous Monday.  Then make a
	# time series of weeks until we pass today.
	my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
	my $low = int($first/86400) - $diff{$wday};
	my $high = int($now / 86400) + 1;
	for ( ; $low < $high; $low += 7) {
	    push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
	}
    } elsif ($range eq 'month') {
	# Convert first time to first of the month.  Then convert
	# into a time-series of months.  This is a bit dodgy, we
	# go by day so we don't need to worry about month dates.
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
	my $start = int(($first - ($mday-1)*86400)/86400);
	my $limit = int($now / 86400) + 1;
	while ($start < $limit) {
	    my $low = $start;
	    my ($prevyear, $prevmon) = ($year, $mon);
	    while ($year == $prevyear && $mon == $prevmon) {
		($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
		    = gmtime ((++$start) * 86400);
	    }
	    push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
	}
    }

    return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
    my ($time, $range) = @_;
    if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
    elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
    elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
    elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
    my @args = @_;
    my $t1 = mktime (@args);
    my @gmt = gmtime ($t1);
    my $t2 = mktime (@gmt);
    return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
    my ($value) = @_;
    if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
    {
        my %scale = ('k' => 2**10, 'M' => 2**20, 'G' => 2**30,
		     'T' => 2**40, 'P' => 2**50, 'E' => 2**60);
        $value = $1 * $scale{$2};
    }
    return $value * 1.0;
}
