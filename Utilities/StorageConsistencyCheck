#!/usr/bin/env perl
use strict;

##H
##H  Find orphan files in storage w.r.t. TMDB or DBS.
##H
##H   Usage:
##H
##H   StorageConsistencyCheck -db DBCONFIG [-lfnlist LFNLIST] [-verbose]
##H 
##H   DBCONFIG is the usual PhEDEx DB contact file.
##H
##H   LFNLIST is a file containing full LFNs as found in your storage
##H   element, one lfn per line. Anything before the '/store/' part is
##H   ignored, anything after it is taken to be the full LFN.
##H   If LFNLIST is given as '-', the script will read from stdin.
##H   Gzipped (*.gz) or bzipped (*.bz2) files can be read directly,
##H   allowing for compact filelists.
##H
##H   The output is a list of files known to the storage element (i.e. in the
##H   input list) but not known to TMDB. After that the same list is
##H   summarised by directory, where purely numerical subdirectories are
##H   grouped (i.e. /path/001 and /path/002 are grouped as /path).
##H
##H   EXAMPLES:
##H
##H   StorageConsistencyCheck -db ~/private/DBParam:Prod/Reader
##H      -lfnlist /afs/cern.ch/user/w/wildish/public/castor.store.merged.txt
##H   
##H

BEGIN {
    $^W = 1; use strict; use warnings;
    our $me = $0; $me =~ s|.*/||;
    our $home = $0;
    if ( $home !~ m%/% ) { $home = '.'; }
    $home =~ s|/[^/]+$||;
    $home ||= ".";
    $home .= "/../Toolkit/Common";
    unshift(@INC, $home);
}

# Process command line arguments.
use Getopt::Long;
use File::Basename;
use UtilsHelp;
use UtilsDB;
use UtilsNamespace;

my ($dbh);
my ($verbose,$debug,$terse);
my (%h,$conn);
my ($DBCONFIG,%lfn);
my ($lfn);
my $debug_me = 1;

$verbose = $debug = $terse = 0;
GetOptions("db=s"           => \$DBCONFIG,
           "lfnlist=s"      => \$lfn,

           "verbose|v+"     => \$verbose,
           "debug+"         => \$debug,
           "terse"          => \$terse,

           "help|h"         => sub { &usage() }
	  );

$|=1;

# Check arguments.
if( !$DBCONFIG )
{
  die "Insufficient parameters, use -h for help.\n";
}

#-------------------------------------------------------------------------------
$conn = { DBCONFIG => $DBCONFIG };
$dbh = &connectToDatabase ( $conn, 0 );

if ( $lfn =~ m%.gz$% )
{ open LFN, "cat $lfn | gzip -d - |" or die "open: $lfn: $!\n"; }
elsif ( $lfn =~ m%.bz2$% )
{ open LFN, "cat $lfn | bzip2 -d - |" or die "open: $lfn: $!\n"; }
elsif ( $lfn =~ m%^-$% )
{ *LFN = *STDIN; }
else
{ open LFN, "<$lfn" or die "open: $lfn: $!\n"; }

while ( <LFN> )
{
  chomp;
  $debug && print "Read: $_\n";;
  s%^.*/store%/store%;
  s%\s.*$%%;
  $h{LFN}{$_}++;
  $_ = dirname $_;
  $_ =~ s%/\d+$%%;
  $h{DIR}{$_}{SE}++;
}

if ( $verbose )
{
  print " #files  : directory\n";
  foreach ( sort keys %{$h{DIR}} )
  {
    printf("%8d : %s\n",$h{DIR}{$_}{SE},$_);
  }
  print "\n";
}
printf "Got %8d LFNs in %5d directories\n",
       scalar keys %{$h{LFN}},
       scalar keys %{$h{DIR}};

#-------------------------------------------------------------------------------
foreach my $dir ( keys %{$h{DIR}} )
{
# $verbose && print "Process $dir\n";
  my $tmp = getLFNsFromWildCard( $dir . '%' );
  foreach ( @{$tmp} )
  {
    delete $h{LFN}{$_};
    $_ = dirname $_;
    $_ =~ s%/\d+$%%;
    $h{DIR}{$_}{TMDB}++;
  }
  $verbose && print scalar keys %{$h{LFN}}, " files left...    \r";
}
$verbose && print "\n";

$dbh->disconnect();

print "Orphaned file summary:\n";
print join("\n", sort keys %{$h{LFN}}), "\n";
print "Final score: ", scalar keys %{$h{LFN}}, " files left...\n";

print "\n";
print "Directory summary:\n";
print "       SE/TMDB  diff : Directory\n";
foreach ( sort keys %{$h{DIR}} )
{
  $h{DIR}{$_}{TMDB} += 0;
  if ( $h{DIR}{$_}{SE} != $h{DIR}{$_}{TMDB} )
  {
    my $x = sprintf "%d/%d", $h{DIR}{$_}{SE}, $h{DIR}{$_}{TMDB};
    my $y = $h{DIR}{$_}{SE} - $h{DIR}{$_}{TMDB};
    printf "%13s %8d : %s\n", $x, $y, $_;
  }
}

print "\nFinished...\n";

#-------------------------------------------------------------------------------
sub getLFNsFromWildCard
{
  my $sql =
	qq {select logical_name from t_dps_file where logical_name like :lfn };
  my %p = ( ":lfn" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub select_single
{
  my ( $query, %param ) = @_;
  my ($q,@r);

  $q = execute_sql( $query, %param );
  @r = map {$$_[0]} @{$q->fetchall_arrayref()};
  return \@r;
}

#-------------------------------------------------------------------------------
sub execute_sql
{
  my ( $query, %param ) = @_;
  my ($q,$r);

  if ( $query =~ m%\blike\b%i )
  {
    foreach ( keys %param ) { $param{$_} =~ s%_%\\_%g; }
    $query =~ s%like\s+(:[^\)\s]+)%like $1 escape '\\' %gi;
  }

  if ( $debug )
  {
    print " ==> About to execute\n\"$query\"\nwith\n";
    foreach ( sort keys %param ) { print "  \"$_\" = \"$param{$_}\"\n"; }
    print "\n";
  }
  $q = &dbexec($dbh, $query, %param);
  return $q;
}
