#!/bin/sh

##H This is a "srmcp"-like script using FTS to transfer files.
##H
##H Usage: ftscp -copyjobfile=FILE [-report=FILE] -passfile=FILE
##H              [-server=SERVER-ACCESS-POINT]
##H
##H Takes a list of source/destination file pairs and copies them
##H using FTS.  The files must be given through a "copyjob" file,
##H with one "SOURCE DESTINATION" line per file copy, the names
##H separated with a single space character, and no leading or
##H trailing white space.
##H
##H If the "-report" option is used, the status of each file copy
##H is written in there.  The exit code from the command is zero
##H if all the files have been copied successfuly, otherwise non-
##H zero; the details can be found in the report file.
##H
##H The "-passfile" specifies the file name from which to read the
##H the password for FTS MyProxy password.  This option is required,
##H and the file must be readable and writeable only by the user or
##H the command will fail.
##H
##H The "-server" option specifies the FTS entry point.  If this
##H option is not used, gLite service discovery is used.

usage() { grep '^##H' < $0 | sed 's/^\(##H \|##H$\)//'; exit 1; }

# Pick up options
report=/dev/null copyjob= passfile= server=
for arg; do
  case $arg in
    -copyjobfile=* )
      copyjobfile="${arg#-copyjobfile=}"
      echo "copyjobfile=$copyjobfile"
      cat $copyjobfile 2>/dev/null
     ;;
    -report=* )
      report="${arg#-report=}"
      echo "report=$report"
      ;;
    -passfile=*)
      passfile="${arg#-passfile=}"
      echo "passfile=$passfile"
      ;;
    -server=* )
      server="${arg#-server=}"
      echo "server=$server"
      ;;
    -h )
      usage;;
    -* )
      echo "unrecognised option $1" 1>&2; exit 1 ;;
    * )
      break ;;
  esac
done

# Verify arguments
[ -z "$copyjobfile" ] && { echo "Missing -copyjobfile, use -h for help." 1>&2; exit 1; }
[ ! -f "$copyjobfile" ] && { echo "$copyjobfile: no such file" 1>&2; exit 2; }
[ ! -r "$copyjobfile" ] && { echo "$copyjobfile: cannot read" 1>&2; exit 3; }
[ -z "$passfile" ] && { echo "Missing -passfile, use -h for help." 1>&2; exit 4; }
[ ! -f "$passfile" ] && { echo "$passfile: no such file" 1>&2; exit 5; }
[ ! -r "$passfile" ] && { echo "$passfile: cannot read" 1>&2; exit 6; }
case $(ls -l "$passfile" 2>/dev/null | awk '{print $1}') in ????------ ) ;;
  * ) echo "$passfile: password file has vulnerable file access permissions" 1>&2;
      echo "$passfile: please restrict with 'chmod 600 $passfile'" 1>&2; exit 7;;
esac

if [ -z "$server" ]; then :; else
  server="-s $server"
fi

# Create FTS transfer job
# FIXME: signal handling
ftsjob=
# trap 1 2 15 's=$?; [ -z "$ftsjob" ] || glite-transfer-cancel $ftsjob; exit $s'

# Create a FTS transfer request.
echo "+ glite-transfer-submit -p _censored_ $server -f $copyjobfile"
ftsjob=$(glite-transfer-submit -p $(cat "$passfile") $server -f $copyjobfile)
echo "ftsjob=$ftsjob"

# Poll transfer status, record output into the report
while true; do
  # FIXME: we need to be recording per-file status, not just the job!
  echo "sleeping 10"
  sleep 10 
  echo "+ glite-transfer-status $server $ftsjob"
  ftsstatus=$(glite-transfer-status $server $ftsjob)
  echo "$ftsjob status is $ftsstatus"
  case $ftsstatus in
    Submitted )
      # [FIXME] need to just ignore this transient state
      ;;

    Pending )
      # [FIXME] Need something smarter here, adaptive sleep based on
      # how much has been done and remains to be done.
      ;;

    Active )
      ;;

    Canceled )
      # [FIXME] how can I find it Canceled?
      ;;

    Hold )
      # [FIXME] what to do in this case?
      echo "+ glite-transfer-cancel $server $ftsjob"
      glite-transfer-cancel $server $ftsjob
      exit 8
      ;;

    Done | Failed )
      # Job done, record report file, quit
      echo "+ glite-transfer-status -l $server $ftsjob"
      glite-transfer-status -l $server $ftsjob |
        while read item arg; do
	  case $item in
	    Source: )
	      src="$arg" ;;
	    Destination:)
	      dest="$arg" ;;
	    State: )
	      case $arg in
	        Done ) status="0" state="$arg" ;;
		*    ) status="1" state="$arg" ;;
	      esac;;
	    Reason: )
	      echo "$src $dest $status $state $arg" ;;
	  esac
	done > "$report"

      echo "+ glite-transfer-status -l $server $ftsjob"
      if glite-transfer-status -l $server $ftsjob | \
	 grep State: | grep -v Done >/dev/null; then
	exit 1
      else
        exit 0
      fi
      ;;

    * )
      echo "ftscp: unexpected job status $ftsstatus" 1>&2
      exit 4
      ;;
  esac
done
