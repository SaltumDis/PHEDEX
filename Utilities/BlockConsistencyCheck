#!/usr/bin/env perl
use strict;

##H
##H  Compare file size (and checks tape migration if possible) for files on
##H  storage vs. TMDB for blocks or datasets
##H
##H   Usage:
##H
##H   BlockConsistencyCheck -db DBCONFIG -buffer BUFFER -tfc TFC
##H                        [-dataset DATASET] [-block BLOCK] [-verbose]
##H                        [-tfcprotocol TFCPROTOCOL]
##H                        [-mssprotocol MSSPROTOCOL]
##H 
##H   DBCONFIG is the usual PhEDEx DB contact file.
##H   TFC is the path to your trivial file catalogue
##H
##H   BUFFER is the name of one or more buffers that you wish to verify.
##H   If you specify more than one buffer, they should support access by
##H   the same technology (rfio, srm, ...). You can specify multiple
##H   buffers as a comma-separated list, or using the '%' character as a
##H   wildcard, or by repeating the --buffer option, or any combination of
##H   the three.
##H
##H   One of DATASET or BLOCK is obligatory. These also support multiple
##H   values as comma-separated lists, or using the '%' wildcard, or by
##H   repeating the option.
##H 
##H   You can give both the DATASET and BLOCK options, in which case the
##H   script will take both into account.
##H
##H   TFCPROTOCOL is the protocol by which LFNs are converted to PFNs. By
##H   default, 'direct' is used, and the namespace-check is then done using
##H   the 'technology' registered for your buffers in TMDB (so a castor site
##H   will use nsls, for example). Currently the only alternative that I know
##H   works is 'srm', DPM and dCache-related alternatives are untested.
##H
##H   MSSPROTOCOL is the protocol by which your SE should be accessed.
##H   Normally this should be deducible from your entry in TMDB, so you
##H   shouldn't need to worry about it.
##H
##H   EXAMPLES:
##H
##H   BlockConsistencyCheck -db ~/private/DBParam:Prod/Reader
##H      -buffer T1_CERN_%
##H      -block '/Minbias/CMSSW_1_4_3-CSA07-1911/GEN-SIM#ff6c979f-377f-47e2-af3b-ec7841baa581'
##H   
##H   BlockConsistencyCheck -db ~/private/DBParam:Prod/Reader
##H      -buffer T1_CERN_%
##H      -block '/Minbias/CMSSW_1_4_3-CSA07-1911/GEN-SIM#ff6c979f%'
##H      --tfcprotocol srm
##H   

##H

BEGIN {
    $^W = 1; use strict; use warnings;
    our $me = $0; $me =~ s|.*/||;
    our $home = $0;
    if ( $home !~ m%/% ) { $home = '.'; }
    $home =~ s|/[^/]+$||;
    $home ||= ".";
    $home .= "/../Toolkit/Common";
    unshift(@INC, $home);
}

# Process command line arguments.
use Getopt::Long;
use Data::Dumper;
use File::Basename;
use UtilsHelp;
use UtilsDB;
use UtilsCatalogue;
use UtilsNamespace;

my ($dbh,$not_on_tape_time);
my ($verbose,$debug,$terse);
my (%h,$conn,$dumpstats,$readstats,$msscache,%msscache);
my ($DBCONFIG,%check,@check);
my (@DATASET,@BLOCK,@LFN,@BUFFER);
my (@dataset,@block,@lfn,@buffer,@bufferIDs);
my ($callout,$callouton,%calloutonAllowed);
my ($data,$lfn,$wide);
my ($tfcprotocol,$mssprotocol,$destination,$tfc,$ns);
my (%info_Files_TMDB,$szcast,$to_tape);
my ($sec_sample,$min_sample,$hour_sample,$day_sample,$month_sample,$year_sample);
my $debug_me = 1;

$not_on_tape_time = 12; # in hour(s)

%check = (
		'Size'		=> 1,
#		'Migration'	=> 0,
#		'Cksum'		=> 0,
#		'DBS'		=> 0,
	 );

$verbose = $debug = $terse = 0;
$tfcprotocol = 'direct';
$mssprotocol = '';
$destination = 'any';
$callouton   = '';
%calloutonAllowed = ( failure => 1, success => 1, all => 1);

#$tfc='/afs/cern.ch/user/w/wildish/public/COMP/SITECONF/CERN/PhEDEx/storage.xml';
GetOptions("db=s"           => \$DBCONFIG,
           "block=s@"       => \@BLOCK,
           "dataset=s@"     => \@DATASET,
           "lfn=s@"         => \@LFN,
	   "buffer=s@"	    => \@BUFFER,
	   "tfc=s"	    => \$tfc,
	   "tfcprotocol=s"  => \$tfcprotocol,
	   "mssprotocol=s"  => \$mssprotocol,

	   "check=s@"	    => \@check,

           "verbose|v+"     => \$verbose,
           "debug+"         => \$debug,
           "terse"          => \$terse,
           "readstats=s"    => \$readstats,
           "dumpstats=s"    => \$dumpstats,
           "msscache=s"     => \$msscache,

           "wide"           => \$wide,
           "callout=s"      => \$callout,
           "callouton=s"    => \$callouton,

           "migrationdelay" => \$not_on_tape_time,

           "help|h"         => sub { &usage() }
	  );

$ns = UtilsNamespace->new( verbose => $verbose, debug => $debug );
$mssprotocol = 'srm' if $tfcprotocol eq 'srm';
$ns->protocol( $mssprotocol ) if $mssprotocol;

if ( $callouton && ! exists($calloutonAllowed{$callouton}) )
{
  die "callouton='$callouton' not valid. Legal values are: '",
       join("', '",keys %calloutonAllowed), "'\n";
}
if ( $callout && !$callouton ) { $callouton = 'success'; }

# Check arguments.
if( !$DBCONFIG ||
    !@BUFFER   ||
    ( !@BLOCK      &&
      !@DATASET    &&
      !@LFN
    ) ||
    !$tfc
  )
{
  die "Insufficient parameters, use -h for help.\n";
}

#-------------------------------------------------------------------------------
# Which integrity checks are we going to run?
foreach ( split m|[,\s*]|, "@check" )
{
  my $v = 1;
  if ( s%^no%% ) { $v = 0; }
  my $k = $_;

  if ( !defined($check{$k}) )
  {
    print "Unknown check \"$_\" requested. Known checks are: ",
	join(', ',
		map { "\"$_\"(" . $check{$_} . ")" } sort keys %check),
	"\n";
    exit 1;
  }
  $check{$k} = $v;
}

my $nchecks=0;
$verbose >= 2 && print "Perform the following checks:\n";
foreach ( sort keys %check )
{
  $verbose >= 2 && printf " %10s : %3s\n", $_, ($check{$_} ? 'yes' : 'no');
  $nchecks += $check{$_};
}
die "Woah, nothing to check!\n" unless $nchecks;

#-------------------------------------------------------------------------------
#
# First, traverse-forward, expanding the arguments from the command line and
# finding the lower strata (buffers->datasets->blocks, blocks->lfns etc)
#
# Then, go backwards, and for all lfns make sure a block is known, for all
# blocks that a dataset is known, etc...
#

goto CHEAT if $readstats;
$conn = { DBCONFIG => $DBCONFIG };
$dbh = &connectToDatabase ( $conn, 0 );

#-------------------------------------------------------------------------------
# Buffers first...
# Expand the Buffer argument...
@buffer = split m|[,\s*]|, "@BUFFER";
foreach my $buffer ( @buffer )
{
  $debug && print "Getting buffers with names like '$buffer'\n";
  my $tmp = getBufferFromWildCard($buffer);
  map { $h{Buffers}{ID}{$_} = $tmp->{$_} } keys %$tmp;
}
$debug && exists($h{Buffers}{ID}) && print "done getting buffers!\n";
@bufferIDs = sort keys %{$h{Buffers}{ID}};

# Check the technologies!
my %t;
map { $t{$h{Buffers}{ID}{$_}{TECHNOLOGY}}++ } @bufferIDs;
die "Woah, too many technologies! (",join(',', keys %t),")\n" if ( scalar keys %t > 1 );
$ns->technology( (keys %t)[0] ) unless $mssprotocol;

#-------------------------------------------------------------------------------
# Datasets next...

# Expand the Dataset argument...
@dataset = split m|[,\s*]|, "@DATASET";
@block = ();
foreach $data ( @dataset )
{
  $debug && print "Getting datasets with names like '$data'\n";
  my $tmp = getDatasetFromWildCard($data);
  map { $h{Datasets}{$_} = {} } @$tmp;
}

# For all known Datasets, get the Block list...
foreach $data ( keys %{$h{Datasets}} )
{
  $debug && print "Getting blocks for dataset '$data'\n";
  my $tmp = getBlocksFromDataset($data);
  map { $h{Blocks}{$_}{Dataset} = $data;
        $h{Datasets}{$data}{Blocks}{$_}++;
      } @$tmp;
}
$debug && exists($h{Datasets}) && print "done getting datasets!\n";

#-------------------------------------------------------------------------------
# Blocks next...

# Expand the BLOCK argument...
push @block, split m|[,\s*]|, "@BLOCK";
if ( @block )
{
# Find those I want and mark them, then GC the rest...
  my %g;
  foreach my $block ( @block )
  {
    $debug && print "Getting blocks with names like '$block'\n";
    my $tmp = getBlocksFromWildCard ($block);
    map { $g{$_}++ } @$tmp;
    map { $h{Blocks}{$_} = {} } @$tmp;
  }
  foreach my $block ( keys %{$h{Blocks}} )
  {
    defined($g{$block}) or delete $h{Blocks}{$block};
  }
}

#-------------------------------------------------------------------------------
# Expand the LFN argument
#@lfn = split m|[,\s*]|, "@LFN";
#foreach my $lfn ( @lfn )
#{
#  $verbose >= 3 && print "Getting lfns with names like '$lfn'\n";
#  my $tmp = getLFNsFromWildCard($lfn);
#  map { $h{LFNs}{$_} = {} } @$tmp;
#}
#
#foreach my $lfn ( keys %{$h{LFNs}} )
#{
#  next if exists($h{LFNs}{$lfn}{Block});
#  my $tmp = getBlocksFromLFN($lfn);
#  map { $h{LFNs}{$lfn}{Block} = $_   } @$tmp;
#  map { $h{Blocks}{$_}{LFNs}{$lfn}++ } @$tmp;
#}
#$debug && defined($h{LFNs}) && print "done getting LFNs!\n";

#-------------------------------------------------------------------------------
# Fill in relationships between Blocks and Datasets or LFNs. Do this after
# inserting LFNs because then {Blocks}{$b}{LFNs} will exist, so blocks which
# are inserted only because they match LFNs will not be expanded!
foreach my $block ( keys %{$h{Blocks}} )
{
  if ( !defined($h{Blocks}{$block}{Dataset}) )
  {
#   Set up Block<->Dataset mapping
    my $tmp = getDatasetsFromBlock($block);
    map { $h{Datasets}{$_}{Blocks}{$block}++ } @$tmp;
    map { $h{Blocks}{$block}{Dataset} = $_   } @$tmp;
  }

  if ( !defined($h{Blocks}{$block}{LFNs}) )
  {
#   Set up Block<->LFN mapping
    my $tmp = getLFNsFromBlock($block);
    map { $h{LFNs}{$_}{Block} = $block   } @$tmp;
    map { $h{Blocks}{$block}{LFNs}{$_}++ } @$tmp;
  }
}

$debug && print "done getting block-lfn mapping!\n\n";
printf "Got %8d Buffers\n",  scalar keys %{$h{Buffers}{ID}};
printf "Got %8d Datasets\n", scalar keys %{$h{Datasets}};
printf "Got %8d Blocks\n",   scalar keys %{$h{Blocks}};
printf "Got %8d LFNs\n",     scalar keys %{$h{LFNs}};

#-------------------------------------------------------------------------------
# Now to start extracting information to check against the storage
foreach my $lfn ( keys %{$h{LFNs}} )
{
  $debug and print "Getting TMDB stats for $lfn\n";
  my $tmp = getTMDBFileStats($lfn);
  map { $h{LFNs}{$lfn}{$_} = $tmp->{$_} } keys %{$tmp};
}

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# All TMDB lookups are done, from here on I compare with storage
$dbh->disconnect();

my %args = (
             PROTOCOL    => 'direct',
             DESTINATION => 'any',
             CATALOGUE   => '/afs/cern.ch/user/w/wildish/public/COMP/SITECONF/CERN/PhEDEx/storage.xml'
           );
foreach $lfn ( keys %{$h{LFNs}} )
{
  my $pfn = pfnLookup($lfn, $tfcprotocol, $destination, $tfc );
  $h{LFN}{$lfn}{PFN} = $pfn;
}

#-------------------------------------------------------------------------------
# Get the information needed for checking...

my ($t,$step,$last,$etc);
$step = 1;
$last = $t = 0;
if ( $check{Size} || $check{Migration} )
{
# Determine the castor size and migration status of the LFNs...
  my ($i,$j);
  $i = scalar keys %{$h{LFNs}};
  foreach $lfn ( keys %{$h{LFNs}} )
  {
    $j++;
    $h{SE}{$lfn} = $msscache{$lfn} if exists($msscache{$lfn});
    next if defined $h{SE}{$lfn};

    if ( time - $t > 1 )
    {
      print "Getting SE stats: file $j / $i";
      $t = time;
      if ( $last )
      {
        $etc = int( 10 * $step * ($i-$j)/($j-$last) ) / 10;
        print ". Done in $etc seconds  ";
        my $dt = $ns->proxy();
        if ( defined($dt) )
        {
          $dt -= time();
          if ( $dt < $etc || $dt < 300 ) { print "(proxy: $dt seconds left) "; }
          die "\nuh-oh, proxy expired. :-(\n" if $dt < 0;
        }
      }
      $last = $j;
      print "\r";
    }

    my $pfn = $h{LFN}{$lfn}{PFN};
    $h{SE}{$lfn} = {};

    my $sesize = $ns->statsize($h{LFN}{$lfn}{PFN});
    if ( defined($h{SE}{$lfn}{Size} = $sesize) )
    {
      $h{SE}{$lfn}{Migration} = $ns->statmode($h{LFN}{$lfn}{PFN});
    }
  }
}
$verbose && print "\n";

#-------------------------------------------------------------------------------
# Has the user requested that we dump the hash for future use?
if ( $dumpstats )
{
  open DUMP, ">$dumpstats" or die "Cannot open \"$dumpstats\" for writing\n";
  print DUMP Data::Dumper->Dump([ \%h ], [ 'h' ]);
  close DUMP;
  print "TMDB data dumped to \"$dumpstats\"\n";
  exit 0;
}

CHEAT:
if ( $readstats )
{
  eval
  {
    do "$readstats";
    map { $h{$_} = delete $main::h->{$_} } keys %{$main::h};
  };
  if ( $@ )
  {
    die "Cannot read $readstats: $@\n";
    exit 1;
  }
}

#-------------------------------------------------------------------------------
# Now to start doing the checks.
if ( $check{Size} )
{
  foreach $lfn ( keys %{$h{SE}} )
  {
#   Don't care about files not in TMDB
    next unless exists $h{LFNs}{$lfn};


    my $block   = $h{LFNs}{$lfn}{Block} or
				 die "Cannot determine block for $lfn\n";
    my $dataset = $h{Blocks}{$block}{Dataset} or
				 die "Cannot determine dataset for $block\n";

    my ($field);
    if ( defined($h{SE}{$lfn}{Size}) )
    {
      if ( $h{LFNs}{$lfn}{Size} == $h{SE}{$lfn}{Size} ) { $field = 'OK'; }
      else { $field = 'SizeMismatch'; }
$DB::single=$debug_me;
      $h{Checks}{Size}{Dataset}{$dataset}{Size} += $h{LFNs}{$lfn}{Size};
      $h{Checks}{Size}{Blocks} {$block}  {Size} += $h{LFNs}{$lfn}{Size};
#      $_ = dirname $lfn;
#      $h{Checks}{Paths}{Dataset}{$dataset}{$_}++;
#      $h{Checks}{Paths}{Blocks} {$block}  {$_}++;
    }
    else { $field = 'Missing'; }
    $h{Checks}{Size}{Dataset}{$dataset}{$field}++;
    $h{Checks}{Size}{Blocks} {$block}  {$field}++;
    $h{Checks}{Size}{LFNs}   {Total}   {$field}++;

    if ( $field ne 'OK' ) { $h{Detail}{$dataset}{$block}{$lfn}{$field}++; }
    $h{LFNs}{$lfn}{$field}++;
  }
}

if ( $check{Migration} )
{
  foreach $lfn ( keys %{$h{SE}} )
  {
#   Don't care about files not in TMDB
    next unless exists $h{LFNs}{$lfn};


    my $block   = $h{LFNs}{$lfn}{Block} or
				 die "Cannot determine block for $lfn\n";
    my $dataset = $h{Blocks}{$block}{Dataset} or
				 die "Cannot determine dataset for $block\n";

    my $field = 'Errors';
    if ( defined($h{SE}{$lfn}{Migration}) )
    {
      $field = $h{SE}{$lfn}{Migration} ? 'OK' : 'NotOnTape';
    }
    else { $field = 'Missing'; }
    $h{Checks}{Migration}{Dataset}{$dataset}{$field}++;
    $h{Checks}{Migration}{Blocks} {$block}  {$field}++;
    $h{Checks}{Migration}{LFNs}   {Total}   {$field}++;

    if ( $field ne 'OK' ) { $h{Detail}{$dataset}{$block}{$lfn}{$field}++; }
  }
}

# Print report
print "\n";
my ($check,$k,$l,$m);
$DB::single=1;
foreach $k ( qw / LFNs Blocks Dataset / )
{
  print "#------------------------------------------------------------------\n";
  print " ==> summarising $k\n";
  foreach $check ( sort keys %{$h{Checks}} )
  {
    print " checking \"$check\"\n\n";
    foreach $l ( sort keys %{$h{Checks}{$check}{$k}} )
    {
      print $wide ? "check=$check $k=$l " : " $l\n";
      foreach $m ( sort keys %{$h{Checks}{$check}{$k}{$l}} )
      {
        if ( $m eq 'Size' )
        {
          next unless $verbose;
          my $n = $h{Checks}{$check}{$k}{$l}{$m};
          $n = int($n*100/1024/1024/1024)/100;
          $h{Checks}{$check}{$k}{$l}{$m} = "$n GB";
        }
        print " $m=",$h{Checks}{$check}{$k}{$l}{$m};
      }
      print "\n\n";
    }
  }
}

print "#------------------------------------------------------------------\n";
if ( ! keys %{$h{Detail}} )
{
  print "There were no failures detected!\n";
}
elsif ( $verbose >= 2 )
{
  print " Detailed list of failures:\n";
  foreach my $dataset ( sort keys %{$h{Detail}} )
  {
    print " ==> Dataset=$dataset\n";
    foreach my $block ( sort keys %{$h{Detail}{$dataset}} )
    {
      print " ==> Block=$block\n";
      foreach my $lfn ( sort keys %{$h{Detail}{$dataset}{$block}} )
      {
        print "     LFN=$lfn ";
        print join(' ', sort keys %{$h{Detail}{$dataset}{$block}{$lfn}} ),"\n";
      }
    }
  }
}

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#return a hash with size and checksum keys for an lfn from TMDB
sub getTMDBFileStats
{
  my $sql = qq {select logical_name, checksum, filesize from t_dps_file
                where logical_name like :filename };
  my $l = shift @_;
  my %p = ( ":filename" => $l );
  my $r = select_hash( $sql, 'LOGICAL_NAME', %p );
  my $s;
  $s->{Size} = $r->{$l}->{FILESIZE};
  foreach ( split( '[,;#$%/\s]+', $r->{$l}->{CHECKSUM} ) )
  {
    my ($k,$v) = m%^\s*([^:]+):(\S+)\s*$%;
    $s->{$k} = $v;
  }
  return $s;
}

#-------------------------------------------------------------------------------
sub getLFNsFromBlock
{
  my $sql = qq {select logical_name from t_dps_file where inblock in
	        (select id from t_dps_block where name like :block)};
  my %p = ( ":block" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub getBlocksFromLFN
{
  my $sql = qq {select name from t_dps_block where id in
      (select inblock from t_dps_file where logical_name like :lfn )};
  my %p = ( ":lfn" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub getDatasetsFromBlock
{
  my $sql = qq {select name from t_dps_dataset where id in
		(select dataset from t_dps_block where name like :block ) };
  my %p = ( ":block" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub getBlocksFromDataset
{
  my $sql = qq {select name from t_dps_block where dataset in
                (select id from t_dps_dataset where name like :dataset ) };
  my %p = ( ":dataset" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub getLFNsFromWildCard
{
  my $sql =
	qq {select logical_name from t_dps_file where logical_name like :lfn };
  my %p = ( ":lfn" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub getBlocksFromWildCard
{
  my $sql = qq {select name from t_dps_block where name like :block_wild};
  my %p = ( ":block_wild" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
# with wildcard 
sub getDatasetFromWildCard
{
  my $sql = qq {select name from t_dps_dataset where name like :dataset_wild };
  my %p = ( ":dataset_wild" => @_ );
  my $r = select_single( $sql, %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub getBufferFromWildCard
{
  my $sql =
	qq {select id, name, technology from t_adm_node where name like :node };
  my %p = ( ":node" => @_ );
  my $r = select_hash( $sql, 'ID', %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub getBlocksOnBuffer
{
  my $sql =
        qq {select node, is_active, node_files, files, is_open, b.name block
	from t_dps_block b join t_dps_block_replica br on br.block = b.id
        join t_adm_node n on n.id = br.node
	where n.name = :buffer };
  my %p = ( ":buffer" => @_ );
  my $r = select_hash( $sql, 'BLOCK', %p );
  return $r;
}

#-------------------------------------------------------------------------------
sub select_single
{
  my ( $query, %param ) = @_;
  my ($q,@r);

  $q = execute_sql( $query, %param );
  @r = map {$$_[0]} @{$q->fetchall_arrayref()};
  return \@r;
}

#-------------------------------------------------------------------------------
sub select_hash
{
  my ( $query, $key, %param ) = @_;
  my ($q,$r);

  $q = execute_sql( $query, %param );
  $r = $q->fetchall_hashref( $key );

  my %s;
  map { $s{$_} = $r->{$_}; delete $s{$_}{$key}; } keys %$r;
  return \%s;
}

#-------------------------------------------------------------------------------
sub execute_sql
{
  my ( $query, %param ) = @_;
  my ($q,$r);

  if ( $query =~ m%\blike\b%i )
  {
    foreach ( keys %param ) { $param{$_} =~ s%_%\\_%g; }
    $query =~ s%like\s+(:[^\)\s]+)%like $1 escape '\\' %gi;
  }

  if ( $debug )
  {
    print " ==> About to execute\n\"$query\"\nwith\n";
    foreach ( sort keys %param ) { print "  \"$_\" = \"$param{$_}\"\n"; }
    print "\n";
  }
  $q = &dbexec($dbh, $query, %param);
  return $q;
}
