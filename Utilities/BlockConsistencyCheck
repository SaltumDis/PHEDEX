#!/usr/bin/env perl
use strict;

##H
##H  Compare file size (and checks tape migration if possible) for files on
##H  storage vs. TMDB for blocks or datasets
##H
##H  Check the PhEDEx Consistency tools page for more documentation. In
##H  particular, it will contain examples and clarifications to the basic
##H  information here. The page is in the CMS Twiki at
##H  https://twiki.cern.ch/twiki/bin/view/CMS/PhedexProjConsistency
##H
##H   Usage:
##H
##H   BlockConsistencyCheck -db DBCONFIG -buffer BUFFER -tfc TFC
##H                        [-dataset DATASET] [-block BLOCK] [-verbose]
##H                        [-tfcprotocol TFCPROTOCOL]
##H                        [-mssprotocol MSSPROTOCOL]
##H 
##H   DBCONFIG is the usual PhEDEx DB contact file.
##H
##H   TFC is the path to your trivial file catalogue
##H
##H   BUFFER is the name of one or more buffers that you wish to verify.
##H   If you specify more than one buffer, they should support access by
##H   the same technology (rfio, srm, ...). You can specify multiple
##H   buffers as a comma-separated list, or using the '%' character as a
##H   wildcard, or by repeating the --buffer option, or any combination of
##H   the three.
##H
##H   One of DATASET or BLOCK is obligatory. These also support multiple
##H   values as comma-separated lists, or using the '%' wildcard, or by
##H   repeating the option.
##H 
##H   You can give both the DATASET and BLOCK options, in which case the
##H   script will take both into account.
##H
##H   TFCPROTOCOL is the protocol by which LFNs are converted to PFNs. By
##H   default, 'direct' is used, and the namespace-check is then done using
##H   the 'technology' registered for your buffers in TMDB (so a castor site
##H   will use nsls, for example). Currently the only alternative that I know
##H   works is 'srm', DPM and dCache-related alternatives are untested.
##H
##H   MSSPROTOCOL is the protocol by which your SE should be accessed.
##H   Normally this should be deducible from your entry in TMDB, so you
##H   shouldn't need to worry about it.
##H
##H   EXAMPLES:
##H
##H   BlockConsistencyCheck -db ~/private/DBParam:Prod/Reader
##H      -buffer T1_CERN_%
##H      -block '/Minbias/CMSSW_1_4_3-CSA07-1911/GEN-SIM#ff6c979f-377f-47e2-af3b-ec7841baa581'
##H      --tfc ~/public/COMP/SITECONF/CERN/PhEDEx/storage.xml
##H   
##H   BlockConsistencyCheck -db ~/private/DBParam:Prod/Reader
##H      -buffer T1_CERN_%
##H      -block '/Minbias/CMSSW_1_4_3-CSA07-1911/GEN-SIM#ff6c979f%'
##H      --tfcprotocol srm
##H      --tfc ~/public/COMP/SITECONF/CERN/PhEDEx/storage.xml
##H   
##H

# Process command line arguments.
use Getopt::Long;
use Data::Dumper;
use File::Basename;
use PHEDEX::Core::Help;
use PHEDEX::Core::DB;
use PHEDEX::Core::Catalogue;
use PHEDEX::BlockConsistency::SQL;
use PHEDEX::Namespace;

my ($dbh,$not_on_tape_time);
my ($verbose,$debug,$terse);
my (%h,$conn,$dumpstats,$readstats,$msscache,%msscache);
my ($DBCONFIG,%check,@check,$autoBlock);
my (@DATASET,@BLOCK,@LFN,@BUFFER);
my (@dataset,@block,@lfn,@buffer,@bufferIDs);
my ($callout,$callouton,%calloutonAllowed);
my ($data,$lfn,$wide);
my ($tfcprotocol,$mssprotocol,$destination,$tfc,$ns);
my ($SQL);
my $debug_me = 1;

$not_on_tape_time = 12; # in hour(s)

%check = (
		'size'		=> 1,
 		'migration'	=> 0,
	        'ondisk'        => 0,
#		'cksum'		=> 0,
#		'dbs'		=> 0,
	 );

$verbose = $debug = $terse = $autoBlock = 0;
$tfcprotocol = 'direct';
$mssprotocol = '';
$destination = 'any';
$callouton   = '';
%calloutonAllowed = ( failure => 1, success => 1, all => 1);

#$tfc='/afs/cern.ch/user/w/wildish/public/COMP/SITECONF/CERN/PhEDEx/storage.xml';
GetOptions("db=s"           => \$DBCONFIG,
           "block=s@"       => \@BLOCK,
           "dataset=s@"     => \@DATASET,
           "lfn=s@"         => \@LFN,
	   "buffer=s@"	    => \@BUFFER,
	   "tfc=s"	    => \$tfc,
	   "tfcprotocol=s"  => \$tfcprotocol,
	   "mssprotocol=s"  => \$mssprotocol,

	   "check=s@"	    => \@check,

           "verbose|v+"     => \$verbose,
           "debug+"         => \$debug,
           "autoBlock"      => \$autoBlock,
           "terse"          => \$terse,
           "readstats=s"    => \$readstats,
           "dumpstats=s"    => \$dumpstats,
           "msscache=s"     => \$msscache,

           "wide"           => \$wide,
           "callout=s"      => \$callout,
           "callouton=s"    => \$callouton,

           "migrationdelay" => \$not_on_tape_time,

           "help|h"         => sub { &usage() }
	  );

$ns = PHEDEX::Namespace->new( verbose => $verbose, debug => $debug );
$mssprotocol = 'srm' if $tfcprotocol eq 'srm';
$ns->protocol( $mssprotocol ) if $mssprotocol;

if ( $callouton && ! exists($calloutonAllowed{$callouton}) )
{
  die "callouton='$callouton' not valid. Legal values are: '",
       join("', '",keys %calloutonAllowed), "'\n";
}
if ( $callout && !$callouton ) { $callouton = 'success'; }

# Check arguments.
if( !$DBCONFIG ||
    !@BUFFER   ||
    ( !@BLOCK      &&
      !@DATASET    &&
      !@LFN
    ) ||
    !$tfc
  )
{
  die "Insufficient parameters, use -h for help.\n";
}

#-------------------------------------------------------------------------------
# Which integrity checks are we going to run?
foreach ( split m|[,\s*]|, "@check" )
{
  my $v = 1;
  if ( s%^no%% ) { $v = 0; }
  my $k = lc($_);

  if ( !defined($check{$k}) )
  {
    print "Unknown check \"$_\" requested. Known checks are: ",
	join(', ',
		map { "\"$_\"(" . $check{$_} . ")" } sort keys %check),
	"\n";
    exit 1;
  }
  $check{$k} = $v;
}

my $nchecks=0;
$verbose >= 2 && print "Perform the following checks:\n";
foreach ( sort keys %check )
{
  $verbose >= 2 && printf " %10s : %3s\n", $_, ($check{$_} ? 'yes' : 'no');
  $nchecks += $check{$_};
}
die "Woah, nothing to check!\n" unless $nchecks;

#-------------------------------------------------------------------------------
#
# First, traverse-forward, expanding the arguments from the command line and
# finding the lower strata (buffers->datasets->blocks, blocks->lfns etc)
#
# Then, go backwards, and for all lfns make sure a block is known, for all
# blocks that a dataset is known, etc...
#

goto CHEAT if $readstats;
$conn = { DBCONFIG => $DBCONFIG };
$dbh = &connectToDatabase ( $conn, 0 );
$SQL = PHEDEX::BlockConsistency::SQL->new( DBH => $dbh );

#-------------------------------------------------------------------------------
# Buffers first...
# Expand the Buffer argument...
@buffer = split m|[,\s*]|, "@BUFFER";
foreach my $buffer ( @buffer )
{
  $debug && print "Getting buffers with names like '$buffer'\n";
  my $tmp = $SQL->getBuffersFromWildCard($buffer);
  map { $h{Buffers}{ID}{$_} = $tmp->{$_} } keys %$tmp;
}
$debug && exists($h{Buffers}{ID}) && print "done getting buffers!\n";
@bufferIDs = sort keys %{$h{Buffers}{ID}};
@bufferIDs or die "No buffers found matching \"@BUFFER\", typo perhaps?\n";

# Check the technologies!
my %t;
map { $t{$h{Buffers}{ID}{$_}{TECHNOLOGY}}++ } @bufferIDs;
die "Woah, too many technologies! (",join(',', keys %t),")\n" if ( scalar keys %t > 1 );
$ns->technology( (keys %t)[0] ) unless $mssprotocol;

#-------------------------------------------------------------------------------
# Datasets next...

#
# Here I cheat. Dataset names are simply short forms of block names, so I
# add a wildcard to the dataset name and call it a block!
#
# Cunning, eh?
#

@dataset = split m|[,\s*]|, "@DATASET";
@block = map { $_ . '%' } @dataset;

#-------------------------------------------------------------------------------
# Blocks next...

# Expand the BLOCK argument...
push @block, split m|[,\s*]|, "@BLOCK";
if ( @block )
{
# Find those I want and mark them, then GC the rest...
  my %g;
  foreach my $block ( @block )
  {
    $debug && print "Getting blocks with names like '$block'\n";
    my $tmp = $SQL->getBlocksOnBufferFromWildCard ($block,@bufferIDs);
    map { $g{$_}++ } @$tmp;
    map { $h{Blocks}{$_} = {} } @$tmp;
  }
  foreach my $block ( keys %{$h{Blocks}} )
  {
    if ( ! defined($g{$block}) )
    {
      my $data = $h{Blocks}{$block}{Dataset};
      delete $h{Datasets}{$data}{Blocks}{$block};
      delete $h{Blocks}{$block};
    }
  }
}

#-------------------------------------------------------------------------------
# Expand the LFN argument
@lfn = split m|[,\s*]|, "@LFN";
foreach my $lfn ( @lfn )
{
  $verbose >= 3 && print "Getting lfns with names like '$lfn'\n";
  my $tmp = $SQL->getLFNsFromWildCard($lfn);
  map { $h{LFNs}{$_} = {} } @$tmp;
}

foreach my $lfn ( keys %{$h{LFNs}} )
{
  next if exists($h{LFNs}{$lfn}{Block});
  my $tmp = $SQL->getBlocksFromLFNs($lfn);
  map { $h{LFNs}{$lfn}{Block} = $_   } @$tmp;
  map { $h{Blocks}{$_}{LFNs}{$lfn}++ } @$tmp;
}
$debug && defined($h{LFNs}) && print "done getting LFNs!\n";

#-------------------------------------------------------------------------------
# Fill in relationships between Blocks and Datasets or LFNs. Do this after
# inserting LFNs because then {Blocks}{$b}{LFNs} will exist, so blocks which
# are inserted only because they match LFNs will not be expanded!
foreach my $block ( keys %{$h{Blocks}} )
{
  if ( !defined($h{Blocks}{$block}{Dataset}) )
  {
#   Set up Block<->Dataset mapping
    my $tmp = $SQL->getDatasetsFromBlocks($block);
    map { $h{Datasets}{$_}{Blocks}{$block}++ } @$tmp;
    map { $h{Blocks}{$block}{Dataset} = $_   } @$tmp;
  }

  if ( $autoBlock || !defined($h{Blocks}{$block}{LFNs}) )
  {
#   Set up Block<->LFN mapping
    my $tmp = $SQL->getLFNsFromBlocks($block);
    map { $h{LFNs}{$_}{Block} = $block   } @$tmp;
    map { $h{Blocks}{$block}{LFNs}{$_}++ } @$tmp;
  }
}

$debug && print "done getting block-lfn mapping!\n\n";
printf "Got %8d Buffers\n",  scalar keys %{$h{Buffers}{ID}};
printf "Got %8d Datasets\n", scalar keys %{$h{Datasets}};
printf "Got %8d Blocks\n",   scalar keys %{$h{Blocks}};
printf "Got %8d LFNs\n",     scalar keys %{$h{LFNs}};

#-------------------------------------------------------------------------------
# Now to start extracting information to check against the storage
foreach my $lfn ( keys %{$h{LFNs}} )
{
  $debug and print "Getting TMDB stats for $lfn\n";
  my $tmp = $SQL->getTMDBFileStats($lfn);
  map { $h{LFNs}{$lfn}{lc($_)} = $tmp->{$_} } keys %{$tmp};
}

#-------------------------------------------------------------------------------
# All TMDB lookups are done, from here on I compare with storage
$dbh->disconnect();

my %args = (
             PROTOCOL    => 'direct',
             DESTINATION => 'any',
             CATALOGUE   => '/afs/cern.ch/user/w/wildish/public/COMP/SITECONF/CERN/PhEDEx/storage.xml'
           );
foreach $lfn ( keys %{$h{LFNs}} )
{
  my $pfn = pfnLookup($lfn, $tfcprotocol, $destination, $tfc );
  $h{LFN}{$lfn}{PFN} = $pfn;
}

#-------------------------------------------------------------------------------
# Get the information needed for checking...

my ($t,$step,$last,$etc);
$step = 1;
$last = $t = 0;
if ( $check{size} || $check{migration} || $check{ondisk} )
{
# Determine the castor size and migration status of the LFNs...
  my ($i,$j);
  $i = scalar keys %{$h{LFNs}};
  foreach $lfn ( keys %{$h{LFNs}} )
  {
    $j++;
    $h{SE}{$lfn} = $msscache{$lfn} if exists($msscache{$lfn});
    next if defined $h{SE}{$lfn};

    if ( time - $t > 1 )
    {
      print STDERR "Getting SE stats: file $j / $i";
      $t = time;
      if ( $last )
      {
        $etc = int( 10 * $step * ($i-$j)/($j-$last) ) / 10;
        print STDERR ". Done in $etc seconds  ";
      }
      $last = $j;
      print STDERR "\r";
    }

    my $pfn = $h{LFN}{$lfn}{PFN};
    $h{SE}{$lfn} = {};

    my $sesize = $ns->statsize($h{LFN}{$lfn}{PFN});
    if ( defined($h{SE}{$lfn}{size} = $sesize) )
    {
      $h{SE}{$lfn}{migration} = $ns->statmode($h{LFN}{$lfn}{PFN});
      $h{SE}{$lfn}{ondisk}    = $ns->statondisk($h{LFN}{$lfn}{PFN});
    }
  }
}
print STDERR "\n";

#-------------------------------------------------------------------------------
# Has the user requested that we dump the hash for future use?
if ( $dumpstats )
{
  open DUMP, ">$dumpstats" or die "Cannot open \"$dumpstats\" for writing\n";
  print DUMP Data::Dumper->Dump([ \%h ], [ 'h' ]);
  close DUMP;
  print "TMDB data dumped to \"$dumpstats\"\n";
  exit 0;
}

CHEAT:
if ( $readstats )
{
  eval
  {
    do "$readstats";
    map { $h{$_} = delete $main::h->{$_} } keys %{$main::h};
  };
  if ( $@ )
  {
    die "Cannot read $readstats: $@\n";
    exit 1;
  }
}

#-------------------------------------------------------------------------------
# Now to start doing the checks.
if ( $check{size} )
{
  foreach $lfn ( keys %{$h{SE}} )
  {
#   Don't care about files not in TMDB
    next unless exists $h{LFNs}{$lfn};


    my $block   = $h{LFNs}{$lfn}{Block} or
				 die "Cannot determine block for $lfn\n";
    my $dataset = $h{Blocks}{$block}{Dataset} or
				 die "Cannot determine dataset for $block\n";

    my ($field);
    if ( defined($h{SE}{$lfn}{size}) )
    {
      if ( $h{LFNs}{$lfn}{size} == $h{SE}{$lfn}{size} ) { $field = 'OK'; }
      else { $field = 'SizeMismatch'; }
      $h{Checks}{size}{Dataset}{$dataset}{size} += $h{LFNs}{$lfn}{size};
      $h{Checks}{size}{Blocks} {$block}  {size} += $h{LFNs}{$lfn}{size};
#      $_ = dirname $lfn;
#      $h{Checks}{Paths}{Dataset}{$dataset}{$_}++;
#      $h{Checks}{Paths}{Blocks} {$block}  {$_}++;
    }
    else { $field = 'Missing'; }
    $h{Checks}{size}{Dataset}{$dataset}{$field}++;
    $h{Checks}{size}{Blocks} {$block}  {$field}++;
    $h{Checks}{size}{LFNs}   {Total}   {$field}++;

    if ( $field ne 'OK' ) { $h{Detail}{$dataset}{$block}{$lfn}{$field}++; }
    $h{LFNs}{$lfn}{$field}++;
  }
}

if ( $check{migration} )
{
  foreach $lfn ( keys %{$h{SE}} )
  {
#   Don't care about files not in TMDB
    next unless exists $h{LFNs}{$lfn};


    my $block   = $h{LFNs}{$lfn}{Block} or
				 die "Cannot determine block for $lfn\n";
    my $dataset = $h{Blocks}{$block}{Dataset} or
				 die "Cannot determine dataset for $block\n";

    my $field = 'Errors';
    if ( defined($h{SE}{$lfn}{migration}) )
    {
      $field = $h{SE}{$lfn}{migration} ? 'OK' : 'NotOnTape';
    }
    else { $field = 'Missing'; }
    $h{Checks}{migration}{Dataset}{$dataset}{$field}++;
    $h{Checks}{migration}{Blocks} {$block}  {$field}++;
    $h{Checks}{migration}{LFNs}   {Total}   {$field}++;

    if ( $field ne 'OK' ) { $h{Detail}{$dataset}{$block}{$lfn}{$field}++; }
  }
}

if ( $check{ondisk} )
{
  foreach $lfn ( keys %{$h{SE}} )
  {
#   Don't care about files not in TMDB
    next unless exists $h{LFNs}{$lfn};


    my $block   = $h{LFNs}{$lfn}{Block} or
				 die "Cannot determine block for $lfn\n";
    my $dataset = $h{Blocks}{$block}{Dataset} or
				 die "Cannot determine dataset for $block\n";

    my $field = 'Errors';
    if ( defined($h{SE}{$lfn}{ondisk}) )
    {
      $field = $h{SE}{$lfn}{ondisk} ? 'OnDisk' : 'NotOnDisk';
    }
    else { $field = 'Missing'; }
    $h{Checks}{ondisk}{Dataset}{$dataset}{$field}++;
    $h{Checks}{ondisk}{Blocks} {$block}  {$field}++;
    $h{Checks}{ondisk}{LFNs}   {Total}   {$field}++;

    if ( $field ne 'OnDisk' ) { $h{Detail}{$dataset}{$block}{$lfn}{$field}++; }
  }
}

# Print report
print "\n";
my ($check,$k,$l,$m);
foreach $k ( qw / LFNs Blocks Dataset / )
{
  print "#------------------------------------------------------------------\n";
  print " ==> summarising $k\n";
  foreach $check ( sort keys %{$h{Checks}} )
  {
    print " checking \"$check\"\n\n";
    foreach $l ( sort keys %{$h{Checks}{$check}{$k}} )
    {
      print $wide ? "check=$check $k=$l " : " $l\n";
      foreach $m ( sort keys %{$h{Checks}{$check}{$k}{$l}} )
      {
        if ( $m eq 'size' )
        {
          next unless $verbose;
          my $n = $h{Checks}{$check}{$k}{$l}{$m};
          $n = int($n*100/1024/1024/1024)/100;
          $h{Checks}{$check}{$k}{$l}{$m} = "$n GB";
        }
        print " $m=",$h{Checks}{$check}{$k}{$l}{$m};
      }
      print "\n\n";
    }
  }
}

print "#------------------------------------------------------------------\n";
if ( ! keys %{$h{Detail}} )
{
  print "There were no failures detected!\n";
}
elsif ( $verbose )
{
  print " Detailed list of failures:\n";
  foreach my $dataset ( sort keys %{$h{Detail}} )
  {
    print " ==> Dataset=$dataset\n";
    foreach my $block ( sort keys %{$h{Detail}{$dataset}} )
    {
      print " ==> Block=$block\n";
      foreach my $lfn ( sort keys %{$h{Detail}{$dataset}{$block}} )
      {
        print "     LFN=$lfn ";
        print join(' ', sort keys %{$h{Detail}{$dataset}{$block}{$lfn}} ),"\n";
        if ( $verbose >= 2 )
        {
          print $ns->Raw($h{LFN}{$lfn}{PFN});
        }
      }
    }
  }
}
