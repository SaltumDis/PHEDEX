#!/usr/bin/env perl

##H Check whether files in DSB for a node exist in catalogue.
##H
##H Usage: DSBCheck [-h] [-dbitype TYPE] -db DBNAME -dbuser USER -dbpass PASS
##H                 -pfnquery COMMAND[,ARG...] -node NODE [PATTERN...]
##H
##H Generates summary information for each OWNER/DATASET pair
##H that matches PATTERNs.  Each PATTERN should be a shell glob
##H pattern for a OWNER/DATASET pair, e.g. "*/bt03_*".
##H
##H Prints out owner/dataset pair with three numbers:
##H  - number of files in the set
##H  - number of files at the node
##H  - number of files found in the specified catalogue

BEGIN { use strict; use warnings;
  my $me = $0; $me =~ s|.*/||;
  my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";
  unshift(@INC, "$home/../Toolkit/Common"); }
use UtilsDB;
use UtilsTR;
use UtilsWriters;
use UtilsCommand;
use UtilsLogging;
use UtilsCatalogue;
use TextGlob 'glob_to_regex';
use File::Path;

my %args = (DBITYPE => "Oracle");
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h' || $ARGV[0] eq '--help') {
	&usage();
    } elsif ($ARGV[0] eq '-dbitype' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBITYPE} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBNAME} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-dbuser' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBUSER} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-dbpass' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBPASS} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-pfnquery' && scalar @ARGV > 1) {
	shift (@ARGV); push(@{$args{PFN_QUERY}}, split (',', shift (@ARGV)));
    } elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1) {
	shift (@ARGV); $args{NODE} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-h' || $ARGV[0] eq '--help') {
	&usage();
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

$TextGlob::strict_wildcard_slash = 0;
$args{PATS} = [ map { &glob_to_regex($_) } @ARGV ];
if (!$args{DBITYPE} || !$args{DBNAME} || !$args{DBUSER} || !$args{DBPASS}
    || !$args{PFN_QUERY} || !$args{NODE})
{
    print STDERR "$0: Error: Not enough arguments",
		 " (help available with \"-h\" option)\n";
    exit (1);
}

# Connect to database
my $dbh = &connectToDatabase (\%args, 0);
$dbh->{FetchHashKeyName} = "NAME_uc";
$dbh->{LongReadLen} = 4096;

# Get all existing datasets and files
my $datasets = &dbexec($dbh, qq{select id, dataset, owner from t_dsb_dataset
				order by owner, dataset})
	       ->fetchall_arrayref ({});

# Get all current datasets
my $stmtcache = {};
foreach my $item (@$datasets)
{
    my $token = "$item->{OWNER}/$item->{DATASET}";
    next if (@ARGV && !grep($token =~ $_, @{$args{PATS}}));
    local $| = 1;
    print $token;

    # Generate drops
    &fetchDatasetInfo ($dbh, $item, $stmtcache);
    my @dsfiles = map { @{$_->{FILES}} } @{$item->{RUNS}};
    my $nfiles = scalar @dsfiles;
    my $onsite = grep ($_ eq $args{NODE}, @{$item->{SITES}}) ? $nfiles : 0;
    my @guids = map { $_->{GUID} } @dsfiles;
    my $pfns = &guidToPFN (\@guids, "direct", "local", @{$args{PFN_QUERY}});
    my $found = grep (defined $_, values %$pfns);
    print " $nfiles $onsite $found\n";
}

$dbh->disconnect ();
exit 0;

# Get dataset information
sub fetchDatasetInfo
{
    my ($dbh, $object, $stmtcache) = @_;

    # Prepare statements
    $stmtcache->{IGUID} ||= &dbprep ($dbh, qq{
	select guid from t_dsb_fileid where id = :fileid});
    $stmtcache->{IFILE} ||= &dbprep ($dbh, qq{
	select filesize, checksum, filename, catfragment from t_dsb_file where fileid = :fileid});
    $stmtcache->{IDR} ||= &dbprep ($dbh, qq{
	select runid from t_dsb_dataset_run where dataset = :dataset});
    $stmtcache->{IDRF} ||= &dbprep ($dbh, qq{
	select fileid from t_dsb_dataset_run_file where dataset = :dataset and runid = :runid});
    $stmtcache->{IDL} ||= &dbprep ($dbh, qq{
	select location from t_dsb_dataset_availability where dataset = :dataset});

    # Get dataset locations
    &dbbindexec ($stmtcache->{IDL}, ":dataset" => $object->{ID});
    while (my ($loc) = $stmtcache->{IDL}->fetchrow()) {
	push (@{$object->{SITES}}, $loc);
    }

    # Get runs and files
    &dbbindexec ($stmtcache->{IDR}, ":dataset" => $object->{ID});
    while (my ($runid) = $stmtcache->{IDR}->fetchrow ())
    {
	my $run = { ID => $runid, FILES => [] };
	push (@{$object->{RUNS}}, $run);
	&dbbindexec ($stmtcache->{IDRF}, ":dataset" => $object->{ID}, ":runid" => $runid);
	while (my ($fileid) = $stmtcache->{IDRF}->fetchrow ())
	{
	    &dbbindexec ($stmtcache->{IGUID}, ":fileid" => $fileid);
	    my ($guid) = $stmtcache->{IGUID}->fetchrow();

	    &dbbindexec ($stmtcache->{IFILE}, ":fileid" => $fileid);
	    my ($size, $cksum, $filename, $frag) = $stmtcache->{IFILE}->fetchrow();
	    push (@{$run->{FILES}}, { ID => $fileid,
				      GUID => $guid,
				      SIZE => $size,
				      CHECKSUM => $cksum,
				      LFN => $filename,
				      XML => $frag });
	}
    }

    $stmtcache->{IGUID}->finish ();
    $stmtcache->{IFILE}->finish ();
    $stmtcache->{IDRF}->finish ();
    $stmtcache->{IDR}->finish ();
    $stmtcache->{IDL}->finish ();
}
