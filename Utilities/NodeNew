#!/usr/bin/env perl

##H Create a new node with neighbours
##H
##H Usage:
##H   NodeNew -db DBCONFIG NODE:KIND [NEIGHBOUR[:LOCAL[:SHARE...]]...]
##H
##H Examples:
##H   NodeNew -db Schema/DBParam:Foo T2_Foo_Buffer:Disk T1_Bar_Buffer
##H   NodeNew -db Schema/DBParam:Foo T1_Foo_Buffer:Buffer T1_Foo_MSS:L T1_Xyzzy_Buffer
##H   NodeNew -db Schema/DBParam:Foo T1_Foo_Buffer:Disk T1_Bar_Buffer:R:1:1:1:1
##H
##H NODE is the name of the new node.
##H KIND is the kind of the new node: Disk, Buffer or MSS.
##H NEIGHBOUR is an existing neighbour node.
##H LOCAL is L for local links, R for remote, default is R.
##H SHARE is link priority share, default is 7:4:1:1

BEGIN {
  $^W = 1; use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments.
use Getopt::Long;
use UtilsHelp;
use UtilsDB;
use UtilsTiming;
&GetOptions ("db=s"        => \$args{DBCONFIG},
	     "help|h"      => sub { &usage() });

# Check arguments.
if (scalar @ARGV < 1 || !$args{DBCONFIG})
{
  die "Insufficient parameters, use -h for help.\n";
}

my $dbh = &connectToDatabase ({ DBCONFIG => $args{DBCONFIG} }, 0);

my $now = &mytimeofday();
my $node = shift(@ARGV);
die "$node: expected NODE:KIND\n" if $node !~ /^(\S+):(\S+)$/;
$node = $1;
my $kind = $2;
die "$kind: expected 'Disk', 'Buffer' or 'MSS'\n"
  if ! grep($kind eq $_, qw(Disk Buffer MSS));

my $nodeid = undef;
&dbexec($dbh, qq{
  insert into t_node (id, name, kind)
  values (seq_node.nextval, :node, :kind)
  returning id into :id},
  ":node" => $node,
  ":kind" => $kind,
  ":id" => \$nodeid);

while (@ARGV)
{
  my $other = shift(@ARGV);
  my ($name, $rest) = ($other =~ /^([^:]+)(:.*)?/);
  my ($junk, $locality, @shares) = split(":", $rest || "");
  $locality = "R" if ! $locality;
  @shares = (7, 4, 1, 1) if ! @shares;

  # Check node id
  my ($id) = &dbexec($dbh, qq{
    select id from t_node where name = :name},
    ":name" => $name)->fetchrow();
  die "Node $name not known\n" if ! defined $id;

  # Add link
  my $tolinkid = undef;
  &dbexec($dbh, qq{
    insert into t_link (id, from_node, to_node, distance, local_boost)
    values (seq_link.nextval, :me, :other, :distance, :local)
    returning id into :id},
    ":id" => \$tolinkid,
    ":me" => $nodeid,
    ":other" => $id,
    ":distance" => ($locality eq "R" ? 2 : 1),
    ":local" => ($locality eq "R" ? 0 : 1));

  my $fromlinkid = undef;
  &dbexec($dbh, qq{
    insert into t_link (id, from_node, to_node, distance, local_boost)
    values (seq_link.nextval, :other, :me, :distance, :local)
    returning id into :id},
    ":id" => \$fromlinkid,
    ":me" => $nodeid,
    ":other" => $id,
    ":distance" => ($locality eq "R" ? 2 : 1),
    ":local" => ($locality eq "R" ? 0 : 1));

  # Add link shares
  for (my $priority = 0; $priority <= $#shares; ++$priority)
  {
    &dbexec($dbh, qq{
      insert into t_link_share (link, priority, link_share)
      values (:link, :priority, :link_share)},
      ":link" => $tolinkid, ":priority" => $priority, ":link_share" => $shares[$priority]);
    &dbexec($dbh, qq{
      insert into t_link_share (link, priority, link_share)
      values (:link, :priority, :link_share)},
      ":link" => $fromlinkid, ":priority" => $priority, ":link_share" => $shares[$priority]);
  }
}

$dbh->commit();
$dbh->disconnect();
