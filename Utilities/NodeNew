#!/usr/bin/env perl

##H Create a new node
##H
##H Usage:
##H   NodeNew -db DBCONFIG NODE:KIND...
##H
##H Examples:
##H   NodeNew -db Schema/DBParam:Foo T2_Foo_Buffer:Disk
##H   NodeNew -db Schema/DBParam:Foo T1_Foo_Buffer:Buffer
##H   NodeNew -db Schema/DBParam:Foo T1_Foo_MSS:MSS
##H
##H NODE is the name of the new node.
##H KIND is the kind of the new node: Disk, Buffer or MSS.

BEGIN {
  $^W = 1; use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments.
use Getopt::Long;
use UtilsHelp;
use UtilsDB;
use UtilsTiming;
&GetOptions ("db=s"        => \$args{DBCONFIG},
	     "help|h"      => sub { &usage() });

# Check arguments.
if (scalar @ARGV < 1 || !$args{DBCONFIG})
{
  die "Insufficient parameters, use -h for help.\n";
}

my $dbh = &connectToDatabase ({ DBCONFIG => $args{DBCONFIG} }, 0);
my $now = &mytimeofday();
while (@ARGV)
{
  my $node = shift(@ARGV);
  die "$node: expected NODE:KIND\n" if $node !~ /^(\S+):(\S+)$/;
  $node = $1;
  my $kind = $2;
  die "$kind: expected 'Disk', 'Buffer' or 'MSS'\n"
    if ! grep($kind eq $_, qw(Disk Buffer MSS));

  print "Creating node $node, kind $kind\n";
  &dbexec($dbh, qq{
    insert into t_node (id, name, kind)
    values (seq_node.nextval, :node, :kind)},
    ":node" => $node, ":kind" => $kind);
  $dbh->commit();
}

$dbh->disconnect();
