#!/usr/bin/env perl
# Storage accounting tool
use strict;
use warnings;
use Time::Local;
use Time::localtime;
use File::Basename;
use PHEDEX::CLI::UserAgent;
use Getopt::Long qw /:config pass_through require_order /;
use PHEDEX::Core::Loader;
use PHEDEX::Core::Util ( qw / str_hash / );
my ($loader,$module,$interface,$ns,$timeFromXml);
my ($verbose,$debug,$terse);
my (@pfn,$dump,$level,$result,$command,$rootdir,$totalsize,$totalfiles,$totaldirs);
my %dirsizes = ();
$totalsize = 0;

sub usage {
  print <<EOF;
  Usage:

  spaceInsert --dump DUMP --strict --sitename SITENAME --depth LEVEL --url URL
              INTERFACE {OPTIONS}
 
  DUMP  is a storage dump file, must exist
  LEVEL is depth of the directory structure you want to go, default is 6
  SITENAME is the name of site, must exist
  URL is the url for data service
  strict is to specify if you need to overwrite the entity with the same timestamp.default is to overwrite with warning message
 
  INTERFACE is the protocol for accessing the SE (should know how to parse the DUMP)

  OPTIONS are:  --verbose, --debug, --help, and anything else that the
  interface might support. Use --help per interface to find out more.

  Known interface protocols in this installation are:
EOF
  #print " '",join("', '", grep (!/\//,sort keys %{$loader->Commands})),"'\n\n";
  exit 0;
}


sub dirlevel {
  my ($pathSimple,$temp1);
  my $path=shift;
  my $depth=shift;
  my @tmp=();
  if  ( not $path =~ /^\//){ die "ERROR: path does not start with a slash:  \"$path\"";}
  if  ( $path = ~ /^(\S+\/cms)(\/\S+)$/) {
      $temp1 = $1;
      $pathSimple = $2;
  }      
  $rootdir = $temp1;
  @tmp = split ('/', $pathSimple, $depth+2);
  pop @tmp;
  if (scalar(@tmp) > 2) {
     return join ("/", @tmp);
  }
  else {
     return $pathSimple;
  }
}

sub parse_chimera_dump {
  my ($file_dump) = @_;
  $totalfiles    = 0;
  $totaldirs     = 0;
  my ($line,$time);
  if ( $file_dump =~ m%.gz$% )
    { open DUMP, "cat $file_dump | gzip -d - |" or die "Could not open: $file_dump\n"; }
  elsif ( $file_dump =~ m%.bz2$% )
    { open DUMP, "cat $file_dump | bzip2 -cd - |" or die "Could not open: $file_dump\n"; }
  else
    { open(DUMP, "cat $file_dump |") or die  "Could not open: $file_dump\n"; }
  while ($line = <DUMP>){
	my ($size,$file);
	#chomp;
	if ($line =~ m/^\S+\s\S+\"(\S+)\"\S+\>(\d+)\<\S+$/) {
	   $file = $1;
	   $size = $2;
	   $debug and print "$file:$size\n";
	   $totalfiles++;
	   my $dir = dirname $file;
	   $dirsizes{$dir}+=$size;
	   $totalsize+=$size;
        }
        if ($line =~ m/^<dump recorded=\"(\S+)\">$/) {
           $time = $1;
        }
  }
  close DUMP;
  $timeFromXml = convertToUnixTime($time);
  
  $totaldirs = keys %dirsizes;
  if ($debug) {
     print "total files: ", $totalfiles,"\n";
     print "total dirs:  ", $totaldirs, "\n";
     print "total size:  ", $totalsize, "\n";
     print "timestamp:  ", $timeFromXml, "\n";
  }
}

sub convertToUnixTime
{
  my ($time) = @_;
  my ($unixTime, $localtime, $mon, $year, $d, $t, @d, @t);
  if ($time =~ m/^(\S+)T(\S+)Z$/)
  {
    $d = $1;
    @d = split /-/, $1;
    $t = $2;
    @t = split /:/, $2;
  }

  $unixTime = timelocal($t[2], $t[1], $t[0], $d[2], $d[1]-1, $d[0]-1900);
  #$localtime = localtime($unixTime);
  #print "the localtime:", $localtime->mon+1,"  ", $localtime->year+1900, "\n";

  return $unixTime;
}

my ($datasvcUrl, $response,$content,$method,$timeout,$pua,$target,$sitename,%payload,%topsizes);
my ($strict);

$datasvcUrl='https://pheSpaceMon.cern.ch/phedex/datasvc';
$level = 6;

GetOptions(
           "dump=s"      => \$dump,
           "sitename=s"      => \$sitename,
           "url=s"      => \$datasvcUrl,
           "level=s"      => \$level,
           "strict=s"     => \$strict,
           "verbose|v+"     => \$verbose,
           "debug+"         => \$debug,
           "help|h"         => sub { &usage() }
          );

if (!$dump || !$sitename) {
   die "You must provide dump file and collection Name!\n";
}
$method   = 'post';
$timeout  = 500;
$pua = PHEDEX::CLI::UserAgent->new
    (
      URL        => $datasvcUrl,
      FORMAT    => 'perl',
      INSTANCE    => 'zhangxm',
    );

if ( $dump ) {
  print "Begin to dump.....\n";
  parse_chimera_dump($dump);
}


#foreach ( keys %dirsizes ) {
#  print "DIRSIZE: $_: $dirsizes{$_} \n";
#}

$payload{"strict"} = defined $strict  ? $strict  : 1;
 
$payload{"sitename"}=$sitename;
$payload{"timestamp"}=$timeFromXml;
$payload{"totalsize"}=$totalsize;
$payload{"totalfiles"}=$totalfiles;
$payload{"totaldirs"}=$totaldirs;

foreach  (keys %dirsizes) {
  $topsizes{ dirlevel($_,$level)}+=$dirsizes{$_} + 0;
}

if ($debug) { print "dumping aggregated directory info......\n" };
foreach ( keys %topsizes ) {
  if ($debug) {
     print "TOPSIZE: $_: $topsizes{$_} \n";
  }
  $payload{$_} = $topsizes{$_} + 0;
}
my $count = 0;
foreach  (keys %payload) {
  print "upload parameter: $_ ==> $payload{$_}\n";
  $count = $count+1;
}
print "total number of records: $count\n";


my ($j, $now, $past, $input);

print "Begin to connect data service.....\n";
$pua->timeout($timeout) if $timeout;
$pua->CALL('storageinsert');
$target = $pua->target;
$response = $pua->$method($target,\%payload);


if ( $pua->response_ok($response) )
{
   # HTTP call returned correctly, print contents and quit...
   no strict 'vars';
   $content = eval($response->content());
   $content = $content->{PHEDEX}{STORAGEINSERT};
   Data::Dumper->Dump([ $content ]);
   foreach $record ( @{$content} ) {
     print "Inserting Record:\n  ",join('  ',map { "$_:$record->{$_}" } sort keys %{$record}),"\n";
   }
}
else
{
   # Something went wrong...
   chomp $content;
   print "Error from server ",$response->code(),"(",$response->message(),"), output below:\n",
         $response->content(),"\n";
   die "exiting after failure\n";
}

print  "Done!\n";
exit 0;

