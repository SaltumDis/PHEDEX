#!/usr/bin/env perl

use strict;
use PHEDEX::CLI::UserAgent;
use Getopt::Long;
use Data::Dumper;
my ($url,$response,$help,$verbose,$quiet,$action,$Action,$h);
my ($instance,$format,$call,$args,$method,$test_cert,$ref,$timeout);
my ($proxy,$debug,$cert_file,$key_file,$ca_file,$ca_dir,$nocert);

$url = 'https://cmswttest.cern.ch:8443/phedex/datasvc';
$instance = 'tbedi';
$format   = 'perl';
$call     = 'getAuth';
$method   = 'post';
$help = $verbose = $debug = $quiet = $nocert = $test_cert = $timeout = 0;

Getopt::Long::Configure( 'pass_through' );
$ref = separateArgs();
if ( $ref )
{
  @ARGV = @{$ref};
#  print "GLOBAL ARGS: @ARGV\n";

  GetOptions
	(
	 'help'		=> \$help,
	 'verbose!'	=> \$verbose,
	 'quiet!'	=> \$quiet,
	 'debug!'	=> \$debug,
	 'proxy=s'	=> \$proxy,
	 'cert_file=s'	=> \$cert_file,
	 'key_file=s'	=> \$key_file,
	 'ca_file=s'	=> \$ca_file,
	 'ca_dir=s'	=> \$ca_dir,
	 'url=s'	=> \$url,
	 'nocert'	=> \$nocert,
	 'testcert'	=> \$test_cert,
	 'timeout=i'	=> \$timeout,

	 'instance=s'	=> \$instance,
	 'format=s'	=> \$format,
#	 'call=s'	=> \$call,
#	 'args=s'	=> \$args,
	 'method=s'	=> \$method,
	);
}

sub usage
{
  print <<EOF;

  Usage: $0 [--proxy=s] [--cert_file=s] [--key_file=s]
	    [--method=s] [--url=s]
	    [--instance=s] [--format=s]
	    [--debug] [--verbose]
	    command <command-options> --
	    command <command-options> --

 where
 --proxy, --cert_file, and --key_file are used to define your certificate.
 if none of these options are specified, your usercert.pem and userkey.pem
 in ~/.globus are assumed. If you specify any of them then you must specify
 all that are needed, the defaults are only taken if none are set.

 If you don't want to use a certificate at all, use --nocert, and you had
 better specify a --url that doesn't connect to https as well.

 --method	'post' or 'get'. Don't set this unless you know why.
 --url		is the URL of the PhEDEx dataservice instance. The default is
		$url

 --instance	name of PhEDEx instance to use: 'prod', 'dev', 'test' etc.
		The default is '$instance'.
 --format	format for returned data: 'perl', 'xml', 'json'. The default
		is 'perl', anything else cannot easily be validated or used.

 --debug, --verbose, and --help are obvious

 Multiple commands can be given in a single call, the arguments for each
command are kept separate by the '--' pseudo-option.

EOF

  my %commands;
  foreach ( @INC )
  {
    foreach ( <$_/PHEDEX/CLI/*pm> )
    {
      m%^.*/PHEDEX/CLI/(.*).pm$%;
      $commands{lc $1}++;
    }
  }

  foreach ( qw / Template UserAgent / )
  { delete $commands{lc $_} if exists $commands{lc $_}; }

  print " Known commands in this installation are:\n",
	' ',join(' ',sort keys %commands),"\n\n",
	" use \"$0 <command> -help\" for details of a particular command\n\n";
  exit 0;
}

$help && usage;

if ( !( $cert_file || $key_file || $proxy || $ca_file || $ca_dir ||
	$ENV{HTTPS_PROXY} || $ENV{HTTPS_CERT_FILE} || $ENV{HTTPS_KEY_FILE} ||
	$ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR} ) )
{
  $cert_file = $ENV{HOME} . '/.globus/usercert.pem';
  $key_file  = $ENV{HOME} . '/.globus/userkey.pem';
}
my $pua = new PHEDEX::CLI::UserAgent
	(
	  DEBUG	 	=> $debug,
	  CERT_FILE	=> $cert_file,
	  KEY_FILE	=> $key_file,
	  PROXY	 	=> $proxy,
	  CA_FILE	=> $ca_file,
	  CA_DIR	=> $ca_dir,
	  URL		=> $url,
	  FORMAT	=> $format,
	  INSTANCE	=> $instance,
#	  CALL		=> $call,
	  NOCERT	=> $nocert,
	);

$pua->timeout($timeout) if $timeout;
$pua->PARANOID(0);
$pua->VERBOSE($verbose);
print $pua->Dump() if $debug;
if ( $test_cert )
{
  $pua->VERBOSE(1);
  $pua->test_certificate();
}

my (%Modules,@responses);
while ( $ref = separateArgs() )
{
  @ARGV = @{$ref};
#  print "SUB ARGS: @ARGV\n"; next;
  $Action = shift;

  next if $Action =~ m%^-+$%;
  $action = lc($Action);
  if ( $action !~ m%^[a-z]+$% )
  {
    die "invalid syntax, use \"$0 --help\" for help\n";
  }
  if ( $action eq $Action )
  {
    my @a = split('',$action);
    $a[0] = uc $a[0];
    $Action = join('',@a);
  }
  my $module = "PHEDEX::CLI::$Action";
  if ( ! exists $Modules{$Action} )
  {
    eval("use $module");
    do { chomp ($@); die "Failed to load module $module: $@\n" } if $@;
    $Modules{$Action}++;
  }
  my $cli = $module->new();
  print "created new $module object\n";
  print $cli->Dump() if $debug;
  $pua->CALL($cli->Call());
  $response = $pua->$method($pua->target,$cli->Payload());

  print "Response: ",$response->content if $debug;
  if ( $pua->response_ok($response) )
  {
    $cli->ParseResponse($response);
    print Data::Dumper->Dump([ $cli->{RESPONSE} ],[ 'Response' ]) if $cli->{VERBOSE};
    $cli->Summary;
    die "response is invalid\n" unless $cli->ResponseIsValid();
    push @responses,$cli->{RESPONSE};
  }
  else
  {
    print Data::Dumper->Dump([ $pua, $cli, $response ],[ 'UserAgent', 'CLI', 'Response' ]);
    die "exiting after failure\n";
  }
}

sub separateArgs()
{
  my @argv;
  my $global = 0;

# static variables!
  our @ARGV_orig;
  our $notFirst;

  if ( !$notFirst )
  {
#   first call: set global arguments array and 'global' flag
    @ARGV_orig = @ARGV;
    $notFirst = $global = 1;
  }

# The easy way out if there are no arguments
  return undef unless @ARGV_orig;

# Remove any '--' arguments, unless they're the first on the command line, in
# which case they signify no global arguments.
  $_ = shift @ARGV_orig;
  while ( m%^--$% )
  {
    return undef if $global;
    $_ = shift @ARGV_orig;
  }

# $_ holds the first argument. If it doesn't start with '-', then either
# return undef (if we're processing global arguments) or push it onto the
# argument list if we're processing non-global arguments
  if ( ! m%^-% )
  {
    if ( $global )
    {
      push @ARGV_orig, $_;
      return undef;
    }
    push @argv, $_;
  }
  else
  { unshift @ARGV_orig, $_; }

# Loop over remaining arguments. Require (-x,y) pairs. Terminate on other
# conditions, taking care to leave the remaining argument stack in good order
  while ( $_ = shift @ARGV_orig )
  {
    last if m%^--$%;
    if ( ! m%^-% )
    {
      unshift @ARGV_orig, $_;
      last;
    }
    push @argv, $_;
    push @argv, shift @ARGV_orig;
  }

  return \@argv;
}

exit 0;
