#!/usr/bin/env perl

use strict;
use PHEDEX::CLI::FakeAgent; # get PHEDEX::CLI::UserAgent for free...
use PHEDEX::Core::Loader;
use Getopt::Long;
use Data::Dumper;
my ($url,$response,$help,$verbose,$quiet,$action,$Action,$fakeagent,$service);
my ($instance,$format,$call,$args,$method,$test_cert,$ref,$timeout,$paranoid);
my ($proxy,$debug,$cert_file,$key_file,$ca_file,$ca_dir,$nocert,$h,@env);
my ($default_service);

$url = 'https://cmswttest.cern.ch:8443/phedex/datasvc';
$instance = 'tbedi';
$format   = 'perl';
$call     = 'getAuth';
$method   = 'post';
$default_service = 'PHEDEX::Web::DataService';
$help = $verbose = $debug = $quiet = 0;
$nocert = $test_cert = $timeout = $paranoid = $fakeagent = 0;

Getopt::Long::Configure( 'pass_through' );
$ref = separateArgs();
if ( $ref )
{
  @ARGV = @{$ref};
#  print "GLOBAL ARGS: @ARGV\n";

  GetOptions
	(
	 'help'		=> \$help,
	 'verbose!'	=> \$verbose,
	 'quiet!'	=> \$quiet,
	 'debug!'	=> \$debug,
	 'proxy=s'	=> \$proxy,
	 'cert_file=s'	=> \$cert_file,
	 'key_file=s'	=> \$key_file,
	 'ca_file=s'	=> \$ca_file,
	 'ca_dir=s'	=> \$ca_dir,
	 'url=s'	=> \$url,
	 'nocert'	=> \$nocert,
	 'testcert'	=> \$test_cert,
	 'timeout=i'	=> \$timeout,
	 'paranoid!'	=> \$paranoid,
	 'fakeagent!'	=> \$fakeagent,

	 'instance=s'	=> \$instance,
	 'format=s'	=> \$format,
	 'method=s'	=> \$method,
	 'service=s'	=> \$service,
	 'env=s@'	=> \@env,
	);

  foreach ( @env )
  {
    m%^([^=]*)=(.*)$% or next;
    $ENV{$1} = $2;
  }
}

my $loader = PHEDEX::Core::Loader->new( NAMESPACE => 'PHEDEX::CLI' );
sub usage
{
  print <<EOF;

  Usage: $0 [--proxy=s] [--cert_file=s] [--key_file=s]
	    [--method=s] [--url=s]
	    [--instance=s] [--format=s]
	    [--timeout=i] [--paranoid]
	    [--fakeagent] [--service=s]
	    [--debug] [--verbose] [--]
	    command <command-options> --
	    command <command-options> --

 where
 --proxy, --cert_file, and --key_file are used to define your certificate.
 if none of these options are specified, your usercert.pem and userkey.pem
 in ~/.globus are assumed. If you specify any of them then you must specify
 all that are needed, the defaults are only taken if none are set.

 If you don't want to use a certificate at all, use --nocert, and you had
 better specify a --url that doesn't connect to https as well.

 --method	'post' or 'get'. Don't set this unless you know why.
 --url		is the URL of the PhEDEx dataservice instance. The default is
		$url

 --instance	name of PhEDEx instance to use: 'prod', 'dev', 'test' etc.
		The default is '$instance'.
 --format	format for returned data: 'perl', 'xml', 'json'. The default
		is 'perl', anything else cannot easily be validated or used.
 --timeout	is the time to wait for a server response. The default is
		probably 30 seconds, set in PHEDEX::CLI::UserAgent
 --paranoid	consider an XML-formatted 'error' message to be fatal, and
		dump lots of useful debugging info.

 --fakeagent	run interactively, with a fake useragent that sets up the
		environment and calls the dataservice directly.
 --service	name of Perl module to load to instantiate the data service.
		If --service is given, --fakeagent is assumed. If --fakeagent
		is given and --service is not specified, the default data
		service ($default_service) is assumed.

 --debug, --verbose, and --help are obvious

 Multiple commands can be given in a single call, the arguments for each
command are kept separate by the '--' pseudo-option. If you specify global
options, you must also use '--' to denote their end, before starting the
subcommand arguments.

E.g.

$0 inject --node T1_XY_Buffer --verbose --help
$0 --verbose -- inject --node T1_XY_Buffer
$0 --verbose -- inject --node T1_XY_Buffer -- inject --node T2_PQ_Buffer

EOF

  my $commands = $loader->Commands();

  print " Known commands in this installation are:\n",
	' ',join(' ',sort values %{$commands}),"\n\n",
	" use \"$0 <command> -help\" for details of a particular command\n\n";
  exit 0;
}

$help && usage;

if ( !( $cert_file || $key_file || $proxy || $ca_file || $ca_dir ||
	$ENV{HTTPS_PROXY} || $ENV{HTTPS_CERT_FILE} || $ENV{HTTPS_KEY_FILE} ||
	$ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR} ) )
{
  $cert_file = $ENV{HOME} . '/.globus/usercert.pem';
  $key_file  = $ENV{HOME} . '/.globus/userkey.pem';
}

$fakeagent = 1 if $service;
my $module = 'PHEDEX::CLI::UserAgent';
if ( $fakeagent )
{
  $service = $default_service unless $service;
  $module = 'PHEDEX::CLI::FakeAgent';
}

my $pua = ($module)->new
	(
	  DEBUG	 	=> $debug,
	  CERT_FILE	=> $cert_file,
	  KEY_FILE	=> $key_file,
	  PROXY	 	=> $proxy,
	  CA_FILE	=> $ca_file,
	  CA_DIR	=> $ca_dir,
	  URL		=> $url,
	  FORMAT	=> $format,
	  INSTANCE	=> $instance,
	  NOCERT	=> $nocert,

	  SERVICE	=> $service,
	);

$pua->timeout($timeout) if $timeout;
$pua->PARANOID($paranoid);
$pua->VERBOSE($verbose);
print $pua->Dump() if $debug;
if ( $test_cert )
{
  $pua->VERBOSE(1);
  $pua->test_certificate();
}

my (@responses);
while ( $ref = separateArgs() )
{
  @ARGV = @{$ref};
  $Action = shift;

  next if $Action =~ m%^-+$%;
  $action = lc($Action);
  if ( $action !~ m%^[a-z][a-z,0-9]+$% )
  { die "invalid syntax, use \"$0 --help\" for help\n"; }
  my $module = $loader->Load($Action);
  my $cli = $module->new();
  print "created new $module object\n";
  print $cli->Dump() if $debug;
  $pua->CALL($cli->Call());
  $response = $pua->$method($pua->target,$cli->Payload());

  print "Response: ",$response->content if $debug;
  if ( $pua->response_ok($response) )
  {
    $cli->ParseResponse($response);
    print Data::Dumper->Dump([ $cli->{RESPONSE} ],[ 'Response' ]) if $cli->{DEBUG};
    $cli->Summary;
    die "response is invalid\n" unless $cli->ResponseIsValid();
    push @responses,$cli->{RESPONSE};
  }
  else
  {
    print Data::Dumper->Dump([ $pua, $cli, $response ],[ 'UserAgent', 'CLI', 'Response' ]);
    die "exiting after failure\n";
  }
}

sub separateArgs()
{
  my @argv;
  my $global = 0;

# static variables!
  our @ARGV_orig;
  our $notFirst;

  if ( !$notFirst )
  {
#   first call: set global arguments array and 'global' flag
    @ARGV_orig = @ARGV;
    $notFirst = $global = 1;
  }

# The easy way out if there are no arguments
  return undef unless @ARGV_orig;

# If we're looking for global arguments, first argument better start with '-'
  return undef if ( $global && $ARGV_orig[0] !~ m%^-% );

# Remove leading '--' arguments, unless this is the first call, in
# which case they signify no global arguments.
  $_ = shift @ARGV_orig;
  while ( m%^--$% )
  {
    return undef if $global;
    $_ = shift @ARGV_orig;
  }
  unshift @ARGV_orig, $_; # put back last argument for next step...

# Loop over remaining arguments. Terminate on '--' or when no arguments left
  while ( $_ = shift @ARGV_orig )
  {
    last if m%^--$%;
    push @argv, $_;
  }

  return \@argv;
}

exit 0;
