#!/usr/bin/perl

# Manage the reallocation of files that are already in distribution to
# new destinations.

# This could get pretty complicated. The trivial example really is
# trivial: get a list of files in distribution and reallocate them 
# (the only real complication is that the list of files needs to be
# defined in some way; currently you can define the list of files by
# defining source_node, destination_node, or dataset.
# it also doesn't check that the files are
# currently staged, as there's no mechanism for generic auto-staging
# in the system yet).

# More advanced algorithms must: generate pre-stage orders (use new
# state- for stage or prep- and have automatic agent doing it?);
# locate best replica (search back from destination through neighbours
# etc); if list of files is generated from metadata, must determine
# whether all files are yet in distribution, if not warn, place
# susbscription; ...

use Getopt::Long;

my $me = $0;
my $state = '';
my $source_node = '';
my $destination_node = '';
my $dataset = '';
my $for_node = '';

# #############################
# Main loop
# #############################

parse_command_line();
act_on_state();

# #############################
# Subroutines
# #############################

sub trivial {	
	my @sql = ();
	my $time = time();

	# We need to make two inserts per guid for completeness- one
	# adds the new destination to t_destinations, the other does a
	# route calc to get the gateway and makes the advert.
	if ( $source_node ) {
	
	
		my $selection = "select guid from t_files_for_transfer "
						."where source_node = '$source_node'";
		# FIXME: Do guid selection -> @guids
		
		# FIXME: this can be a sub
		$selection = "select gateway from t_routing "
						."where from_node = '$source_node' " 
						."and to_node = '$for_node'";
		# FIXME: Do route determination -> $gateway
		
		# FIXME: In dire straits could hack a remote stage command here...
		# but should wait for proper structure in V3.
		
		foreach $guid ( @guids ) {
			push( @sql, "insert into t_destinations '$guid','$for_node'" );
			push( @sql, "insert into t_file_state values ('$guid','$gateway',1,'$source_node',$time)" );
		}		
		
		
	} elsif ( $destination_node ) {
		
		my %source_by_guid = ();
		my $selection = "select guid,source_node from t_destinations,t_files_for_transfer "
						."where destination_node = '$destination_node' "
						."and t_files_for_transfer.guid = t_destinations.guid "
						."and t_files_for_transfer.guid = '$guid'";
		# FIXME: Do guid selection -> %source_by_guid
		
		foreach $guid ( keys %source_by_guid ) {
			#FIXME: this can be a sub
			$selection = "select gateway from t_routing "
					."where from_node = '$source_by_guid{$guid}' " 
					."and to_node = '$for_node'";
			# FIXME: Do route determination -> $gateway
		
			push( @sql, "insert into t_destinations '$guid','$for_node'" );
			push( @sql, "insert into t_file_state values ('$guid','$gateway',1,'$source_node',$time)" );			
		}
		
		
	} elsif ( $dataset ) {
	
		my %source_by_guid = ();
		my $selection = "select guid,source_node "
						."from t_destinations,t_files_for_transfer,t_replica_metadata "
						."where t_replica_metadata.guid = '$guid' "
						."and key = 'POOL_Dataset' "
						."and value = '$dataset' "
						."and t_destinations.guid = t_files_for_transfer.guid "
						."and t_destinations.guid = t_replica_metadata.guid"
		# FIXME: Do guid selection -> %source_by_guid
		
		foreach $guid ( keys %source_by_guid ) {
			#FIXME: this can be a sub
			$selection = "select gateway from t_routing "
					."where from_node = '$source_by_guid{$guid}' " 
					."and to_node = '$for_node'";
			# FIXME: Do route determination -> $gateway
		
			push( @sql, "insert into t_destinations '$guid','$for_node'" );
			push( @sql, "insert into t_file_state values ('$guid','$gateway',1,'$source_node',$time)" );			
		}		
	
	
	} else {
		display_usage();
	}
}

sub act_on_state {
	if ( $state eq "trivial" ) {
		trivial();
	} else {
		display_usage();
	}
}

sub log_entry {
	my $entry = shift;
	my $time = time();
	my $local = localtime( $time );
	print "$local: $entry\n";
}

sub display_usage {
	print "Usage:\n";
	print "  $me trivial \t-for <node to reallocate to>"
			."\n\t\t\t\t\tand then one of the following to generate the file list"
			."\n\t\t\t\t\t[-source <source node>] \n\t\t\t\t\t[-dest <destination node>] \n\t\t\t\t\t[-dataset <dataset>]\n";
	exit(1);
}

sub parse_command_line () {
	GetOptions(	'name=s' => \$node_name,
				'source=s' => \$source_node,
				'destination' => \$destination_node,
				'dataset' => \$destination_node,
				'for=s' => \$for_node,
				);
				
	if ( ! $ARGV[0] || $ARGV[1]) {
		display_usage();
	} else {
		$state = $ARGV[0];
	}
}