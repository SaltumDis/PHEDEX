#!/usr/bin/env perl

# Manage the reallocation of files that are already in distribution to
# new destinations.

# This could get pretty complicated. The trivial example really is
# trivial: get a list of files in distribution and reallocate them 
# (the only real complication is that the list of files needs to be
# defined in some way; currently you can define the list of files by
# defining source_node, destination_node, or dataset.
# it also doesn't check that the files are
# currently staged, as there's no mechanism for generic auto-staging
# in the system yet).

# More advanced algorithms must: generate pre-stage orders (use new
# state- for stage or prep- and have automatic agent doing it?);
# locate best replica (search back from destination through neighbours
# etc); if list of files is generated from metadata, must determine
# whether all files are yet in distribution, if not warn, place
# susbscription; ...

use Getopt::Long;
use DBI;

my $me = $0;
my $state = '';
my $source_node = '';
my $destination_node = '';
my $dataset = '';
my $for_node = '';
my $user = '';
my $password = '';
my $review = 0;

# #############################
# Main loop
# #############################

parse_command_line();
act_on_state();

# #############################
# Subroutines
# #############################

# Eventually we might want to connect to MySQL etc as well,
# so try to hide it ...
sub connect_to_db {
	my $dbh = DBI->connect(	"DBI:Oracle:$dbname",
							$user,
							$password,
							{RaiseError => 1, AutoCommit => 1})
							
							or die "Couldn't connect to database $dbname @_";
	
	# FIXME: is this ok, or will it leave outstanding
	# connections? Return ref to handle?
	return $dbh;
}

# For SQL queries that result in single field answers
sub sql_results_into_array {
	my $sql = shift;
	my @results = ();

	my $dbh;
	if ($dbname) {
		$dbh = connect_to_db();
	} else {
		log_entry( "No db specified, just logging sql" );
	}		
	
	foreach $command ( @$sql ) {
		if ($dbname) {
			my $query = $dbh->prepare($command);	
			
        	$query->execute();
        	while (@row = $query->fetchrow_array) {	
   	       		$row[0] =~ s/\s+//g;
	       		push( @results, $row[0] );
        	}
        	$query->finish();
    	} else {
    		log_entry( $command );
    	}    
	}
				 
	$dbh->disconnect() if $dbh;

	return @results;
}

# For SQL queries that result in two field answers that are to
# be placed in a hash, of form "result2_by_result1"
sub sql_results_into_hash {
	my $sql = shift;
	my %results = ();

	my $dbh;
	
	if ($dbname) {
		$dbh = connect_to_db();
	} else {
		log_entry( "No db specified, just logging sql" );
	}		
	
	foreach $command ( @$sql ) {
		if ($dbname) {
			my $query = $dbh->prepare($command);	
			
    	    $query->execute();
        	while (@row = $query->fetchrow_array) {	
   	       		$row[0] =~ s/\s+//g;
   	       		$row[1] =~ s/\s+//g;
	       		$results{$row[1]} = "$row[0] ";
        	}
        	$query->finish();
        } else {
        	log_entry( $command );
        }
	}
				 
	$dbh->disconnect() if $dbh;

	return %results;
}

sub do_sql {
	my $sql = shift;
	
	eval {
		my $dbh;
		if ($dbname) { 
			$dbh = connect_to_db(); 
		} else {
			log_entry( "No db specified, just logging sql" );
		}
	
		foreach my $cmd (@$sql)
	    {
		if ($dbname) {
		    	$dbh->do ($cmd);
	        } else {
		    	log_entry ($cmd);
			}
	    }

		$dbh->disconnect if $dbh;
	};
	
	if ($@)
    {
		log_entry( "database operation failed: $@" );
		if ($dbh)
		{
	    	$dbh->rollback;
	    	$dbh->disconnect;
		}
		return 1;
    }


	return 0;
}


sub trivial {	
	my @sql = ();
	my $time = time();

	# We need to make two inserts per guid for completeness- one
	# adds the new destination to t_destinations, the other does a
	# route calc to get the gateway and makes the advert.
	if ( $source_node ) {
	
		
		my @guids = ();
		push( @sql, "select guid from t_files_for_transfer "
						."where source_node = '$source_node'" );
		@guids = sql_results_into_array( \@sql );

		@sql = ();
		
		# FIXME: this can be a sub
		push( @sql, "select gateway from t_routing "
						."where from_node = '$source_node' " 
						."and to_node = '$for_node'" );
		@gateway = sql_results_into_array( \@sql );
		
		# FIXME: In dire straits could hack a remote stage command here...
		# but should wait for proper structure in V3.
		
		@sql = ();
		
		foreach $guid ( @guids ) {
			push( @sql, "insert into t_destinations values ('$guid','$for_node')" );
			push( @sql, "insert into t_file_state values ('$guid','$gateway[0]',1,'$source_node',$time)" );
		}
		
		do_sql( \@sql );		
		
		
	} elsif ( $destination_node ) {
		
		
		push( @sql, "select source_node,t_files_for_transfer.guid from t_destinations,t_files_for_transfer "
						."where destination_node = '$destination_node' "
						."and t_files_for_transfer.guid = t_destinations.guid" );
		my %source_by_guid = sql_results_into_hash( \@sql );
		
		@sql = ();
		
		foreach $guid ( keys %source_by_guid ) {
			# FIXME: this can be a sub
			my @temp = ();
			push( @temp, "select gateway from t_routing "
						."where from_node = '$source_by_guid{$guid}' " 
						."and to_node = '$for_node'" );
			my @gateway = sql_results_into_array( \@temp );
		
			push( @sql, "insert into t_destinations '$guid','$for_node'" );
			push( @sql, "insert into t_file_state values ('$guid','$gateway[0]',1,'$source_by_guid{$guid}',$time)" );			
		}
		
		do_sql( \@sql );
		
	} elsif ( $dataset ) {
	
	
		push( @sql, "select source_node,t_files_for_transfer.guid "
						."from t_files_for_transfer,t_replica_metadata "
						."where key = 'POOL_dataset' "
						."and value = '$dataset' "
						."and t_files_for_transfer.guid = t_replica_metadata.guid" );
		my %source_by_guid = sql_results_into_hash( \@sql );
		
		@sql = ();
		
		foreach $guid ( keys %source_by_guid ) {
			# FIXME: this can be a sub
			my @temp = ();
			push( @temp, "select gateway from t_routing "
						."where from_node = '$source_by_guid{$guid}' " 
						."and to_node = '$for_node'" );
			my @gateway = sql_results_into_array( \@temp );
		
			push( @sql, "insert into t_destinations values ('$guid','$for_node')" );
			push( @sql, "insert into t_file_state values ('$guid','$gateway[0]',1,'$source_by_guid{$guid}',$time)" );		

		}
		
		do_sql( \@sql );		
	
	
	} else {
		display_usage();
	}
}

sub act_on_state {
	if ( $state eq "trivial" ) {
		trivial();
	} else {
		display_usage();
	}
}

sub log_entry {
	my $entry = shift;
	my $time = time();
	my $local = localtime( $time );
	print "$local: $entry\n";
}

sub display_usage {
	print "Usage:\n";
	print "  $me trivial \t-for <node to reallocate to>"
			."\n\t\t\t\t\tand then one of the following to generate the file list"
			."\n\t\t\t\t\t[-source <source node>] \n\t\t\t\t\t[-dest <destination node>] \n\t\t\t\t\t[-dataset <dataset>]\n";
	exit(1);
}

sub parse_command_line () {
	GetOptions(	'name=s' => \$node_name,
				'source=s' => \$source_node,
				'destination=s' => \$destination_node,
				'dataset=s' => \$dataset,
				'for=s' => \$for_node,
				'user=s' => \$user,
				'password=s' => \$password,
				'db=s' => \$dbname,
				);
				
	if ( ! $ARGV[0] || $ARGV[1]) {
		display_usage();
	} else {
		$state = $ARGV[0];
	}
}