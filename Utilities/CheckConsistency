#!/usr/bin/env perl

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

my $me = $0; $me =~ s|.*/||;
my %args = (DBITYPE => "Oracle", NJOBS => 10);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBNAME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbi' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBITYPE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbuser' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBUSER} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbpass' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBPASS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MYNODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-catalogue' && scalar @ARGV > 1)
    { shift (@ARGV); $args{CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-match' && scalar @ARGV > 1)
    { shift (@ARGV); $args{HOST_KEY} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-jobs' && scalar @ARGV > 1)
    { shift (@ARGV); $args{NJOBS} = shift(@ARGV); }
    else
    { last; }
}

if (scalar @ARGV || !$args{DBNAME} || !$args{DBUSER} || !$args{DBPASS}
    || !$args{DBITYPE} || !$args{MYNODE} || !$args{CATALOGUE} || !$args{HOST_KEY})
{
    print STDERR "usage: $me -node NODE -catalogue CATALOGUE -match PATTERN\n",
		 " [-jobs NJOBS] -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n";
    exit (1);
}


my $files = {};
die if ! &fetchGuids(\%args, $files);
die if ! &fetchPFNs(\%args, $files);

foreach my $file (values %$files) {
    print "no guid for pfn $file->{PFN}\n" if ! $file->{GUID};
    print "no pfn for guid $file->{GUID}\n" if ! $file->{PFN};
}

exit 0;

######################################################################
# Fetch all guids for a node in the TMDB.
sub fetchGuids
{
    my ($args, $files) = @_;
    use UtilsDB;
    local $| = 1;

    $dbh = &connectToDatabase ($args, 0);
    my $stmt = &dbexec($dbh, qq{
	select guid from t_replica_state where node = :node},
	":node" => $args->{MYNODE});
    my $nguids = 0;
    print "downloading guids: ";
    while (my ($guid) = $stmt->fetchrow()) {
	$files->{$guid}{GUID} = $guid;
	$files->{$guid}{IN_TMDB} = 1;
	print "." if ++$nguids % 1000 == 0;
    }
    print " done\n";
    $dbh->disconnect();
    undef $stmt;
    undef $dbh;
    return 1;
}

# Map GUIDs to PFNs using catalogue, running a number of queries
# in parallel.  Adds "PFN" entry to each file in $files.
sub fetchPFNs
{
    my ($args, $files) = @_;
    local $| = 1;

    # Create jobs to resolve guids to pfns
    print "fetching pfns: ";
    my @hex = qw(0 1 2 3 4 5 6 7 8 9 A B C D E F);
    my @hex2 = map { my $x = $_; map { "$x$_" } @hex } @hex;
    my @hex3 = map { my $x = $_; map { "$x$_%" } @hex } @hex2;
    open (CAT, "$home/../../Utilities/PFClistGuidPFN"
	  . " -u '$args->{CATALOGUE}' -j '$args->{NJOBS}' -g -m @hex3 |")
       or die "cannot run PFClistGuidPFN: $!\n";
    my $nguids = 0;
    while (<CAT>)
    {
	my ($guid, $pfn) = /^([-0-9A-F]+)\s+(.*)/;
	if ($pfn =~ /$args->{HOST_KEY}/) {
	    $files->{$guid}{FCPFN} = $pfn;
	    $files->{$guid}{IN_FC} = 1;
	}
	print "." if ++$nguids % 1000 == 0;
    }
    close (CAT) or die "PFClistGuidPFN: $!\n";
    return 1;
}
