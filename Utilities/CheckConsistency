#!/usr/bin/env perl

# tab: Note on domains option: allows you to choose which domains to examine
# construct as comma separated list: p [phedex], c [catalogue], fs [file
# system], f [files]

BEGIN {
  use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

use File::Copy;

my $me = $0; $me =~ s|.*/||;
my %args = (DBITYPE => "Oracle", NJOBS => 10);
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBNAME} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbi' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBITYPE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbuser' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBUSER} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-dbpass' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBPASS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-node' && scalar @ARGV > 1)
    { shift (@ARGV); $args{MYNODE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-catalogue' && scalar @ARGV > 1)
    { shift (@ARGV); $args{CATALOGUE} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-match' && scalar @ARGV > 1)
    { shift (@ARGV); $args{HOST_KEY} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-jobs' && scalar @ARGV > 1)
    { shift (@ARGV); $args{NJOBS} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-domains' && scalar @ARGV > 1)
    { shift (@ARGV); map { $args{DOMAINS}{$_} = 1 } split(/,/, shift(@ARGV)); }
    elsif ($ARGV[0] eq '-fstype' && scalar @ARGV > 1)
    { shift (@ARGV); $args{TYPE} = shift(@ARGV); }
    else
    { last; }
}

# FIXME: would be good to check for known fstypes: castor or mount
if (scalar @ARGV || !$args{DBNAME} || !$args{DBUSER} || !$args{DBPASS}
    || !$args{DBITYPE} || !$args{MYNODE} || !$args{HOST_KEY}
    || (($args{DOMAINS}{fs} || $args{DOMAINS}{f}) && !$args{TYPE} )
    || ($args{DOMAINS}{c} && !$args{CATALOGUE}) )
{
    print STDERR "usage: $me -node NODE [-catalogue CATALOGUE] -match PATTERN\n",
		 " [-jobs NJOBS] -db NAME -dbuser USER -dbpass PASSWORD [-dbitype TYPE]\n",
                 " -domains DOMAINS [-fstype TYPE]\n";
    exit (1);
}


my $files = {};

if ($args{DOMAINS}{p}) {
    if ( -e "./phedex-cache" ) {
	&readPhedexCache(\%args,$files);
    } else {
	die if ! &queryPhEDEx(\%args, $files);
	&writePhedexCache(\%args,$files);
    }
}
if ($args{DOMAINS}{c}) {
    if ( -e "./catalogue-cache" ) {
	&readCatalogueCache(\%args, $files);
    } else {
	die if ! &queryFileCatalogue(\%args, $files);
	&writeCatalogueCache(\%args, $files);
    }
}
if ($args{DOMAINS}{fs}) {
    die if ! &queryFileSystem(\%args, $files);
}
if ($args{DOMAINS}{f}) {
    die if ! &queryFiles(\%args, $files);
}

# Build matrix of counts for all possible states. As guids are found in
# each domain the DOMAIN tag is ORd with the existing value. The domain
# tag is then used to build a table of guid counts in each state
my @counts = ();
foreach my $file (values %$files) {
    $counts[$file->{DOMAINS}]++;
}

print "P C L  #\n";
for (my $idx=0;$idx<8;$idx++) {
    my $s = '';
    if ( $idx & 4 ) { $s = "x " } else { $s = "  "; }
    if ( $idx & 2 ) { $s .= "x " } else { $s .= "  "; }
    if ( $idx & 1 ) { $s .= "x " } else { $s .= "  "; }
    print "$s $counts[$idx]\n";
}

exit 0;

######################################################################
sub readPhedexCache
{
    my ($args, $files) = @_;
    open(CACHE, "gunzip -c < ./phedex-cache |");
    while(<CACHE>) {
	chop;
	my ($guid) = split( / / );
	$files->{$guid}{GUID} = $guid;
	$files->{$guid}{DOMAINS} += 4;
    }
    die if ! close(CACHE);
}

sub writePhedexCache
{
    my ($args, $files) = @_;
    open(CACHE, "| gzip -c > ./phedex-cache") || die "Couldn't open phedex-cache fro write";
    foreach my $file (values %$files) {
	print CACHE "$file->{GUID}\n";
    }
    die if ! close(CACHE);
}

sub readCatalogueCache
{
    my ($args, $files) = @_;
    open(CACHE, "gunzip -c < ./catalogue-cache |");
    while(<CACHE>) {
	chop;
	my ($guid,$fcsurl) = split( / / );
	$files->{$guid}{GUID} = $guid;
	$files->{$guid}{DOMAINS} += 2;
	$files->{$guid}{FCSURL} = $fcsurl;
    }
    die if ! close(CACHE);
}

sub writeCatalogueCache
{
    my ($args, $files) = @_;
    open(CACHE, "| gzip -c > ./catalogue-cache");
    foreach my $file (values %$files) {
	print CACHE "$file->{$guid}{GUID} $file->{$guid}{FCSURL}\n";
    }
    die if ! close(CACHE);
}

# Fetch all guids for a node in the TMDB.
sub queryPhEDEx
{
    my ($args, $files) = @_;
    use UtilsDB;
    local $| = 1;

    $dbh = &connectToDatabase ($args, 0);
    my $stmt = &dbexec($dbh, qq{
	select guid from t_replica_state where node = :node},
	":node" => $args->{MYNODE});
    my $nguids = 0;
    print "downloading guids: ";
    while (my ($guid) = $stmt->fetchrow()) {
	$files->{$guid}{GUID} = $guid;
	$files->{$guid}{DOMAINS} += 4;
	print "." if ++$nguids % 1000 == 0;
    }
    print " done\n";
    $dbh->disconnect();
    undef $stmt;
    undef $dbh;
    return 1;
}

# Map GUIDs to PFNs using catalogue, running a number of queries
# in parallel.  Adds "PFN" entry to each file in $files.
sub queryFileCatalogue
{
    my ($args, $files) = @_;
    local $| = 1;

    # Create jobs to resolve guids to pfns
    print "fetching pfns: ";
    my @hex = qw(0 1 2 3 4 5 6 7 8 9 A B C D E F);
    my @hex2 = map { my $x = $_; map { "$x$_" } @hex } @hex;
    my @hex3 = map { my $x = $_; map { "$x$_%" } @hex } @hex2;
    open (CAT, "$home/../../Utilities/PFClistGuidPFN"
	  . " -u '$args->{CATALOGUE}' -j '$args->{NJOBS}' -g -m @hex3 |")
       or die "cannot run PFClistGuidPFN: $!\n";
    my $nguids = 0;
    while (<CAT>)
    {
	my ($guid, $pfn) = /^([-0-9A-F]+)\s+(.*)/;
	if ($pfn =~ /$args->{HOST_KEY}/) {
	    $files->{$guid}{FCPFN} = $pfn;
	    $files->{$guid}{DOMAINS} += 2;
	}
	print "." if ++$nguids % 1000 == 0;
    }
    close (CAT) or die "PFClistGuidPFN: $!\n";
    print "done\n";
    return 1;
}

# Get local SURLs. Compare to FC. If all files are in the FC then
# and only then can we make the full comparison to the TMDB.
sub queryFileSystem
{
    print "Sorry, direct File System checks aren't supported yet\n";
    return 1;
}

sub queryFiles
{
    print "Sorry, direct file checks aren't supported yet\n";
    return 1;
}
