#!/usr/bin/env perl

##H Dump in XML dataset information from DBS database.
##H
##H Usage:
##H   DBSXMLDump { -from RefDB | -from DBS -db FILE[:SECTION] }
##H           [-datatier] [-getDatasetProvenance] [-getDatasetContents]
##H           [PATTERN...]
##H
##H -from DBS     read information from DBS
##H -from RefDB   read information from RefDB
##H -db           database connection configuration parameter file
##H -to           output XML file name
##H -datatier     get the required data-tiers as a comma-separated list 
##H -getDatasetProvenance dump the dataset provenance , use it with -datatier option         
##H -getDatasetContents   dump EventCollection information 
##H PATTERN       block match constraint (owner/dataset), such as "*/bt03_*"

BEGIN { use strict; use warnings; $^W=1;
  my $me = $0; $me =~ s|.*/||;
  my $home = $0; $home =~ s|/[^/]+$||; $home ||= ".";
  unshift(@INC, "$home/../Toolkit/Common"); }
use UtilsHelp;
use UtilsDBS;
use TextGlob 'glob_to_regex';
use XML::Simple;

my %args = (DETAILS => 0, FILES => 0, OUTFILE => "-");
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-h') {
	&usage();
    } elsif ($ARGV[0] eq '-from' && scalar @ARGV > 1) {
	shift (@ARGV); $args{FROM} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-db' && scalar @ARGV > 1) {
	shift (@ARGV); $args{DBCONFIG} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-to' && scalar @ARGV > 1) {
        shift (@ARGV); $args{OUTFILE} = shift (@ARGV);
    } elsif ($ARGV[0] eq '-datatier' && scalar @ARGV > 1) {
        shift (@ARGV); push (@{$args{DATATIER}}, split(/,/, shift(@ARGV)));
    } elsif ($ARGV[0] eq '-getDatasetProvenance') {
        shift (@ARGV); $args{DATASETPROVENANCE} = 1;
    } elsif ($ARGV[0] eq '-getDatasetContents') {
        shift (@ARGV); $args{DATASETCONTENTS} = 1;
    } elsif ($ARGV[0] eq '--') {
	shift (@ARGV); last;
    } elsif ($ARGV[0] =~ '^-') {
	&usage ("$0: unrecognised option $ARGV[0]\n\n");
    } else {
	last;
    }
}

$TextGlob::strict_wildcard_slash = 0;
$args{PATS} = [ map { &glob_to_regex($_) } @ARGV ];
if (!$args{FROM}
    || !grep($args{FROM} eq $_, qw(RefDB DBS))
    || !($args{FROM} ne 'DBS' || $args{DBCONFIG}))
{
    die "Insufficient parameters, use -h for help.\n";
}

# Create appropriate dataset bookkeeping proxy
my $dbs = UtilsDBS->connect ($args{FROM}, $args{DBCONFIG});
my $result = {};

# Get all existing datasets
my $datasets = $dbs->fetchPublishedData();
$datasets = [ sort { $a->{DATASET} cmp $b->{DATASET} ||
		     $a->{OWNER} cmp $b->{OWNER} } @$datasets ];

# Get all current datasets
while (my $item = shift (@$datasets))
{
    my $token = "$item->{OWNER}/$item->{DATASET}";
    next if (@ARGV && !grep($token =~ $_, @{$args{PATS}}));

    # Get the full data
    eval { $dbs->fillDatasetInfo ($item); };
    do { chomp ($@); warn ("$@\n"); next } if $@;

    # Initialise result
    my $dbspath = "/$item->{DATASET}/$item->{DSINFO}{DataTier}/$item->{OWNER}";
    my $object = $result->{'processed-dataset'}{$dbspath} = { 'path' => $dbspath };

    # Handle requested information
    if ($args{DATASETPROVENANCE})
    {
        # Build data structure of parents 
        foreach my $parent (@{$item->{PARENTS}})
        {
	    next if ($args{DATATIER}
		     && ! grep ($_ eq $parent->{DSINFO}{DataTier}, @{$args{DATATIER}}));
            my $ppath = "/$parent->{DATASET}/$parent->{DSINFO}{DataTier}/$parent->{OWNER}";
	    $object->{'parent'}{$ppath} = {
                'path' => $ppath,
                'tier' => $parent->{DSINFO}{DataTier},
	        'type' => $parent->{TYPE}
            };
        }
    }

    if ($args{DATASETCONTENTS})
    {
        # Build data structure of event collection grouped by fileblock
        foreach my $block (values %{$item->{BLOCKS}})
        {
            my $blockres = $object->{'block'}{$block->{NAME}} = {
                'id' => $block->{ID},
                'name' => $block->{NAME},
                'event-collection' => {}
            };

            foreach my $run (sort { $a->{NAME} cmp $b->{NAME} } values %{$item->{RUNS}})
	    {
                $collname  ="EvC_Run$run->{NAME}";
                $blockres->{'event-collection'}{$collname} = {
                  'name' => $collname,
                  'events' => $run->{EVTS}
                };
            }
        }
    }
}

# Dump data structure into xml
my $outputxml = XMLout($result, XMLDecl => 1, RootName => "dbs",
    KeyAttr => { 'processed-dataset' => 'path',
	         'block' => 'name',
		 'event-collection' => 'name',
		 'parent' => 'path' });
open (XML, "> $args{OUTFILE}") or die "cannot open $args{OUTFILE}: $!\n";
print XML $outputxml;
close (XML);

$dbs->disconnect();
exit 0;
