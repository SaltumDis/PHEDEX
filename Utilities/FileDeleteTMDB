#!/usr/bin/env perl

##H Delete files from TMDB
##H
##H Usage:
##H   FileDeleteTMDB -db DBCONFIG -storage STORAGEMAP -list PFNS -node NODENAME
##H                  [-protocol PROTOCOL]
##H
##H Examples:
##H
##H   FileDeleteTMDB -db <path>/DBConfig:Dev/Admin -storage <path>/storage.xml
##H                  -list <path>/pfns_to_delete.txt -node T1_RAL_Buffer
##H                  -node T1_FNAL_Buffer, T1_CNAF_Buffer
##H
##H   STORAGEMAP is the TFC XML file
##H   PFNS       is either a ASCII file containing a list of PFNs/LFNs to remove or
##H              a comma separated list of PFNs/LFNs.
##H              The syntax is: pfn:<PFN> for a PFN; lfn:<LFN> for an LFN.
##H   NODENAMES  is a comma separated list of nodes for which you wish to delete
##H              files. Keyword 'all' will delete the file completely
##H              
##H   PROTOCOL   protocol used for resolving LFN via TFC. Defaults to 'direct'.
##H

BEGIN {
  $^W = 1; use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments.
use Getopt::Long;
use UtilsHelp;
use UtilsDB;
use UtilsCatalogue;
use UtilsTiming;

my %args = ( PROTOCOL => 'direct' );
&GetOptions ("db=s"        => \$args{DBCONFIG},
	     "storage=s"   => \$args{STORAGEMAP},
	     "list=s"      => \$args{FILELIST},
	     "nodes=s"     => \$args{NODES},
	     "protocol=s"  => \$args{PROTOCOL},
             "help|h"      => sub { &usage() });

# Check arguments.
if (!$args{DBCONFIG} || !$args{STORAGEMAP} || !$args{FILELIST} || !$args{NODES})
{
    die "Insufficient parameters, use -h for help.\n";
}

our $dbh = &connectToDatabase ({ DBCONFIG => $args{DBCONFIG} }, 0);
my $now = &mytimeofday();
my $nodes = [ split m|,\s*|, $args{NODES} ];
my $files = [ split m|,\s*|, $args{FILELIST} ];
my $tables = &setTableList ($nodes);

# Get a list of LFNs from the input provied by user
# lock tables if there is work to do and finally delete the LFNs
my $lfns = &getFileList ($args{STORAGEMAP}, $args{PROTOCOL}, $files);
&lockTables ($tables) if grep { defined $_ } @$lfns;
my $stats = &deleteLFNs ($lfns, $dbh, $nodes, $tables);

# commit and exit
$dbh->commit();
$dbh->disconnect();

# Some statistics
print "\nSUMMARY\n";
print "problematic input files: $$stats{NOLFN}\n";
foreach my $node ( @$nodes )
{
    print "skipped files at node $node:  ${$stats{SKIPPED}{$node}}\n"
	if defined ${$stats{SKIPPED}{$node}};
    print "deleted files at node $node:  ${$stats{DELETED}{$node}}\n"
	if defined ${$stats{DELETED}{$node}};
}
exit 0;



# Define the tables to delete based on whether all files
# or just the files at a site will be deleted
sub setTableList
{
    my ( $nodes ) = @_;
    my @tables = ();
    
    if ( $$nodes[0] eq 'all')
    {
	@tables = ('t_xfer_state',
		   't_xfer_replica',
		   't_xfer_request',
		   't_xfer_path',
		   't_xfer_file',
		   't_dps_file');
    }
    else
    {
	@tables = ('t_xfer_state',
		   't_xfer_replica',
		   't_xfer_request',
		   't_xfer_path');
    }    
    return \@tables;
}

# Do LFN transformation where necessary
sub getFileList
{
    my ($storage, $protocol, $files ) = @_;
    my $fileref = [];

    if ( -e ${$files}[0] )
    {
	my @FileList = ();
	open(IFILE, '<', "$file") or die "Could not open $file";
	while (<IFILE>)
	{
	    chomp $_;
	    push ( @FileList,  $_ );
	}
	$fileref = \@FileList;
    }
    else
    {
	$fileref = $files;
    }

    my @lfns = ();
    map
    {
	if ( $_ =~ m|^pfn| )
	{
	    $_ =~ s|^pfn:||;
	    my $lfn = &lfnLookup ($_, $protocol, 'any', $storage) || undef;
	    print "Couldn't resolve LFN for file $_\n"
		if !defined $lfn;
	    
	    push @lfns, $lfn;
	}
	elsif ( $_ =~ m|^lfn| )
	{
	    $_ =~ s|^lfn:||;
	    push @lfns, $_;
	}
	else
	{
	    print "Unknown protocol for file $_\n";
	    push @lfns, undef;
	}
    } @$fileref;    
    return \@lfns;
}



# Deletes LFNs from TMDB
sub deleteLFNs
{
    my ( $lfns, $dbh, $nodenames, $tables ) = @_;
    my $stats = { DELETED => undef, SKIPPED => undef, NOLFN => 0 };
    my $nodes = {};

    map {$$nodes{$_} = &getNodeID ($_)} @$nodenames;
    foreach my $lfnname ( @$lfns )
    {
	# Check if we have a mapped LFN, else skip it
	if ( !defined $lfnname )
	{
	    $$stats{NOLFN} += 1;
	    next;
	}
	
	foreach my $nodename ( keys %$nodes )
	{
	    my $exists = &checkFileExistence ($lfnname, $$nodes{$nodename}, $nodename);
	    if ( !$exists )
	    {
		print "Skipping at node $nodename file with LFN: $lfnname\n";
		${$stats{SKIPPED}{$nodename}} += 1;
		next;
	    }
	
	    my $lfn = &getLFNID ($lfnname);
	    &deleteAllTMDBEntries ($lfn, $lfnname, $tables)
		if ( $nodename eq 'all' );
	    &deleteSiteTMDBEntries ($lfn, $lfnname, $$nodes{$nodename}, $nodename, $tables)
		if ( $nodename ne 'all' );
	    ${$stats{DELETED}{$nodename}} += 1;
	}
    }

    # Update block statistics if necessary
    &dbexec($dbh, qq{
	update t_dps_block b set (files, bytes) =
	    (select NVL(count(f.id),0), NVL(sum(f.filesize),0)
	     from t_dps_file f where f.inblock = b.id)})
	if grep defined $_, ( values %{$stats{DELETED}} );
    
    return $stats;
}

# Maybe there is nothing to do - check for files in TMDB
sub checkFileExistence
{
    my ( $lfnname, $node, $nodename ) = @_;
    my $lfn = &getLFNID ($lfnname);
    
    # Check if we need to deal with that file at all
    my $q = &dbexec($dbh, qq{
	select count(*) from t_dps_file where logical_name = :lfn},
		    ":lfn" => $lfnname);
    my ( $exists_TMDB ) = $q->fetchrow();
    if ( !$exists_TMDB )
    {
	print "File unknown to TMDB\n";
	return 0; # return false
    }

    # if want to delete from nodes only, check that the file is actually at that node
    # and make sure, that the block wasn't collapsed. Re-enable it in this case.
    if ( $nodename ne 'all' )
    {
	$q = &dbexec($dbh, qq{
	    select dest_files, node_files from t_dps_block_replica where
		node = :node and block in
		(select inblock from t_dps_file where logical_name = :lfn)},
		     ":node" => $node, ":lfn" => $lfnname);
	my ( $dest_files, $node_files ) = $q->fetchrow();
	
	$q = &dbexec($dbh, qq{
	    select count(*) from t_xfer_replica where
		fileid = :lfn and node = :node},
		     ":lfn" => $lfn, ":node" => $node);
	my ( $exists_xfer_rep ) = $q->fetchrow();

	if ( !$node_files || (!$exists_xfer_rep && ($dest_files != $node_files)) )
	{
	    print "File not at site $nodename\n";
	    return 0; # return false
	}
	elsif ( !$exists_xfer_rep && ($dest_files == $node_files) )
	{
	    print "File at node $nodename, but file level informations not available\n";
	    print "Reactivating file level info.... Please rerun this script in a few minutes\n";
	    &enableBlock ($lfnname, $lfn, $node, $q);
	}
    }
    return 1; # return true otherwise
}

# We need the same node ID very often - get it here
sub getNodeID
{
    my ( $nodename ) = @_;

    return undef if ( $nodename eq 'all' );
    my $q = &dbexec($dbh, qq{
	select id from t_node where name = :nodename},
		    ":nodename" => $nodename);
    my ( $node ) = $q->fetchrow();
    return $node;
}

# We also need the LFN ID in TMDB - derive it from the LFN string
sub getLFNID
{
    my ( $lfnname ) = @_;
    my $q = &dbexec($dbh, qq{
	select id from t_dps_file where logical_name = :lfnname},
		    ":lfnname" => $lfnname);
    my ( $lfn ) = $q->fetchrow();
    return $lfn;
}

# Lock the tables we are about to modify
sub lockTables
{
    my ( $tablesref ) = @_;

    foreach my $table ( @$tablesref )
    {
	&dbexec($dbh, qq{
	    select * from $table for update});
    }
}

# ask for block to get reactivated - this is the last thing we do and
# we ask the user to rerun the script at a later point
sub enableBlock
{
    my ( $lfnname, $lfn, $node, $q ) = @_;
    my $now = &mytimeofday ();
    my $end = $now + 3600*24*5;
    
    # rollback all changes done so far
    $dbh->rollback();
    $q->finish();

    $q = &dbexec($dbh, qq{
	insert into t_dps_block_activate (block, time_request, time_until)
	    select inblock, $now, $end from t_dps_file
	    where id = :lfnname},":lfnname" => $lfn);
    $dbh->commit();
    $dbh->disconnect();
    exit 0;
}


# Delete complete knowledge of a file in TMDB
sub deleteAllTMDBEntries
{
    my ( $lfn, $lfnname, $tables ) = @_;
    
    print "deleting: $lfnname\n";
    
    foreach my $table ( @$tables )
    {
	if ( $table eq 't_xfer_file' || $table eq 't_dps_file' )
	{
	    &dbexec($dbh, qq{
		delete from $table where id = :lfn},
		    ":lfn" => $lfn);
	}
	else
	{
	    &dbexec($dbh, qq{
		delete from $table where fileid = :lfn},
		    ":lfn" => $lfn);
	}
    }
}


# Delete replica informations for a file at a specified site
sub deleteSiteTMDBEntries
{
    my ( $lfn, $lfnname, $node, $nodename, $tables ) = @_;
    
    print "deleting at node: $nodename file $lfnname\n";

    foreach my $table ( @$tables )
    {
	&dbexec($dbh, qq{
	    delete from $table where
		(from_node = :node or to_node = :node) and fileid = :lfn},
		":lfn" => $lfn, ":node" => $node)
	    if ( $table eq 't_xfer_state' or $table eq 't_xfer_path' );
	&dbexec($dbh, qq{
	    delete from $table where
		node = :node and fileid = :lfn},
		":lfn" => $lfn, ":node" => $node)
	    if ( $table eq 't_xfer_replica' );
	&dbexec($dbh, qq{
	    delete from $table where
		destination = :node and fileid = :lfn},
		":lfn" => $lfn, ":node" => $node)
	    if ( $table eq 't_xfer_request' );
    }
}
