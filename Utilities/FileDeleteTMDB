#!/usr/bin/env perl

##H Delete files from TMDB
##H
##H Usage:
##H   FileDeleteTMDB -db DBCONFIG -storage STORAGEMAP -list FILES
##H                  -node NODENAME [-protocol PROTOCOL] [-f]
##H
##H Examples:
##H
##H   FileDeleteTMDB -db <path>/DBConfig:Dev/Admin -storage <path>/storage.xml
##H                  -list <path>/pfns_to_delete.txt
##H                  -node T1_FNAL_Buffer, T1_CNAF_Buffer
##H
##H   STORAGEMAP is the TFC XML file
##H   FILES      is either a ASCII file containing a list of PFNs/LFNs/blocks
##H              to remove or a comma separated list of PFNs/LFNs/blocks.
##H              The syntax is:
##H                       pfn:<PFN> for a PFN
##H                       lfn:<LFN> for an LFN
##H                       block:<BLOCK> for all files in a block
##H   NODENAMES  is a comma separated list of nodes for which you wish to delete
##H              files. Keyword 'all' will delete the file completely.
##H              Wildecard '%' is supported too.
##H              
##H   PROTOCOL   protocol used for resolving LFN via TFC. Defaults to 'direct'.
##H
##H   SWITCHES
##H         -h   invoke this help text
##H         -f   delete the file also physically. This is DANGEROUS and DISCOURAGED !
##H              PFN is derived from the TFC using PROTOCOL and a corresponding delete
##H              command is issued.
##H

BEGIN {
  $^W = 1; use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}

# Process command line arguments.
use Getopt::Long;
use UtilsHelp;
use UtilsDB;
use UtilsCatalogue;
use UtilsTiming;

my %args = ( PROTOCOL => 'direct' );
&GetOptions ("db=s"        => \$args{DBCONFIG},
	     "storage=s"   => \$args{STORAGEMAP},
	     "list=s"      => \$args{FILELIST},
	     "block=s"     => \$args{BLOCK},
	     "nodes=s"     => \$args{NODES},
	     "protocol=s"  => \$args{PROTOCOL},
	     "f"           => \$args{RMDISK},
             "help|h"      => sub { &usage() });
# Check arguments.
if (!$args{DBCONFIG} || !$args{STORAGEMAP} ||
    !$args{FILELIST} || !$args{NODES})
{
    die "Insufficient parameters, use -h for help.\n";
}

my $self = { DBCONFIG => $args{DBCONFIG} };
our $dbh = &connectToDatabase ($self, 0);
my $now = &mytimeofday();
my $nodes = [ split m|,\s*|, $args{NODES} ];
my $files = [ split m|,\s*|, $args{FILELIST} ];
my $tables = &setTableList ($nodes);

# Get a list of LFNs from the input provided by the user
# finally delete the LFNs
my $lfns = &getFileList ( $args{STORAGEMAP}, $args{PROTOCOL}, $files );
my $stats = &deleteLFNs ( $lfns, $dbh, $nodes, $tables, $args{RMDISK} );


# commit and exit
$dbh->commit();
&disconnectFromDatabase($self, $dbh, 1);

# Some statistics
print "\nSUMMARY\n";
print "cannot get LFN:         $$stats{NOLFN}\n";

# Ugly hack to get final node names and eliminate double names
my %nodenames = ();
map {$nodenames{$_} = 0} ( map { keys %{$stats{$_}} } (keys %$stats) );

foreach my $node (keys %nodenames )
{
    print "skipped copies at node $node:         ${$stats{SKIPPED}{$node}}\n"
	if defined ${$stats{SKIPPED}{$node}};
    print "deleted copies at node $node:         ${$stats{DEL_DB}{$node}}\n"
	if defined ${$stats{DEL_DB}{$node}};
    print "deleted physical files at node $node: ${$stats{DEL_DISK}{$node}}\n"
	if defined ${$stats{DEL_DISK}{$node}};
}
exit 0;



# Define the tables to delete based on whether all files
# or just the files at a site will be deleted
sub setTableList
{
    my ( $nodes ) = @_;
    my @tables = ();
    
    if ( $$nodes[0] eq 'all')
    {
	@tables = ('t_xfer_task',
		   't_xfer_replica',
		   't_xfer_request',
		   't_xfer_path',
		   't_xfer_file',
		   't_dps_file');
    }
    else
    {
	@tables = ('t_xfer_task',
		   't_xfer_replica');
    }    
    return \@tables;
}

# Do LFN transformation where necessary
sub getFileList
{
    my ($storage, $protocol, $files ) = @_;
    my $fileref = [];

    if ( -e ${$files}[0] )
    {
	my @FileList = ();
	open(IFILE, '<', "${$files}[0]") or die "Could not open ${$files}[0]";
	while (<IFILE>)
	{
	    chomp $_;
	    push ( @FileList,  $_ ) if (length $_ > 0);
	}
	$fileref = \@FileList;
    }
    else
    {
	$fileref = $files;
    }

    my %lfns = ();
    map
    {
	if ( $_ =~ s|^pfn:|| )
	{
	    my $lfn = &lfnLookup ($_, $protocol, 'any', $storage) || undef;
	    print "Couldn't resolve LFN for file $_\n"
		if !defined $lfn;
	    
	    $lfns{$lfn} = $_;
	}
	elsif ( $_ =~ s|^lfn:|| )
	{
	    $lfns{$_} = &pfnLookup ($_, $protocol, 'any', $storage) || undef;
	}
	elsif ( $_ =~ s|^block:|| )
	{
	    my $lfnlist = &getLFNsFromBlock ($_);
	    map {$lfns{$_} = &pfnLookup ($_, $protocol, 'any', $storage) || undef} @$lfnlist;
	}
	else
	{
	    print "Unknown protocol for file $_\n";
	    print "Please use one of the following protocols for each file:\n";
	    print "lfn: for LFNs\n";
	    print "pfn: for PFNs\n";
	    print "block: for whole blocks\n";
	}
    } @$fileref;    
    return \%lfns;
}

# Get the LFNs belonging to a certain block
sub getLFNsFromBlock
{
    my ( $block ) = @_;
    my $q = undef;
    my $lfns = [];

    if ( $block =~ m|%| )
    {
	$q = &dbexec($dbh, qq{
	    select logical_name from t_dps_file f where inblock in
		(select id from t_dps_block where name like :block)},
		     ":block" => $block);
    }
    else
    {
	$q = &dbexec($dbh, qq{
	    select logical_name from t_dps_file f where inblock in
		(select id from t_dps_block where name = :block)},
		     ":block" => $block);
    }
    map {push @$lfns, $$_[0]} @{$q->fetchall_arrayref()};
    return $lfns;
}

# Deletes LFNs from TMDB
sub deleteLFNs
{
    my ( $lfns, $dbh, $nodenames, $tables, $rm ) = @_;
    my $stats = { DEL_DB => undef, DEL_DISK => undef, SKIPPED => undef,
		  NOLFN => 0, DEL_DB_SUM => 0 };

    my $nodes = &getNodeID ($nodenames);
    foreach my $lfnname ( keys %$lfns )
    {
	# Check if we have a mapped LFN, else skip it
	if ( !defined $lfnname )
	{
	    $$stats{NOLFN} += 1;
	    next;
	}

	# Get the ID for each LFN and lock the corresponding rows in the tables
	my $lfn = &getLFNID ($lfnname);
	&lockTables ($tables, $lfn);
	
	# now at node level check for file existence and start purging those tables
	foreach my $nodename ( keys %$nodes )
	{
	    my $exists = &checkFileExistence ($lfnname, $$nodes{$nodename}, $nodename);
	    if ( !$exists )
	    {
		print "Skipping at node $nodename non-existent file with LFN: $lfnname\n";
		${$stats{SKIPPED}{$nodename}} += 1;
		next;
	    }

	    &deleteAllTMDBEntries ($lfn, $lfnname, $tables)
		if ( $nodename eq 'all' );
	    &deleteSiteTMDBEntries ($lfn, $lfnname, $$nodes{$nodename}, $nodename, $tables)
		if ( $nodename ne 'all' );
	    ${$stats{DEL_DISK}{$nodename}} += 1 if ( $rm && &deletePhysicalFile ($$lfns{$lfnname}) );
	    ${$stats{DEL_DB}{$nodename}} += 1;
	}
	$$stats{DEL_DB_SUM} += 1;
	$dbh->commit() if ( $$stats{DEL_DB_SUM}%20 == 0 );
    }

    return $stats;
}

# Maybe there is nothing to do - check for files in TMDB
sub checkFileExistence
{
    my ( $lfnname, $node, $nodename ) = @_;
    my $lfn = &getLFNID ($lfnname);
    
    # Check if we need to deal with that file at all
    my $q = &dbexec($dbh, qq{
	select count(id) from t_dps_file where logical_name = :lfn},
		    ":lfn" => $lfnname);
    my ( $exists_TMDB ) = $q->fetchrow();
    if ( !$exists_TMDB )
    {
	print "File unknown to TMDB: $lfnname\n";
	return 0; # return false
    }
    
    
    # if want to delete from nodes only, check that the file is actually at that node
    # and make sure, that the block wasn't collapsed. Re-enable it in this case.
    if ( $nodename ne 'all' )
    {
	$q = &dbexec($dbh, qq{
	    select b.files, br.node_files from t_dps_block_replica br left join t_dps_block b
		on br.block = b.id where node = :node and block in
		(select inblock from t_dps_file where logical_name = :lfn)},
		     ":node" => $node, ":lfn" => $lfnname);
	my ( $block_files, $node_files ) = $q->fetchrow();
	
	$q = &dbexec($dbh, qq{
	    select count(*) from t_xfer_replica where
		fileid = :lfn and node = :node},
		     ":lfn" => $lfn, ":node" => $node);
	( $exists_xfer_rep ) = $q->fetchrow();
	
	if ( !$node_files || (!$exists_xfer_rep && ($block_files != $node_files)) )
	{
	    return 0; # return false, since file is not at node
	}
	elsif ( !$exists_xfer_rep && ($block_files == $node_files) )
	{
	    print "File at node $nodename, but file level informations not available\n";
	    print "Reactivating file level info.... Please rerun this script in about 15 minutes\n";
	    &enableBlock ($lfnname, $lfn, $q);
	}
    }
    return 1; # return true otherwise
}

# We need the same node ID very often - get it here
sub getNodeID
{
    my ( $nodenames ) = @_;
    my $node = {};

    
    foreach my $nodename (@$nodenames)
    {
	my $q = undef;
	if ( $nodename =~ m|%| )
	{
	    $q = &dbexec($dbh, qq{
		select name, id from t_adm_node where name like :nodename},
			    ":nodename" => $nodename);
	}
	else
	{
	    $q = &dbexec($dbh, qq{
		select name, id from t_adm_node where name = :nodename},
			    ":nodename" => $nodename);
	}
	map {$$node{$$_[0]} = $$_[1]} @{$q->fetchall_arrayref()};
	$$node{$nodename} = undef if ( $nodename eq 'all' ); # no ID in case of all
    }
    return $node;
}

# We also need the LFN ID in TMDB - derive it from the LFN string
sub getLFNID
{
    my ( $lfnname ) = @_;
    my $q = &dbexec($dbh, qq{
	select id from t_dps_file where logical_name = :lfnname},
		    ":lfnname" => $lfnname);
    my ( $lfn ) = $q->fetchrow();
    return $lfn;
}

# Lock the tables we are about to modify
sub lockTables
{
    my ( $tablesref, $lfn ) = @_;

    foreach my $table ( @$tablesref )
    {
	if ( $table eq 't_xfer_file' || $table eq 't_dps_file' )
	{
	    &dbexec($dbh, qq{
		select *  from $table where id = :lfn for update},
		    ":lfn" => $lfn);
	}
	else
	{
	    &dbexec($dbh, qq{
		select * from $table where fileid = :lfn for update},
		    ":lfn" => $lfn);
	}
    }
}

# ask for block to get reactivated - this is the last thing we do and
# we ask the user to rerun the script at a later point
sub enableBlock
{
    my ( $lfnname, $lfn, $q ) = @_;
    my $now = &mytimeofday ();
    my $end = $now + 3600*24*5;
    
    # rollback all changes done so far
    $dbh->rollback();
    $q->finish();

    $q = &dbexec($dbh, qq{
	insert into t_dps_block_activate (block, time_request, time_until)
	    select inblock, $now, $end from t_dps_file
	    where id = :lfnname},":lfnname" => $lfn);
    $dbh->commit();
    &disconnectFromDatabase($self, $dbh, 1);
    exit 0;
}

# try to delete the file physically from storage or disk
sub deletePhysicalFile
{
    my ( $pfn ) = @_;
    
    my $cmd = 'rm';
    my $failed = 0;

    if ( $pfn =~ m|^srm| )
    {
	$cmd = "srm-advisory-delete $pfn";
    }
    elsif ( $pfn =~ s|^rfio:|| || $pfn =~ m|^/castor/| )
    {
	$cmd = "stager_rm -M $pfn; nsrm $pfn";
    }
    else
    {
	$pfn =~ s|^dcap:||;
	$cmd = "rm $pfn";
    }
    $failed += 1 if system($cmd);
    
    return 1 if !$failed; # success
    return 0; # failure
}


# Delete complete knowledge of a file in TMDB
sub deleteAllTMDBEntries
{
    my ( $lfn, $lfnname, $tables ) = @_;

    my $exists_tracking = 1;
    while ( $exists_tracking )
    {
	# check if there is tracking information for that LFN and wait
	my $q = &dbexec($dbh, qq{
	    select count(*) from t_xfer_task_done xtd
	    join t_xfer_task xt on xt.id = xtd.task
	    where xt.fileid = :lfn},
	    ":lfn" => $lfn);
	$exists_tracking = $q->fetchrow();
	if ( $exists_tracking )
	{
	    print "files are still being harvested, waiting 30s for table to be emptied\n";
	    $dbh->commit();
	    sleep 30;
	}
    }

    print "deleting: $lfnname\n";
    
    foreach my $table ( @$tables )
    {
	if ( $table eq 't_xfer_file' || $table eq 't_dps_file' )
	{
	    &dbexec($dbh, qq{
		delete from $table where id = :lfn},
		    ":lfn" => $lfn);
	}
	else
	{
	    &dbexec($dbh, qq{
		delete from $table where fileid = :lfn},
		    ":lfn" => $lfn);
	}
    }
}


# Delete replica informations for a file at a specified site
sub deleteSiteTMDBEntries
{
    my ( $lfn, $lfnname, $node, $nodename, $tables ) = @_;
    
    print "deleting at node $nodename file with LFN: $lfnname\n";

    foreach my $table ( @$tables )
    {
	&dbexec($dbh, qq{
	    delete from $table where
		(from_node = :node or to_node = :node) and fileid = :lfn},
		":lfn" => $lfn, ":node" => $node)
	    if ( $table eq 't_xfer_task' );
	&dbexec($dbh, qq{
	    delete from $table where
		node = :node and fileid = :lfn},
		":lfn" => $lfn, ":node" => $node)
	    if ( $table eq 't_xfer_replica' );
    }
}
