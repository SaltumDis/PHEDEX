#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long qw /:config pass_through require_order /;
use PHEDEX::Core::Loader;
use PHEDEX::Core::Catalogue;
use PHEDEX::Core::Util ( qw / str_hash / );
#use PHEDEX::Namespace;

my ($loader,$module,$interface,$ns,$mapping);
my ($verbose,$debug,$terse);
my (@lfn,$lfnlist,$catalogue,$result,$command);

sub usage
{
  print <<EOF;

  Usage:

  setool --lfnlist LFNLIST --catalogue CATALOGUE INTERFACE {OPTIONS} [COMMAND]
 
  LFNLIST is a file containing full LFNs as found in your storage
  element, one lfn per line.
  If LFNLIST is given as '-', the script will read from stdin.
  Gzipped (*.gz) or bzipped (*.bz2) files can be read directly,
  allowing for compact filelists.
  CATALOGUE is xml file providing storage trivial file catalogue (storage.xml)

  INTERFACE is the protocol for accessing the SE.

  OPTIONS are --verbose, --debug, --help, and anything else that the
  interface might support. Use --help per interface to find out more.

  COMMAND is an operation against the SE that the INTERFACE supports,
  such as 'stat', 'is_migrated' etc. The --help option for the interface
  will list them.

  Known interface protocols in this installation are:
EOF
  print " '",join("', '", grep (!/\//,sort keys %{$loader->Commands})),"'\n\n";
  exit 0;
}

$loader = PHEDEX::Core::Loader->new( NAMESPACE => 'PHEDEX::Namespace',
				     REJECT    => [ qw / common namespace / ] );

GetOptions(
           "lfnlist|l=s"    => \$lfnlist,
           "catalogue|c=s"  => \$catalogue,
           "verbose|v+"     => \$verbose,
           "debug+"         => \$debug,
           "help|h"         => sub { &usage() }
	  );

$interface = shift;
die "INTERFACE argument must be specified\n" unless $interface;
$module = $loader->Load($interface);
$ns = $module->new();
if ( $lfnlist )
{
  die "CATALOGUE argument must be specified\n" unless $catalogue;
  $mapping = PHEDEX::Core::Catalogue->new($catalogue);
  if ( $lfnlist =~ m%.gz$% )
  { open LFN, "cat $lfnlist | gzip -d - |" or die "open: $lfnlist: $!\n"; }
  elsif ( $lfnlist =~ m%.bz2$% )
  { open LFN, "cat $lfnlist | bzip2 -d - |" or die "open: $lfnlist: $!\n"; }
  elsif ( $lfnlist =~ m%^-$% )
  { *LFN = *STDIN; }
  else
  { open LFN, "<$lfnlist" or die "open: $lfnlist: $!\n"; }
  while ( <LFN> )
  {
    chomp;
    $debug && print "Read: $_\n";;
    push @lfn, $_;
  }
}

while ( $command = shift @ARGV )
{
  foreach my $f ( @lfn )
  {
    $result = $ns->$command($f, $mapping);
    print "$f $command = ",str_hash($result),"\n";
  }
}
