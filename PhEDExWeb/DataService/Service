#!/usr/bin/env perl

=head1 NAME

Service - Main program of the PhEDEx data service

=head1 DESCRIPTION

Checks configuration, parses URL path for parameters, makes API call

=cut

use warnings;
use strict;

use CGI qw(header path_info self_url param Vars);

#use CMSWebTools::SecurityModule::Oracle;
use PHEDEX::Web::Config;
use PHEDEX::Web::Core;
use PHEDEX::Core::Timing;

our ($TESTING, $TESTING_MAIL);

# Read PhEDEx web server configuration
my $config_file = $ENV{PHEDEX_SERVER_CONFIG} ||
    die "ERROR:  Web page config file not set";

my $dev_name = $ENV{PHEDEX_DEV_NAME};

my $config = PHEDEX::Web::Config->read($config_file, $dev_name);
# eval "use CGI::Carp qw(fatalsToBrowser)"; # XXX turn off when in production!

# my $secmod_config = $$config{SECMOD_CONFIG};
# if (!$secmod_config) {
#     die "ERROR:  SecurityModule config file not set in $config_file";
# }
#my $secmod = new CMSWebTools::SecurityModule::Oracle({CONFIG => $secmod_config});

# Set debug mode
$TESTING = $$config{TESTING_MODE} ? 1 : 0;
$TESTING_MAIL = $$config{TESTING_MAIL} || undef;

# Interpret the trailing path suffix: /FORMAT/DB/API?QUERY
my $path = path_info() || "xml/prod";

my ($format, $db, $call) = ("xml", "prod", undef);
$format = $1 if ($path =~ m!\G/([^/]+)!g);
$db =     $1 if ($path =~ m!\G/([^/]+)!g);
$call =   $1 if ($path =~ m!\G/([^/]+)!g);

unless ($format && $db && $call) {
    print header(-type => 'text/xml');
    print "<error>URL format not recognized.  Should be .*/datasvc/FORMAT/DB/API?QUERY</error>";
    return;
}

# Print documentation
if ($format eq 'doc') {
    chdir '/tmp';
    print header();
    print `perldoc -m PHEDEX::Web::Core | pod2html -css http://cern.ch/wildish/PHEDEX/phedex_pod.css`;
    return;
}

my $core = new PHEDEX::Web::Core(DBCONFIG => $config->{INSTANCES}->{$db}->{DBCONFIG},
				 INSTANCE => $db,
				 REQUEST_URL => self_url(),
				 DEBUG => $TESTING
				 );

my $type;
if    ($format eq 'xml')  { $type = 'text/xml'; }
elsif ($format eq 'json') { $type = 'text/javascript'; }
elsif ($format eq 'perl') { $type = 'text/plain'; }
else {
    print header(-type => 'text/xml');
    print "<error>Unsupported format '$format'</error>";
    return;
}

my $http_now = &formatTime(&mytimeofday(), 'http');

# Get the query string variables
my %args = Vars();

# Reformat multiple value variables into name => [ values ]
foreach my $key (keys %args) {
    my @vals = split("\0", $args{$key});
    $args{$key} = \@vals if ($#vals > 0);
}

$args{format} = $format;

my %cache_headers;
unless (param('nocache')) {
    my $duration = $core->getCacheDuration($call) || 300;
    %cache_headers = (-Cache_Control => "max-age=$duration",
		      -Date => $http_now,
		      -Last_Modified => $http_now,
		      -Expires => "+${duration}s");
    warn "cache duration for '$call' is $duration seconds\n" if $TESTING;
}

print header(-type => $type, %cache_headers );
$core->call($call, %args);
print "\n";

exit(0);
